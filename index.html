<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>C-Sharp 6 Draft Specs</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;csharp&quot;,&quot;bash&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" alt="Logo" />
        <div class="lang-selector">
              <a href="#" data-language-name="csharp">csharp</a>
              <a href="#" data-language-name="bash">bash</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://dot.net'>Get Started with dotNet</a></li>
            <li><a href='https://www.otienoken.me'>WHOAMI</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="about-these-draft-specs">About these Draft Specs</h1>

<p>C# is designed by the C# Language Design Team (LDT) in close coordination with the <a href="https://github.com/dotnet/roslyn">Roslyn</a> project, which implements the language.</p>

<p>If you discover bugs or deficiencies in the above, please leave an issue to raise them, or even better: a pull request to fix them.</p>

<p>For <em>new feature proposals</em>, however, please raise them for <a href="https://github.com/dotnet/csharplang/labels/Discussion">discussion</a>, and <em>only</em> submit a proposal as a pull request if invited to do so by a member of the Language Design Team (a &ldquo;champion&rdquo;).</p>

          <h1 id="introduction">Introduction</h1>

<p>C# (pronounced &ldquo;See Sharp&rdquo;) is a simple, modern, object-oriented, and type-safe programming language. C# has its roots in the C family of languages and will be immediately familiar to C, C++, and Java programmers. C# is standardized by ECMA International as the <strong><em>ECMA-334</em></strong> standard and by ISO/IEC as the <strong><em>ISO/IEC 23270</em></strong> standard. Microsoft&rsquo;s C# compiler for the .NET Framework is a conforming implementation of both of these standards.</p>

<p>C# is an object-oriented language, but C# further includes support for <strong><em>component-oriented</em></strong> programming. Contemporary software design increasingly relies on software components in the form of self-contained and self-describing packages of functionality. Key to such components is that they present a programming model with properties, methods, and events; they have attributes that provide declarative information about the component; and they incorporate their own documentation. C# provides language constructs to directly support these concepts, making C# a very natural language in which to create and use software components.</p>

<p>Several C# features aid in the construction of robust and durable applications: <strong><em>Garbage collection</em></strong> automatically reclaims memory occupied by unused objects; <strong><em>exception handling</em></strong> provides a structured and extensible approach to error detection and recovery; and the <strong><em>type-safe</em></strong> design of the language makes it impossible to read from uninitialized variables, to index arrays beyond their bounds, or to perform unchecked type casts.</p>

<p>C# has a <strong><em>unified type system</em></strong>. All C# types, including primitive types such as <code class="prettyprint">int</code> and <code class="prettyprint">double</code>, inherit from a single root <code class="prettyprint">object</code> type. Thus, all types share a set of common operations, and values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined reference types and value types, allowing dynamic allocation of objects as well as in-line storage of lightweight structures.</p>

<p>To ensure that C# programs and libraries can evolve over time in a compatible manner, much emphasis has been placed on <strong><em>versioning</em></strong> in C#&lsquo;s design. Many programming languages pay little attention to this issue, and, as a result, programs written in those languages break more often than necessary when newer versions of dependent libraries are introduced. Aspects of C#&rsquo;s design that were directly influenced by versioning considerations include the separate <code class="prettyprint">virtual</code> and <code class="prettyprint">override</code> modifiers, the rules for method overload resolution, and support for explicit interface member declarations.</p>

<p>The rest of this chapter describes the essential features of the C# language. Although later chapters describe rules and exceptions in a detail-oriented and sometimes mathematical manner, this chapter strives for clarity and brevity at the expense of completeness. The intent is to provide the reader with an introduction to the language that will facilitate the writing of early programs and the reading of later chapters.</p>

<h2 id="hello-world">Hello world</h2>

<p>The &ldquo;Hello, World&rdquo; program is traditionally used to introduce a programming language. Here it is in C#:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Hello</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello, World"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>C# source files typically have the file extension <code class="prettyprint">.cs</code>. Assuming that the &ldquo;Hello, World&rdquo; program is stored in the file <code class="prettyprint">hello.cs</code>, the program can be compiled with the Microsoft C# compiler using the command line
<code class="prettyprint">
csc hello.cs
</code>
which produces an executable assembly named <code class="prettyprint">hello.exe</code>. The output produced by this application when it is run is
<code class="prettyprint">
Hello, World
</code></p>

<p>The &ldquo;Hello, World&rdquo; program starts with a <code class="prettyprint">using</code> directive that references the <code class="prettyprint">System</code> namespace. Namespaces provide a hierarchical means of organizing C# programs and libraries. Namespaces contain types and other namespacesâ€”for example, the <code class="prettyprint">System</code> namespace contains a number of types, such as the <code class="prettyprint">Console</code> class referenced in the program, and a number of other namespaces, such as <code class="prettyprint">IO</code> and <code class="prettyprint">Collections</code>. A <code class="prettyprint">using</code> directive that references a given namespace enables unqualified use of the types that are members of that namespace. Because of the <code class="prettyprint">using</code> directive, the program can use <code class="prettyprint">Console.WriteLine</code> as shorthand for <code class="prettyprint">System.Console.WriteLine</code>.</p>

<p>The <code class="prettyprint">Hello</code> class declared by the &ldquo;Hello, World&rdquo; program has a single member, the method named <code class="prettyprint">Main</code>. The <code class="prettyprint">Main</code> method is declared with the <code class="prettyprint">static</code> modifier. While instance methods can reference a particular enclosing object instance using the keyword <code class="prettyprint">this</code>, static methods operate without reference to a particular object. By convention, a static method named <code class="prettyprint">Main</code> serves as the entry point of a program.</p>

<p>The output of the program is produced by the <code class="prettyprint">WriteLine</code> method of the <code class="prettyprint">Console</code> class in the <code class="prettyprint">System</code> namespace. This class is provided by the .NET Framework class libraries, which, by default, are automatically referenced by the Microsoft C# compiler. Note that C# itself does not have a separate runtime library. Instead, the .NET Framework is the runtime library of C#.</p>

<h2 id="program-structure">Program structure</h2>

<p>The key organizational concepts in C# are <strong><em>programs</em></strong>, <strong><em>namespaces</em></strong>, <strong><em>types</em></strong>, <strong><em>members</em></strong>, and <strong><em>assemblies</em></strong>. C# programs consist of one or more source files. Programs declare types, which contain members and can be organized into namespaces. Classes and interfaces are examples of types. Fields, methods, properties, and events are examples of members. When C# programs are compiled, they are physically packaged into assemblies. Assemblies typically have the file extension <code class="prettyprint">.exe</code> or <code class="prettyprint">.dll</code>, depending on whether they implement <strong><em>applications</em></strong> or <strong><em>libraries</em></strong>.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Acme.Collections</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Stack</span>
    <span class="p">{</span>
        <span class="n">Entry</span> <span class="n">top</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="kt">object</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">top</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Entry</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">object</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
            <span class="kt">object</span> <span class="n">result</span> <span class="p">=</span> <span class="n">top</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">top</span> <span class="p">=</span> <span class="n">top</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">class</span> <span class="nc">Entry</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="n">Entry</span> <span class="n">next</span><span class="p">;</span>
            <span class="k">public</span> <span class="kt">object</span> <span class="n">data</span><span class="p">;</span>

            <span class="k">public</span> <span class="nf">Entry</span><span class="p">(</span><span class="n">Entry</span> <span class="n">next</span><span class="p">,</span> <span class="kt">object</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
                <span class="k">this</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>declares a class named <code class="prettyprint">Stack</code> in a namespace called <code class="prettyprint">Acme.Collections</code>. The fully qualified name of this class is <code class="prettyprint">Acme.Collections.Stack</code>. The class contains several members: a field named <code class="prettyprint">top</code>, two methods named <code class="prettyprint">Push</code> and <code class="prettyprint">Pop</code>, and a nested class named <code class="prettyprint">Entry</code>. The <code class="prettyprint">Entry</code> class further contains three members: a field named <code class="prettyprint">next</code>, a field named <code class="prettyprint">data</code>, and a constructor. Assuming that the source code of the example is stored in the file <code class="prettyprint">acme.cs</code>, the command line</p>
<pre class="highlight shell"><code>csc /t:library acme.cs
</code></pre>
<p>compiles the example as a library (code without a <code class="prettyprint">Main</code> entry point) and produces an assembly named <code class="prettyprint">acme.dll</code>.</p>

<p>Assemblies contain executable code in the form of <strong><em>Intermediate Language</em></strong> (IL) instructions, and symbolic information in the form of <strong><em>metadata</em></strong>. Before it is executed, the IL code in an assembly is automatically converted to processor-specific code by the Just-In-Time (JIT) compiler of .NET Common Language Runtime.</p>

<p>Because an assembly is a self-describing unit of functionality containing both code and metadata, there is no need for <code class="prettyprint">#include</code> directives and header files in C#. The public types and members contained in a particular assembly are made available in a C# program simply by referencing that assembly when compiling the program. For example, this program uses the <code class="prettyprint">Acme.Collections.Stack</code> class from the <code class="prettyprint">acme.dll</code> assembly:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Acme.Collections</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Stack</span> <span class="n">s</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stack</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">Pop</span><span class="p">());</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">Pop</span><span class="p">());</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">Pop</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>If the program is stored in the file <code class="prettyprint">test.cs</code>, when <code class="prettyprint">test.cs</code> is compiled, the <code class="prettyprint">acme.dll</code> assembly can be referenced using the compiler&rsquo;s <code class="prettyprint">/r</code> option:</p>
<pre class="highlight shell"><code>csc /r:acme.dll test.cs
</code></pre>
<p>This creates an executable assembly named <code class="prettyprint">test.exe</code>, which, when run, produces the output:</p>
<pre class="highlight shell"><code>100
10
1
</code></pre>
<p>C# permits the source text of a program to be stored in several source files. When a multi-file C# program is compiled, all of the source files are processed together, and the source files can freely reference each otherâ€”conceptually, it is as if all the source files were concatenated into one large file before being processed. Forward declarations are never needed in C# because, with very few exceptions, declaration order is insignificant. C# does not limit a source file to declaring only one public type nor does it require the name of the source file to match a type declared in the source file.</p>

<h2 id="types-and-variables">Types and variables</h2>

<p>There are two kinds of types in C#: <strong><em>value types</em></strong> and <strong><em>reference types</em></strong>. Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter variables).</p>

<p>C#&rsquo;s value types are further divided into <strong><em>simple types</em></strong>, <strong><em>enum types</em></strong>, <strong><em>struct types</em></strong>, and <strong><em>nullable types</em></strong>, and C#&rsquo;s reference types are further divided into <strong><em>class types</em></strong>, <strong><em>interface types</em></strong>, <strong><em>array types</em></strong>, and <strong><em>delegate types</em></strong>.</p>

<p>The following table provides an overview of C#&rsquo;s type system.</p>

<table><thead>
<tr>
<th><strong>Category</strong></th>
<th></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Value types</td>
<td>Simple types</td>
<td>Signed integral: <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">int</code>, <code class="prettyprint">long</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Unsigned integral: <code class="prettyprint">byte</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Unicode characters: <code class="prettyprint">char</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>IEEE floating point: <code class="prettyprint">float</code>, <code class="prettyprint">double</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>High-precision decimal: <code class="prettyprint">decimal</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Boolean: <code class="prettyprint">bool</code></td>
</tr>
<tr>
<td></td>
<td>Enum types</td>
<td>User-defined types of the form <code class="prettyprint">enum E {...}</code></td>
</tr>
<tr>
<td></td>
<td>Struct types</td>
<td>User-defined types of the form <code class="prettyprint">struct S {...}</code></td>
</tr>
<tr>
<td></td>
<td>Nullable types</td>
<td>Extensions of all other value types with a <code class="prettyprint">null</code> value</td>
</tr>
<tr>
<td>Reference types</td>
<td>Class types</td>
<td>Ultimate base class of all other types: <code class="prettyprint">object</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Unicode strings: <code class="prettyprint">string</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td>User-defined types of the form <code class="prettyprint">class C {...}</code></td>
</tr>
<tr>
<td></td>
<td>Interface types</td>
<td>User-defined types of the form <code class="prettyprint">interface I {...}</code></td>
</tr>
<tr>
<td></td>
<td>Array types</td>
<td>Single- and multi-dimensional, for example, <code class="prettyprint">int[]</code> and <code class="prettyprint">int[,]</code></td>
</tr>
<tr>
<td></td>
<td>Delegate types</td>
<td>User-defined types of the form e.g. <code class="prettyprint">delegate int  D(...)</code></td>
</tr>
</tbody></table>

<p>The eight integral types provide support for 8-bit, 16-bit, 32-bit, and 64-bit values in signed or unsigned form.</p>

<p>The two floating point types, <code class="prettyprint">float</code> and <code class="prettyprint">double</code>, are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats.</p>

<p>The <code class="prettyprint">decimal</code> type is a 128-bit data type suitable for financial and monetary calculations.</p>

<p>C#&rsquo;s <code class="prettyprint">bool</code> type is used to represent boolean valuesâ€”values that are either <code class="prettyprint">true</code> or <code class="prettyprint">false</code>.</p>

<p>Character and string processing in C# uses Unicode encoding. The <code class="prettyprint">char</code> type represents a UTF-16 code unit, and the <code class="prettyprint">string</code> type represents a sequence of UTF-16 code units.</p>

<p>The following table summarizes C#&rsquo;s numeric types.</p>

<table><thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Bits</strong></th>
<th><strong>Type</strong></th>
<th><strong>Range/Precision</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Signed integral</td>
<td>8</td>
<td><code class="prettyprint">sbyte</code></td>
<td>-128&hellip;127</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td><code class="prettyprint">short</code></td>
<td>-32,768&hellip;32,767</td>
</tr>
<tr>
<td></td>
<td>32</td>
<td><code class="prettyprint">int</code></td>
<td>-2,147,483,648&hellip;2,147,483,647</td>
</tr>
<tr>
<td></td>
<td>64</td>
<td><code class="prettyprint">long</code></td>
<td>-9,223,372,036,854,775,808&hellip;9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>Unsigned integral</td>
<td>8</td>
<td><code class="prettyprint">byte</code></td>
<td>0&hellip;255</td>
</tr>
<tr>
<td></td>
<td>16</td>
<td><code class="prettyprint">ushort</code></td>
<td>0&hellip;65,535</td>
</tr>
<tr>
<td></td>
<td>32</td>
<td><code class="prettyprint">uint</code></td>
<td>0&hellip;4,294,967,295</td>
</tr>
<tr>
<td></td>
<td>64</td>
<td><code class="prettyprint">ulong</code></td>
<td>0&hellip;18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>Floating point</td>
<td>32</td>
<td><code class="prettyprint">float</code></td>
<td>1.5Â Ã—Â 10^âˆ’45 to 3.4Â Ã—Â 10^38, 7-digit precision</td>
</tr>
<tr>
<td></td>
<td>64</td>
<td><code class="prettyprint">double</code></td>
<td>5.0Â Ã—Â 10^âˆ’324 to 1.7Â Ã—Â 10^308, 15-digit precision</td>
</tr>
<tr>
<td>Decimal</td>
<td>128</td>
<td><code class="prettyprint">decimal</code></td>
<td>1.0Â Ã—Â 10^âˆ’28 to 7.9Â Ã—Â 10^28, 28-digit precision</td>
</tr>
</tbody></table>

<p>C# programs use <strong><em>type declarations</em></strong> to create new types. A type declaration specifies the name and the members of the new type. Five of C#&rsquo;s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.</p>

<p>A class type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.</p>

<p>A struct type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and do not require heap allocation. Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <code class="prettyprint">object</code>.</p>

<p>An interface type defines a contract as a named set of public function members. A class or struct that implements an interface must provide implementations of the interface&rsquo;s function members. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</p>

<p>A delegate type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</p>

<p>Class, struct, interface and delegate types all support generics, whereby they can be parameterized with other types.</p>

<p>An enum type is a distinct type with named constants. Every enum type has an underlying type, which must be one of the eight integral types. The set of values of an enum type is the same as the set of values of the underlying type.</p>

<p>C# supports single- and multi-dimensional arrays of any type. Unlike the types listed above, array types do not have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, <code class="prettyprint">int[]</code> is a single-dimensional array of <code class="prettyprint">int</code>, <code class="prettyprint">int[,]</code> is a two-dimensional array of <code class="prettyprint">int</code>, and <code class="prettyprint">int[][]</code> is a single-dimensional array of single-dimensional arrays of <code class="prettyprint">int</code>.</p>

<p>Nullable types also do not have to be declared before they can be used. For each non-nullable value type <code class="prettyprint">T</code> there is a corresponding nullable type <code class="prettyprint">T?</code>, which can hold an additional value <code class="prettyprint">null</code>. For instance, <code class="prettyprint">int?</code> is a type that can hold any 32 bit integer or the value <code class="prettyprint">null</code>.</p>

<p>C#&rsquo;s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the <code class="prettyprint">object</code> class type, and <code class="prettyprint">object</code> is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type <code class="prettyprint">object</code>. Values of value types are treated as objects by performing <strong><em>boxing</em></strong> and <strong><em>unboxing</em></strong> operations. In the following example, an <code class="prettyprint">int</code> value is converted to <code class="prettyprint">object</code> and back again to <code class="prettyprint">int</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">123</span><span class="p">;</span>
        <span class="kt">object</span> <span class="n">o</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>          <span class="c1">// Boxing</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">o</span><span class="p">;</span>        <span class="c1">// Unboxing</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>When a value of a value type is converted to type <code class="prettyprint">object</code>, an object instance, also called a &ldquo;box,&rdquo; is allocated to hold the value, and the value is copied into that box. Conversely, when an <code class="prettyprint">object</code> reference is cast to a value type, a check is made that the referenced object is a box of the correct value type, and, if the check succeeds, the value in the box is copied out.</p>

<p>C#&rsquo;s unified type system effectively means that value types can become objects &ldquo;on demand.&rdquo; Because of the unification, general-purpose libraries that use type <code class="prettyprint">object</code> can be used with both reference types and value types.</p>

<p>There are several kinds of <strong><em>variables</em></strong> in C#, including fields, array elements, local variables, and parameters. Variables represent storage locations, and every variable has a type that determines what values can be stored in the variable, as shown by the following table.</p>

<table><thead>
<tr>
<th><strong>Type of Variable</strong></th>
<th><strong>Possible Contents</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Non-nullable value type</td>
<td>A value of that exact type</td>
</tr>
<tr>
<td>Nullable value type</td>
<td>A null value or a value of that exact type</td>
</tr>
<tr>
<td><code class="prettyprint">object</code></td>
<td>A null reference, a reference to an object of any reference type, or a reference to a boxed value of any value type</td>
</tr>
<tr>
<td>Class type</td>
<td>A null reference, a reference to an instance of that class type, or a reference to an instance of a class derived from that class type</td>
</tr>
<tr>
<td>Interface type</td>
<td>A null reference, a reference to an instance of a class type that implements that interface type, or a reference to a boxed value of a value type that implements that interface type</td>
</tr>
<tr>
<td>Array type</td>
<td>A null reference, a reference to an instance of that array type, or a reference to an instance of a compatible array type</td>
</tr>
<tr>
<td>Delegate type</td>
<td>A null reference or a reference to an instance of that delegate type</td>
</tr>
</tbody></table>

<h2 id="expressions">Expressions</h2>

<p><strong><em>Expressions</em></strong> are constructed from <strong><em>operands</em></strong> and <strong><em>operators</em></strong>. The operators of an expression indicate which operations to apply to the operands. Examples of operators include <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, and <code class="prettyprint">new</code>. Examples of operands include literals, fields, local variables, and expressions.</p>

<p>When an expression contains multiple operators, the <strong><em>precedence</em></strong> of the operators controls the order in which the individual operators are evaluated. For example, the expression <code class="prettyprint">x + y * z</code> is evaluated as <code class="prettyprint">x + (y * z)</code> because the <code class="prettyprint">*</code> operator has higher precedence than the <code class="prettyprint">+</code> operator.</p>

<p>Most operators can be <strong><em>overloaded</em></strong>. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</p>

<p>The following table summarizes C#&rsquo;s operators, listing the operator categories in order of precedence from highest to lowest. Operators in the same category have equal precedence.</p>

<table><thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Expression</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Primary</td>
<td><code class="prettyprint">x.m</code></td>
<td>Member access</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x(...)</code></td>
<td>Method and delegate invocation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x[...]</code></td>
<td>Array and indexer access</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x++</code></td>
<td>Post-increment</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x--</code></td>
<td>Post-decrement</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">new T(...)</code></td>
<td>Object and delegate creation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">new T(...){...}</code></td>
<td>Object creation with initializer</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">new {...}</code></td>
<td>Anonymous object initializer</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">new T[...]</code></td>
<td>Array creation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">typeof(T)</code></td>
<td>Obtain <code class="prettyprint">System.Type</code> object for <code class="prettyprint">T</code></td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">checked(x)</code></td>
<td>Evaluate expression in checked context</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">unchecked(x)</code></td>
<td>Evaluate expression in unchecked context</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">default(T)</code></td>
<td>Obtain default value of type <code class="prettyprint">T</code></td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">delegate {...}</code></td>
<td>Anonymous function (anonymous method)</td>
</tr>
<tr>
<td>Unary</td>
<td><code class="prettyprint">+x</code></td>
<td>Identity</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">-x</code></td>
<td>Negation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">!x</code></td>
<td>Logical negation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">~x</code></td>
<td>Bitwise negation</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">++x</code></td>
<td>Pre-increment</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">--x</code></td>
<td>Pre-decrement</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">(T)x</code></td>
<td>Explicitly convert <code class="prettyprint">x</code> to type <code class="prettyprint">T</code></td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">await x</code></td>
<td>Asynchronously wait for <code class="prettyprint">x</code> to complete</td>
</tr>
<tr>
<td>Multiplicative</td>
<td><code class="prettyprint">x * y</code></td>
<td>Multiplication</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x / y</code></td>
<td>Division</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x % y</code></td>
<td>Remainder</td>
</tr>
<tr>
<td>Additive</td>
<td><code class="prettyprint">x + y</code></td>
<td>Addition, string concatenation, delegate combination</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x - y</code></td>
<td>Subtraction, delegate removal</td>
</tr>
<tr>
<td>Shift</td>
<td><code class="prettyprint">x &lt;&lt; y</code></td>
<td>Shift left</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x &gt;&gt; y</code></td>
<td>Shift right</td>
</tr>
<tr>
<td>Relational and type testing</td>
<td><code class="prettyprint">x &lt; y</code></td>
<td>Less than</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x &gt; y</code></td>
<td>Greater than</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x &lt;= y</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x &gt;= y</code></td>
<td>Greater than or equal</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x is T</code></td>
<td>Return <code class="prettyprint">true</code> if <code class="prettyprint">x</code> is a <code class="prettyprint">T</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x as T</code></td>
<td>Return <code class="prettyprint">x</code> typed as <code class="prettyprint">T</code>, or <code class="prettyprint">null</code> if <code class="prettyprint">x</code> is not a <code class="prettyprint">T</code></td>
</tr>
<tr>
<td>Equality</td>
<td><code class="prettyprint">x == y</code></td>
<td>Equal</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x != y</code></td>
<td>Not equal</td>
</tr>
<tr>
<td>Logical AND</td>
<td><code class="prettyprint">x &amp; y</code></td>
<td>Integer bitwise AND, boolean logical AND</td>
</tr>
<tr>
<td>Logical XOR</td>
<td><code class="prettyprint">x ^ y</code></td>
<td>Integer bitwise XOR, boolean logical XOR</td>
</tr>
<tr>
<td>Logical OR</td>
<td>`x</td>
<td>y`</td>
</tr>
<tr>
<td>Conditional AND</td>
<td><code class="prettyprint">x &amp;&amp; y</code></td>
<td>Evaluates <code class="prettyprint">y</code> only if <code class="prettyprint">x</code> is <code class="prettyprint">true</code></td>
</tr>
<tr>
<td>Conditional OR</td>
<td>`x</td>
<td></td>
</tr>
<tr>
<td>Null coalescing</td>
<td><code class="prettyprint">X ?? y</code></td>
<td>Evaluates to <code class="prettyprint">y</code> if <code class="prettyprint">x</code> is <code class="prettyprint">null</code>, to <code class="prettyprint">x</code> otherwise</td>
</tr>
<tr>
<td>Conditional</td>
<td><code class="prettyprint">x ? y : z</code></td>
<td>Evaluates <code class="prettyprint">y</code> if <code class="prettyprint">x</code> is <code class="prettyprint">true</code>, <code class="prettyprint">z</code> if <code class="prettyprint">x</code> is <code class="prettyprint">false</code></td>
</tr>
<tr>
<td>Assignment or anonymous function</td>
<td><code class="prettyprint">x = y</code></td>
<td>Assignment</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x op= y</code></td>
<td>Compound assignment; supported operators are <code class="prettyprint">*=</code> <code class="prettyprint">/=</code> <code class="prettyprint">%=</code> <code class="prettyprint">+=</code> <code class="prettyprint">-=</code> <code class="prettyprint">&lt;&lt;=</code> <code class="prettyprint">&gt;&gt;=</code> <code class="prettyprint">&amp;=</code> <code class="prettyprint">^=</code> `</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">(T x) =&gt; y</code></td>
<td>Anonymous function (lambda expression)</td>
</tr>
</tbody></table>

<h2 id="statements">Statements</h2>

<p>The actions of a program are expressed using <strong><em>statements</em></strong>. C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</p>

<p>A <strong><em>block</em></strong> permits multiple statements to be written in contexts where a single statement is allowed. A block consists of a list of statements written between the delimiters <code class="prettyprint">{</code> and <code class="prettyprint">}</code>.</p>

<p><strong><em>Declaration statements</em></strong> are used to declare local variables and constants.</p>

<p><strong><em>Expression statements</em></strong> are used to evaluate expressions. Expressions that can be used as statements include method invocations, object allocations using the <code class="prettyprint">new</code> operator, assignments using <code class="prettyprint">=</code> and the compound assignment operators, increment and decrement operations using the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators and await expressions.</p>

<p><strong><em>Selection statements</em></strong> are used to select one of a number of possible statements for execution based on the value of some expression. In this group are the <code class="prettyprint">if</code> and <code class="prettyprint">switch</code> statements.</p>

<p><strong><em>Iteration statements</em></strong> are used to repeatedly execute an embedded statement. In this group are the <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, and <code class="prettyprint">foreach</code> statements.</p>

<p><strong><em>Jump statements</em></strong> are used to transfer control. In this group are the <code class="prettyprint">break</code>, <code class="prettyprint">continue</code>, <code class="prettyprint">goto</code>, <code class="prettyprint">throw</code>, <code class="prettyprint">return</code>, and <code class="prettyprint">yield</code> statements.</p>

<p>The <code class="prettyprint">try</code>&hellip;<code class="prettyprint">catch</code> statement is used to catch exceptions that occur during execution of a block, and the <code class="prettyprint">try</code>&hellip;<code class="prettyprint">finally</code> statement is used to specify finalization code that is always executed, whether an exception occurred or not.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements are used to control the overflow checking context for integral-type arithmetic operations and conversions.</p>

<p>The <code class="prettyprint">lock</code> statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</p>

<p>The <code class="prettyprint">using</code> statement is used to obtain a resource, execute a statement, and then dispose of that resource.</p>

<p>Below are examples of each kind of statement</p>

<p><strong>Local variable declarations</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span> <span class="n">c</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
   <span class="n">a</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
   <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span> <span class="p">+</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><strong>Local constant declaration</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">pi</span> <span class="p">=</span> <span class="m">3.1415927f</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span> <span class="p">=</span> <span class="m">25</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">pi</span> <span class="p">*</span> <span class="n">r</span> <span class="p">*</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><strong>Expression statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="p">=</span> <span class="m">123</span><span class="p">;</span>                <span class="c1">// Expression statement</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">// Expression statement</span>
    <span class="n">i</span><span class="p">++;</span>                    <span class="c1">// Expression statement</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">// Expression statement</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">if</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"No arguments"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"One or more arguments"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">switch</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"No arguments"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"One argument"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"{0} arguments"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">while</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="p">++;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">do</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">s</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="p">!=</span> <span class="k">null</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">for</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">foreach</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="k">in</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">break</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">continue</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">StartsWith</span><span class="p">(</span><span class="s">"/"</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">goto</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
    <span class="n">loop</span><span class="p">:</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">++]);</span>
    <span class="n">check</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">return</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">yield</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Range</span><span class="p">(</span><span class="kt">int</span> <span class="k">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="k">from</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="nf">Range</span><span class="p">(-</span><span class="m">10</span><span class="p">,</span><span class="m">10</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">throw</code> and <code class="prettyprint">try</code> statements</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="kt">double</span> <span class="nf">Divide</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">DivideByZeroException</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Two numbers required"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="p">=</span> <span class="kt">double</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
        <span class="kt">double</span> <span class="n">y</span> <span class="p">=</span> <span class="kt">double</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">finally</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Good bye!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>
    <span class="k">checked</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>        <span class="c1">// Exception</span>
    <span class="p">}</span>
    <span class="k">unchecked</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>        <span class="c1">// Overflow</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">lock</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Account</span>
<span class="p">{</span>
    <span class="kt">decimal</span> <span class="n">balance</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Withdraw</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="p">&gt;</span> <span class="n">balance</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Insufficient funds"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">balance</span> <span class="p">-=</span> <span class="n">amount</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><strong><code class="prettyprint">using</code> statement</strong></p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="p">(</span><span class="n">TextWriter</span> <span class="n">w</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="nf">CreateText</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">w</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Line one"</span><span class="p">);</span>
        <span class="n">w</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Line two"</span><span class="p">);</span>
        <span class="n">w</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Line three"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id="classes-and-objects">Classes and objects</h2>

<p><strong><em>Classes</em></strong> are the most fundamental of C#&rsquo;s types. A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit. A class provides a definition for dynamically created <strong><em>instances</em></strong> of the class, also known as <strong><em>objects</em></strong>. Classes support <strong><em>inheritance</em></strong> and <strong><em>polymorphism</em></strong>, mechanisms whereby <strong><em>derived classes</em></strong> can extend and specialize <strong><em>base classes</em></strong>.</p>

<p>New classes are created using class declarations. A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class. The header is followed by the class body, which consists of a list of member declarations written between the delimiters <code class="prettyprint">{</code> and <code class="prettyprint">}</code>.</p>

<p>The following is a declaration of a simple class named <code class="prettyprint">Point</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Instances of classes are created using the <code class="prettyprint">new</code> operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance. The following statements create two <code class="prettyprint">Point</code> objects and store references to those objects in two variables:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Point</span> <span class="n">p1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">p2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">);</span>
</code></pre>
<p>The memory occupied by an object is automatically reclaimed when the object is no longer in use. It is neither necessary nor possible to explicitly deallocate objects in C#.</p>

<h3 id="members">Members</h3>

<p>The members of a class are either <strong><em>static members</em></strong> or <strong><em>instance members</em></strong>. Static members belong to classes, and instance members belong to objects (instances of classes).</p>

<p>The following table provides an overview of the kinds of members a class can contain.</p>

<table><thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Constants</td>
<td>Constant values associated with the class</td>
</tr>
<tr>
<td>Fields</td>
<td>Variables of the class</td>
</tr>
<tr>
<td>Methods</td>
<td>Computations and actions that can be performed by the class</td>
</tr>
<tr>
<td>Properties</td>
<td>Actions associated with reading and writing named properties of the class</td>
</tr>
<tr>
<td>Indexers</td>
<td>Actions associated with indexing instances of the class like an array</td>
</tr>
<tr>
<td>Events</td>
<td>Notifications that can be generated by the class</td>
</tr>
<tr>
<td>Operators</td>
<td>Conversions and expression operators supported by the class</td>
</tr>
<tr>
<td>Constructors</td>
<td>Actions required to initialize instances of the class or the class itself</td>
</tr>
<tr>
<td>Destructors</td>
<td>Actions to perform before instances of the class are permanently discarded</td>
</tr>
<tr>
<td>Types</td>
<td>Nested types declared by the class</td>
</tr>
</tbody></table>

<h3 id="accessibility">Accessibility</h3>

<p>Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member. There are five possible forms of accessibility. These are summarized in the following table.</p>

<table><thead>
<tr>
<th><strong>Accessibility</strong></th>
<th><strong>Meaning</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">public</code></td>
<td>Access not limited</td>
</tr>
<tr>
<td><code class="prettyprint">protected</code></td>
<td>Access limited to this class or classes derived from this class</td>
</tr>
<tr>
<td><code class="prettyprint">internal</code></td>
<td>Access limited to this program</td>
</tr>
<tr>
<td><code class="prettyprint">protected internal</code></td>
<td>Access limited to this program or classes derived from this class</td>
</tr>
<tr>
<td><code class="prettyprint">private</code></td>
<td>Access limited to this class</td>
</tr>
</tbody></table>

<h3 id="type-parameters">Type parameters</h3>

<p>A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names. The type parameters can the be used in the body of the class declarations to define the members of the class. In the following example, the type parameters of <code class="prettyprint">Pair</code> are <code class="prettyprint">TFirst</code> and <code class="prettyprint">TSecond</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Pair</span><span class="p">&lt;</span><span class="n">TFirst</span><span class="p">,</span><span class="n">TSecond</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">TFirst</span> <span class="n">First</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">TSecond</span> <span class="n">Second</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>A class type that is declared to take type parameters is called a generic class type. Struct, interface and delegate types can also be generic.</p>

<p>When the generic class is used, type arguments must be provided for each of the type parameters:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Pair</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">pair</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">First</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">Second</span> <span class="p">=</span> <span class="s">"two"</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">First</span><span class="p">;</span>     <span class="c1">// TFirst is int</span>
<span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">Second</span><span class="p">;</span> <span class="c1">// TSecond is string</span>
</code></pre>
<p>A generic type with type arguments provided, like <code class="prettyprint">Pair&lt;int,string&gt;
</code> above, is called a constructed type.</p>

<h3 id="base-classes">Base classes</h3>

<p>A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class. Omitting a base class specification is the same as deriving from type <code class="prettyprint">object</code>. In the following example, the base class of <code class="prettyprint">Point3D</code> is <code class="prettyprint">Point</code>, and the base class of <code class="prettyprint">Point</code> is <code class="prettyprint">object</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Point3D</span><span class="p">:</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Point3D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">):</span> <span class="k">base</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A class inherits the members of its base class. Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the destructors of the base class. A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member. In the previous example, <code class="prettyprint">Point3D</code> inherits the <code class="prettyprint">x</code> and <code class="prettyprint">y</code> fields from <code class="prettyprint">Point</code>, and every <code class="prettyprint">Point3D</code> instance contains three fields, <code class="prettyprint">x</code>, <code class="prettyprint">y</code>, and <code class="prettyprint">z</code>.</p>

<p>An implicit conversion exists from a class type to any of its base class types. Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class. For example, given the previous class declarations, a variable of type <code class="prettyprint">Point</code> can reference either a <code class="prettyprint">Point</code> or a <code class="prettyprint">Point3D</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Point</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point3D</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">);</span>
</code></pre>
<h3 id="fields">Fields</h3>

<p>A field is a variable that is associated with a class or with an instance of a class.</p>

<p>A field declared with the <code class="prettyprint">static</code> modifier defines a <strong><em>static field</em></strong>. A static field identifies exactly one storage location. No matter how many instances of a class are created, there is only ever one copy of a static field.</p>

<p>A field declared without the <code class="prettyprint">static</code> modifier defines an <strong><em>instance field</em></strong>. Every instance of a class contains a separate copy of all the instance fields of that class.</p>

<p>In the following example, each instance of the <code class="prettyprint">Color</code> class has a separate copy of the <code class="prettyprint">r</code>, <code class="prettyprint">g</code>, and <code class="prettyprint">b</code> instance fields, but there is only one copy of the <code class="prettyprint">Black</code>, <code class="prettyprint">White</code>, <code class="prettyprint">Red</code>, <code class="prettyprint">Green</code>, and <code class="prettyprint">Blue</code> static fields:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Color</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Color</span> <span class="n">Black</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Color</span> <span class="n">White</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">255</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">255</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Color</span> <span class="n">Red</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">255</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Color</span> <span class="n">Green</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Color</span> <span class="n">Blue</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">255</span><span class="p">);</span>
    <span class="k">private</span> <span class="kt">byte</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Color</span><span class="p">(</span><span class="kt">byte</span> <span class="n">r</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">g</span><span class="p">,</span> <span class="kt">byte</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">r</span> <span class="p">=</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">g</span> <span class="p">=</span> <span class="n">g</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">b</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>As shown in the previous example, <strong><em>read-only fields</em></strong> may be declared with a <code class="prettyprint">readonly</code> modifier. Assignment to a <code class="prettyprint">readonly</code> field can only occur as part of the field&rsquo;s declaration or in a constructor in the same class.</p>

<h3 id="methods">Methods</h3>

<p>A <strong><em>method</em></strong> is a member that implements a computation or action that can be performed by an object or class. <strong><em>Static methods</em></strong> are accessed through the class. <strong><em>Instance methods</em></strong> are accessed through instances of the class.</p>

<p>Methods have a (possibly empty) list of <strong><em>parameters</em></strong>, which represent values or variable references passed to the method, and a <strong><em>return type</em></strong>, which specifies the type of the value computed and returned by the method. A method&rsquo;s return type is <code class="prettyprint">void</code> if it does not return a value.</p>

<p>Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called. Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</p>

<p>The <strong><em>signature</em></strong> of a method must be unique in the class in which the method is declared. The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters. The signature of a method does not include the return type.</p>

<h4 id="parameters">Parameters</h4>

<p>Parameters are used to pass values or variable references to methods. The parameters of a method get their actual values from the <strong><em>arguments</em></strong> that are specified when the method is invoked. There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</p>

<p>A <strong><em>value parameter</em></strong> is used for input parameter passing. A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter. Modifications to a value parameter do not affect the argument that was passed for the parameter.</p>

<p>Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</p>

<p>A <strong><em>reference parameter</em></strong> is used for both input and output parameter passing. The argument passed for a reference parameter must be a variable, and during execution of the method, the reference parameter represents the same storage location as the argument variable. A reference parameter is declared with the <code class="prettyprint">ref</code> modifier. The following example shows the use of <code class="prettyprint">ref</code> parameters.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">y</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span> <span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">j</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"{0} {1}"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>            <span class="c1">// Outputs "2 1"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An <strong><em>output parameter</em></strong> is used for output parameter passing. An output parameter is similar to a reference parameter except that the initial value of the caller-provided argument is unimportant. An output parameter is declared with the <code class="prettyprint">out</code> modifier. The following example shows the use of <code class="prettyprint">out</code> parameters.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">remainder</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="p">=</span> <span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">remainder</span> <span class="p">=</span> <span class="n">x</span> <span class="p">%</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>
        <span class="nf">Divide</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="k">out</span> <span class="n">res</span><span class="p">,</span> <span class="k">out</span> <span class="n">rem</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"{0} {1}"</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rem</span><span class="p">);</span>    <span class="c1">// Outputs "3 1"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <strong><em>parameter array</em></strong> permits a variable number of arguments to be passed to a method. A parameter array is declared with the <code class="prettyprint">params</code> modifier. Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type. The <code class="prettyprint">Write</code> and <code class="prettyprint">WriteLine</code> methods of the <code class="prettyprint">System.Console</code> class are good examples of parameter array usage. They are declared as follows.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Console</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="kt">string</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">params</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="kt">string</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">params</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type. However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array. In the latter case, an array instance is automatically created and initialized with the given arguments. This example</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"x={0} y={1} z={2}"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</code></pre>
<p>is equivalent to writing the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="s">"x={0} y={1} z={2}"</span><span class="p">;</span>
<span class="kt">object</span><span class="p">[]</span> <span class="n">args</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
<span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
<span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
<span class="n">args</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</code></pre>
<h4 id="method-body-and-local-variables">Method body and local variables</h4>

<p>A method&rsquo;s body specifies the statements to execute when the method is invoked.</p>

<p>A method body can declare variables that are specific to the invocation of the method. Such variables are called <strong><em>local variables</em></strong>. A local variable declaration specifies a type name, a variable name, and possibly an initial value. The following example declares a local variable <code class="prettyprint">i</code> with an initial value of zero and a local variable <code class="prettyprint">j</code> with no initial value.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Squares</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">j</span> <span class="p">=</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"{0} x {0} = {1}"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">i</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>C# requires a local variable to be <strong><em>definitely assigned</em></strong> before its value can be obtained. For example, if the declaration of the previous <code class="prettyprint">i</code> did not include an initial value, the compiler would report an error for the subsequent usages of <code class="prettyprint">i</code> because <code class="prettyprint">i</code> would not be definitely assigned at those points in the program.</p>

<p>A method can use <code class="prettyprint">return</code> statements to return control to its caller. In a method returning <code class="prettyprint">void</code>, <code class="prettyprint">return</code> statements cannot specify an expression. In a method returning non-<code class="prettyprint">void</code>, <code class="prettyprint">return</code> statements must include an expression that computes the return value.</p>

<h4 id="static-and-instance-methods">Static and instance methods</h4>

<p>A method declared with a <code class="prettyprint">static</code> modifier is a <strong><em>static method</em></strong>. A static method does not operate on a specific instance and can only directly access static members.</p>

<p>A method declared without a <code class="prettyprint">static</code> modifier is an <strong><em>instance method</em></strong>. An instance method operates on a specific instance and can access both static and instance members. The instance on which an instance method was invoked can be explicitly accessed as <code class="prettyprint">this</code>. It is an error to refer to <code class="prettyprint">this</code> in a static method.</p>

<p>The following <code class="prettyprint">Entity</code> class has both static and instance members.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Entity</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">nextSerialNo</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serialNo</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Entity</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">serialNo</span> <span class="p">=</span> <span class="n">nextSerialNo</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="nf">GetSerialNo</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">serialNo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">GetNextSerialNo</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nextSerialNo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SetNextSerialNo</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextSerialNo</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Each <code class="prettyprint">Entity</code> instance contains a serial number (and presumably some other information that is not shown here). The <code class="prettyprint">Entity</code> constructor (which is like an instance method) initializes the new instance with the next available serial number. Because the constructor is an instance member, it is permitted to access both the <code class="prettyprint">serialNo</code> instance field and the <code class="prettyprint">nextSerialNo</code> static field.</p>

<p>The <code class="prettyprint">GetNextSerialNo</code> and <code class="prettyprint">SetNextSerialNo</code> static methods can access the <code class="prettyprint">nextSerialNo</code> static field, but it would be an error for them to directly access the <code class="prettyprint">serialNo</code> instance field.</p>

<p>The following example shows the use of the <code class="prettyprint">Entity</code> class.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Entity</span><span class="p">.</span><span class="nf">SetNextSerialNo</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
        <span class="n">Entity</span> <span class="n">e1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Entity</span><span class="p">();</span>
        <span class="n">Entity</span> <span class="n">e2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Entity</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e1</span><span class="p">.</span><span class="nf">GetSerialNo</span><span class="p">());</span>           <span class="c1">// Outputs "1000"</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e2</span><span class="p">.</span><span class="nf">GetSerialNo</span><span class="p">());</span>           <span class="c1">// Outputs "1001"</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">Entity</span><span class="p">.</span><span class="nf">GetNextSerialNo</span><span class="p">());</span>   <span class="c1">// Outputs "1002"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Note that the <code class="prettyprint">SetNextSerialNo</code> and <code class="prettyprint">GetNextSerialNo</code> static methods are invoked on the class whereas the <code class="prettyprint">GetSerialNo</code> instance method is invoked on instances of the class.</p>

<h4 id="virtual-override-and-abstract-methods">Virtual, override, and abstract methods</h4>

<p>When an instance method declaration includes a <code class="prettyprint">virtual</code> modifier, the method is said to be a <strong><em>virtual method</em></strong>. When no <code class="prettyprint">virtual</code> modifier is present, the method is said to be a <strong><em>non-virtual method</em></strong>.</p>

<p>When a virtual method is invoked, the <strong><em>run-time type</em></strong> of the instance for which that invocation takes place determines the actual method implementation to invoke. In a nonvirtual method invocation, the <strong><em>compile-time type</em></strong> of the instance is the determining factor.</p>

<p>A virtual method can be <strong><em>overridden</em></strong> in a derived class. When an instance method declaration includes an <code class="prettyprint">override</code> modifier, the method overrides an inherited virtual method with the same signature. Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</p>

<p>An <strong><em>abstract</em></strong> method is a virtual method with no implementation. An abstract method is declared with the <code class="prettyprint">abstract</code> modifier and is permitted only in a class that is also declared <code class="prettyprint">abstract</code>. An abstract method must be overridden in every non-abstract derived class.</p>

<p>The following example declares an abstract class, <code class="prettyprint">Expression</code>, which represents an expression tree node, and three derived classes, <code class="prettyprint">Constant</code>, <code class="prettyprint">VariableReference</code>, and <code class="prettyprint">Operation</code>, which implement expression tree nodes for constants, variable references, and arithmetic operations. (This is similar to, but not to be confused with the expression tree types introduced in <a href="types.md#expression-tree-types">Expression tree types</a>).</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expression</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">abstract</span> <span class="kt">double</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">Hashtable</span> <span class="n">vars</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Constant</span><span class="p">:</span> <span class="n">Expression</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Constant</span><span class="p">(</span><span class="kt">double</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">double</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">Hashtable</span> <span class="n">vars</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">VariableReference</span><span class="p">:</span> <span class="n">Expression</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">VariableReference</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">double</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">Hashtable</span> <span class="n">vars</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">object</span> <span class="k">value</span> <span class="p">=</span> <span class="n">vars</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Unknown variable: "</span> <span class="p">+</span> <span class="n">name</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Convert</span><span class="p">.</span><span class="nf">ToDouble</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Operation</span><span class="p">:</span> <span class="n">Expression</span>
<span class="p">{</span>
    <span class="n">Expression</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">op</span><span class="p">;</span>
    <span class="n">Expression</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Operation</span><span class="p">(</span><span class="n">Expression</span> <span class="n">left</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op</span><span class="p">,</span> <span class="n">Expression</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">left</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">op</span> <span class="p">=</span> <span class="n">op</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">right</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">double</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">Hashtable</span> <span class="n">vars</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="p">=</span> <span class="n">left</span><span class="p">.</span><span class="nf">Evaluate</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">y</span> <span class="p">=</span> <span class="n">right</span><span class="p">.</span><span class="nf">Evaluate</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span> <span class="p">-</span> <span class="n">y</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">'*'</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">y</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">'/'</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span> <span class="p">/</span> <span class="n">y</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Unknown operator"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The previous four classes can be used to model arithmetic expressions. For example, using instances of these classes, the expression <code class="prettyprint">x + 3</code> can be represented as follows.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Expression</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Operation</span><span class="p">(</span>
    <span class="k">new</span> <span class="nf">VariableReference</span><span class="p">(</span><span class="s">"x"</span><span class="p">),</span>
    <span class="sc">'+'</span><span class="p">,</span>
    <span class="k">new</span> <span class="nf">Constant</span><span class="p">(</span><span class="m">3</span><span class="p">));</span>
</code></pre>
<p>The <code class="prettyprint">Evaluate</code> method of an <code class="prettyprint">Expression</code> instance is invoked to evaluate the given expression and produce a <code class="prettyprint">double</code> value. The method takes as an argument a <code class="prettyprint">Hashtable</code> that contains variable names (as keys of the entries) and values (as values of the entries). The <code class="prettyprint">Evaluate</code> method is a virtual abstract method, meaning that non-abstract derived classes must override it to provide an actual implementation.</p>

<p>A <code class="prettyprint">Constant</code>&rsquo;s implementation of <code class="prettyprint">Evaluate</code> simply returns the stored constant. A <code class="prettyprint">VariableReference</code>&rsquo;s implementation looks up the variable name in the hashtable and returns the resulting value. An <code class="prettyprint">Operation</code>&rsquo;s implementation first evaluates the left and right operands (by recursively invoking their <code class="prettyprint">Evaluate</code> methods) and then performs the given arithmetic operation.</p>

<p>The following program uses the <code class="prettyprint">Expression</code> classes to evaluate the expression <code class="prettyprint">x * (y + 2)</code> for different values of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Expression</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Operation</span><span class="p">(</span>
            <span class="k">new</span> <span class="nf">VariableReference</span><span class="p">(</span><span class="s">"x"</span><span class="p">),</span>
            <span class="sc">'*'</span><span class="p">,</span>
            <span class="k">new</span> <span class="nf">Operation</span><span class="p">(</span>
                <span class="k">new</span> <span class="nf">VariableReference</span><span class="p">(</span><span class="s">"y"</span><span class="p">),</span>
                <span class="sc">'+'</span><span class="p">,</span>
                <span class="k">new</span> <span class="nf">Constant</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">);</span>
        <span class="n">Hashtable</span> <span class="n">vars</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Hashtable</span><span class="p">();</span>
        <span class="n">vars</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
        <span class="n">vars</span><span class="p">[</span><span class="s">"y"</span><span class="p">]</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="nf">Evaluate</span><span class="p">(</span><span class="n">vars</span><span class="p">));</span>        <span class="c1">// Outputs "21"</span>
        <span class="n">vars</span><span class="p">[</span><span class="s">"x"</span><span class="p">]</span> <span class="p">=</span> <span class="m">1.5</span><span class="p">;</span>
        <span class="n">vars</span><span class="p">[</span><span class="s">"y"</span><span class="p">]</span> <span class="p">=</span> <span class="m">9</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="nf">Evaluate</span><span class="p">(</span><span class="n">vars</span><span class="p">));</span>        <span class="c1">// Outputs "16.5"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h4 id="method-overloading">Method overloading</h4>

<p>Method <strong><em>overloading</em></strong> permits multiple methods in the same class to have the same name as long as they have unique signatures. When compiling an invocation of an overloaded method, the compiler uses <strong><em>overload resolution</em></strong> to determine the specific method to invoke. Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found. The following example shows overload resolution in effect. The comment for each invocation in the <code class="prettyprint">Main</code> method shows which method is actually invoked.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F()"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">object</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F(object)"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F(int)"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F(double)"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="n">F</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F&lt;T&gt;(T)"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F(double, double)"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">F</span><span class="p">();</span>                 <span class="c1">// Invokes F()</span>
        <span class="nf">F</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>                <span class="c1">// Invokes F(int)</span>
        <span class="nf">F</span><span class="p">(</span><span class="m">1.0</span><span class="p">);</span>              <span class="c1">// Invokes F(double)</span>
        <span class="nf">F</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span>            <span class="c1">// Invokes F(object)</span>
        <span class="nf">F</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="m">1</span><span class="p">);</span>        <span class="c1">// Invokes F(double)</span>
        <span class="nf">F</span><span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="m">1</span><span class="p">);</span>        <span class="c1">// Invokes F(object)</span>
        <span class="n">F</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">);</span>           <span class="c1">// Invokes F&lt;T&gt;(T)</span>
        <span class="nf">F</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>             <span class="c1">// Invokes F(double, double)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</p>

<h3 id="other-function-members">Other function members</h3>

<p>Members that contain executable code are collectively known as the <strong><em>function members</em></strong> of a class. The preceding section describes methods, which are the primary kind of function members. This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and destructors.</p>

<p>The following code shows a generic class called <code class="prettyprint">List&lt;T&gt;</code>, which implements a growable list of objects. The class contains several examples of the most common kinds of function members.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="c1">// Constant...</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">defaultCapacity</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>

    <span class="c1">// Fields...</span>
    <span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="c1">// Constructors...</span>
    <span class="k">public</span> <span class="nf">List</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span> <span class="p">=</span> <span class="n">defaultCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Properties...</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Capacity</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="k">value</span> <span class="p">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">T</span><span class="p">[]</span> <span class="n">newItems</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="k">value</span><span class="p">];</span>
                <span class="n">Array</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">newItems</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
                <span class="n">items</span> <span class="p">=</span> <span class="n">newItems</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Indexer...</span>
    <span class="k">public</span> <span class="n">T</span> <span class="k">this</span><span class="p">[</span><span class="kt">int</span> <span class="n">index</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="nf">OnChanged</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Methods...</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="p">==</span> <span class="n">Capacity</span><span class="p">)</span> <span class="n">Capacity</span> <span class="p">=</span> <span class="n">count</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span>
        <span class="n">items</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">count</span><span class="p">++;</span>
        <span class="nf">OnChanged</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnChanged</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Changed</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="nf">Changed</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">EventArgs</span><span class="p">.</span><span class="n">Empty</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Equals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span> <span class="k">as</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;);</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">b</span> <span class="p">==</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">a</span><span class="p">.</span><span class="n">count</span> <span class="p">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="kt">object</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Event...</span>
    <span class="k">public</span> <span class="k">event</span> <span class="n">EventHandler</span> <span class="n">Changed</span><span class="p">;</span>

    <span class="c1">// Operators...</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">!</span><span class="nf">Equals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h4 id="constructors">Constructors</h4>

<p>C# supports both instance and static constructors. An <strong><em>instance constructor</em></strong> is a member that implements the actions required to initialize an instance of a class. A <strong><em>static constructor</em></strong> is a member that implements the actions required to initialize a class itself when it is first loaded.</p>

<p>A constructor is declared like a method with no return type and the same name as the containing class. If a constructor declaration includes a <code class="prettyprint">static</code> modifier, it declares a static constructor. Otherwise, it declares an instance constructor.</p>

<p>Instance constructors can be overloaded. For example, the <code class="prettyprint">List&lt;T&gt;
</code> class declares two instance constructors, one with no parameters and one that takes an <code class="prettyprint">int</code> parameter. Instance constructors are invoked using the <code class="prettyprint">new</code> operator. The following statements allocate two <code class="prettyprint">List&lt;string&gt;
</code> instances using each of the constructors of the <code class="prettyprint">List</code> class.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">list1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">list2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span><span class="m">10</span><span class="p">);</span>
</code></pre>
<p>Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class. If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</p>

<h4 id="properties">Properties</h4>

<p><strong><em>Properties</em></strong> are a natural extension of fields. Both are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties do not denote storage locations. Instead, properties have <strong><em>accessors</em></strong> that specify the statements to be executed when their values are read or written.</p>

<p>A property is declared like a field, except that the declaration ends with a <code class="prettyprint">get</code> accessor and/or a <code class="prettyprint">set</code> accessor written between the delimiters <code class="prettyprint">{</code> and <code class="prettyprint">}</code> instead of ending in a semicolon. A property that has both a <code class="prettyprint">get</code> accessor and a <code class="prettyprint">set</code> accessor is a <strong><em>read-write property</em></strong>, a property that has only a <code class="prettyprint">get</code> accessor is a <strong><em>read-only property</em></strong>, and a property that has only a <code class="prettyprint">set</code> accessor is a <strong><em>write-only property</em></strong>.</p>

<p>A <code class="prettyprint">get</code> accessor corresponds to a parameterless method with a return value of the property type. Except as the target of an assignment, when a property is referenced in an expression, the <code class="prettyprint">get</code> accessor of the property is invoked to compute the value of the property.</p>

<p>A <code class="prettyprint">set</code> accessor corresponds to a method with a single parameter named <code class="prettyprint">value</code> and no return type. When a property is referenced as the target of an assignment or as the operand of <code class="prettyprint">++</code> or <code class="prettyprint">--</code>, the <code class="prettyprint">set</code> accessor is invoked with an argument that provides the new value.</p>

<p>The <code class="prettyprint">List&lt;T&gt;
</code> class declares two properties, <code class="prettyprint">Count</code> and <code class="prettyprint">Capacity</code>, which are read-only and read-write, respectively. The following is an example of use of these properties.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="n">names</span><span class="p">.</span><span class="n">Capacity</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>            <span class="c1">// Invokes set accessor</span>
<span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">names</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>             <span class="c1">// Invokes get accessor</span>
<span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="n">names</span><span class="p">.</span><span class="n">Capacity</span><span class="p">;</span>          <span class="c1">// Invokes get accessor</span>
</code></pre>
<p>Similar to fields and methods, C# supports both instance properties and static properties. Static properties are declared with the <code class="prettyprint">static</code> modifier, and instance properties are declared without it.</p>

<p>The accessor(s) of a property can be virtual. When a property declaration includes a <code class="prettyprint">virtual</code>, <code class="prettyprint">abstract</code>, or <code class="prettyprint">override</code> modifier, it applies to the accessor(s) of the property.</p>

<h4 id="indexers">Indexers</h4>

<p>An <strong><em>indexer</em></strong> is a member that enables objects to be indexed in the same way as an array. An indexer is declared like a property except that the name of the member is <code class="prettyprint">this</code> followed by a parameter list written between the delimiters <code class="prettyprint">[</code> and <code class="prettyprint">]</code>. The parameters are available in the accessor(s) of the indexer. Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</p>

<p>The <code class="prettyprint">List</code> class declares a single read-write indexer that takes an <code class="prettyprint">int</code> parameter. The indexer makes it possible to index <code class="prettyprint">List</code> instances with <code class="prettyprint">int</code> values. For example</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
<span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Liz"</span><span class="p">);</span>
<span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Martha"</span><span class="p">);</span>
<span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Beth"</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">names</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</p>

<h4 id="events">Events</h4>

<p>An <strong><em>event</em></strong> is a member that enables a class or object to provide notifications. An event is declared like a field except that the declaration includes an <code class="prettyprint">event</code> keyword and the type must be a delegate type.</p>

<p>Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors). The field stores a reference to a delegate that represents the event handlers that have been added to the event. If no event handles are present, the field is <code class="prettyprint">null</code>.</p>

<p>The <code class="prettyprint">List&lt;T&gt;
</code> class declares a single event member called <code class="prettyprint">Changed</code>, which indicates that a new item has been added to the list. The <code class="prettyprint">Changed</code> event is raised by the <code class="prettyprint">OnChanged</code> virtual method, which first checks whether the event is <code class="prettyprint">null</code> (meaning that no handlers are present). The notion of raising an event is precisely equivalent to invoking the delegate represented by the eventâ€”thus, there are no special language constructs for raising events.</p>

<p>Clients react to events through <strong><em>event handlers</em></strong>. Event handlers are attached using the <code class="prettyprint">+=</code> operator and removed using the <code class="prettyprint">-=</code> operator. The following example attaches an event handler to the <code class="prettyprint">Changed</code> event of a <code class="prettyprint">List&lt;string&gt;
</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">changeCount</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">ListChanged</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">changeCount</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
        <span class="n">names</span><span class="p">.</span><span class="n">Changed</span> <span class="p">+=</span> <span class="k">new</span> <span class="nf">EventHandler</span><span class="p">(</span><span class="n">ListChanged</span><span class="p">);</span>
        <span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Liz"</span><span class="p">);</span>
        <span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Martha"</span><span class="p">);</span>
        <span class="n">names</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"Beth"</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">changeCount</span><span class="p">);</span>        <span class="c1">// Outputs "3"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide <code class="prettyprint">add</code> and <code class="prettyprint">remove</code> accessors, which are somewhat similar to the <code class="prettyprint">set</code> accessor of a property.</p>

<h4 id="operators">Operators</h4>

<p>An <strong><em>operator</em></strong> is a member that defines the meaning of applying a particular expression operator to instances of a class. Three kinds of operators can be defined: unary operators, binary operators, and conversion operators. All operators must be declared as <code class="prettyprint">public</code> and <code class="prettyprint">static</code>.</p>

<p>The <code class="prettyprint">List&lt;T&gt;
</code> class declares two operators, <code class="prettyprint">operator==</code> and <code class="prettyprint">operator!=</code>, and thus gives new meaning to expressions that apply those operators to <code class="prettyprint">List</code> instances. Specifically, the operators define equality of two <code class="prettyprint">List&lt;T&gt;
</code> instances as comparing each of the contained objects using their <code class="prettyprint">Equals</code> methods. The following example uses the <code class="prettyprint">==</code> operator to compare two <code class="prettyprint">List&lt;int&gt;
</code> instances.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
        <span class="n">a</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">b</span><span class="p">);</span>        <span class="c1">// Outputs "True"</span>
        <span class="n">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="m">3</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">b</span><span class="p">);</span>        <span class="c1">// Outputs "False"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The first <code class="prettyprint">Console.WriteLine</code> outputs <code class="prettyprint">True</code> because the two lists contain the same number of objects with the same values in the same order. Had <code class="prettyprint">List&lt;T&gt;
</code> not defined <code class="prettyprint">operator==</code>, the first <code class="prettyprint">Console.WriteLine</code> would have output <code class="prettyprint">False</code> because <code class="prettyprint">a</code> and <code class="prettyprint">b</code> reference different <code class="prettyprint">List&lt;int&gt;
</code> instances.</p>

<h4 id="destructors">Destructors</h4>

<p>A <strong><em>destructor</em></strong> is a member that implements the actions required to destruct an instance of a class. Destructors cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly. The destructor for an instance is invoked automatically during garbage collection.</p>

<p>The garbage collector is allowed wide latitude in deciding when to collect objects and run destructors. Specifically, the timing of destructor invocations is not deterministic, and destructors may be executed on any thread. For these and other reasons, classes should implement destructors only when no other solutions are feasible.</p>

<p>The <code class="prettyprint">using</code> statement provides a better approach to object destruction.</p>

<h2 id="structs">Structs</h2>

<p>Like classes, <strong><em>structs</em></strong> are data structures that can contain data members and function members, but unlike classes, structs are value types and do not require heap allocation. A variable of a struct type directly stores the data of the struct, whereas a variable of a class type stores a reference to a dynamically allocated object. Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type <code class="prettyprint">object</code>.</p>

<p>Structs are particularly useful for small data structures that have value semantics. Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs. The use of structs rather than classes for small data structures can make a large difference in the number of memory allocations an application performs. For example, the following program creates and initializes an array of 100 points. With <code class="prettyprint">Point</code> implemented as a class, 101 separate objects are instantiatedâ€”one for the array and one each for the 100 elements.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Point</span><span class="p">[]</span> <span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">[</span><span class="m">100</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An alternative is to make <code class="prettyprint">Point</code> a struct.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">struct</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Now, only one object is instantiatedâ€”the one for the arrayâ€”and the <code class="prettyprint">Point</code> instances are stored in-line in the array.</p>

<p>Struct constructors are invoked with the <code class="prettyprint">new</code> operator, but that does not imply that memory is being allocated. Instead of dynamically allocating an object and returning a reference to it, a struct constructor simply returns the struct value itself (typically in a temporary location on the stack), and this value is then copied as necessary.</p>

<p>With classes, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With structs, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other. For example, the output produced by the following code fragment depends on whether <code class="prettyprint">Point</code> is a class or a struct.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Point</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">b</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</code></pre>
<p>If <code class="prettyprint">Point</code> is a class, the output is <code class="prettyprint">20</code> because <code class="prettyprint">a</code> and <code class="prettyprint">b</code> reference the same object. If <code class="prettyprint">Point</code> is a struct, the output is <code class="prettyprint">10</code> because the assignment of <code class="prettyprint">a</code> to <code class="prettyprint">b</code> creates a copy of the value, and this copy is unaffected by the subsequent assignment to <code class="prettyprint">a.x</code>.</p>

<p>The previous example highlights two of the limitations of structs. First, copying an entire struct is typically less efficient than copying an object reference, so assignment and value parameter passing can be more expensive with structs than with reference types. Second, except for <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameters, it is not possible to create references to structs, which rules out their usage in a number of situations.</p>

<h2 id="arrays">Arrays</h2>

<p>An <strong><em>array</em></strong> is a data structure that contains a number of variables that are accessed through computed indices. The variables contained in an array, also called the <strong><em>elements</em></strong> of the array, are all of the same type, and this type is called the <strong><em>element type</em></strong> of the array.</p>

<p>Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance. Actual array instances are created dynamically at run-time using the <code class="prettyprint">new</code> operator. The <code class="prettyprint">new</code> operation specifies the <strong><em>length</em></strong> of the new array instance, which is then fixed for the lifetime of the instance. The indices of the elements of an array range from <code class="prettyprint">0</code> to <code class="prettyprint">Length - 1</code>. The <code class="prettyprint">new</code> operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and <code class="prettyprint">null</code> for all reference types.</p>

<p>The following example creates an array of <code class="prettyprint">int</code> elements, initializes the array, and prints out the contents of the array.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"a[{0}] = {1}"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This example creates and operates on a <strong><em>single-dimensional array</em></strong>. C# also supports <strong><em>multi-dimensional arrays</em></strong>. The number of dimensions of an array type, also known as the <strong><em>rank</em></strong> of the array type, is one plus the number of commas written between the square brackets of the array type. The following example allocates a one-dimensional, a two-dimensional, and a three-dimensional array.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">[]</span> <span class="n">a1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">a2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">,</span> <span class="m">5</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[,,]</span> <span class="n">a3</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">];</span>
</code></pre>
<p>The <code class="prettyprint">a1</code> array contains 10 elements, the <code class="prettyprint">a2</code> array contains 50 (10 Ã— 5) elements, and the <code class="prettyprint">a3</code> array contains 100 (10 Ã— 5 Ã— 2) elements.</p>

<p>The element type of an array can be any type, including an array type. An array with elements of an array type is sometimes called a <strong><em>jagged array</em></strong> because the lengths of the element arrays do not all have to be the same. The following example allocates an array of arrays of <code class="prettyprint">int</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">[][]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">][];</span>
<span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
<span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">5</span><span class="p">];</span>
<span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">20</span><span class="p">];</span>
</code></pre>
<p>The first line creates an array with three elements, each of type <code class="prettyprint">int[]</code> and each with an initial value of <code class="prettyprint">null</code>. The subsequent lines then initialize the three elements with references to individual array instances of varying lengths.</p>

<p>The <code class="prettyprint">new</code> operator permits the initial values of the array elements to be specified using an <strong><em>array initializer</em></strong>, which is a list of expressions written between the delimiters <code class="prettyprint">{</code> and <code class="prettyprint">}</code>. The following example allocates and initializes an <code class="prettyprint">int[]</code> with three elements.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>
</code></pre>
<p>Note that the length of the array is inferred from the number of expressions between <code class="prettyprint">{</code> and <code class="prettyprint">}</code>. Local variable and field declarations can be shortened further such that the array type does not have to be restated.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>
</code></pre>
<p>Both of the previous examples are equivalent to the following:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">[]</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
<span class="n">t</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="n">t</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
<span class="n">t</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
</code></pre>
<h2 id="interfaces">Interfaces</h2>

<p>An <strong><em>interface</em></strong> defines a contract that can be implemented by classes and structs. An interface can contain methods, properties, events, and indexers. An interface does not provide implementations of the members it definesâ€”it merely specifies the members that must be supplied by classes or structs that implement the interface.</p>

<p>Interfaces may employ <strong><em>multiple inheritance</em></strong>. In the following example, the interface <code class="prettyprint">IComboBox</code> inherits from both <code class="prettyprint">ITextBox</code> and <code class="prettyprint">IListBox</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">interface</span> <span class="n">IControl</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Paint</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="n">ITextBox</span><span class="p">:</span> <span class="n">IControl</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">SetText</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="n">IListBox</span><span class="p">:</span> <span class="n">IControl</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">SetItems</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">items</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="n">IComboBox</span><span class="p">:</span> <span class="n">ITextBox</span><span class="p">,</span> <span class="n">IListBox</span> <span class="p">{}</span>
</code></pre>
<p>Classes and structs can implement multiple interfaces. In the following example, the class <code class="prettyprint">EditBox</code> implements both <code class="prettyprint">IControl</code> and <code class="prettyprint">IDataBound</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">interface</span> <span class="n">IDataBound</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">Binder</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">EditBox</span><span class="p">:</span> <span class="n">IControl</span><span class="p">,</span> <span class="n">IDataBound</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Paint</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Bind</span><span class="p">(</span><span class="n">Binder</span> <span class="n">b</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type. For example</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">EditBox</span> <span class="n">editBox</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">EditBox</span><span class="p">();</span>
<span class="n">IControl</span> <span class="n">control</span> <span class="p">=</span> <span class="n">editBox</span><span class="p">;</span>
<span class="n">IDataBound</span> <span class="n">dataBound</span> <span class="p">=</span> <span class="n">editBox</span><span class="p">;</span>
</code></pre>
<p>In cases where an instance is not statically known to implement a particular interface, dynamic type casts can be used. For example, the following statements use dynamic type casts to obtain an object&rsquo;s <code class="prettyprint">IControl</code> and <code class="prettyprint">IDataBound</code> interface implementations. Because the actual type of the object is <code class="prettyprint">EditBox</code>, the casts succeed.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">object</span> <span class="n">obj</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">EditBox</span><span class="p">();</span>
<span class="n">IControl</span> <span class="n">control</span> <span class="p">=</span> <span class="p">(</span><span class="n">IControl</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
<span class="n">IDataBound</span> <span class="n">dataBound</span> <span class="p">=</span> <span class="p">(</span><span class="n">IDataBound</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</code></pre>
<p>In the previous <code class="prettyprint">EditBox</code> class, the <code class="prettyprint">Paint</code> method from the <code class="prettyprint">IControl</code> interface and the <code class="prettyprint">Bind</code> method from the <code class="prettyprint">IDataBound</code> interface are implemented using <code class="prettyprint">public</code> members. C# also supports <strong><em>explicit interface member implementations</em></strong>, using which the class or struct can avoid making the members <code class="prettyprint">public</code>. An explicit interface member implementation is written using the fully qualified interface member name. For example, the <code class="prettyprint">EditBox</code> class could implement the <code class="prettyprint">IControl.Paint</code> and <code class="prettyprint">IDataBound.Bind</code> methods using explicit interface member implementations as follows.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EditBox</span><span class="p">:</span> <span class="n">IControl</span><span class="p">,</span> <span class="n">IDataBound</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="n">IControl</span><span class="p">.</span><span class="nf">Paint</span><span class="p">()</span> <span class="p">{...}</span>
    <span class="k">void</span> <span class="n">IDataBound</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="n">Binder</span> <span class="n">b</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>Explicit interface members can only be accessed via the interface type. For example, the implementation of <code class="prettyprint">IControl.Paint</code> provided by the previous <code class="prettyprint">EditBox</code> class can only be invoked by first converting the <code class="prettyprint">EditBox</code> reference to the <code class="prettyprint">IControl</code> interface type.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">EditBox</span> <span class="n">editBox</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">EditBox</span><span class="p">();</span>
<span class="n">editBox</span><span class="p">.</span><span class="nf">Paint</span><span class="p">();</span>                        <span class="c1">// Error, no such method</span>
<span class="n">IControl</span> <span class="n">control</span> <span class="p">=</span> <span class="n">editBox</span><span class="p">;</span>
<span class="n">control</span><span class="p">.</span><span class="nf">Paint</span><span class="p">();</span>                        <span class="c1">// Ok</span>
</code></pre>
<h2 id="enums">Enums</h2>

<p>An <strong><em>enum type</em></strong> is a distinct value type with a set of named constants. The following example declares and uses an enum type named <code class="prettyprint">Color</code> with three constant values, <code class="prettyprint">Red</code>, <code class="prettyprint">Green</code>, and <code class="prettyprint">Blue</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Color</span>
<span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Blue</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">PrintColor</span><span class="p">(</span><span class="n">Color</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">:</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Red"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">:</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Green"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">:</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Unknown color"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">;</span>
        <span class="nf">PrintColor</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="nf">PrintColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Each enum type has a corresponding integral type called the <strong><em>underlying type</em></strong> of the enum type. An enum type that does not explicitly declare an underlying type has an underlying type of <code class="prettyprint">int</code>. An enum type&rsquo;s storage format and range of possible values are determined by its underlying type. The set of values that an enum type can take on is not limited by its enum members. In particular, any value of the underlying type of an enum can be cast to the enum type and is a distinct valid value of that enum type.</p>

<p>The following example declares an enum type named <code class="prettyprint">Alignment</code> with an underlying type of <code class="prettyprint">sbyte</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Alignment</span><span class="p">:</span> <span class="kt">sbyte</span>
<span class="p">{</span>
    <span class="n">Left</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span>
    <span class="n">Center</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
    <span class="n">Right</span> <span class="p">=</span> <span class="m">1</span>
<span class="p">}</span>
</code></pre>
<p>As shown by the previous example, an enum member declaration can include a constant expression that specifies the value of the member. The constant value for each enum member must be in the range of the underlying type of the enum. When an enum member declaration does not explicitly specify a value, the member is given the value zero (if it is the first member in the enum type) or the value of the textually preceding enum member plus one.</p>

<p>Enum values can be converted to integral values and vice versa using type casts. For example</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">;</span>        <span class="c1">// int i = 2;</span>
<span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="p">(</span><span class="n">Color</span><span class="p">)</span><span class="m">2</span><span class="p">;</span>             <span class="c1">// Color c = Color.Blue;</span>
</code></pre>
<p>The default value of any enum type is the integral value zero converted to the enum type. In cases where variables are automatically initialized to a default value, this is the value given to variables of enum types. In order for the default value of an enum type to be easily available, the literal <code class="prettyprint">0</code> implicitly converts to any enum type. Thus, the following is permitted.</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Color</span> <span class="n">c</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</code></pre>
<h2 id="delegates">Delegates</h2>

<p>A <strong><em>delegate type</em></strong> represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.</p>

<p>The following example declares and uses a delegate type named <code class="prettyprint">Function</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">delegate</span> <span class="kt">double</span> <span class="nf">Function</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">Multiplier</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">factor</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Multiplier</span><span class="p">(</span><span class="kt">double</span> <span class="n">factor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">factor</span> <span class="p">=</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">double</span> <span class="nf">Multiply</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">factor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">double</span> <span class="nf">Square</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">double</span><span class="p">[]</span> <span class="nf">Apply</span><span class="p">(</span><span class="kt">double</span><span class="p">[]</span> <span class="n">a</span><span class="p">,</span> <span class="n">Function</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span><span class="m">0.0</span><span class="p">,</span> <span class="m">0.5</span><span class="p">,</span> <span class="m">1.0</span><span class="p">};</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">squares</span> <span class="p">=</span> <span class="nf">Apply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Square</span><span class="p">);</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">sines</span> <span class="p">=</span> <span class="nf">Apply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="n">Sin</span><span class="p">);</span>
        <span class="n">Multiplier</span> <span class="n">m</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Multiplier</span><span class="p">(</span><span class="m">2.0</span><span class="p">);</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">doubles</span> <span class="p">=</span>  <span class="nf">Apply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">Multiply</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An instance of the <code class="prettyprint">Function</code> delegate type can reference any method that takes a <code class="prettyprint">double</code> argument and returns a <code class="prettyprint">double</code> value. The <code class="prettyprint">Apply</code> method applies a given <code class="prettyprint">Function</code> to the elements of a <code class="prettyprint">double[]</code>, returning a <code class="prettyprint">double[]</code> with the results. In the <code class="prettyprint">Main</code> method, <code class="prettyprint">Apply</code> is used to apply three different functions to a <code class="prettyprint">double[]</code>.</p>

<p>A delegate can reference either a static method (such as <code class="prettyprint">Square</code> or <code class="prettyprint">Math.Sin</code> in the previous example) or an instance method (such as <code class="prettyprint">m.Multiply</code> in the previous example). A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes <code class="prettyprint">this</code> in the invocation.</p>

<p>Delegates can also be created using anonymous functions, which are &ldquo;inline methods&rdquo; that are created on the fly. Anonymous functions can see the local variables of the sourrounding methods. Thus, the multiplier example above can be written more easily without using a <code class="prettyprint">Multiplier</code> class:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">double</span><span class="p">[]</span> <span class="n">doubles</span> <span class="p">=</span>  <span class="nf">Apply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="m">2.0</span><span class="p">);</span>
</code></pre>
<p>An interesting and useful property of a delegate is that it does not know or care about the class of the method it references; all that matters is that the referenced method has the same parameters and return type as the delegate.</p>

<h2 id="attributes">Attributes</h2>

<p>Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior. For example, the accessibility of a method is controlled using the <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers. C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time. Programs specify this additional declarative information by defining and using <strong><em>attributes</em></strong>.</p>

<p>The following example declares a <code class="prettyprint">HelpAttribute</code> attribute that can be placed on program entities to provide links to their associated documentation.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">HelpAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">url</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">topic</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">HelpAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">url</span> <span class="p">=</span> <span class="n">url</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">url</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Topic</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">topic</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">topic</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>All attribute classes derive from the <code class="prettyprint">System.Attribute</code> base class provided by the .NET Framework. Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration. If an attribute&rsquo;s name ends in <code class="prettyprint">Attribute</code>, that part of the name can be omitted when the attribute is referenced. For example, the <code class="prettyprint">HelpAttribute</code> attribute can be used as follows.</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Help("http://msdn.microsoft.com/.../MyClass.htm")]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Widget</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">Help</span><span class="p">(</span><span class="s">"http://msdn.microsoft.com/.../MyClass.htm"</span><span class="p">,</span> <span class="n">Topic</span> <span class="p">=</span> <span class="s">"Display"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Display</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>This example attaches a <code class="prettyprint">HelpAttribute</code> to the <code class="prettyprint">Widget</code> class and another <code class="prettyprint">HelpAttribute</code> to the <code class="prettyprint">Display</code> method in the class. The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity. Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the <code class="prettyprint">Topic</code> property previously).</p>

<p>The following example shows how attribute information for a given program entity can be retrieved at run-time using reflection.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">ShowHelp</span><span class="p">(</span><span class="n">MemberInfo</span> <span class="n">member</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HelpAttribute</span> <span class="n">a</span> <span class="p">=</span> <span class="n">Attribute</span><span class="p">.</span><span class="nf">GetCustomAttribute</span><span class="p">(</span><span class="n">member</span><span class="p">,</span>
            <span class="k">typeof</span><span class="p">(</span><span class="n">HelpAttribute</span><span class="p">))</span> <span class="k">as</span> <span class="n">HelpAttribute</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"No help for {0}"</span><span class="p">,</span> <span class="n">member</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Help for {0}:"</span><span class="p">,</span> <span class="n">member</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"  Url={0}, Topic={1}"</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Url</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Topic</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">ShowHelp</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Widget</span><span class="p">));</span>
        <span class="nf">ShowHelp</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Widget</span><span class="p">).</span><span class="nf">GetMethod</span><span class="p">(</span><span class="s">"Display"</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>When a particular attribute is requested through reflection, the constructor for the attribute class is invoked with the information provided in the program source, and the resulting attribute instance is returned. If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</p>

          <h1 id="basic-concepts">Basic concepts</h1>

<h2 id="application-startup">Application Startup</h2>

<p>An assembly that has an <strong><em>entry point</em></strong> is called an <strong><em>application</em></strong>. When an application is run, a new <strong><em>application domain</em></strong> is created. Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</p>

<p>An application domain enables application isolation by acting as a container for application state. An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses. Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains. For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain. Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</p>

<p><strong><em>Application startup</em></strong> occurs when the execution environment calls a designated method, which is referred to as the application&rsquo;s entry point. This entry point method is always named <code class="prettyprint">Main</code>, and can have one of the following signatures:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>
</code></pre>
<p>As shown, the entry point may optionally return an <code class="prettyprint">int</code> value. This return value is used in application termination (<a href="basic-concepts.md#application-termination">Application termination</a>).</p>

<p>The entry point may optionally have one formal parameter. The parameter may have any name, but the type of the parameter must be <code class="prettyprint">string[]</code>. If the formal parameter is present, the execution environment creates and passes a <code class="prettyprint">string[]</code> argument containing the command-line arguments that were specified when the application was started. The <code class="prettyprint">string[]</code> argument is never null, but it may have a length of zero if no command-line arguments were specified.</p>

<p>Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature. However, within a single program, no class or struct may contain more than one method called <code class="prettyprint">Main</code> whose definition qualifies it to be used as an application entry point. Other overloaded versions of <code class="prettyprint">Main</code> are permitted, however, provided they have more than one parameter, or their only parameter is other than type <code class="prettyprint">string[]</code>.</p>

<p>An application can be made up of multiple classes or structs. It is possible for more than one of these classes or structs to contain a method called <code class="prettyprint">Main</code> whose definition qualifies it to be used as an application entry point. In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these <code class="prettyprint">Main</code> methods as the entry point.</p>

<p>In C#, every method must be defined as a member of a class or struct. Ordinarily, the declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) of a method is determined by the access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration. In order for a given method of a given type to be callable, both the type and the member must be accessible. However, the application entry point is a special case. Specifically, the execution environment can access the application&rsquo;s entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</p>

<p>The application entry point method may not be in a generic class declaration.</p>

<p>In all other respects, entry point methods behave like those that are not entry points.</p>

<h2 id="application-termination">Application termination</h2>

<p><strong><em>Application termination</em></strong> returns control to the execution environment.</p>

<p>If the return type of the application&rsquo;s <strong><em>entry point</em></strong> method is <code class="prettyprint">int</code>, the value returned serves as the application&rsquo;s <strong><em>termination status code</em></strong>. The purpose of this code is to allow communication of success or failure to the execution environment.</p>

<p>If the return type of the entry point method is <code class="prettyprint">void</code>, reaching the right brace (<code class="prettyprint">}</code>) which terminates that method, or executing a <code class="prettyprint">return</code> statement that has no expression, results in a termination status code of <code class="prettyprint">0</code>.</p>

<p>Prior to an application&rsquo;s termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method <code class="prettyprint">GC.SuppressFinalize</code>, for example).</p>

<h2 id="declarations">Declarations</h2>

<p>Declarations in a C# program define the constituent elements of the program. C# programs are organized using namespaces (<a href="namespaces.md#namespaces">Namespaces</a>), which can contain type declarations and nested namespace declarations. Type declarations (<a href="namespaces.md#type-declarations">Type declarations</a>) are used to define classes (<a href="classes.md#classes">Classes</a>), structs (<a href="classes.md#iterators">Iterators</a>), interfaces (<a href="interfaces.md#interfaces">Interfaces</a>), enums (<a href="enums.md#enums">Enums</a>), and delegates (<a href="delegates.md#delegates">Delegates</a>). The kinds of members permitted in a type declaration depend on the form of the type declaration. For instance, class declarations can contain declarations for constants (<a href="classes.md#constants">Constants</a>), fields (<a href="classes.md#fields">Fields</a>), methods (<a href="classes.md#methods">Methods</a>), properties (<a href="classes.md#properties">Properties</a>), events (<a href="classes.md#events">Events</a>), indexers (<a href="classes.md#indexers">Indexers</a>), operators (<a href="classes.md#operators">Operators</a>), instance constructors (<a href="classes.md#instance-constructors">Instance constructors</a>), static constructors (<a href="classes.md#static-constructors">Static constructors</a>), destructors (<a href="classes.md#destructors">Destructors</a>), and nested types(<a href="classes.md#nested-types">Nested types</a>).</p>

<p>A declaration defines a name in the <strong><em>declaration space</em></strong> to which the declaration belongs. Except for overloaded members (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space. It is never possible for a declaration space to contain different kinds of members with the same name. For example, a declaration space can never contain a field and a method by the same name.</p>

<p>There are several different types of declaration spaces, as described in the following.</p>

<ul>
<li> Within all source files of a program, <em>namespace_member_declaration*s with no enclosing *namespace_declaration</em> are members of a single combined declaration space called the <strong><em>global declaration space</em></strong>.</li>
<li> Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</li>
<li> Each class, struct, or interface declaration creates a new declaration space. Names are introduced into this declaration space through <em>class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s. Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct. A class, struct, or interface permits the declaration of overloaded methods and indexers. Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators. For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>). Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface. Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member. Such a member is said to *</em><em>hide</em>** the inherited member.</li>
<li> Each delegate declaration creates a new declaration space. Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</li>
<li> Each enumeration declaration creates a new declaration space. Names are introduced into this declaration space through <em>enum_member_declarations</em>.</li>
<li> Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a <strong><em>local variable declaration space</em></strong>. Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s. The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space. It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name. Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space. It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</li>
<li> Each <em>block</em> or <em>switch_block</em> , as well as a <em>for</em>, <em>foreach</em> and <em>using</em> statement, creates a local variable declaration space for local variables and local constants . Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s. Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters. Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</li>
<li> Each <em>block</em> or <em>switch_block</em> creates a separate declaration space for labels. Names are introduced into this declaration space through <em>labeled_statement*s, and the names are referenced through *goto_statement*s. The *</em><em>label declaration space</em>** of a block includes any nested blocks. Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</li>
</ul>

<p>The textual order in which names are declared is generally of no significance. In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types. Declaration order is significant in the following ways:</p>

<ul>
<li> Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</li>
<li> Local variables must be defined before they are used (<a href="basic-concepts.md#scopes">Scopes</a>).</li>
<li> Declaration order for enum member declarations (<a href="enums.md#enum-members">Enum members</a>) is significant when <em>constant_expression</em> values are omitted.</li>
</ul>

<p>The declaration space of a namespace is &ldquo;open ended&rdquo;, and two namespace declarations with the same fully qualified name contribute to the same declaration space. For example
&ldquo;`csharp
namespace Megacorp.Data
{
    class Customer
    {
        &hellip;
    }
}</p>

<p>namespace Megacorp.Data
{
    class Order
    {
        &hellip;
    }
}
&rdquo;`</p>

<p>The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names <code class="prettyprint">Megacorp.Data.Customer</code> and <code class="prettyprint">Megacorp.Data.Order</code>. Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</p>

<p>As specified above, the declaration space of a block includes any nested blocks. Thus, in the following example, the <code class="prettyprint">F</code> and <code class="prettyprint">G</code> methods result in a compile-time error because the name <code class="prettyprint">i</code> is declared in the outer block and cannot be redeclared in the inner block. However, the <code class="prettyprint">H</code> and <code class="prettyprint">I</code> methods are valid since the two <code class="prettyprint">i</code>&lsquo;s are declared in separate non-nested blocks.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>            
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">H</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">I</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="nf">H</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="nf">H</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id="members">Members</h2>

<p>Namespaces and types have <strong><em>members</em></strong>. The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a &ldquo;<code class="prettyprint">.</code>&rdquo; token, followed by the name of the member.</p>

<p>Members of a type are either declared in the type declaration or <strong><em>inherited</em></strong> from the base class of the type. When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type. The declared accessibility of a base class member does not control whether the member is inheritedâ€”inheritance extends to any member that isn&rsquo;t an instance constructor, static constructor, or destructor. However, an inherited member may not be accessible in a derived type, either because of its declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) or because it is hidden by a declaration in the type itself (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>).</p>

<h3 id="namespace-members">Namespace members</h3>

<p>Namespaces and types that have no enclosing namespace are members of the <strong><em>global namespace</em></strong>. This corresponds directly to the names declared in the global declaration space.</p>

<p>Namespaces and types declared within a namespace are members of that namespace. This corresponds directly to the names declared in the declaration space of the namespace.</p>

<p>Namespaces have no access restrictions. It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</p>

<h3 id="struct-members">Struct members</h3>

<p>The members of a struct are the members declared in the struct and the members inherited from the struct&rsquo;s direct base class <code class="prettyprint">System.ValueType</code> and the indirect base class <code class="prettyprint">object</code>.</p>

<p>The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</p>

<ul>
<li> The members of <code class="prettyprint">sbyte</code> are the members of the <code class="prettyprint">System.SByte</code> struct.</li>
<li> The members of <code class="prettyprint">byte</code> are the members of the <code class="prettyprint">System.Byte</code> struct.</li>
<li> The members of <code class="prettyprint">short</code> are the members of the <code class="prettyprint">System.Int16</code> struct.</li>
<li> The members of <code class="prettyprint">ushort</code> are the members of the <code class="prettyprint">System.UInt16</code> struct.</li>
<li> The members of <code class="prettyprint">int</code> are the members of the <code class="prettyprint">System.Int32</code> struct.</li>
<li> The members of <code class="prettyprint">uint</code> are the members of the <code class="prettyprint">System.UInt32</code> struct.</li>
<li> The members of <code class="prettyprint">long</code> are the members of the <code class="prettyprint">System.Int64</code> struct.</li>
<li> The members of <code class="prettyprint">ulong</code> are the members of the <code class="prettyprint">System.UInt64</code> struct.</li>
<li> The members of <code class="prettyprint">char</code> are the members of the <code class="prettyprint">System.Char</code> struct.</li>
<li> The members of <code class="prettyprint">float</code> are the members of the <code class="prettyprint">System.Single</code> struct.</li>
<li> The members of <code class="prettyprint">double</code> are the members of the <code class="prettyprint">System.Double</code> struct.</li>
<li> The members of <code class="prettyprint">decimal</code> are the members of the <code class="prettyprint">System.Decimal</code> struct.</li>
<li> The members of <code class="prettyprint">bool</code> are the members of the <code class="prettyprint">System.Boolean</code> struct.</li>
</ul>

<h3 id="enumeration-members">Enumeration members</h3>

<p>The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration&rsquo;s direct base class <code class="prettyprint">System.Enum</code> and the indirect base classes <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">object</code>.</p>

<h3 id="class-members">Class members</h3>

<p>The members of a class are the members declared in the class and the members inherited from the base class (except for class <code class="prettyprint">object</code> which has no base class). The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class. Base class members are inherited without regard to their accessibility.</p>

<p>A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</p>

<p>The members of <code class="prettyprint">object</code> and <code class="prettyprint">string</code> correspond directly to the members of the class types they alias:</p>

<ul>
<li> The members of <code class="prettyprint">object</code> are the members of the <code class="prettyprint">System.Object</code> class.</li>
<li> The members of <code class="prettyprint">string</code> are the members of the <code class="prettyprint">System.String</code> class.</li>
</ul>

<h3 id="interface-members">Interface members</h3>

<p>The members of an interface are the members declared in the interface and in all base interfaces of the interface. The members in class <code class="prettyprint">object</code> are not, strictly speaking, members of any interface (<a href="interfaces.md#interface-members">Interface members</a>). However, the members in class <code class="prettyprint">object</code> are available via member lookup in any interface type (<a href="expressions.md#member-lookup">Member lookup</a>).</p>

<h3 id="array-members">Array members</h3>

<p>The members of an array are the members inherited from class <code class="prettyprint">System.Array</code>.</p>

<h3 id="delegate-members">Delegate members</h3>

<p>The members of a delegate are the members inherited from class <code class="prettyprint">System.Delegate</code>.</p>

<h2 id="member-access">Member access</h2>

<p>Declarations of members allow control over member access. The accessibility of a member is established by the declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) of the member combined with the accessibility of the immediately containing type, if any.</p>

<p>When access to a particular member is allowed, the member is said to be <strong><em>accessible</em></strong>. Conversely, when access to a particular member is disallowed, the member is said to be <strong><em>inaccessible</em></strong>. Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the member.</p>

<h3 id="declared-accessibility">Declared accessibility</h3>

<p>The <strong><em>declared accessibility</em></strong> of a member can be one of the following:</p>

<ul>
<li> Public, which is selected by including a <code class="prettyprint">public</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">public</code> is &ldquo;access not limited&rdquo;.</li>
<li> Protected, which is selected by including a <code class="prettyprint">protected</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">protected</code> is &ldquo;access limited to the containing class or types derived from the containing class&rdquo;.</li>
<li> Internal, which is selected by including an <code class="prettyprint">internal</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">internal</code> is &ldquo;access limited to this program&rdquo;.</li>
<li> Protected internal (meaning protected or internal), which is selected by including both a <code class="prettyprint">protected</code> and an <code class="prettyprint">internal</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">protected internal</code> is &ldquo;access limited to this program or types derived from the containing class&rdquo;.</li>
<li> Private, which is selected by including a <code class="prettyprint">private</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">private</code> is &ldquo;access limited to the containing type&rdquo;.</li>
</ul>

<p>Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted. Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</p>

<ul>
<li> Namespaces implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on namespace declarations.</li>
<li> Types declared in compilation units or namespaces can have <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility and default to <code class="prettyprint">internal</code> declared accessibility.</li>
<li> Class members can have any of the five kinds of declared accessibility and default to <code class="prettyprint">private</code> declared accessibility. (Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility.)</li>
<li> Struct members can have <code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> declared accessibility and default to <code class="prettyprint">private</code> declared accessibility because structs are implicitly sealed. Struct members introduced in a struct (that is, not inherited by that struct) cannot have <code class="prettyprint">protected</code> or <code class="prettyprint">protected internal</code> declared accessibility. (Note that a type declared as a member of a struct can have <code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> declared accessibility, whereas a type declared as a member of a namespace can have only <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility.)</li>
<li> Interface members implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on interface member declarations.</li>
<li> Enumeration members implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on enumeration member declarations.</li>
</ul>

<h3 id="accessibility-domains">Accessibility domains</h3>

<p>The <strong><em>accessibility domain</em></strong> of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted. For purposes of defining the accessibility domain of a member, a member is said to be <strong><em>top-level</em></strong> if it is not declared within a type, and a member is said to be <strong><em>nested</em></strong> if it is declared within another type. Furthermore, the <strong><em>program text</em></strong> of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</p>

<p>The accessibility domain of a predefined type (such as <code class="prettyprint">object</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">double</code>) is unlimited.</p>

<p>The accessibility domain of a top-level unbound type <code class="prettyprint">T</code> (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>) that is declared in a program <code class="prettyprint">P</code> is defined as follows:</p>

<ul>
<li> If the declared accessibility of <code class="prettyprint">T</code> is <code class="prettyprint">public</code>, the accessibility domain of <code class="prettyprint">T</code> is the program text of <code class="prettyprint">P</code> and any program that references <code class="prettyprint">P</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">T</code> is <code class="prettyprint">internal</code>, the accessibility domain of <code class="prettyprint">T</code> is the program text of <code class="prettyprint">P</code>.</li>
</ul>

<p>From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</p>

<p>The accessibility domain for a constructed type <code class="prettyprint">T&lt;A1, ..., An&gt;</code> is the intersection of the accessibility domain of the unbound generic type <code class="prettyprint">T</code> and the accessibility domains of the type arguments <code class="prettyprint">A1, ..., An</code>.</p>

<p>The accessibility domain of a nested member <code class="prettyprint">M</code> declared in a type <code class="prettyprint">T</code> within a program <code class="prettyprint">P</code> is defined as follows (noting that <code class="prettyprint">M</code> itself may possibly be a type):</p>

<ul>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">public</code>, the accessibility domain of <code class="prettyprint">M</code> is the accessibility domain of <code class="prettyprint">T</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">protected internal</code>, let <code class="prettyprint">D</code> be the union of the program text of <code class="prettyprint">P</code> and the program text of any type derived from <code class="prettyprint">T</code>, which is declared outside <code class="prettyprint">P</code>. The accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with <code class="prettyprint">D</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">protected</code>, let <code class="prettyprint">D</code> be the union of the program text of <code class="prettyprint">T</code> and the program text of any type derived from <code class="prettyprint">T</code>. The accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with <code class="prettyprint">D</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">internal</code>, the accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with the program text of <code class="prettyprint">P</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">private</code>, the accessibility domain of <code class="prettyprint">M</code> is the program text of <code class="prettyprint">T</code>.</li>
</ul>

<p>From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared. Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</p>

<p>In intuitive terms, when a type or member <code class="prettyprint">M</code> is accessed, the following steps are evaluated to ensure that the access is permitted:</p>

<ul>
<li> First, if <code class="prettyprint">M</code> is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</li>
<li> Then, if <code class="prettyprint">M</code> is <code class="prettyprint">public</code>, the access is permitted.</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">protected internal</code>, the access is permitted if it occurs within the program in which <code class="prettyprint">M</code> is declared, or if it occurs within a class derived from the class in which <code class="prettyprint">M</code> is declared and takes place through the derived class type (<a href="basic-concepts.md#protected-access-for-instance-members">Protected access for instance members</a>).</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">protected</code>, the access is permitted if it occurs within the class in which <code class="prettyprint">M</code> is declared, or if it occurs within a class derived from the class in which <code class="prettyprint">M</code> is declared and takes place through the derived class type (<a href="basic-concepts.md#protected-access-for-instance-members">Protected access for instance members</a>).</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">internal</code>, the access is permitted if it occurs within the program in which <code class="prettyprint">M</code> is declared.</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">private</code>, the access is permitted if it occurs within the type in which <code class="prettyprint">M</code> is declared.</li>
<li> Otherwise, the type or member is inaccessible, and a compile-time error occurs.</li>
</ul>

<p>In the example
&ldquo;`csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}</p>

<p>internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;</p>

<p>public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }</p>

<p>private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
&rdquo;`
the classes and members have the following accessibility domains:</p>

<ul>
<li> The accessibility domain of <code class="prettyprint">A</code> and <code class="prettyprint">A.X</code> is unlimited.</li>
<li> The accessibility domain of <code class="prettyprint">A.Y</code>, <code class="prettyprint">B</code>, <code class="prettyprint">B.X</code>, <code class="prettyprint">B.Y</code>, <code class="prettyprint">B.C</code>, <code class="prettyprint">B.C.X</code>, and <code class="prettyprint">B.C.Y</code> is the program text of the containing program.</li>
<li> The accessibility domain of <code class="prettyprint">A.Z</code> is the program text of <code class="prettyprint">A</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.Z</code> and <code class="prettyprint">B.D</code> is the program text of <code class="prettyprint">B</code>, including the program text of <code class="prettyprint">B.C</code> and <code class="prettyprint">B.D</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.C.Z</code> is the program text of <code class="prettyprint">B.C</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.D.X</code> and <code class="prettyprint">B.D.Y</code> is the program text of <code class="prettyprint">B</code>, including the program text of <code class="prettyprint">B.C</code> and <code class="prettyprint">B.D</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.D.Z</code> is the program text of <code class="prettyprint">B.D</code>.</li>
</ul>

<p>As the example illustrates, the accessibility domain of a member is never larger than that of a containing type. For example, even though all <code class="prettyprint">X</code> members have public declared accessibility, all but <code class="prettyprint">A.X</code> have accessibility domains that are constrained by a containing type.</p>

<p>As described in <a href="basic-concepts.md#members">Members</a>, all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types. This includes even private members of a base class. However, the accessibility domain of a private member includes only the program text of the type in which the member is declared. In the example
&ldquo;`csharp
class A
{
    int x;</p>

<p>static void F(B b) {
        b.x = 1;        // Ok
    }
}</p>

<p>class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
&rdquo;<code class="prettyprint">
the</code>B<code class="prettyprint">class inherits the private member</code>x<code class="prettyprint">from the</code>A<code class="prettyprint">class. Because the member is private, it is only accessible within the *class_body* of</code>A<code class="prettyprint">. Thus, the access to</code>b.x<code class="prettyprint">succeeds in the</code>A.F<code class="prettyprint">method, but fails in the</code>B.F` method.</p>

<h3 id="protected-access-for-instance-members">Protected access for instance members</h3>

<p>When a <code class="prettyprint">protected</code> instance member is accessed outside the program text of the class in which it is declared, and when a <code class="prettyprint">protected internal</code> instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared. Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it. This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</p>

<p>Let <code class="prettyprint">B</code> be a base class that declares a protected instance member <code class="prettyprint">M</code>, and let <code class="prettyprint">D</code> be a class that derives from <code class="prettyprint">B</code>. Within the <em>class_body</em> of <code class="prettyprint">D</code>, access to <code class="prettyprint">M</code> can take one of the following forms:</p>

<ul>
<li> An unqualified <em>type_name</em> or <em>primary_expression</em> of the form <code class="prettyprint">M</code>.</li>
<li> A <em>primary_expression</em> of the form <code class="prettyprint">E.M</code>, provided the type of <code class="prettyprint">E</code> is <code class="prettyprint">T</code> or a class derived from <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the class type <code class="prettyprint">D</code>, or a class type constructed from <code class="prettyprint">D</code></li>
<li> A <em>primary_expression</em> of the form <code class="prettyprint">base.M</code>.</li>
</ul>

<p>In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a <em>constructor_initializer</em> (<a href="classes.md#constructor-initializers">Constructor initializers</a>).</p>

<p>In the example
&ldquo;`csharp
public class A
{
    protected int x;</p>

<p>static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}</p>

<p>public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
&rdquo;<code class="prettyprint">
within</code>A<code class="prettyprint">, it is possible to access</code>x<code class="prettyprint">through instances of both</code>A<code class="prettyprint">and</code>B<code class="prettyprint">, since in either case the access takes place through an instance of</code>A<code class="prettyprint">or a class derived from</code>A<code class="prettyprint">. However, within</code>B<code class="prettyprint">, it is not possible to access</code>x<code class="prettyprint">through an instance of</code>A<code class="prettyprint">, since</code>A<code class="prettyprint">does not derive from</code>B`.</p>

<p>In the example
&ldquo;`csharp
class C<T>
{
    protected T x;
}</p>

<p>class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = &quot;test&rdquo;;
    }
}
&ldquo;<code class="prettyprint">
the three assignments to</code>x` are permitted because they all take place through instances of class types constructed from the generic type.</p>

<h3 id="accessibility-constraints">Accessibility constraints</h3>

<p>Several constructs in the C# language require a type to be <strong><em>at least as accessible as</em></strong> a member or another type. A type <code class="prettyprint">T</code> is said to be at least as accessible as a member or type <code class="prettyprint">M</code> if the accessibility domain of <code class="prettyprint">T</code> is a superset of the accessibility domain of <code class="prettyprint">M</code>. In other words, <code class="prettyprint">T</code> is at least as accessible as <code class="prettyprint">M</code> if <code class="prettyprint">T</code> is accessible in all contexts in which <code class="prettyprint">M</code> is accessible.</p>

<p>The following accessibility constraints exist:</p>

<ul>
<li> The direct base class of a class type must be at least as accessible as the class type itself.</li>
<li> The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</li>
<li> The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</li>
<li> The type of a constant must be at least as accessible as the constant itself.</li>
<li> The type of a field must be at least as accessible as the field itself.</li>
<li> The return type and parameter types of a method must be at least as accessible as the method itself.</li>
<li> The type of a property must be at least as accessible as the property itself.</li>
<li> The type of an event must be at least as accessible as the event itself.</li>
<li> The type and parameter types of an indexer must be at least as accessible as the indexer itself.</li>
<li> The return type and parameter types of an operator must be at least as accessible as the operator itself.</li>
<li> The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</li>
</ul>

<p>In the example
&rdquo;`csharp
class A {&hellip;}</p>

<p>public class B: A {&hellip;}
&ldquo;<code class="prettyprint">
the</code>B<code class="prettyprint">class results in a compile-time error because</code>A<code class="prettyprint">is not at least as accessible as</code>B`.</p>

<p>Likewise, in the example
&rdquo;`csharp
class A {&hellip;}</p>

<p>public class B
{
    A F() {&hellip;}</p>

<p>internal A G() {&hellip;}</p>

<p>public A H() {&hellip;}
}
&ldquo;<code class="prettyprint">
the</code>H<code class="prettyprint">method in</code>B<code class="prettyprint">results in a compile-time error because the return type</code>A` is not at least as accessible as the method.</p>

<h2 id="signatures-and-overloading">Signatures and overloading</h2>

<p>Methods, instance constructors, indexers, and operators are characterized by their <strong><em>signatures</em></strong>:</p>

<ul>
<li> The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right. For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method. The signature of a method specifically does not include the return type, the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</li>
<li> The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right. The signature of an instance constructor specifically does not include the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter.</li>
<li> The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right. The signature of an indexer specifically does not include the element type, nor does it include the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter.</li>
<li> The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right. The signature of an operator specifically does not include the result type.</li>
</ul>

<p>Signatures are the enabling mechanism for <strong><em>overloading</em></strong> of members in classes, structs, and interfaces:</p>

<ul>
<li> Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</li>
<li> Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</li>
<li> Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</li>
<li> Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</li>
</ul>

<p>Although <code class="prettyprint">out</code> and <code class="prettyprint">ref</code> parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>. A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with <code class="prettyprint">out</code> modifiers were changed to <code class="prettyprint">ref</code> modifiers. For other purposes of signature matching (e.g., hiding or overriding), <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> are considered part of the signature and do not match each other. (This restriction is to allow C#Â  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.)</p>

<p>For the purposes of singatures, the types <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code> are considered the same. Members declared in a single type can therefore not differ in signature solely by <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>.</p>

<p>The following example shows a set of overloaded method declarations along with their signatures.
&rdquo;`csharp
interface ITest
{
    void F();                        // F()</p>

<p>void F(int x);                   // F(int)</p>

<p>void F(ref int x);               // F(ref int)</p>

<p>void F(out int x);               // F(out int)      error</p>

<p>void F(int x, int y);            // F(int, int)</p>

<p>int F(string s);                 // F(string)</p>

<p>int F(int x);                    // F(int)          error</p>

<p>void F(string[] a);              // F(string[])</p>

<p>void F(params string[] a);       // F(string[])     error
}
&ldquo;`</p>

<p>Note that any <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter modifiers (<a href="classes.md#method-parameters">Method parameters</a>) are part of a signature. Thus, <code class="prettyprint">F(int)</code> and <code class="prettyprint">F(ref int)</code> are unique signatures. However, <code class="prettyprint">F(ref int)</code> and <code class="prettyprint">F(out int)</code> cannot be declared within the same interface because their signatures differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>. Also, note that the return type and the <code class="prettyprint">params</code> modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the <code class="prettyprint">params</code> modifier. As such, the declarations of the methods <code class="prettyprint">F(int)</code> and <code class="prettyprint">F(params string[])</code> identified above result in a compile-time error.</p>

<h2 id="scopes">Scopes</h2>

<p>The <strong><em>scope</em></strong> of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name. Scopes can be <strong><em>nested</em></strong>, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by <a href="basic-concepts.md#declarations">Declarations</a> that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block). The name from the outer scope is then said to be <strong><em>hidden</em></strong> in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</p>

<ul>
<li> The scope of a namespace member declared by a <em>namespace_member_declaration</em> (<a href="namespaces.md#namespace-members">Namespace members</a>) with no enclosing <em>namespace_declaration</em> is the entire program text.</li>
<li> The scope of a namespace member declared by a <em>namespace_member_declaration</em> within a <em>namespace_declaration</em> whose fully qualified name is <code class="prettyprint">N</code> is the <em>namespace_body</em> of every <em>namespace_declaration</em> whose fully qualified name is <code class="prettyprint">N</code> or starts with <code class="prettyprint">N</code>, followed by a period.</li>
<li> The scope of name defined by an <em>extern_alias_directive</em> extends over the <em>using_directive*s, *global_attributes</em> and <em>namespace_member_declaration*s of its immediately containing compilation unit or namespace body. An *extern_alias_directive</em> does not contribute any new members to the underlying declaration space. In other words, an <em>extern_alias_directive</em> is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</li>
<li> The scope of a name defined or imported by a <em>using_directive</em> (<a href="namespaces.md#using-directives">Using directives</a>) extends over the <em>namespace_member_declaration*s of the *compilation_unit</em> or <em>namespace_body</em> in which the <em>using_directive</em> occurs. A <em>using_directive</em> may make zero or more namespace, type or member names available within a particular <em>compilation_unit</em> or <em>namespace_body</em>, but does not contribute any new members to the underlying declaration space. In other words, a <em>using_directive</em> is not transitive but rather affects only the <em>compilation_unit</em> or <em>namespace_body</em> in which it occurs.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>class_declaration</em> (<a href="classes.md#class-declarations">Class declarations</a>) is the <em>class_base</em>, <em>type_parameter_constraints_clause*s, and *class_body</em> of that <em>class_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>struct_declaration</em> (<a href="structs.md#struct-declarations">Struct declarations</a>) is the <em>struct_interfaces</em>, <em>type_parameter_constraints_clause*s, and *struct_body</em> of that <em>struct_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on an <em>interface_declaration</em> (<a href="interfaces.md#interface-declarations">Interface declarations</a>) is the <em>interface_base</em>, <em>type_parameter_constraints_clause*s, and *interface_body</em> of that <em>interface_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>delegate_declaration</em> (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) is the <em>return_type</em>, <em>formal_parameter_list</em>, and <em>type_parameter_constraints_clause*s of that *delegate_declaration</em>.</li>
<li> The scope of a member declared by a <em>class_member_declaration</em> (<a href="classes.md#class-body">Class body</a>) is the <em>class_body</em> in which the declaration occurs. In addition, the scope of a class member extends to the <em>class_body</em> of those derived classes that are included in the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the member.</li>
<li> The scope of a member declared by a <em>struct_member_declaration</em> (<a href="structs.md#struct-members">Struct members</a>) is the <em>struct_body</em> in which the declaration occurs.</li>
<li> The scope of a member declared by an <em>enum_member_declaration</em>  (<a href="enums.md#enum-members">Enum members</a>) is the <em>enum_body</em> in which the declaration occurs.</li>
<li> The scope of a parameter declared in a <em>method_declaration</em> (<a href="classes.md#methods">Methods</a>) is the <em>method_body</em> of that <em>method_declaration</em>.</li>
<li> The scope of a parameter declared in an <em>indexer_declaration</em> (<a href="classes.md#indexers">Indexers</a>) is the <em>accessor_declarations</em> of that <em>indexer_declaration</em>.</li>
<li> The scope of a parameter declared in an <em>operator_declaration</em> (<a href="classes.md#operators">Operators</a>) is the <em>block</em> of that <em>operator_declaration</em>.</li>
<li> The scope of a parameter declared in a <em>constructor_declaration</em> (<a href="classes.md#instance-constructors">Instance constructors</a>) is the <em>constructor_initializer</em> and <em>block</em> of that <em>constructor_declaration</em>.</li>
<li> The scope of a parameter declared in a <em>lambda_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) is the <em>anonymous_function_body</em> of that <em>lambda_expression</em></li>
<li> The scope of a parameter declared in an <em>anonymous_method_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) is the <em>block</em> of that <em>anonymous_method_expression</em>.</li>
<li> The scope of a label declared in a <em>labeled_statement</em> (<a href="statements.md#labeled-statements">Labeled statements</a>) is the <em>block</em> in which the declaration occurs.</li>
<li> The scope of a local variable declared in a <em>local_variable_declaration</em> (<a href="statements.md#local-variable-declarations">Local variable declarations</a>) is the block in which the declaration occurs.</li>
<li> The scope of a local variable declared in a <em>switch_block</em> of a <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>) is the <em>switch_block</em>.</li>
<li> The scope of a local variable declared in a <em>for_initializer</em> of a <code class="prettyprint">for</code> statement (<a href="statements.md#the-for-statement">The for statement</a>) is the <em>for_initializer</em>, the <em>for_condition</em>, the <em>for_iterator</em>, and the contained <em>statement</em> of the <code class="prettyprint">for</code> statement.</li>
<li> The scope of a local constant declared in a <em>local_constant_declaration</em> (<a href="statements.md#local-constant-declarations">Local constant declarations</a>) is the block in which the declaration occurs. It is a compile-time error to refer to a local constant in a textual position that precedes its <em>constant_declarator</em>.</li>
<li> The scope of a variable declared as part of a <em>foreach_statement</em>, <em>using_statement</em>, <em>lock_statement</em> or <em>query_expression</em> is determined by the expansion of the given construct.</li>
</ul>

<p>Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member. For example
&rdquo;`csharp
class A
{
    void F() {
        i = 1;
    }</p>

<p>int i = 0;
}
&ldquo;<code class="prettyprint">
Here, it is valid for</code>F<code class="prettyprint">to refer to</code>i` before it is declared.</p>

<p>Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the <em>local_variable_declarator</em> of the local variable. For example
&rdquo;`csharp
class A
{
    int i = 0;</p>

<p>void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }</p>

<p>void G() {
        int j = (j = 1);        // Valid
    }</p>

<p>void H() {
        int a = 1, b = ++a;    // Valid
    }
}
&ldquo;`</p>

<p>In the <code class="prettyprint">F</code> method above, the first assignment to <code class="prettyprint">i</code> specifically does not refer to the field declared in the outer scope. Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable. In the <code class="prettyprint">G</code> method, the use of <code class="prettyprint">j</code> in the initializer for the declaration of <code class="prettyprint">j</code> is valid because the use does not precede the <em>local_variable_declarator</em>. In the <code class="prettyprint">H</code> method, a subsequent <em>local_variable_declarator</em> correctly refers to a local variable declared in an earlier <em>local_variable_declarator</em> within the same <em>local_variable_declaration</em>.</p>

<p>The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block. If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</p>

<p>The meaning of a name within a block may differ based on the context in which the name is used. In the example
&rdquo;`csharp
using System;</p>

<p>class A {}</p>

<p>class Test
{
    static void Main() {
        string A = &ldquo;hello, world&rdquo;;
        string s = A;                            // expression context</p>

<p>Type t = typeof(A);                      // type context</p>

<p>Console.WriteLine(s);                    // writes &ldquo;hello, world&rdquo;
        Console.WriteLine(t);                    // writes &ldquo;A&rdquo;
    }
}
&ldquo;<code class="prettyprint">
the name</code>A<code class="prettyprint">is used in an expression context to refer to the local variable</code>A<code class="prettyprint">and in a type context to refer to the class</code>A`.</p>

<h3 id="name-hiding">Name hiding</h3>

<p>The scope of an entity typically encompasses more program text than the declaration space of the entity. In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name. Such declarations cause the original entity to become <strong><em>hidden</em></strong>. Conversely, an entity is said to be <strong><em>visible</em></strong> when it is not hidden.</p>

<p>Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance. The characteristics of the two types of hiding are described in the following sections.</p>

<h4 id="hiding-through-nesting">Hiding through nesting</h4>

<p>Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</p>

<p>In the example
&rdquo;`csharp
class A
{
    int i = 0;</p>

<p>void F() {
        int i = 1;
    }</p>

<p>void G() {
        i = 1;
    }
}
&ldquo;<code class="prettyprint">
within the</code>F<code class="prettyprint">method, the instance variable</code>i<code class="prettyprint">is hidden by the local variable</code>i<code class="prettyprint">, but within the</code>G<code class="prettyprint">method,</code>i` still refers to the instance variable.</p>

<p>When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name. In the example
&rdquo;`csharp
class Outer
{
    static void F(int i) {}</p>

<p>static void F(string s) {}</p>

<p>class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F(&ldquo;Hello&rdquo;);        // Error
        }</p>

<p>static void F(long l) {}
    }
}
&ldquo;<code class="prettyprint">
the call</code>F(1)<code class="prettyprint">invokes the</code>F<code class="prettyprint">declared in</code>Inner<code class="prettyprint">because all outer occurrences of</code>F<code class="prettyprint">are hidden by the inner declaration. For the same reason, the call</code>F(&quot;Hello&rdquo;)` results in a compile-time error.</p>

<h4 id="hiding-through-inheritance">Hiding through inheritance</h4>

<p>Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes. This type of name hiding takes one of the following forms:</p>

<ul>
<li> A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</li>
<li> A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</li>
<li> An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</li>
</ul>

<p>The rules governing operator declarations (<a href="classes.md#operators">Operators</a>) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class. Thus, operators never hide one another.</p>

<p>Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported. In the example
&ldquo;`csharp
class Base
{
    public void F() {}
}</p>

<p>class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
&rdquo;<code class="prettyprint">
the declaration of</code>F<code class="prettyprint">in</code>Derived<code class="prettyprint">causes a warning to be reported. Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes. For example, the above situation might have come about because a later version of</code>Base<code class="prettyprint">introduced an</code>F` method that wasn&rsquo;t present in an earlier version of the class. Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</p>

<p>The warning caused by hiding an inherited name can be eliminated through use of the <code class="prettyprint">new</code> modifier:
&ldquo;`csharp
class Base
{
    public void F() {}
}</p>

<p>class Derived: Base
{
    new public void F() {}
}
&rdquo;`</p>

<p>The <code class="prettyprint">new</code> modifier indicates that the <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> is &ldquo;new&rdquo;, and that it is indeed intended to hide the inherited member.</p>

<p>A declaration of a new member hides an inherited member only within the scope of the new member.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">new</span> <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>    <span class="c1">// Hides Base.F in Derived only</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MoreDerived</span><span class="p">:</span> <span class="n">Derived</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span> <span class="nf">F</span><span class="p">();</span> <span class="p">}</span>          <span class="c1">// Invokes Base.F</span>
<span class="p">}</span>
</code></pre>
<p>In the example above, the declaration of <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> hides the <code class="prettyprint">F</code> that was inherited from <code class="prettyprint">Base</code>, but since the new <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> has private access, its scope does not extend to <code class="prettyprint">MoreDerived</code>. Thus, the call <code class="prettyprint">F()</code> in <code class="prettyprint">MoreDerived.G</code> is valid and will invoke <code class="prettyprint">Base.F</code>.</p>

<h2 id="namespace-and-type-names">Namespace and type names</h2>

<p>Several contexts in a C#Â program require a <em>namespace_name</em> or a <em>type_name</em> to be specified.</p>
<pre class="highlight plaintext"><code>namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
</code></pre>
<p>A <em>namespace_name</em> is a <em>namespace_or_type_name</em> that refers to a namespace. Following resolution as described below, the <em>namespace_or_type_name</em> of a <em>namespace_name</em> must refer to a namespace, or otherwise a compile-time error occurs. No type arguments (<a href="types.md#type-arguments">Type arguments</a>) can be present in a <em>namespace_name</em> (only types can have type arguments).</p>

<p>A <em>type_name</em> is a <em>namespace_or_type_name</em> that refers to a type. Following resolution as described below, the <em>namespace_or_type_name</em> of a <em>type_name</em> must refer to a type, or otherwise a compile-time error occurs.</p>

<p>If the <em>namespace_or_type_name</em> is a qualified-alias-member its meaning is as described in <a href="namespaces.md#namespace-alias-qualifiers">Namespace alias qualifiers</a>. Otherwise, a <em>namespace_or_type_name</em> has one of four forms:</p>

<ul>
<li> <code class="prettyprint">I</code></li>
<li> <code class="prettyprint">I&lt;A1, ..., Ak&gt;</code></li>
<li> <code class="prettyprint">N.I</code></li>
<li> <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code></li>
</ul>

<p>where <code class="prettyprint">I</code> is a single identifier, <code class="prettyprint">N</code> is a <em>namespace_or_type_name</em> and <code class="prettyprint">&lt;A1, ..., Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">k</code> to be zero.</p>

<p>The meaning of a <em>namespace_or_type_name</em> is determined as follows:</p>

<ul>
<li>  If the <em>namespace_or_type_name</em> is of the form <code class="prettyprint">I</code> or of the form <code class="prettyprint">I&lt;A1, ..., Ak&gt;</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the <em>namespace_or_type_name</em> appears within a generic method declaration (<a href="classes.md#methods">Methods</a>) and if that declaration includes a type parameter (<a href="classes.md#type-parameters">Type parameters</a>) with nameÂ <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that type parameter.</li>
<li>Otherwise, if the <em>namespace_or_type_name</em> appears within a type declaration, then for each instance typeÂ <code class="prettyprint">T</code> (<a href="classes.md#the-instance-type">The instance type</a>), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):

<ul>
<li>If <code class="prettyprint">K</code> is zero and the declaration of <code class="prettyprint">T</code> includes a type parameter with nameÂ <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that type parameter.</li>
<li>Otherwise, if the <em>namespace_or_type_name</em> appears within the body of the type declaration, and <code class="prettyprint">T</code> or any of its base types contain a nested accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments. If there is more than one such type, the type declared within the more derived type is selected. Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the <em>namespace_or_type_name</em>.</li>
</ul></li>
<li>If the previous steps were unsuccessful then, for each namespaceÂ <code class="prettyprint">N</code>, starting with the namespace in which the <em>namespace_or_type_name</em> occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:

<ul>
<li>If <code class="prettyprint">K</code> is zero and <code class="prettyprint">I</code> is the name of a namespace inÂ <code class="prettyprint">N</code>, then:

<ul>
<li>If the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with a namespace or type, then the <em>namespace_or_type_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the namespace named <code class="prettyprint">I</code> in <code class="prettyprint">N</code>.</li>
</ul></li>
<li>Otherwise, if <code class="prettyprint">N</code> contains an accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with a namespace or type, then the <em>namespace_or_type_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the type constructed with the given type arguments.</li>
</ul></li>
<li>Otherwise, if the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with an imported namespace or type, then the <em>namespace_or_type_name</em> refers to that namespace or type.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the *namespace_or_type_name</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the *namespace_or_type_name</em> is ambiguous and an error occurs.</li>
</ul></li>
</ul></li>
<li>Otherwise, the <em>namespace_or_type_name</em> is undefined and a compile-time error occurs.</li>
</ul></li>
<li> Otherwise, the <em>namespace_or_type_name</em> is of the form <code class="prettyprint">N.I</code> or of the form <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code>. <code class="prettyprint">N</code> is first resolved as a <em>namespace_or_type_name</em>. If the resolution of <code class="prettyprint">N</code> is not successful, a compile-time error occurs. Otherwise, <code class="prettyprint">N.I</code> or <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code> is resolved as follows:

<ul>
<li>If <code class="prettyprint">K</code> is zero and <code class="prettyprint">N</code> refers to a namespace and <code class="prettyprint">N</code> contains a nested namespace with name <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that nested namespace.</li>
<li>Otherwise, if <code class="prettyprint">N</code> refers to a namespace and <code class="prettyprint">N</code> contains an accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, if <code class="prettyprint">N</code> refers to a (possibly constructed) class or struct type and <code class="prettyprint">N</code> or any of its base classes contain a nested accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments. If there is more than one such type, the type declared within the more derived type is selected. Note that if the meaning of <code class="prettyprint">N.I</code> is being determined as part of resolving the base class specification of <code class="prettyprint">N</code> then the direct base class of <code class="prettyprint">N</code> is considered to be object (<a href="classes.md#base-classes">Base classes</a>).</li>
<li>Otherwise, <code class="prettyprint">N.I</code> is an invalid <em>namespace_or_type_name</em>, and a compile-time error occurs.</li>
</ul></li>
</ul>

<p>A <em>namespace_or_type_name</em> is permitted to reference a static class (<a href="classes.md#static-classes">Static classes</a>) only if</p>

<ul>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>namespace_or_type_name</em> of the form <code class="prettyprint">T.I</code>, or</li>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>typeof_expression</em> (<a href="expressions.md#argument-lists">Argument lists</a>1) of the form <code class="prettyprint">typeof(T)</code>.</li>
</ul>

<h3 id="fully-qualified-names">Fully qualified names</h3>

<p>Every namespace and type has a <strong><em>fully qualified name</em></strong>, which uniquely identifies the namespace or type amongst all others. The fully qualified name of a namespace or type <code class="prettyprint">N</code> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">N</code> is a member of the global namespace, its fully qualified name is <code class="prettyprint">N</code>.</li>
<li> Otherwise, its fully qualified name is <code class="prettyprint">S.N</code>, where <code class="prettyprint">S</code> is the fully qualified name of the namespace or type in which <code class="prettyprint">N</code> is declared.</li>
</ul>

<p>In other words, the fully qualified name of <code class="prettyprint">N</code> is the complete hierarchical path of identifiers that lead to <code class="prettyprint">N</code>, starting from the global namespace. Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</p>

<p>The example below shows several namespace and type declarations along with their associated fully qualified names.
&ldquo;`csharp
class A {}                // A</p>

<p>namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }</p>

<p>namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}</p>

<p>namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
&rdquo;`</p>

<h2 id="automatic-memory-management">Automatic memory management</h2>

<p>C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects. Automatic memory management policies are implemented by a <strong><em>garbage collector</em></strong>. The memory management life cycle of an object is as follows:</p>

<ol>
<li>When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</li>
<li>If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction. The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future. For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</li>
<li>Once the object is eligible for destruction, at some unspecified later time the destructor (<a href="classes.md#destructors">Destructors</a>) (if any) for the object is run. Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</li>
<li>Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</li>
<li>Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</li>
</ol>

<p>The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</p>

<p>Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies. For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</p>

<p>The behavior of the garbage collector can be controlled, to some degree, via static methods on the class <code class="prettyprint">System.GC</code>. This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</p>

<p>Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code. The program
&ldquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&quot;Destruct instance of A&rdquo;);
    }
}</p>

<p>class B
{
    object Ref;</p>

<p>public B(object o) {
        Ref = o;
    }</p>

<p>~B() {
        Console.WriteLine(&ldquo;Destruct instance of B&rdquo;);
    }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
<code class="prettyprint">
creates an instance of class `A` and an instance of class `B`. These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them. The output could be either
</code>
Destruct instance of A
Destruct instance of B
<code class="prettyprint">
or
</code>
Destruct instance of B
Destruct instance of A
&ldquo;`
because the language imposes no constraints on the order in which objects are garbage collected.</p>

<p>In subtle cases, the distinction between &quot;eligible for destruction&rdquo; and &ldquo;eligible for collection&rdquo; can be important. For example,
&ldquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&quot;Destruct instance of A&rdquo;);
    }</p>

<p>public void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
        Test.RefA = this;
    }
}</p>

<p>class B
{
    public A Ref;</p>

<p>~B() {
        Console.WriteLine(&ldquo;Destruct instance of B&rdquo;);
        Ref.F();
    }
}</p>

<p>class Test
{
    public static A RefA;
    public static B RefB;</p>

<p>static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;</p>

<p>// A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();</p>

<p>// B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine(&ldquo;RefA is not null&rdquo;);
    }
}
&ldquo;`</p>

<p>In the above program, if the garbage collector chooses to run the destructor of <code class="prettyprint">A</code> before the destructor of <code class="prettyprint">B</code>, then the output of this program might be:
<code class="prettyprint">
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
</code></p>

<p>Note that although the instance of <code class="prettyprint">A</code> was not in use and <code class="prettyprint">A</code>&rsquo;s destructor was run, it is still possible for methods of <code class="prettyprint">A</code> (in this case, <code class="prettyprint">F</code>) to be called from another destructor. Also, note that running of a destructor may cause an object to become usable from the mainline program again. In this case, the running of <code class="prettyprint">B</code>&rsquo;s destructor caused an instance of <code class="prettyprint">A</code> that was previously not in use to become accessible from the live reference <code class="prettyprint">Test.RefA</code>. After the call to <code class="prettyprint">WaitForPendingFinalizers</code>, the instance of <code class="prettyprint">B</code> is eligible for collection, but the instance of <code class="prettyprint">A</code> is not, because of the reference <code class="prettyprint">Test.RefA</code>.</p>

<p>To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object&rsquo;s own fields, and not to perform any actions on referenced objects or static fields.</p>

<p>An alternative to using destructors is to let a class implement the <code class="prettyprint">System.IDisposable</code> interface. This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a <code class="prettyprint">using</code> statement (<a href="statements.md#the-using-statement">The using statement</a>).</p>

<h2 id="execution-order">Execution order</h2>

<p>Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points. A <strong><em>side effect</em></strong> is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception. The critical execution points at which the order of these side effects must be preserved are references to volatile fields (<a href="classes.md#volatile-fields">Volatile fields</a>), <code class="prettyprint">lock</code> statements (<a href="statements.md#the-lock-statement">The lock statement</a>), and thread creation and termination. The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</p>

<ul>
<li> Data dependence is preserved within a thread of execution. That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</li>
<li> Initialization ordering rules are preserved (<a href="classes.md#field-initialization">Field initialization</a> and <a href="classes.md#variable-initializers">Variable initializers</a>).</li>
<li> The ordering of side effects is preserved with respect to volatile reads and writes (<a href="classes.md#volatile-fields">Volatile fields</a>). Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression&rsquo;s value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field). When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</li>
</ul>

          <h1 id="types">Types</h1>

<p>The types of the C# language are divided into two main categories: <strong><em>value types</em></strong> and <strong><em>reference types</em></strong>. Both value types and reference types may be <strong><em>generic types</em></strong>, which take one or more <strong><em>type parameters</em></strong>. Type parameters can designate both value types and reference types.</p>
<pre class="highlight plaintext"><code>type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
</code></pre>
<p>The final category of types, pointers, is available only in unsafe code. This is discussed further in <a href="unsafe-code.md#pointer-types">Pointer types</a>.</p>

<p>Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store <strong><em>references</em></strong> to their data, the latter being known as <strong><em>objects</em></strong>. With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</p>

<p>C#&lsquo;s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the <code class="prettyprint">object</code> class type, and <code class="prettyprint">object</code> is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type <code class="prettyprint">object</code>. Values of value types are treated as objects by performing boxing and unboxing operations (<a href="types.md#boxing-and-unboxing">Boxing and unboxing</a>).</p>

<h2 id="value-types">Value types</h2>

<p>A value type is either a struct type or an enumeration type. C# provides a set of predefined struct types called the <strong><em>simple types</em></strong>. The simple types are identified through reserved words.</p>
<pre class="highlight plaintext"><code>value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
</code></pre>
<p>Unlike a variable of a reference type, a variable of a value type can contain the value <code class="prettyprint">null</code> only if the value type is a nullable type.  For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value <code class="prettyprint">null</code>.</p>

<p>Assignment to a variable of a value type creates a copy of the value being assigned. This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</p>

<h3 id="the-system-valuetype-type">The System.ValueType type</h3>

<p>All value types implicitly inherit from the class <code class="prettyprint">System.ValueType</code>, which, in turn, inherits from class <code class="prettyprint">object</code>. It is not possible for any type to derive from a value type, and value types are thus implicitly sealed (<a href="classes.md#sealed-classes">Sealed classes</a>).</p>

<p>Note that <code class="prettyprint">System.ValueType</code> is not itself a <em>value_type</em>. Rather, it is a <em>class_type</em> from which all *value_type*s are automatically derived.</p>

<h3 id="default-constructors">Default constructors</h3>

<p>All value types implicitly declare a public parameterless instance constructor called the <strong><em>default constructor</em></strong>. The default constructor returns a zero-initialized instance known as the <strong><em>default value</em></strong> for the value type:</p>

<ul>
<li> For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:

<ul>
<li>For <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code>, the default value is <code class="prettyprint">0</code>.</li>
<li>For <code class="prettyprint">char</code>, the default value is <code class="prettyprint">&#39;\x0000&#39;</code>.</li>
<li>For <code class="prettyprint">float</code>, the default value is <code class="prettyprint">0.0f</code>.</li>
<li>For <code class="prettyprint">double</code>, the default value is <code class="prettyprint">0.0d</code>.</li>
<li>For <code class="prettyprint">decimal</code>, the default value is <code class="prettyprint">0.0m</code>.</li>
<li>For <code class="prettyprint">bool</code>, the default value is <code class="prettyprint">false</code>.</li>
</ul></li>
<li> For an <em>enum_type</em> <code class="prettyprint">E</code>, the default value is <code class="prettyprint">0</code>, converted to the type <code class="prettyprint">E</code>.</li>
<li> For a <em>struct_type</em>, the default value is the value produced by setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code>.</li>
<li> For a <em>nullable_type</em> the default value is an instance for which the <code class="prettyprint">HasValue</code> property is false and the <code class="prettyprint">Value</code> property is undefined. The default value is also known as the <strong><em>null value</em></strong> of the nullable type.</li>
</ul>

<p>Like any other instance constructor, the default constructor of a value type is invoked using the <code class="prettyprint">new</code> operator. For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call. In the example below, variables <code class="prettyprint">i</code> and <code class="prettyprint">j</code> are both initialized to zero.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor. A struct type is however permitted to declare parameterized instance constructors (<a href="structs.md#constructors">Constructors</a>).</p>

<h3 id="struct-types">Struct types</h3>

<p>A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types. The declaration of struct types is described in <a href="structs.md#struct-declarations">Struct declarations</a>.</p>

<h3 id="simple-types">Simple types</h3>

<p>C# provides a set of predefined struct types called the <strong><em>simple types</em></strong>. The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the <code class="prettyprint">System</code> namespace, as described in the table below.</p>

<table><thead>
<tr>
<th><strong>Reserved word</strong></th>
<th><strong>Aliased type</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">sbyte</code></td>
<td><code class="prettyprint">System.SByte</code></td>
</tr>
<tr>
<td><code class="prettyprint">byte</code></td>
<td><code class="prettyprint">System.Byte</code></td>
</tr>
<tr>
<td><code class="prettyprint">short</code></td>
<td><code class="prettyprint">System.Int16</code></td>
</tr>
<tr>
<td><code class="prettyprint">ushort</code></td>
<td><code class="prettyprint">System.UInt16</code></td>
</tr>
<tr>
<td><code class="prettyprint">int</code></td>
<td><code class="prettyprint">System.Int32</code></td>
</tr>
<tr>
<td><code class="prettyprint">uint</code></td>
<td><code class="prettyprint">System.UInt32</code></td>
</tr>
<tr>
<td><code class="prettyprint">long</code></td>
<td><code class="prettyprint">System.Int64</code></td>
</tr>
<tr>
<td><code class="prettyprint">ulong</code></td>
<td><code class="prettyprint">System.UInt64</code></td>
</tr>
<tr>
<td><code class="prettyprint">char</code></td>
<td><code class="prettyprint">System.Char</code></td>
</tr>
<tr>
<td><code class="prettyprint">float</code></td>
<td><code class="prettyprint">System.Single</code></td>
</tr>
<tr>
<td><code class="prettyprint">double</code></td>
<td><code class="prettyprint">System.Double</code></td>
</tr>
<tr>
<td><code class="prettyprint">bool</code></td>
<td><code class="prettyprint">System.Boolean</code></td>
</tr>
<tr>
<td><code class="prettyprint">decimal</code></td>
<td><code class="prettyprint">System.Decimal</code></td>
</tr>
</tbody></table>

<p>Because a simple type aliases a struct type, every simple type has members. For example, <code class="prettyprint">int</code> has the members declared in <code class="prettyprint">System.Int32</code> and the members inherited from <code class="prettyprint">System.Object</code>, and the following statements are permitted:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>           <span class="c1">// System.Int32.MaxValue constant</span>
<span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>        <span class="c1">// System.Int32.ToString() instance method</span>
<span class="kt">string</span> <span class="n">t</span> <span class="p">=</span> <span class="m">123.</span><span class="nf">ToString</span><span class="p">();</span>      <span class="c1">// System.Int32.ToString() instance method</span>
</code></pre>
<p>The simple types differ from other struct types in that they permit certain additional operations:</p>

<ul>
<li> Most simple types permit values to be created by writing <em>literals</em> (<a href="lexical-structure.md#literals">Literals</a>). For example, <code class="prettyprint">123</code> is a literal of type <code class="prettyprint">int</code> and <code class="prettyprint">&#39;a&#39;</code> is a literal of type <code class="prettyprint">char</code>. C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</li>
<li> When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time. Such an expression is known as a <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>). Expressions involving operators defined by other struct types are not considered to be constant expressions.</li>
<li> Through <code class="prettyprint">const</code> declarations it is possible to declare constants of the simple types (<a href="classes.md#constants">Constants</a>). It is not possible to have constants of other struct types, but a similar effect is provided by <code class="prettyprint">static readonly</code> fields.</li>
<li> Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator (<a href="conversions.md#evaluation-of-user-defined-conversions">Evaluation of user-defined conversions</a>).</li>
</ul>

<h3 id="integral-types">Integral types</h3>

<p>C# supports nine integral types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, and <code class="prettyprint">char</code>. The integral types have the following sizes and ranges of values:</p>

<ul>
<li> The <code class="prettyprint">sbyte</code> type represents signed 8-bit integers with values between -128 and 127.</li>
<li> The <code class="prettyprint">byte</code> type represents unsigned 8-bit integers with values between 0 and 255.</li>
<li> The <code class="prettyprint">short</code> type represents signed 16-bit integers with values between -32768 and 32767.</li>
<li> The <code class="prettyprint">ushort</code> type represents unsigned 16-bit integers with values between 0 and 65535.</li>
<li> The <code class="prettyprint">int</code> type represents signed 32-bit integers with values between -2147483648 and 2147483647.</li>
<li> The <code class="prettyprint">uint</code> type represents unsigned 32-bit integers with values between 0 and 4294967295.</li>
<li> The <code class="prettyprint">long</code> type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</li>
<li> The <code class="prettyprint">ulong</code> type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</li>
<li> The <code class="prettyprint">char</code> type represents unsigned 16-bit integers with values between 0 and 65535. The set of possible values for the <code class="prettyprint">char</code> type corresponds to the Unicode character set. Although <code class="prettyprint">char</code> has the same representation as <code class="prettyprint">ushort</code>, not all operations permitted on one type are permitted on the other.</li>
</ul>

<p>The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</p>

<ul>
<li> For the unary <code class="prettyprint">+</code> and <code class="prettyprint">~</code> operators, the operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>.</li>
<li> For the unary <code class="prettyprint">-</code> operator, the operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code> and <code class="prettyprint">long</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>. The unary <code class="prettyprint">-</code> operator cannot be applied to operands of type <code class="prettyprint">ulong</code>.</li>
<li> For the binary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">^</code>, <code class="prettyprint">|</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, and <code class="prettyprint">&lt;=</code> operators, the operands are converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of both operands. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code> (or <code class="prettyprint">bool</code> for the relational operators). It is not permitted for one operand to be of type <code class="prettyprint">long</code> and the other to be of type <code class="prettyprint">ulong</code> with the binary operators.</li>
<li> For the binary <code class="prettyprint">&lt;&lt;</code> and <code class="prettyprint">&gt;&gt;</code> operators, the left operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>.</li>
</ul>

<p>The <code class="prettyprint">char</code> type is classified as an integral type, but it differs from the other integral types in two ways:</p>

<ul>
<li> There are no implicit conversions from other types to the <code class="prettyprint">char</code> type. In particular, even though the <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, and <code class="prettyprint">ushort</code> types have ranges of values that are fully representable using the <code class="prettyprint">char</code> type, implicit conversions from <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, or <code class="prettyprint">ushort</code> to <code class="prettyprint">char</code> do not exist.</li>
<li> Constants of the <code class="prettyprint">char</code> type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type <code class="prettyprint">char</code>. For example, <code class="prettyprint">(char)10</code> is the same as <code class="prettyprint">&#39;\x000A&#39;</code>.</li>
</ul>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>). In a <code class="prettyprint">checked</code> context, an overflow produces a compile-time error or causes a <code class="prettyprint">System.OverflowException</code> to be thrown. In an <code class="prettyprint">unchecked</code> context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</p>

<h3 id="floating-point-types">Floating point types</h3>

<p>C# supports two floating point types: <code class="prettyprint">float</code> and <code class="prettyprint">double</code>. The <code class="prettyprint">float</code> and <code class="prettyprint">double</code> types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</p>

<ul>
<li> Positive zero and negative zero. In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two (<a href="expressions.md#division-operator">Division operator</a>).</li>
<li> Positive infinity and negative infinity. Infinities are produced by such operations as dividing a non-zero number by zero. For example, <code class="prettyprint">1.0 / 0.0</code> yields positive infinity, and <code class="prettyprint">-1.0 / 0.0</code> yields negative infinity.</li>
<li> The <strong><em>Not-a-Number</em></strong> value, often abbreviated NaN. NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</li>
<li> The finite set of non-zero values of the form <code class="prettyprint">sÂ *Â mÂ *Â 2^e</code>, where <code class="prettyprint">s</code> is 1 or -1, and <code class="prettyprint">m</code> and <code class="prettyprint">e</code> are determined by the particular floating-point type: For <code class="prettyprint">float</code>, <code class="prettyprint">0 &lt; m &lt; 2^24</code> and <code class="prettyprint">-149 &lt;= e &lt;= 104</code>, and for <code class="prettyprint">double</code>, <code class="prettyprint">0 &lt; m &lt; 2^53</code> and <code class="prettyprint">1075 &lt;= e &lt;= 970</code>. Denormalized floating-point numbers are considered valid non-zero values.</li>
</ul>

<p>The <code class="prettyprint">float</code> type can represent values ranging from approximately <code class="prettyprint">1.5Â *Â 10^-45</code> to <code class="prettyprint">3.4Â *Â 10^38</code> with a precision of 7 digits.</p>

<p>The <code class="prettyprint">double</code> type can represent values ranging from approximately <code class="prettyprint">5.0Â *Â 10^-324</code> to <code class="prettyprint">1.7Â Ã—Â 10^308</code> with a precision of 15-16 digits.</p>

<p>If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</p>

<ul>
<li> If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</li>
<li> Then, if either of the operands is of type <code class="prettyprint">double</code>, the other operand is converted to <code class="prettyprint">double</code>, the operation is performed using at least <code class="prettyprint">double</code> range and precision, and the type of the result is <code class="prettyprint">double</code> (or <code class="prettyprint">bool</code> for the relational operators).</li>
<li> Otherwise, the operation is performed using at least <code class="prettyprint">float</code> range and precision, and the type of the result is <code class="prettyprint">float</code> (or <code class="prettyprint">bool</code> for the relational operators).</li>
</ul>

<p>The floating-point operators, including the assignment operators, never produce exceptions. Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</p>

<ul>
<li> If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</li>
<li> If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</li>
<li> If a floating-point operation is invalid, the result of the operation becomes NaN.</li>
<li> If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</li>
</ul>

<p>Floating-point operations may be performed with higher precision than the result type of the operation. For example, some hardware architectures support an &ldquo;extended&rdquo; or &ldquo;long double&rdquo; floating-point type with greater range and precision than the <code class="prettyprint">double</code> type, and implicitly perform all floating-point operations using this higher precision type. Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations. Other than delivering more precise results, this rarely has any measurable effects. However, in expressions of the form <code class="prettyprint">x * y / z</code>, where the multiplication produces a result that is outside the <code class="prettyprint">double</code> range, but the subsequent division brings the temporary result back into the <code class="prettyprint">double</code> range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</p>

<h3 id="the-decimal-type">The decimal type</h3>

<p>The <code class="prettyprint">decimal</code> type is a 128-bit data type suitable for financial and monetary calculations. The <code class="prettyprint">decimal</code> type can represent values ranging from <code class="prettyprint">1.0Â *Â 10^-28</code> to approximately <code class="prettyprint">7.9Â *Â 10^28</code> with 28-29 significant digits.</p>

<p>The finite set of values of type <code class="prettyprint">decimal</code> are of the form <code class="prettyprint">(-1)^sÂ *Â cÂ *Â 10^-e</code>, where the sign <code class="prettyprint">s</code> is 0 or 1, the coefficient <code class="prettyprint">c</code> is given by <code class="prettyprint">0Â &lt;=Â *c*Â &lt;Â 2^96</code>, and the scale <code class="prettyprint">e</code> is such that <code class="prettyprint">0Â &lt;=Â e &lt;=Â 28</code>.The <code class="prettyprint">decimal</code> type does not support signed zeros, infinities, or NaN&rsquo;s. A <code class="prettyprint">decimal</code> is represented as a 96-bit integer scaled by a power of ten. For <code class="prettyprint">decimal</code>s with an absolute value less than <code class="prettyprint">1.0m</code>, the value is exact to the 28th decimal place, but no further. For <code class="prettyprint">decimal</code>s with an absolute value greater than or equal to <code class="prettyprint">1.0m</code>, the value is exact to 28 or 29 digits. Contrary to the <code class="prettyprint">float</code> and <code class="prettyprint">double</code> data types, decimal fractional numbers such as 0.1 can be represented exactly in the <code class="prettyprint">decimal</code> representation. In the <code class="prettyprint">float</code> and <code class="prettyprint">double</code> representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</p>

<p>If one of the operands of a binary operator is of type <code class="prettyprint">decimal</code>, then the other operand must be of an integral type or of type <code class="prettyprint">decimal</code>. If an integral type operand is present, it is converted to <code class="prettyprint">decimal</code> before the operation is performed.</p>

<p>The result of an operation on values of type <code class="prettyprint">decimal</code> is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation. Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as &ldquo;banker&rsquo;s rounding&rdquo;). A zero result always has a sign of 0 and a scale of 0.</p>

<p>If a decimal arithmetic operation produces a value less than or equal to <code class="prettyprint">5Â *Â 10^-29</code> in absolute value, the result of the operation becomes zero. If a <code class="prettyprint">decimal</code> arithmetic operation produces a result that is too large for the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The <code class="prettyprint">decimal</code> type has greater precision but smaller range than the floating-point types. Thus, conversions from the floating-point types to <code class="prettyprint">decimal</code> might produce overflow exceptions, and conversions from <code class="prettyprint">decimal</code> to the floating-point types might cause loss of precision. For these reasons, no implicit conversions exist between the floating-point types and <code class="prettyprint">decimal</code>, and without explicit casts, it is not possible to mix floating-point and <code class="prettyprint">decimal</code> operands in the same expression.</p>

<h3 id="the-bool-type">The bool type</h3>

<p>The <code class="prettyprint">bool</code> type represents boolean logical quantities. The possible values of type <code class="prettyprint">bool</code> are <code class="prettyprint">true</code> and <code class="prettyprint">false</code>.</p>

<p>No standard conversions exist between <code class="prettyprint">bool</code> and other types. In particular, the <code class="prettyprint">bool</code> type is distinct and separate from the integral types, and a <code class="prettyprint">bool</code> value cannot be used in place of an integral value, and vice versa.</p>

<p>In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value <code class="prettyprint">false</code>, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value <code class="prettyprint">true</code>. In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to <code class="prettyprint">null</code>.</p>

<h3 id="enumeration-types">Enumeration types</h3>

<p>An enumeration type is a distinct type with named constants. Every enumeration type has an underlying type, which must be <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code>. The set of values of the enumeration type is the same as the set of values of the underlying type. Values of the enumeration type are not restricted to the values of the named constants. Enumeration types are defined through enumeration declarations (<a href="enums.md#enum-declarations">Enum declarations</a>).</p>

<h3 id="nullable-types">Nullable types</h3>

<p>A nullable type can represent all values of its <strong><em>underlying type</em></strong> plus an additional null value. A nullable type is written <code class="prettyprint">T?</code>, where <code class="prettyprint">T</code> is the underlying type. This syntax is shorthand for <code class="prettyprint">System.Nullable&lt;T&gt;</code>, and the two forms can be used interchangeably.</p>

<p>A <strong><em>non-nullable value type</em></strong> conversely is any value type other than <code class="prettyprint">System.Nullable&lt;T&gt;</code> and its shorthand <code class="prettyprint">T?</code> (for any <code class="prettyprint">T</code>), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a <code class="prettyprint">struct</code> constraint). The <code class="prettyprint">System.Nullable&lt;T&gt;</code> type specifies the value type constraint for <code class="prettyprint">T</code> (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), which means that the underlying type of a nullable type can be any non-nullable value type. The underlying type of a nullable type cannot be a nullable type or a reference type. For example, <code class="prettyprint">int??</code> and <code class="prettyprint">string?</code> are invalid types.</p>

<p>An instance of a nullable type <code class="prettyprint">T?</code> has two public read-only properties:</p>

<ul>
<li> A <code class="prettyprint">HasValue</code> property of type <code class="prettyprint">bool</code></li>
<li> A <code class="prettyprint">Value</code> property of type <code class="prettyprint">T</code></li>
</ul>

<p>An instance for which <code class="prettyprint">HasValue</code> is true is said to be non-null. A non-null instance contains a known value and <code class="prettyprint">Value</code> returns that value.</p>

<p>An instance for which <code class="prettyprint">HasValue</code> is false is said to be null. A null instance has an undefined value. Attempting to read the <code class="prettyprint">Value</code> of a null instance causes a <code class="prettyprint">System.InvalidOperationException</code> to be thrown. The process of accessing the <code class="prettyprint">Value</code> property of a nullable instance is referred to as <strong><em>unwrapping</em></strong>.</p>

<p>In addition to the default constructor, every nullable type <code class="prettyprint">T?</code> has a public constructor that takes a single argument of type <code class="prettyprint">T</code>. Given a value <code class="prettyprint">x</code> of type <code class="prettyprint">T</code>, a constructor invocation of the form</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">new</span> <span class="n">T</span><span class="p">?(</span><span class="n">x</span><span class="p">)</span>
</code></pre>
<p>creates a non-null instance of <code class="prettyprint">T?</code> for which the <code class="prettyprint">Value</code> property is <code class="prettyprint">x</code>. The process of creating a non-null instance of a nullable type for a given value is referred to as <strong><em>wrapping</em></strong>.</p>

<p>Implicit conversions are available from the <code class="prettyprint">null</code> literal to <code class="prettyprint">T?</code> (<a href="conversions.md#null-literal-conversions">Null literal conversions</a>) and from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code> (<a href="conversions.md#implicit-nullable-conversions">Implicit nullable conversions</a>).</p>

<h2 id="reference-types">Reference types</h2>

<p>A reference type is a class type, an interface type, an array type, or a delegate type.</p>
<pre class="highlight plaintext"><code>reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
</code></pre>
<p>A reference type value is a reference to an <strong><em>instance</em></strong> of the type, the latter known as an <strong><em>object</em></strong>. The special value <code class="prettyprint">null</code> is compatible with all reference types and indicates the absence of an instance.</p>

<h3 id="class-types">Class types</h3>

<p>A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types. Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes. Instances of class types are created using *object_creation_expression*s (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>).</p>

<p>Class types are described in <a href="classes.md#classes">Classes</a>.</p>

<p>Certain predefined class types have special meaning in the C# language, as described in the table below.</p>

<table><thead>
<tr>
<th><strong>Class type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">System.Object</code></td>
<td>The ultimate base class of all other types. See <a href="types.md#the-object-type">The object type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.String</code></td>
<td>The string type of the C# language. See <a href="types.md#the-string-type">The string type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.ValueType</code></td>
<td>The base class of all value types. See <a href="types.md#the-systemvaluetype-type">The System.ValueType type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Enum</code></td>
<td>The base class of all enum types. See <a href="enums.md#enums">Enums</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Array</code></td>
<td>The base class of all array types. See <a href="arrays.md#arrays">Arrays</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Delegate</code></td>
<td>The base class of all delegate types. See <a href="delegates.md#delegates">Delegates</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Exception</code></td>
<td>The base class of all exception types. See <a href="exceptions.md#exceptions">Exceptions</a>.</td>
</tr>
</tbody></table>

<h3 id="the-object-type">The object type</h3>

<p>The <code class="prettyprint">object</code> class type is the ultimate base class of all other types. Every type in C# directly or indirectly derives from the <code class="prettyprint">object</code> class type.</p>

<p>The keyword <code class="prettyprint">object</code> is simply an alias for the predefined class <code class="prettyprint">System.Object</code>.</p>

<h3 id="the-dynamic-type">The dynamic type</h3>

<p>The <code class="prettyprint">dynamic</code> type, like <code class="prettyprint">object</code>, can reference any object. When operators are applied to expressions of type <code class="prettyprint">dynamic</code>, their resolution is deferred until the program is run. Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation. Instead an exception will be thrown when resolution of the operator fails at run-time.</p>

<p>Its purpose is to allow dynamic binding, which is described in detail in <a href="expressions.md#dynamic-binding">Dynamic binding</a>.</p>

<p><code class="prettyprint">dynamic</code> is considered identical to <code class="prettyprint">object</code> except in the following respects:</p>

<ul>
<li> Operations on expressions of type <code class="prettyprint">dynamic</code> can be dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>).</li>
<li> Type inference (<a href="expressions.md#type-inference">Type inference</a>) will prefer <code class="prettyprint">dynamic</code> over <code class="prettyprint">object</code> if both are candidates.</li>
</ul>

<p>Because of this equivalence, the following holds:</p>

<ul>
<li> There is an implicit identity conversion between <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>, and between constructed types that are the same when replacing <code class="prettyprint">dynamic</code> with <code class="prettyprint">object</code></li>
<li> Implicit and explicit conversions to and from <code class="prettyprint">object</code> also apply to and from <code class="prettyprint">dynamic</code>.</li>
<li> Method signatures that are the same when replacing <code class="prettyprint">dynamic</code> with <code class="prettyprint">object</code> are considered the same signature</li>
<li> The type <code class="prettyprint">dynamic</code> is indistinguishable from <code class="prettyprint">object</code> at run-time.</li>
<li> An expression of the type <code class="prettyprint">dynamic</code> is referred to as a <strong><em>dynamic expression</em></strong>.</li>
</ul>

<h3 id="the-string-type">The string type</h3>

<p>The <code class="prettyprint">string</code> type is a sealed class type that inherits directly from <code class="prettyprint">object</code>. Instances of the <code class="prettyprint">string</code> class represent Unicode character strings.</p>

<p>Values of the <code class="prettyprint">string</code> type can be written as string literals (<a href="lexical-structure.md#string-literals">String literals</a>).</p>

<p>The keyword <code class="prettyprint">string</code> is simply an alias for the predefined class <code class="prettyprint">System.String</code>.</p>

<h3 id="interface-types">Interface types</h3>

<p>An interface defines a contract. A class or struct that implements an interface must adhere to its contract. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</p>

<p>Interface types are described in <a href="interfaces.md#interfaces">Interfaces</a>.</p>

<h3 id="array-types">Array types</h3>

<p>An array is a data structure that contains zero or more variables which are accessed through computed indices. The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</p>

<p>Array types are described in <a href="arrays.md#arrays">Arrays</a>.</p>

<h3 id="delegate-types">Delegate types</h3>

<p>A delegate is a data structure that refers to one or more methods. For instance methods, it also refers to their corresponding object instances.</p>

<p>The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods. In the latter case, the delegate stores not only a reference to the method&rsquo;s entry point, but also a reference to the object instance on which to invoke the method.</p>

<p>Delegate types are described in <a href="delegates.md#delegates">Delegates</a>.</p>

<h2 id="boxing-and-unboxing">Boxing and unboxing</h2>

<p>The concept of boxing and unboxing is central to C#&rsquo;s type system. It provides a bridge between <em>value_type*s and *reference_type*s by permitting any value of a *value_type</em> to be converted to and from type <code class="prettyprint">object</code>. Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</p>

<h3 id="boxing-conversions">Boxing conversions</h3>

<p>A boxing conversion permits a <em>value_type</em> to be implicitly converted to a <em>reference_type</em>. The following boxing conversions exist:</p>

<ul>
<li> From any <em>value_type</em> to the type <code class="prettyprint">object</code>.</li>
<li> From any <em>value_type</em> to the type <code class="prettyprint">System.ValueType</code>.</li>
<li> From any <em>non_nullable_value_type</em> to any <em>interface_type</em> implemented by the <em>value_type</em>.</li>
<li> From any <em>nullable_type</em> to any <em>interface_type</em> implemented by the underlying type of the <em>nullable_type</em>.</li>
<li> From any <em>enum_type</em> to the type <code class="prettyprint">System.Enum</code>.</li>
<li> From any <em>nullable_type</em> with an underlying <em>enum_type</em> to the type <code class="prettyprint">System.Enum</code>.</li>
<li> Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type (<a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a>).</li>
</ul>

<p>Boxing a value of a <em>non_nullable_value_type</em> consists of allocating an object instance and copying the <em>non_nullable_value_type</em> value into that instance.</p>

<p>Boxing a value of a <em>nullable_type</em> produces a null reference if it is the <code class="prettyprint">null</code> value (<code class="prettyprint">HasValue</code> is <code class="prettyprint">false</code>), or the result of unwrapping and boxing the underlying value otherwise.</p>

<p>The actual process of boxing a value of a <em>non_nullable_value_type</em> is best explained by imagining the existence of a generic <strong><em>boxing class</em></strong>, which behaves as if it were declared as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">sealed</span> <span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">System</span><span class="p">.</span><span class="n">ValueType</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Box</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">value</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Boxing of a value <code class="prettyprint">v</code> of type <code class="prettyprint">T</code> now consists of executing the expression <code class="prettyprint">new Box&lt;T&gt;(v)</code>, and returning the resulting instance as a value of type <code class="prettyprint">object</code>. Thus, the statements
<code class="prettyprint">csharp
int i = 123;
object box = i;
</code>
conceptually correspond to
<code class="prettyprint">csharp
int i = 123;
object box = new Box&lt;int&gt;(i);
</code></p>

<p>A boxing class like <code class="prettyprint">Box&lt;T&gt;</code> above doesn&rsquo;t actually exist and the dynamic type of a boxed value isn&rsquo;t actually a class type. Instead, a boxed value of type <code class="prettyprint">T</code> has the dynamic type <code class="prettyprint">T</code>, and a dynamic type check using the <code class="prettyprint">is</code> operator can simply reference type <code class="prettyprint">T</code>. For example,
<code class="prettyprint">csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write(&quot;Box contains an int&quot;);
}
</code>
will output the string &ldquo;<code class="prettyprint">Box contains an int</code>&rdquo; on the console.</p>

<p>A boxing conversion implies making a copy of the value being boxed. This is different from a conversion of a <em>reference_type</em> to type <code class="prettyprint">object</code>, in which the value continues to reference the same instance and simply is regarded as the less derived type <code class="prettyprint">object</code>. For example, given the declaration
&ldquo;`csharp
struct Point
{
    public int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
<code class="prettyprint">
the following statements
</code>csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
&rdquo;<code class="prettyprint">
will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of</code>p<code class="prettyprint">to</code>box<code class="prettyprint">causes the value of</code>p<code class="prettyprint">to be copied. Had</code>Point<code class="prettyprint">been declared a</code>class<code class="prettyprint">instead, the value 20 would be output because</code>p<code class="prettyprint">and</code>box` would reference the same instance.</p>

<h3 id="unboxing-conversions">Unboxing conversions</h3>

<p>An unboxing conversion permits a <em>reference_type</em> to be explicitly converted to a <em>value_type</em>. The following unboxing conversions exist:</p>

<ul>
<li> From the type <code class="prettyprint">object</code> to any <em>value_type</em>.</li>
<li> From the type <code class="prettyprint">System.ValueType</code> to any <em>value_type</em>.</li>
<li> From any <em>interface_type</em> to any <em>non_nullable_value_type</em> that implements the <em>interface_type</em>.</li>
<li> From any <em>interface_type</em> to any <em>nullable_type</em> whose underlying type implements the <em>interface_type</em>.</li>
<li> From the type <code class="prettyprint">System.Enum</code> to any <em>enum_type</em>.</li>
<li> From the type <code class="prettyprint">System.Enum</code> to any <em>nullable_type</em> with an underlying <em>enum_type</em>.</li>
<li> Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type (<a href="conversions.md#explicit-dynamic-conversions">Explicit dynamic conversions</a>).</li>
</ul>

<p>An unboxing operation to a <em>non_nullable_value_type</em> consists of first checking that the object instance is a boxed value of the given <em>non_nullable_value_type</em>, and then copying the value out of the instance.</p>

<p>Unboxing to a <em>nullable_type</em> produces the null value of the <em>nullable_type</em> if the source operand is <code class="prettyprint">null</code>, or the wrapped result of unboxing the object instance to the underlying type of the <em>nullable_type</em> otherwise.</p>

<p>Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object <code class="prettyprint">box</code> to a <em>value_type</em> <code class="prettyprint">T</code> consists of executing the expression <code class="prettyprint">((Box&lt;T&gt;)box).value</code>. Thus, the statements
<code class="prettyprint">csharp
object box = 123;
int i = (int)box;
</code>
conceptually correspond to
<code class="prettyprint">csharp
object box = new Box&lt;int&gt;(123);
int i = ((Box&lt;int&gt;)box).value;
</code></p>

<p>For an unboxing conversion to a given <em>non_nullable_value_type</em> to succeed at run-time, the value of the source operand must be a reference to a boxed value of that <em>non_nullable_value_type</em>. If the source operand is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown. If the source operand is a reference to an incompatible object, a <code class="prettyprint">System.InvalidCastException</code> is thrown.</p>

<p>For an unboxing conversion to a given <em>nullable_type</em> to succeed at run-time, the value of the source operand must be either <code class="prettyprint">null</code> or a reference to a boxed value of the underlying <em>non_nullable_value_type</em> of the <em>nullable_type</em>. If the source operand is a reference to an incompatible object, a <code class="prettyprint">System.InvalidCastException</code> is thrown.</p>

<h2 id="constructed-types">Constructed types</h2>

<p>A generic type declaration, by itself, denotes an <strong><em>unbound generic type</em></strong> that is used as a &ldquo;blueprint&rdquo; to form many different types, by way of applying <strong><em>type arguments</em></strong>. The type arguments are written within angle brackets (<code class="prettyprint">&lt;</code> and <code class="prettyprint">&gt;</code>) immediately following the name of the generic type. A type that includes at least one type argument is called a <strong><em>constructed type</em></strong>. A constructed type can be used in most places in the language in which a type name can appear. An unbound generic type can only be used within a <em>typeof_expression</em> (<a href="expressions.md#the-typeof-operator">The typeof operator</a>).</p>

<p>Constructed types can also be used in expressions as simple names (<a href="expressions.md#simple-names">Simple names</a>) or when accessing a member (<a href="expressions.md#member-access">Member access</a>).</p>

<p>When a <em>namespace_or_type_name</em> is evaluated, only generic types with the correct number of type parameters are considered. Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters. This is useful when mixing generic and non-generic classes in the same program:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">Widgets</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Queue</span> <span class="p">{...}</span>
    <span class="k">class</span> <span class="nc">Queue</span><span class="p">&lt;</span><span class="n">TElement</span><span class="p">&gt;</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">MyApplication</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">Widgets</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">X</span>
    <span class="p">{</span>
        <span class="n">Queue</span> <span class="n">q1</span><span class="p">;</span>            <span class="c1">// Non-generic Widgets.Queue</span>
        <span class="n">Queue</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">q2</span><span class="p">;</span>       <span class="c1">// Generic Widgets.Queue</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <em>type_name</em> might identify a constructed type even though it doesn&rsquo;t specify type parameters directly. This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup (<a href="classes.md#nested-types-in-generic-classes">Nested types in generic classes</a>):</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Outer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Inner</span> <span class="p">{...}</span>

    <span class="k">public</span> <span class="n">Inner</span> <span class="n">i</span><span class="p">;</span>                <span class="c1">// Type of i is Outer&lt;T&gt;.Inner</span>
<span class="p">}</span>
</code></pre>
<p>In unsafe code, a constructed type cannot be used as an <em>unmanaged_type</em> (<a href="unsafe-code.md#pointer-types">Pointer types</a>).</p>

<h3 id="type-arguments">Type arguments</h3>

<p>Each argument in a type argument list is simply a <em>type</em>.</p>
<pre class="highlight plaintext"><code>type_argument_list
    : '&lt;' type_arguments '&gt;'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
</code></pre>
<p>In unsafe code (<a href="unsafe-code.md#unsafe-code">Unsafe code</a>), a <em>type_argument</em> may not be a pointer type. Each type argument must satisfy any constraints on the corresponding type parameter (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</p>

<h3 id="open-and-closed-types">Open and closed types</h3>

<p>All types can be classified as either <strong><em>open types</em></strong> or <strong><em>closed types</em></strong>. An open type is a type that involves type parameters. More specifically:</p>

<ul>
<li> A type parameter defines an open type.</li>
<li> An array type is an open type if and only if its element type is an open type.</li>
<li> A constructed type is an open type if and only if one or more of its type arguments is an open type. A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</li>
</ul>

<p>A closed type is a type that is not an open type.</p>

<p>At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration. Each type parameter within the generic type is bound to a particular run-time type. The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</p>

<p>Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types. Since an open type does not exist at run-time, there are no static variables associated with an open type. Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</p>

<h3 id="bound-and-unbound-types">Bound and unbound types</h3>

<p>The term <strong><em>unbound type</em></strong> refers to a non-generic type or an unbound generic type. The term <strong><em>bound type</em></strong> refers to a non-generic type or a constructed type.</p>

<p>An unbound type refers to the entity declared by a type declaration. An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type. The only construct in which an unbound generic type can be referenced is the <code class="prettyprint">typeof</code> expression (<a href="expressions.md#the-typeof-operator">The typeof operator</a>).</p>

<h3 id="satisfying-constraints">Satisfying constraints</h3>

<p>Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For each <code class="prettyprint">where</code> clause, the type argument <code class="prettyprint">A</code> that corresponds to the named type parameter is checked against each constraint as follows:</p>

<ul>
<li> If the constraint is a class type, an interface type, or a type parameter, let <code class="prettyprint">C</code> represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint. To satisfy the constraint, it must be the case that type <code class="prettyprint">A</code> is convertible to type <code class="prettyprint">C</code> by one of the following:

<ul>
<li>An identity conversion (<a href="conversions.md#identity-conversion">Identity conversion</a>)</li>
<li>An implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>)</li>
<li>A boxing conversion (<a href="conversions.md#boxing-conversions">Boxing conversions</a>), provided that type A is a non-nullable value type.</li>
<li>An implicit reference, boxing or type parameter conversion from a type parameter <code class="prettyprint">A</code> to <code class="prettyprint">C</code>.</li>
</ul></li>
<li> If the constraint is the reference type constraint (<code class="prettyprint">class</code>), the type <code class="prettyprint">A</code> must satisfy one of the following:

<ul>
<li><code class="prettyprint">A</code> is an interface type, class type, delegate type or array type. Note that <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">System.Enum</code> are reference types that satisfy this constraint.</li>
<li><code class="prettyprint">A</code> is a type parameter that is known to be a reference type (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
</ul></li>
<li> If the constraint is the value type constraint (<code class="prettyprint">struct</code>), the type <code class="prettyprint">A</code> must satisfy one of the following:

<ul>
<li><code class="prettyprint">A</code> is a struct type or enum type, but not a nullable type. Note that <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">System.Enum</code> are reference types that do not satisfy this constraint.</li>
<li><code class="prettyprint">A</code> is a type parameter having the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
</ul></li>
<li> If the constraint is the constructor constraint <code class="prettyprint">new()</code>, the type <code class="prettyprint">A</code> must not be <code class="prettyprint">abstract</code> and must have a public parameterless constructor. This is satisfied if one of the following is true:

<ul>
<li><code class="prettyprint">A</code> is a value type, since all value types have a public default constructor (<a href="types.md#default-constructors">Default constructors</a>).</li>
<li><code class="prettyprint">A</code> is a type parameter having the constructor constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li><code class="prettyprint">A</code> is a type parameter having the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li><code class="prettyprint">A</code> is a class that is not <code class="prettyprint">abstract</code> and contains an explicitly declared <code class="prettyprint">public</code> constructor with no parameters.</li>
<li><code class="prettyprint">A</code> is not <code class="prettyprint">abstract</code> and has a default constructor (<a href="classes.md#default-constructors">Default constructors</a>).</li>
</ul></li>
</ul>

<p>A compile-time error occurs if one or more of a type parameter&rsquo;s constraints are not satisfied by the given type arguments.</p>

<p>Since type parameters are not inherited, constraints are never inherited either. In the example below, <code class="prettyprint">D</code> needs to specify the constraint on its type parameter <code class="prettyprint">T</code> so that <code class="prettyprint">T</code> satisfies the constraint imposed by the base class <code class="prettyprint">B&lt;T&gt;</code>. In contrast, class <code class="prettyprint">E</code> need not specify a constraint, because <code class="prettyprint">List&lt;T&gt;</code> implements <code class="prettyprint">IEnumerable</code> for any <code class="prettyprint">T</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IEnumerable</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IEnumerable</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">E</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="p">{...}</span>
</code></pre>
<h2 id="type-parameters">Type parameters</h2>

<p>A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</p>
<pre class="highlight plaintext"><code>type_parameter
    : identifier
    ;
</code></pre>
<p>Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types. These include:</p>

<ul>
<li> A type parameter cannot be used directly to declare a base class (<a href="classes.md#base-class">Base class</a>) or interface (<a href="interfaces.md#variant-type-parameter-lists">Variant type parameter lists</a>).</li>
<li> The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter. They are detailed in <a href="expressions.md#member-lookup">Member lookup</a>.</li>
<li> The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter. They are detailed in <a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a> and <a href="conversions.md#explicit-dynamic-conversions">Explicit dynamic conversions</a>.</li>
<li> The literal <code class="prettyprint">null</code> cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type (<a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a>). However, a <code class="prettyprint">default</code> expression (<a href="expressions.md#default-value-expressions">Default value expressions</a>) can be used instead. In addition, a value with a type given by a type parameter can be compared with <code class="prettyprint">null</code> using <code class="prettyprint">==</code> and <code class="prettyprint">!=</code> (<a href="expressions.md#reference-type-equality-operators">Reference type equality operators</a>) unless the type parameter has the value type constraint.</li>
<li> A <code class="prettyprint">new</code> expression (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>) can only be used with a type parameter if the type parameter is constrained by a <em>constructor_constraint</em> or the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li> A type parameter cannot be used anywhere within an attribute.</li>
<li> A type parameter cannot be used in a member access (<a href="expressions.md#member-access">Member access</a>) or type name (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) to identify a static member or a nested type.</li>
<li> In unsafe code, a type parameter cannot be used as an <em>unmanaged_type</em> (<a href="unsafe-code.md#pointer-types">Pointer types</a>).</li>
</ul>

<p>As a type, type parameters are purely a compile-time construct. At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration. Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type (<a href="types.md#open-and-closed-types">Open and closed types</a>). The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</p>

<h2 id="expression-tree-types">Expression tree types</h2>

<p><strong><em>Expression trees</em></strong> permit lambda expressions to be represented as data structures instead of executable code. Expression trees are values of <strong><em>expression tree types</em></strong> of the form <code class="prettyprint">System.Linq.Expressions.Expression&lt;D&gt;</code>, where <code class="prettyprint">D</code> is any delegate type. For the remainder of this specification we will refer to these types using the shorthand <code class="prettyprint">Expression&lt;D&gt;</code>.</p>

<p>If a conversion exists from a lambda expression to a delegate type <code class="prettyprint">D</code>, a conversion also exists to the expression tree type <code class="prettyprint">Expression&lt;D&gt;</code>. Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</p>

<p>Expression trees are efficient in-memory data representations of lambda expressionsand make the structure of the lambda expressiontransparent and explicit.</p>

<p>Just like a delegate type <code class="prettyprint">D</code>, <code class="prettyprint">Expression&lt;D&gt;</code> is said to have parameter and return types, which are the same as those of <code class="prettyprint">D</code>.</p>

<p>The following example represents a lambda expressionboth as executable code and as an expression tree. Because a conversion exists to <code class="prettyprint">Func&lt;int,int&gt;</code>, a conversion also exists to <code class="prettyprint">Expression&lt;Func&lt;int,int&gt;&gt;</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">del</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>                    <span class="c1">// Code</span>

<span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="n">exp</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>        <span class="c1">// Data</span>
</code></pre>
<p>Following these assignments, the delegate <code class="prettyprint">del</code> references a method that returns <code class="prettyprint">x + 1</code>, and the expression tree <code class="prettyprint">exp</code> references a data structure that describes the expression <code class="prettyprint">x =&gt; x + 1</code>.</p>

<p>The exact definition of the generic type <code class="prettyprint">Expression&lt;D&gt;</code> as well as the precise rules for constructing an expression tree when a lambda expressionis converted to an expression tree type, are both outside the scope of this specification.</p>

<p>Two things are important to make explicit:</p>

<ul>
<li> Not all lambda expressions can be converted to expression trees. For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented. In these cases, a conversion still exists, but will fail at compile-time. These exceptions are detailed in <a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>.</li>
<li><p><code class="prettyprint">Expression&lt;D&gt;</code> offers an instance method <code class="prettyprint">Compile</code> which produces a delegate of type <code class="prettyprint">D</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">del2</span> <span class="p">=</span> <span class="n">exp</span><span class="p">.</span><span class="nf">Compile</span><span class="p">();</span>
</code></pre>
<p>Invoking this delegate causes the code represented by the expression tree to be executed. Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">i1</span> <span class="p">=</span> <span class="nf">del</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">i2</span> <span class="p">=</span> <span class="nf">del2</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</code></pre>
<p>After executing this code,  <code class="prettyprint">i1</code> and <code class="prettyprint">i2</code> will both have the value <code class="prettyprint">2</code>.</p></li>
</ul>

          <h1 id="variables">Variables</h1>

<p>Variables represent storage locations. Every variable has a type that determines what values can be stored in the variable. C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type. The value of a variable can be changed through assignment or through use of the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators.</p>

<p>A variable must be <strong><em>definitely assigned</em></strong> (<a href="variables.md#definite-assignment">Definite assignment</a>) before its value can be obtained.</p>

<p>As described in the following sections, variables are either <strong><em>initially assigned</em></strong> or <strong><em>initially unassigned</em></strong>. An initially assigned variable has a well-defined initial value and is always considered definitely assigned. An initially unassigned variable has no initial value. For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</p>

<h2 id="variable-categories">Variable categories</h2>

<p>C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables. The sections that follow describe each of these categories.</p>

<p>In the example
&ldquo;`csharp
class A
{
public static int x;
int y;</p>

<p>void F(int[] v, int a, ref int b, out int c) {
int i = 1;
c = a + b++;
}
}
&rdquo;<code class="prettyprint">
</code>x<code class="prettyprint">is a static variable,</code>y<code class="prettyprint">is an instance variable,</code>v[0]<code class="prettyprint">is an array element,</code>a<code class="prettyprint">is a value parameter,</code>b<code class="prettyprint">is a reference parameter,</code>c<code class="prettyprint">is an output parameter, and</code>i` is a local variable.</p>

<h3 id="static-variables">Static variables</h3>

<p>A field declared with the <code class="prettyprint">static</code> modifier is called a <strong><em>static variable</em></strong>. A static variable comes into existence before execution of the static constructor (<a href="classes.md#static-constructors">Static constructors</a>) for its containing type, and ceases to exist when the associated application domain ceases to exist.</p>

<p>The initial value of a static variable is the default value (<a href="variables.md#default-values">Default values</a>) of the variable&rsquo;s type.</p>

<p>For purposes of definite assignment checking, a static variable is considered initially assigned.</p>

<h3 id="instance-variables">Instance variables</h3>

<p>A field declared without the <code class="prettyprint">static</code> modifier is called an <strong><em>instance variable</em></strong>.</p>

<h4 id="instance-variables-in-classes">Instance variables in classes</h4>

<p>An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance&rsquo;s destructor (if any) has executed.</p>

<p>The initial value of an instance variable of a class is the default value (<a href="variables.md#default-values">Default values</a>) of the variable&rsquo;s type.</p>

<p>For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</p>

<h4 id="instance-variables-in-structs">Instance variables in structs</h4>

<p>An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs. In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</p>

<p>The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable. In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</p>

<h3 id="array-elements">Array elements</h3>

<p>The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</p>

<p>The initial value of each of the elements of an array is the default value (<a href="variables.md#default-values">Default values</a>) of the type of the array elements.</p>

<p>For the purpose of definite assignment checking, an array element is considered initially assigned.</p>

<h3 id="value-parameters">Value parameters</h3>

<p>A parameter declared without a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> modifier is a <strong><em>value parameter</em></strong>.</p>

<p>A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation. A value parameter normally ceases to exist upon return of the function member or anonymous function. However, if the value parameter is captured by an anonymous function (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</p>

<p>For the purpose of definite assignment checking, a value parameter is considered initially assigned.</p>

<h3 id="reference-parameters">Reference parameters</h3>

<p>A parameter declared with a <code class="prettyprint">ref</code> modifier is a <strong><em>reference parameter</em></strong>.</p>

<p>A reference parameter does not create a new storage location. Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation. Thus, the value of a reference parameter is always the same as the underlying variable.</p>

<p>The following definite assignment rules apply to reference parameters. Note the different rules for output parameters described in <a href="variables.md#output-parameters">Output parameters</a>.</p>

<ul>
<li> A variable must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before it can be passed as a reference parameter in a function member or delegate invocation.</li>
<li> Within a function member or anonymous function, a reference parameter is considered initially assigned.</li>
</ul>

<p>Within an instance method or instance accessor of a struct type, the <code class="prettyprint">this</code> keyword behaves exactly as a reference parameter of the struct type (<a href="expressions.md#this-access">This access</a>).</p>

<h3 id="output-parameters">Output parameters</h3>

<p>A parameter declared with an <code class="prettyprint">out</code> modifier is an <strong><em>output parameter</em></strong>.</p>

<p>An output parameter does not create a new storage location. Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation. Thus, the value of an output parameter is always the same as the underlying variable.</p>

<p>The following definite assignment rules apply to output parameters. Note the different rules for reference parameters described in <a href="variables.md#reference-parameters">Reference parameters</a>.</p>

<ul>
<li> A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</li>
<li> Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</li>
<li> Within a function member or anonymous function, an output parameter is considered initially unassigned.</li>
<li> Every output parameter of a function member or anonymous function must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before the function member or anonymous function returns normally.</li>
</ul>

<p>Within an instance constructor of a struct type, the <code class="prettyprint">this</code> keyword behaves exactly as an output parameter of the struct type (<a href="expressions.md#this-access">This access</a>).</p>

<h3 id="local-variables">Local variables</h3>

<p>A <strong><em>local variable</em></strong> is declared by a <em>local_variable_declaration</em>, which may occur in a <em>block</em>, a <em>for_statement</em>, a <em>switch_statement</em> or a <em>using_statement</em>; or by a <em>foreach_statement</em> or a <em>specific_catch_clause</em> for a <em>try_statement</em>.</p>

<p>The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it. This lifetime extends at least from entry into the <em>block</em>, <em>for_statement</em>, <em>switch_statement</em>, <em>using_statement</em>, <em>foreach_statement</em>, or <em>specific_catch_clause</em> with which it is associated, until execution of that <em>block</em>, <em>for_statement</em>, <em>switch_statement</em>, <em>using_statement</em>, <em>foreach_statement</em>, or <em>specific_catch_clause</em> ends in any way. (Entering an enclosed <em>block</em> or calling a method suspends, but does not end, execution of the current <em>block</em>, <em>for_statement</em>, <em>switch_statement</em>, <em>using_statement</em>, <em>foreach_statement</em>, or <em>specific_catch_clause</em>.) If the local variable is captured by an anonymous function (<a href="expressions.md#captured-outer-variables">Captured outer variables</a>), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</p>

<p>If the parent <em>block</em>, <em>for_statement</em>, <em>switch_statement</em>, <em>using_statement</em>, <em>foreach_statement</em>, or <em>specific_catch_clause</em> is entered recursively, a new instance of the local variable is created each time, and its <em>local_variable_initializer</em>, if any, is evaluated each time.</p>

<p>A local variable introduced by a <em>local_variable_declaration</em> is not automatically initialized and thus has no default value. For the purpose of definite assignment checking, a local variable introduced by a <em>local_variable_declaration</em> is considered initially unassigned. A <em>local_variable_declaration</em> may include a <em>local_variable_initializer</em>, in which case the variable is considered definitely assigned only after the initializing expression (<a href="variables.md#declaration-statements">Declaration statements</a>).</p>

<p>Within the scope of a local variableintroduced by a <em>local_variable_declaration</em>, it is a compile-time error to refer to that local variable in a textual position that precedes its <em>local_variable_declarator</em>. If the local variable declaration is implicit (<a href="statements.md#local-variable-declarations">Local variable declarations</a>), it is also an error to refer to the variable within its <em>local_variable_declarator</em>.</p>

<p>A local variable introduced by a <em>foreach_statement</em> or a <em>specific_catch_clause</em> is considered definitely assigned in its entire scope.</p>

<p>The actual lifetime of a local variable is implementation-dependent. For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block. Using this analysis, the compiler could generate code that results in the variable&rsquo;s storage having a shorter lifetime than its containing block.</p>

<p>The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable (<a href="basic-concepts.md#automatic-memory-management">Automatic memory management</a>).</p>

<h2 id="default-values">Default values</h2>

<p>The following categories of variables are automatically initialized to their default values:</p>

<ul>
<li> Static variables.</li>
<li> Instance variables of class instances.</li>
<li> Array elements.</li>
</ul>

<p>The default value of a variable depends on the type of the variable and is determined as follows:</p>

<ul>
<li> For a variable of a <em>value_type</em>, the default value is the same as the value computed by the <em>value_type</em>&lsquo;s default constructor (<a href="types.md#default-constructors">Default constructors</a>).</li>
<li> For a variable of a <em>reference_type</em>, the default value is <code class="prettyprint">null</code>.</li>
</ul>

<p>Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use. For this reason, it is convenient to use all-bits-zero to represent the null reference.</p>

<h2 id="definite-assignment">Definite assignment</h2>

<p>At a given location in the executable code of a function member, a variable is said to be <strong><em>definitely assigned</em></strong> if the compiler can prove, by a particular static flow analysis (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>), that the variable has been automatically initialized or has been the target of at least one assignment. Informally stated, the rules of definite assignment are:</p>

<ul>
<li> An initially assigned variable (<a href="variables.md#initially-assigned-variables">Initially assigned variables</a>) is always considered definitely assigned.</li>
<li> An initially unassigned variable (<a href="variables.md#initially-unassigned-variables">Initially unassigned variables</a>) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:

<ul>
<li>A simple assignment (<a href="expressions.md#simple-assignment">Simple assignment</a>) in which the variable is the left operand.</li>
<li>An invocation expression (<a href="expressions.md#invocation-expressions">Invocation expressions</a>) or object creation expression (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>) that passes the variable as an output parameter.</li>
<li>For a local variable, a local variable declaration (<a href="statements.md#local-variable-declarations">Local variable declarations</a>) that includes a variable initializer.</li>
</ul></li>
</ul>

<p>The formal specification underlying the above informal rules is described in <a href="variables.md#initially-assigned-variables">Initially assigned variables</a>, <a href="variables.md#initially-unassigned-variables">Initially unassigned variables</a>, and <a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>.</p>

<p>The definite assignment states of instance variables of a <em>struct_type</em> variable are tracked individually as well as collectively. In additional to the rules above, the following rules apply to <em>struct_type</em> variables and their instance variables:</p>

<ul>
<li> An instance variable is considered definitely assigned if its containing <em>struct_type</em> variable is considered definitely assigned.</li>
<li> A <em>struct_type</em> variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</li>
</ul>

<p>Definite assignment is a requirement in the following contexts:</p>

<ul>
<li> A variable must be definitely assigned at each location where its value is obtained. This ensures that undefined values never occur. The occurrence of a variable in an expression is considered to obtain the value of the variable, except when

<ul>
<li>the variable is the left operand of a simple assignment,</li>
<li>the variable is passed as an output parameter, or</li>
<li>the variable is a <em>struct_type</em> variable and occurs as the left operand of a member access.</li>
</ul></li>
<li> A variable must be definitely assigned at each location where it is passed as a reference parameter. This ensures that the function member being invoked can consider the reference parameter initially assigned.</li>
<li> All output parameters of a function member must be definitely assigned at each location where the function member returns (through a <code class="prettyprint">return</code> statement or through execution reaching the end of the function member body). This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</li>
<li> The <code class="prettyprint">this</code> variable of a <em>struct_type</em> instance constructor must be definitely assigned at each location where that instance constructor returns.</li>
</ul>

<h3 id="initially-assigned-variables">Initially assigned variables</h3>

<p>The following categories of variables are classified as initially assigned:</p>

<ul>
<li> Static variables.</li>
<li> Instance variables of class instances.</li>
<li> Instance variables of initially assigned struct variables.</li>
<li> Array elements.</li>
<li> Value parameters.</li>
<li> Reference parameters.</li>
<li> Variables declared in a <code class="prettyprint">catch</code> clause or a <code class="prettyprint">foreach</code> statement.</li>
</ul>

<h3 id="initially-unassigned-variables">Initially unassigned variables</h3>

<p>The following categories of variables are classified as initially unassigned:</p>

<ul>
<li> Instance variables of initially unassigned struct variables.</li>
<li> Output parameters, including the <code class="prettyprint">this</code> variable of struct instance constructors.</li>
<li> Local variables, except those declared in a <code class="prettyprint">catch</code> clause or a <code class="prettyprint">foreach</code> statement.</li>
</ul>

<h3 id="precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</h3>

<p>In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</p>

<p>The compiler processes the body of each function member that has one or more initially unassigned variables. For each initially unassigned variable <em>v</em>, the compiler determines a <strong><em>definite assignment state</em></strong> for <em>v</em> at each of the following points in the function member:</p>

<ul>
<li> At the beginning of each statement</li>
<li> At the end point (<a href="statements.md#end-points-and-reachability">End points and reachability</a>) of each statement</li>
<li> On each arc which transfers control to another statement or to the end point of a statement</li>
<li> At the beginning of each expression</li>
<li> At the end of each expression</li>
</ul>

<p>The definite assignment state of <em>v</em> can be either:</p>

<ul>
<li> Definitely assigned. This indicates that on all possible control flows to this point, <em>v</em> has been assigned a value.</li>
<li> Not definitely assigned. For the state of a variable at the end of an expression of type <code class="prettyprint">bool</code>, the state of a variable that isn&rsquo;t definitely assigned may (but doesn&rsquo;t necessarily) fall into one of the following sub-states:

<ul>
<li>Definitely assigned after true expression. This state indicates that <em>v</em> is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</li>
<li>Definitely assigned after false expression. This state indicates that <em>v</em> is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</li>
</ul></li>
</ul>

<p>The following rules govern how the state of a variable <em>v</em> is determined at each location.</p>

<h4 id="general-rules-for-statements">General rules for statements</h4>

<ul>
<li> <em>v</em> is not definitely assigned at the beginning of a function member body.</li>
<li> <em>v</em> is definitely assigned at the beginning of any unreachable statement.</li>
<li> The definite assignment state of <em>v</em> at the beginning of any other statement is determined by checking the definite assignment state of <em>v</em> on all control flow transfers that target the beginning of that statement. If (and only if) <em>v</em> is definitely assigned on all such control flow transfers, then <em>v</em> is definitely assigned at the beginning of the statement. The set of possible control flow transfers is determined in the same way as for checking statement reachability (<a href="statements.md#end-points-and-reachability">End points and reachability</a>).</li>
<li> The definite assignment state of <em>v</em> at the end point of a block, <code class="prettyprint">checked</code>, <code class="prettyprint">unchecked</code>, <code class="prettyprint">if</code>, <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, <code class="prettyprint">foreach</code>, <code class="prettyprint">lock</code>, <code class="prettyprint">using</code>, or <code class="prettyprint">switch</code> statement is determined by checking the definite assignment state of <em>v</em> on all control flow transfers that target the end point of that statement. If <em>v</em> is definitely assigned on all such control flow transfers, then <em>v</em> is definitely assigned at the end point of the statement. Otherwise; <em>v</em> is not definitely assigned at the end point of the statement. The set of possible control flow transfers is determined in the same way as for checking statement reachability (<a href="statements.md#end-points-and-reachability">End points and reachability</a>).</li>
</ul>

<h4 id="block-statements-checked-and-unchecked-statements">Block statements, checked, and unchecked statements</h4>

<p>The definite assignment state of <em>v</em> on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of <em>v</em> before the block, <code class="prettyprint">checked</code>, or <code class="prettyprint">unchecked</code> statement.</p>

<h4 id="expression-statements">Expression statements</h4>

<p>For an expression statement <em>stmt</em> that consists of the expression <em>expr</em>:</p>

<ul>
<li> <em>v</em> has the same definite assignment state at the beginning of <em>expr</em> as at the beginning of <em>stmt</em>.</li>
<li> If <em>v</em> if definitely assigned at the end of <em>expr</em>, it is definitely assigned at the end point of <em>stmt</em>; otherwise; it is not definitely assigned at the end point of <em>stmt</em>.</li>
</ul>

<h4 id="declaration-statements">Declaration statements</h4>

<ul>
<li> If <em>stmt</em> is a declaration statement without initializers, then <em>v</em> has the same definite assignment state at the end point of <em>stmt</em> as at the beginning of <em>stmt</em>.</li>
<li> If <em>stmt</em> is a declaration statement with initializers, then the definite assignment state for <em>v</em> is determined as if <em>stmt</em> were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</li>
</ul>

<h4 id="if-statements">If statements</h4>

<p>For an <code class="prettyprint">if</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
if ( expr ) then_stmt else else_stmt
</code></p>

<ul>
<li> <em>v</em> has the same definite assignment state at the beginning of <em>expr</em> as at the beginning of <em>stmt</em>.</li>
<li> If <em>v</em> is definitely assigned at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to <em>then_stmt</em> and to either <em>else_stmt</em> or to the end-point of <em>stmt</em> if there is no else clause.</li>
<li> If <em>v</em> has the state &ldquo;definitely assigned after true expression&rdquo; at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to <em>then_stmt</em>, and not definitely assigned on the control flow transfer to either <em>else_stmt</em> or to the end-point of <em>stmt</em> if there is no else clause.</li>
<li> If <em>v</em> has the state &ldquo;definitely assigned after false expression&rdquo; at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to <em>else_stmt</em>, and not definitely assigned on the control flow transfer to <em>then_stmt</em>. It is definitely assigned at the end-point of <em>stmt</em> if and only if it is definitely assigned at the end-point of <em>then_stmt</em>.</li>
<li> Otherwise, <em>v</em> is considered not definitely assigned on the control flow transfer to either the <em>then_stmt</em> or <em>else_stmt</em>, or to the end-point of <em>stmt</em> if there is no else clause.</li>
</ul>

<h4 id="switch-statements">Switch statements</h4>

<p>In a <code class="prettyprint">switch</code> statement <em>stmt</em> with a controlling expression <em>expr</em>:</p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of <em>v</em> at the end of <em>expr</em>.</li>
</ul>

<h4 id="while-statements">While statements</h4>

<p>For a <code class="prettyprint">while</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
while ( expr ) while_body
</code></p>

<ul>
<li> <em>v</em> has the same definite assignment state at the beginning of <em>expr</em> as at the beginning of <em>stmt</em>.</li>
<li> If <em>v</em> is definitely assigned at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to <em>while_body</em> and to the end point of <em>stmt</em>.</li>
<li> If <em>v</em> has the state &ldquo;definitely assigned after true expression&rdquo; at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to <em>while_body</em>, but not definitely assigned at the end-point of <em>stmt</em>.</li>
<li> If <em>v</em> has the state &ldquo;definitely assigned after false expression&rdquo; at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to the end point of <em>stmt</em>, but not definitely assigned on the control flow transfer to <em>while_body</em>.</li>
</ul>

<h4 id="do-statements">Do statements</h4>

<p>For a <code class="prettyprint">do</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
do do_body while ( expr ) ;
</code></p>

<ul>
<li> <em>v</em> has the same definite assignment state on the control flow transfer from the beginning of <em>stmt</em> to <em>do_body</em> as at the beginning of <em>stmt</em>.</li>
<li> <em>v</em> has the same definite assignment state at the beginning of <em>expr</em> as at the end point of <em>do_body</em>.</li>
<li> If <em>v</em> is definitely assigned at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to the end point of <em>stmt</em>.</li>
<li> If <em>v</em> has the state &ldquo;definitely assigned after false expression&rdquo; at the end of <em>expr</em>, then it is definitely assigned on the control flow transfer to the end point of <em>stmt</em>.</li>
</ul>

<h4 id="for-statements">For statements</h4>

<p>Definite assignment checking for a <code class="prettyprint">for</code> statement of the form:
<code class="prettyprint">csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
</code>
is done as if the statement were written:
<code class="prettyprint">csharp
{
for_initializer ;
while ( for_condition ) {
embedded_statement ;
for_iterator ;
}
}
</code></p>

<p>If the <em>for_condition</em> is omitted from the <code class="prettyprint">for</code> statement, then evaluation of definite assignment proceeds as if <em>for_condition</em> were replaced with <code class="prettyprint">true</code> in the above expansion.</p>

<h4 id="break-continue-and-goto-statements">Break, continue, and goto statements</h4>

<p>The definite assignment state of <em>v</em> on the control flow transfer caused by a <code class="prettyprint">break</code>, <code class="prettyprint">continue</code>, or <code class="prettyprint">goto</code> statement is the same as the definite assignment state of <em>v</em> at the beginning of the statement.</p>

<h4 id="throw-statements">Throw statements</h4>

<p>For a statement <em>stmt</em> of the form
<code class="prettyprint">csharp
throw expr ;
</code></p>

<p>The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</p>

<h4 id="return-statements">Return statements</h4>

<p>For a statement <em>stmt</em> of the form
<code class="prettyprint">csharp
return expr ;
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> If <em>v</em> is an output parameter, then it must be definitely assigned either:

<ul>
<li>after <em>expr</em></li>
<li>or at the end of the <code class="prettyprint">finally</code> block of a <code class="prettyprint">try</code>-<code class="prettyprint">finally</code> or <code class="prettyprint">try</code>-<code class="prettyprint">catch</code>-<code class="prettyprint">finally</code> that encloses the <code class="prettyprint">return</code> statement.</li>
</ul></li>
</ul>

<p>For a statement stmt of the form:
<code class="prettyprint">csharp
return ;
</code></p>

<ul>
<li> If <em>v</em> is an output parameter, then it must be definitely assigned either:

<ul>
<li>before <em>stmt</em></li>
<li>or at the end of the <code class="prettyprint">finally</code> block of a <code class="prettyprint">try</code>-<code class="prettyprint">finally</code> or <code class="prettyprint">try</code>-<code class="prettyprint">catch</code>-<code class="prettyprint">finally</code> that encloses the <code class="prettyprint">return</code> statement.</li>
</ul></li>
</ul>

<h4 id="try-catch-statements">Try-catch statements</h4>

<p>For a statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>try_block</em> is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> at the beginning of <em>catch_block_i</em> (for any <em>i</em>) is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> at the end-point of <em>stmt</em> is definitely assigned if (and only if) <em>v</em> is definitely assigned at the end-point of <em>try_block</em> and every <em>catch_block_i</em> (for every <em>i</em> from 1 to <em>n</em>).</li>
</ul>

<h4 id="try-finally-statements">Try-finally statements</h4>

<p>For a <code class="prettyprint">try</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
try try_block finally finally_block
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>try_block</em> is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> at the beginning of <em>finally_block</em> is the same as the definite assignment state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> at the end-point of <em>stmt</em> is definitely assigned if (and only if) at least one of the following is true:

<ul>
<li><em>v</em> is definitely assigned at the end-point of <em>try_block</em></li>
<li><em>v</em> is definitely assigned at the end-point of <em>finally_block</em></li>
</ul></li>
</ul>

<p>If a control flow transfer (for example, a <code class="prettyprint">goto</code> statement) is made that begins within <em>try_block</em>, and ends outside of <em>try_block</em>, then <em>v</em> is also considered definitely assigned on that control flow transfer if <em>v</em> is definitely assigned at the end-point of <em>finally_block</em>. (This is not an only ifâ€”if <em>v</em> is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</p>

<h4 id="try-catch-finally-statements">Try-catch-finally statements</h4>

<p>Definite assignment analysis for a <code class="prettyprint">try</code>-<code class="prettyprint">catch</code>-<code class="prettyprint">finally</code> statement of the form:
<code class="prettyprint">csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
</code>
is done as if the statement were a <code class="prettyprint">try</code>-<code class="prettyprint">finally</code> statement enclosing a <code class="prettyprint">try</code>-<code class="prettyprint">catch</code> statement:
<code class="prettyprint">csharp
try {
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
}
finally finally_block
</code></p>

<p>The following example demonstrates how the different blocks of a <code class="prettyprint">try</code> statement (<a href="statements.md#the-try-statement">The try statement</a>) affect definite assignment.
&ldquo;`csharp
class A
{
static void F() {
int i, j;
try {
goto LABEL;
// neither i nor j definitely assigned
i = 1;
// i definitely assigned
}</p>

<p>catch {
// neither i nor j definitely assigned
i = 3;
// i definitely assigned
}</p>

<p>finally {
// neither i nor j definitely assigned
j = 5;
// j definitely assigned
}
// i and j definitely assigned
LABEL:;
// j definitely assigned</p>

<p>}
}
&rdquo;`</p>

<h4 id="foreach-statements">Foreach statements</h4>

<p>For a <code class="prettyprint">foreach</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
foreach ( type identifier in expr ) embedded_statement
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> on the control flow transfer to <em>embedded_statement</em> or to the end point of <em>stmt</em> is the same as the state of <em>v</em> at the end of <em>expr</em>.</li>
</ul>

<h4 id="using-statements">Using statements</h4>

<p>For a <code class="prettyprint">using</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
using ( resource_acquisition ) embedded_statement
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>resource_acquisition</em> is the same as the state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> on the control flow transfer to <em>embedded_statement</em> is the same as the state of <em>v</em> at the end of <em>resource_acquisition</em>.</li>
</ul>

<h4 id="lock-statements">Lock statements</h4>

<p>For a <code class="prettyprint">lock</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
lock ( expr ) embedded_statement
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> on the control flow transfer to <em>embedded_statement</em> is the same as the state of <em>v</em> at the end of <em>expr</em>.</li>
</ul>

<h4 id="yield-statements">Yield statements</h4>

<p>For a <code class="prettyprint">yield return</code> statement <em>stmt</em> of the form:
<code class="prettyprint">csharp
yield return expr ;
</code></p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>expr</em> is the same as the state of <em>v</em> at the beginning of <em>stmt</em>.</li>
<li> The definite assignment state of <em>v</em> at the end of <em>stmt</em> is the same as the state of <em>v</em> at the end of <em>expr</em>.</li>
<li> A <code class="prettyprint">yield break</code> statement has no effect on the definite assignment state.</li>
</ul>

<h4 id="general-rules-for-simple-expressions">General rules for simple expressions</h4>

<p>The following rule applies to these kinds of expressions: literals (<a href="expressions.md#literals">Literals</a>), simple names (<a href="expressions.md#simple-names">Simple names</a>), member access expressions (<a href="expressions.md#member-access">Member access</a>), non-indexed base access expressions (<a href="expressions.md#base-access">Base access</a>), <code class="prettyprint">typeof</code> expressions (<a href="expressions.md#the-typeof-operator">The typeof operator</a>), default value expressions (<a href="expressions.md#default-value-expressions">Default value expressions</a>) and <code class="prettyprint">nameof</code> expressions (<a href="expressions.md#nameof-expressions">Nameof expressions</a>).</p>

<ul>
<li> The definite assignment state of <em>v</em> at the end of such an expression is the same as the definite assignment state of <em>v</em> at the beginning of the expression.</li>
</ul>

<h4 id="general-rules-for-expressions-with-embedded-expressions">General rules for expressions with embedded expressions</h4>

<p>The following rules apply to these kinds of expressions: parenthesized expressions (<a href="expressions.md#parenthesized-expressions">Parenthesized expressions</a>), element access expressions (<a href="expressions.md#element-access">Element access</a>), base access expressions with indexing (<a href="expressions.md#base-access">Base access</a>), increment and decrement expressions (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>, <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>), cast expressions (<a href="expressions.md#cast-expressions">Cast expressions</a>), unary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">~</code>, <code class="prettyprint">*</code> expressions, binary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;
    &gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&lt;=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&gt;=</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">is</code>, <code class="prettyprint">as</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code> expressions (<a href="expressions.md#arithmetic-operators">Arithmetic operators</a>, <a href="expressions.md#shift-operators">Shift operators</a>, <a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a>, <a href="expressions.md#logical-operators">Logical operators</a>), compound assignment expressions (<a href="expressions.md#compound-assignment">Compound assignment</a>), <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> expressions (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>), plus array and delegate creation expressions (<a href="expressions.md#the-new-operator">The new operator</a>).</p>

<p>Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order. For example, the binary <code class="prettyprint">%</code> operator evaluates the left hand side of the operator, then the right hand side. An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right. For an expression <em>expr</em>, which has sub-expressions <em>e1, e2, &hellip;, eN</em>, evaluated in that order:</p>

<ul>
<li> The definite assignment state of <em>v</em> at the beginning of <em>e1</em> is the same as the definite assignment state at the beginning of <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> at the beginning of <em>ei</em> (<em>i</em> greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</li>
<li> The definite assignment state of <em>v</em> at the end of <em>expr</em> is the same as the definite assignment state at the end of <em>eN</em></li>
</ul>

<h4 id="invocation-expressions-and-object-creation-expressions">Invocation expressions and object creation expressions</h4>

<p>For an invocation expression <em>expr</em> of the form:
<code class="prettyprint">csharp
primary_expression ( arg1 , arg2 , ... , argN )
</code>
or an object creation expression of the form:
<code class="prettyprint">csharp
new type ( arg1 , arg2 , ... , argN )
</code></p>

<ul>
<li> For an invocation expression, the definite assignment state of <em>v</em> before <em>primary_expression</em> is the same as the state of <em>v</em> before <em>expr</em>.</li>
<li> For an invocation expression, the definite assignment state of <em>v</em> before <em>arg1</em> is the same as the state of <em>v</em> after <em>primary_expression</em>.</li>
<li> For an object creation expression, the definite assignment state of <em>v</em> before <em>arg1</em> is the same as the state of <em>v</em> before <em>expr</em>.</li>
<li> For each argument <em>argi</em>, the definite assignment state of <em>v</em> after <em>argi</em> is determined by the normal expression rules, ignoring any <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> modifiers.</li>
<li> For each argument <em>argi</em> for any <em>i</em> greater than one, the definite assignment state of <em>v</em> before <em>argi</em> is the same as the state of <em>v</em> after the previous <em>arg</em>.</li>
<li> If the variable <em>v</em> is passed as an <code class="prettyprint">out</code> argument (i.e., an argument of the form <code class="prettyprint">out v</code>) in any of the arguments, then the state of <em>v</em> after <em>expr</em> is definitely assigned. Otherwise; the state of <em>v</em> after <em>expr</em> is the same as the state of <em>v</em> after <em>argN</em>.</li>
<li> For array initializers (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>), object initializers (<a href="expressions.md#object-initializers">Object initializers</a>), collection initializers (<a href="expressions.md#collection-initializers">Collection initializers</a>) and anonymous object initializers (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</li>
</ul>

<h4 id="simple-assignment-expressions">Simple assignment expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">w = expr_rhs</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_rhs</em> is the same as the definite assignment state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If <em>w</em> is the same variable as <em>v</em>, then the definite assignment state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, if the assignment occurs within the instance constructor of a struct type, if <em>w</em> is a property access designating an automatically implemented property <em>P</em> on the instance being constructed and <em>v</em> is the hidden backing field of <em>P</em>, then the definite assignment state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, the definite assignment state of <em>v</em> after <em>expr</em> is the same as the definite assignment state of <em>v</em> after <em>expr_rhs</em>.</li>
</ul></li>
</ul>

<h4 id="conditional-and-expressions">&amp;&amp; (conditional AND) expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">expr_first &amp;&amp; expr_second</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_first</em> is the same as the definite assignment state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> before <em>expr_second</em> is definitely assigned if the state of <em>v</em> after <em>expr_first</em> is either definitely assigned or &ldquo;definitely assigned after true expression&rdquo;. Otherwise, it is not definitely assigned.</li>
<li> The definite assignment state of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If <em>expr_first</em> is a constant expression with the value <code class="prettyprint">false</code>, then the definite assignment state of <em>v</em> after <em>expr</em> is the same as the definite assignment state of <em>v</em> after <em>expr_first</em>.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_first</em> is definitely assigned, then the state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_second</em> is definitely assigned, and the state of <em>v</em> after <em>expr_first</em> is &ldquo;definitely assigned after false expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_second</em> is definitely assigned or &ldquo;definitely assigned after true expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is &ldquo;definitely assigned after true expression&rdquo;.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_first</em> is &ldquo;definitely assigned after false expression&rdquo;, and the state of <em>v</em> after <em>expr_second</em> is &ldquo;definitely assigned after false expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is &ldquo;definitely assigned after false expression&rdquo;.</li>
<li>Otherwise, the state of <em>v</em> after <em>expr</em> is not definitely assigned.</li>
</ul></li>
</ul>

<p>In the example
<code class="prettyprint">csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x &gt;= 0 &amp;&amp; (i = y) &gt;= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
</code>
the variable <code class="prettyprint">i</code> is considered definitely assigned in one of the embedded statements of an <code class="prettyprint">if</code> statement but not in the other. In the <code class="prettyprint">if</code> statement in method <code class="prettyprint">F</code>, the variable <code class="prettyprint">i</code> is definitely assigned in the first embedded statement because execution of the expression <code class="prettyprint">(i = y)</code> always precedes execution of this embedded statement. In contrast, the variable <code class="prettyprint">i</code> is not definitely assigned in the second embedded statement, since <code class="prettyprint">x &gt;= 0</code> might have tested false, resulting in the variable <code class="prettyprint">i</code> being unassigned.</p>

<h4 id="conditional-or-expressions">|| (conditional OR) expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">expr_first || expr_second</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_first</em> is the same as the definite assignment state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> before <em>expr_second</em> is definitely assigned if the state of <em>v</em> after <em>expr_first</em> is either definitely assigned or &ldquo;definitely assigned after false expression&rdquo;. Otherwise, it is not definitely assigned.</li>
<li> The definite assignment statement of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If <em>expr_first</em> is a constant expression with the value <code class="prettyprint">true</code>, then the definite assignment state of <em>v</em> after <em>expr</em> is the same as the definite assignment state of <em>v</em> after <em>expr_first</em>.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_first</em> is definitely assigned, then the state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_second</em> is definitely assigned, and the state of <em>v</em> after <em>expr_first</em> is &ldquo;definitely assigned after true expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_second</em> is definitely assigned or &ldquo;definitely assigned after false expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is &ldquo;definitely assigned after false expression&rdquo;.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_first</em> is &ldquo;definitely assigned after true expression&rdquo;, and the state of <em>v</em> after <em>expr_second</em> is &ldquo;definitely assigned after true expression&rdquo;, then the state of <em>v</em> after <em>expr</em> is &ldquo;definitely assigned after true expression&rdquo;.</li>
<li>Otherwise, the state of <em>v</em> after <em>expr</em> is not definitely assigned.</li>
</ul></li>
</ul>

<p>In the example
<code class="prettyprint">csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x &gt;= 0 || (i = y) &gt;= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
</code>
the variable <code class="prettyprint">i</code> is considered definitely assigned in one of the embedded statements of an <code class="prettyprint">if</code> statement but not in the other. In the <code class="prettyprint">if</code> statement in method <code class="prettyprint">G</code>, the variable <code class="prettyprint">i</code> is definitely assigned in the second embedded statement because execution of the expression <code class="prettyprint">(i = y)</code> always precedes execution of this embedded statement. In contrast, the variable <code class="prettyprint">i</code> is not definitely assigned in the first embedded statement, since <code class="prettyprint">x &gt;= 0</code> might have tested true, resulting in the variable <code class="prettyprint">i</code> being unassigned.</p>

<h4 id="logical-negation-expressions">! (logical negation) expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">! expr_operand</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_operand</em> is the same as the definite assignment state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If the state of <em>v</em> after <em>expr_operand *is definitely assigned, then the state of *v</em> after <em>expr</em> is definitely assigned.</li>
<li>If the state of <em>v</em> after <em>expr_operand *is not definitely assigned, then the state of *v</em> after <em>expr</em> is not definitely assigned.</li>
<li>If the state of <em>v</em> after <em>expr_operand *is &ldquo;definitely assigned after false expression&rdquo;, then the state of *v</em> after <em>expr</em> is &ldquo;definitely assigned after true expression&rdquo;.</li>
<li>If the state of <em>v</em> after <em>expr_operand *is &ldquo;definitely assigned after true expression&rdquo;, then the state of *v</em> after <em>expr</em> is &ldquo;definitely assigned after false expression&rdquo;.</li>
</ul></li>
</ul>

<h4 id="null-coalescing-expressions">?? (null coalescing) expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">expr_first ?? expr_second</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_first</em> is the same as the definite assignment state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> before <em>expr_second</em> is the same as the definite assignment state of <em>v</em> after <em>expr_first</em>.</li>
<li> The definite assignment statement of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If <em>expr_first</em> is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>) with value null, then the the state of <em>v</em> after <em>expr</em> is the same as the state of <em>v</em> after <em>expr_second</em>.</li>
</ul></li>
<li> Otherwise, the state of <em>v</em> after <em>expr</em> is the same as the definite assignment state of <em>v</em> after <em>expr_first</em>.</li>
</ul>

<h4 id="conditional-expressions">?: (conditional) expressions</h4>

<p>For an expression <em>expr</em> of the form <code class="prettyprint">expr_cond ? expr_true : expr_false</code>:</p>

<ul>
<li> The definite assignment state of <em>v</em> before <em>expr_cond</em> is the same as the state of <em>v</em> before <em>expr</em>.</li>
<li> The definite assignment state of <em>v</em> before <em>expr_true</em> is definitely assigned if and only if one of the following holds:

<ul>
<li><em>expr_cond</em> is a constant expression with the value <code class="prettyprint">false</code></li>
<li>the state of <em>v</em> after <em>expr_cond</em> is definitely assigned or &ldquo;definitely assigned after true expression&rdquo;.</li>
</ul></li>
<li> The definite assignment state of <em>v</em> before <em>expr_false</em> is definitely assigned if and only if one of the following holds:

<ul>
<li><em>expr_cond</em> is a constant expression with the value <code class="prettyprint">true</code></li>
</ul></li>
<li> the state of <em>v</em> after <em>expr_cond</em> is definitely assigned or &ldquo;definitely assigned after false expression&rdquo;.</li>
<li> The definite assignment state of <em>v</em> after <em>expr</em> is determined by:

<ul>
<li>If <em>expr_cond</em> is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>) with value <code class="prettyprint">true</code> then the state of <em>v</em> after <em>expr</em> is the same as the state of <em>v</em> after <em>expr_true</em>.</li>
<li>Otherwise, if <em>expr_cond</em> is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>) with value <code class="prettyprint">false</code> then the state of <em>v</em> after <em>expr</em> is the same as the state of <em>v</em> after <em>expr_false</em>.</li>
<li>Otherwise, if the state of <em>v</em> after <em>expr_true</em> is definitely assigned and the state of <em>v</em> after <em>expr_false</em> is definitely assigned, then the state of <em>v</em> after <em>expr</em> is definitely assigned.</li>
<li>Otherwise, the state of <em>v</em> after <em>expr</em> is not definitely assigned.</li>
</ul></li>
</ul>

<h4 id="anonymous-functions">Anonymous functions</h4>

<p>For a <em>lambda_expression</em> or <em>anonymous_method_expression</em> <em>expr</em> with a body (either <em>block</em> or <em>expression</em>) <em>body</em>:</p>

<ul>
<li> The definite assignment state of an outer variable <em>v</em> before <em>body</em> is the same as the state of <em>v</em> before <em>expr</em>. That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</li>
<li> The definite assignment state of an outer variable <em>v</em> after <em>expr</em> is the same as the state of <em>v</em> before <em>expr</em>.</li>
</ul>

<p>The example
&ldquo;`csharp
delegate bool Filter(int i);</p>

<p>void F() {
    int max;</p>

<p>// Error, max is not definitely assigned
    Filter f = (int n) =&gt; n &lt; max;</p>

<p>max = 5;
    DoWork(f);
}
<code class="prettyprint">
generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared. The example
</code>csharp
delegate void D();</p>

<p>void F() {
    int n;
    D d = () =&gt; { n = 1; };</p>

<p>d();</p>

<p>// Error, n is not definitely assigned
    Console.WriteLine(n);
}
&rdquo;<code class="prettyprint">
also generates a compile-time error since the assignment to</code>n<code class="prettyprint">in the anonymous function has no affect on the definite assignment state of</code>n` outside the anonymous function.</p>

<h2 id="variable-references">Variable references</h2>

<p>A <em>variable_reference</em> is an <em>expression</em> that is classified as a variable. A <em>variable_reference</em> denotes a storage location that can be accessed both to fetch the current value and to store a new value.</p>
<pre class="highlight plaintext"><code>variable_reference
    : expression
    ;
</code></pre>
<p>In C and C++, a <em>variable_reference</em> is known as an <em>lvalue</em>.</p>

<h2 id="atomicity-of-variable-references">Atomicity of variable references</h2>

<p>Reads and writes of the following data types are atomic: <code class="prettyprint">bool</code>, <code class="prettyprint">char</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">int</code>, <code class="prettyprint">float</code>, and reference types. In addition, reads and writes of enum types with an underlying type in the previous list are also atomic. Reads and writes of other types, including <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">double</code>, and <code class="prettyprint">decimal</code>, as well as user-defined types, are not guaranteed to be atomic. Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</p>

          <h1 id="conversions">Conversions</h1>

<p>A <strong><em>conversion</em></strong> enables an expression to be treated as being of a particular type. A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type. Conversions can be <strong><em>implicit</em></strong> or <strong><em>explicit</em></strong>, and this determines whether an explicit cast is required. For instance, the conversion from type <code class="prettyprint">int</code> to type <code class="prettyprint">long</code> is implicit, so expressions of type <code class="prettyprint">int</code> can implicitly be treated as type <code class="prettyprint">long</code>. The opposite conversion, from type <code class="prettyprint">long</code> to type <code class="prettyprint">int</code>, is explicit and so an explicit cast is required.</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">123</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">b</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>         <span class="c1">// implicit conversion from int to long</span>
<span class="kt">int</span> <span class="n">c</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// explicit conversion from long to int</span>
</code></pre>
<p>Some conversions are defined by the language. Programs may also define their own conversions (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>).</p>

<h2 id="implicit-conversions">Implicit conversions</h2>

<p>The following conversions are classified as implicit conversions:</p>

<ul>
<li> Identity conversions</li>
<li> Implicit numeric conversions</li>
<li> Implicit enumeration conversions.</li>
<li> Implicit nullable conversions</li>
<li> Null literal conversions</li>
<li> Implicit reference conversions</li>
<li> Boxing conversions</li>
<li> Implicit dynamic conversions</li>
<li> Implicit constant expression conversions</li>
<li> User-defined implicit conversions</li>
<li> Anonymous function conversions</li>
<li> Method group conversions</li>
</ul>

<p>Implicit conversions can occur in a variety of situations, including function member invocations (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>), cast expressions (<a href="expressions.md#cast-expressions">Cast expressions</a>), and assignments (<a href="expressions.md#assignment-operators">Assignment operators</a>).</p>

<p>The pre-defined implicit conversions always succeed and never cause exceptions to be thrown. Properly designed user-defined implicit conversions should exhibit these characteristics as well.</p>

<p>For the purposes of conversion, the types <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code> are considered equivalent.</p>

<p>However, dynamic conversions (<a href="conversions.md#implicit-dynamic-conversions">Implicit dynamic conversions</a> and <a href="conversions.md#explicit-dynamic-conversions">Explicit dynamic conversions</a>) apply only to expressions of type <code class="prettyprint">dynamic</code> (<a href="types.md#the-dynamic-type">The dynamic type</a>).</p>

<h3 id="identity-conversion">Identity conversion</h3>

<p>An identity conversion converts from any type to the same type. This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</p>

<ul>
<li> Because object and dynamic are considered equivalent there is an identity conversion between <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>, and between constructed types that are the same when replacing all occurences of <code class="prettyprint">dynamic</code> with <code class="prettyprint">object</code>.</li>
</ul>

<h3 id="implicit-numeric-conversions">Implicit numeric conversions</h3>

<p>The implicit numeric conversions are:</p>

<ul>
<li> From <code class="prettyprint">sbyte</code> to <code class="prettyprint">short</code>, <code class="prettyprint">int</code>, <code class="prettyprint">long</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">byte</code> to <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">short</code> to <code class="prettyprint">int</code>, <code class="prettyprint">long</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">ushort</code> to <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">int</code> to <code class="prettyprint">long</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">uint</code> to <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">long</code> to <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">ulong</code> to <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">char</code> to <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">float</code> to <code class="prettyprint">double</code>.</li>
</ul>

<p>Conversions from <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code> to <code class="prettyprint">float</code> and from <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code> to <code class="prettyprint">double</code> may cause a loss of precision, but will never cause a loss of magnitude. The other implicit numeric conversions never lose any information.</p>

<p>There are no implicit conversions to the <code class="prettyprint">char</code> type, so values of the other integral types do not automatically convert to the <code class="prettyprint">char</code> type.</p>

<h3 id="implicit-enumeration-conversions">Implicit enumeration conversions</h3>

<p>An implicit enumeration conversion permits the <em>decimal_integer_literal</em> <code class="prettyprint">0</code> to be converted to any <em>enum_type</em> and to any <em>nullable_type</em> whose underlying type is an <em>enum_type</em>. In the latter case the conversion is evaluated by converting to the underlying <em>enum_type</em> and wrapping the result (<a href="types.md#nullable-types">Nullable types</a>).</p>

<h3 id="implicit-interpolated-string-conversions">Implicit interpolated string conversions</h3>

<p>An implicit interpolated string conversion permits an <em>interpolated_string_expression</em> (<a href="expressions.md#interpolated-strings">Interpolated strings</a>) to be converted to <code class="prettyprint">System.IFormattable</code> or <code class="prettyprint">System.FormattableString</code> (which implements <code class="prettyprint">System.IFormattable</code>).</p>

<p>When this conversion is applied a string value is not composed from the interpolated string. Instead an instance of <code class="prettyprint">System.FormattableString</code> is created, as further described in <a href="expressions.md#interpolated-strings">Interpolated strings</a>.</p>

<h3 id="implicit-nullable-conversions">Implicit nullable conversions</h3>

<p>Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types. For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type <code class="prettyprint">S</code> to a non-nullable value type <code class="prettyprint">T</code>, the following implicit nullable conversions exist:</p>

<ul>
<li> An implicit conversion from <code class="prettyprint">S?</code> to <code class="prettyprint">T?</code>.</li>
<li> An implicit conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T?</code>.</li>
</ul>

<p>Evaluation of an implicit nullable conversion based on an underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> proceeds as follows:</p>

<ul>
<li><p>If the nullable conversion is from <code class="prettyprint">S?</code> to <code class="prettyprint">T?</code>:</p>

<ul>
<li>If the source value is null (<code class="prettyprint">HasValue</code> property is false), the result is the null value of type <code class="prettyprint">T?</code>.</li>
<li>Otherwise, the conversion is evaluated as an unwrapping from <code class="prettyprint">S?</code> to <code class="prettyprint">S</code>, followed by the underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>, followed by a wrapping (<a href="types.md#nullable-types">Nullable types</a>) from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code>.</li>
</ul></li>
<li><p>If the nullable conversion is from <code class="prettyprint">S</code> to <code class="prettyprint">T?</code>, the conversion is evaluated as the underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> followed by a wrapping from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code>.</p></li>
</ul>

<h3 id="null-literal-conversions">Null literal conversions</h3>

<p>An implicit conversion exists from the <code class="prettyprint">null</code> literal to any nullable type. This conversion produces the null value (<a href="types.md#nullable-types">Nullable types</a>) of the given nullable type.</p>

<h3 id="implicit-reference-conversions">Implicit reference conversions</h3>

<p>The implicit reference conversions are:</p>

<ul>
<li> From any <em>reference_type</em> to <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>.</li>
<li> From any <em>class_type</em> <code class="prettyprint">S</code> to any <em>class_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> is derived from <code class="prettyprint">T</code>.</li>
<li> From any <em>class_type</em> <code class="prettyprint">S</code> to any <em>interface_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> implements <code class="prettyprint">T</code>.</li>
<li> From any <em>interface_type</em> <code class="prettyprint">S</code> to any <em>interface_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> is derived from <code class="prettyprint">T</code>.</li>
<li> From an <em>array_type</em> <code class="prettyprint">S</code> with an element type <code class="prettyprint">SE</code> to an <em>array_type</em> <code class="prettyprint">T</code> with an element type <code class="prettyprint">TE</code>, provided all of the following are true:

<ul>
<li><code class="prettyprint">S</code> and <code class="prettyprint">T</code> differ only in element type. In other words, <code class="prettyprint">S</code> and <code class="prettyprint">T</code> have the same number of dimensions.</li>
<li>Both <code class="prettyprint">SE</code> and <code class="prettyprint">TE</code> are *reference_type*s.</li>
<li>An implicit reference conversion exists from <code class="prettyprint">SE</code> to <code class="prettyprint">TE</code>.</li>
</ul></li>
<li> From any <em>array_type</em> to <code class="prettyprint">System.Array</code> and the interfaces it implements.</li>
<li> From a single-dimensional array type <code class="prettyprint">S[]</code> to <code class="prettyprint">System.Collections.Generic.IList&lt;T&gt;</code> and its base interfaces, provided that there is an implicit identity or reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>.</li>
<li> From any <em>delegate_type</em> to <code class="prettyprint">System.Delegate</code> and the interfaces it implements.</li>
<li> From the null literal to any <em>reference_type</em>.</li>
<li> From any <em>reference_type</em> to a <em>reference_type</em> <code class="prettyprint">T</code> if it has an implicit identity or reference conversion to a <em>reference_type</em> <code class="prettyprint">T0</code> and <code class="prettyprint">T0</code> has an identity conversion to <code class="prettyprint">T</code>.</li>
<li> From any <em>reference_type</em> to an interface or delegate type <code class="prettyprint">T</code> if it has an implicit identity or reference conversion to an interface or delegate type <code class="prettyprint">T0</code> and <code class="prettyprint">T0</code> is variance-convertible (<a href="interfaces.md#variance-conversion">Variance conversion</a>) to <code class="prettyprint">T</code>.</li>
<li> Implicit conversions involving type parameters that are known to be reference types. See <a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a> for more details on implicit conversions involving type parameters.</li>
</ul>

<p>The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</p>

<p>Reference conversions, implicit or explicit, never change the referential identity of the object being converted. In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</p>

<h3 id="boxing-conversions">Boxing conversions</h3>

<p>A boxing conversion permits a <em>value_type</em> to be implicitly converted to a reference type. A boxing conversion exists from any <em>non_nullable_value_type</em> to <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>, to <code class="prettyprint">System.ValueType</code> and to any <em>interface_type</em> implemented by the <em>non_nullable_value_type</em>. Furthermore an <em>enum_type</em> can be converted to the type <code class="prettyprint">System.Enum</code>.</p>

<p>A boxing conversion exists from a <em>nullable_type</em> to a reference type, if and only if a boxing conversion exists from the underlying <em>non_nullable_value_type</em> to the reference type.</p>

<p>A value type has a boxing conversion to an interface type <code class="prettyprint">I</code> if it has a boxing conversion to an interface type <code class="prettyprint">I0</code> and <code class="prettyprint">I0</code> has an identity conversion to <code class="prettyprint">I</code>.</p>

<p>A value type has a boxing conversion to an interface type <code class="prettyprint">I</code> if it has a boxing conversion to an interface or delegate type <code class="prettyprint">I0</code> and <code class="prettyprint">I0</code> is variance-convertible (<a href="interfaces.md#variance-conversion">Variance conversion</a>) to <code class="prettyprint">I</code>.</p>

<p>Boxing a value of a <em>non_nullable_value_type</em> consists of allocating an object instance and copying the <em>value_type</em> value into that instance. A struct can be boxed to the type <code class="prettyprint">System.ValueType</code>, since that is a base class for all structsÂ (<a href="structs.md#inheritance">Inheritance</a>).</p>

<p>Boxing a value of a <em>nullable_type</em> proceeds as follows:</p>

<ul>
<li> If the source value is null (<code class="prettyprint">HasValue</code> property is false), the result is a null reference of the target type.</li>
<li> Otherwise, the result is a reference to a boxed <code class="prettyprint">T</code> produced by unwrapping and boxing the source value.</li>
</ul>

<p>Boxing conversions are described further in <a href="types.md#boxing-conversions">Boxing conversions</a>.</p>

<h3 id="implicit-dynamic-conversions">Implicit dynamic conversions</h3>

<p>An implicit dynamic conversion exists from an expression of type <code class="prettyprint">dynamic</code> to any type <code class="prettyprint">T</code>. The conversion is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to <code class="prettyprint">T</code>. If no conversion is found, a run-time exception is thrown.</p>

<p>Note that this implicit conversion seemingly violates the advice in the beginning of <a href="conversions.md#implicit-conversions">Implicit conversions</a> that an implicit conversion should never cause an exception. However it is not the conversion itself, but the <em>finding</em> of the conversion that causes the exception. The risk of run-time exceptions is inherent in the use of dynamic binding. If dynamic binding of the conversion is not desired, the expression can be first converted to <code class="prettyprint">object</code>, and then to the desired type.</p>

<p>The following example illustrates implicit dynamic conversions:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">object</span> <span class="n">o</span>  <span class="p">=</span> <span class="s">"object"</span>
<span class="kt">dynamic</span> <span class="n">d</span> <span class="p">=</span> <span class="s">"dynamic"</span><span class="p">;</span>

<span class="kt">string</span> <span class="n">s1</span> <span class="p">=</span> <span class="n">o</span><span class="p">;</span> <span class="c1">// Fails at compile-time -- no conversion exists</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="p">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// Compiles and succeeds at run-time</span>
<span class="kt">int</span> <span class="n">i</span>     <span class="p">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// Compiles but fails at run-time -- no conversion exists</span>
</code></pre>
<p>The assignments to <code class="prettyprint">s2</code> and <code class="prettyprint">i</code> both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time. At run-time, implicit conversions are sought from the run-time type of <code class="prettyprint">d</code> &ndash; <code class="prettyprint">string</code> &ndash; to the target type. A conversion is found to <code class="prettyprint">string</code> but not to <code class="prettyprint">int</code>.</p>

<h3 id="implicit-constant-expression-conversions">Implicit constant expression conversions</h3>

<p>An implicit constant expression conversion permits the following conversions:</p>

<ul>
<li> A <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>) of type <code class="prettyprint">int</code> can be converted to type <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code>, provided the value of the <em>constant_expression</em> is within the range of the destination type.</li>
<li> A <em>constant_expression</em> of type <code class="prettyprint">long</code> can be converted to type <code class="prettyprint">ulong</code>, provided the value of the <em>constant_expression</em> is not negative.</li>
</ul>

<h3 id="implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</h3>

<p>The following implicit conversions exist for a given type parameter <code class="prettyprint">T</code>:</p>

<ul>
<li> From <code class="prettyprint">T</code> to its effective base class <code class="prettyprint">C</code>, from <code class="prettyprint">T</code> to any base class of <code class="prettyprint">C</code>, and from <code class="prettyprint">T</code> to any interface implemented by <code class="prettyprint">C</code>. At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as a boxing conversion. Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</li>
<li> From <code class="prettyprint">T</code> to an interface type <code class="prettyprint">I</code> in <code class="prettyprint">T</code>&lsquo;s effective interface set and from <code class="prettyprint">T</code> to any base interface of <code class="prettyprint">I</code>. At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as a boxing conversion. Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</li>
<li> From <code class="prettyprint">T</code> to a type parameter <code class="prettyprint">U</code>, provided <code class="prettyprint">T</code> depends on <code class="prettyprint">U</code> (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). At run-time, if <code class="prettyprint">U</code> is a value type, then <code class="prettyprint">T</code> and <code class="prettyprint">U</code> are necessarily the same type and no conversion is performed. Otherwise, if <code class="prettyprint">T</code> is a value type, the conversion is executed as a boxing conversion. Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</li>
<li> From the null literal to <code class="prettyprint">T</code>, provided <code class="prettyprint">T</code> is known to be a reference type.</li>
<li> From <code class="prettyprint">T</code> to a reference type <code class="prettyprint">I</code> if it has an implicit conversion to a reference type <code class="prettyprint">S0</code> and <code class="prettyprint">S0</code> has an identity conversion to <code class="prettyprint">S</code>. At run-time the conversion is executed the same way as the conversion to <code class="prettyprint">S0</code>.</li>
<li> From <code class="prettyprint">T</code> to an interface type <code class="prettyprint">I</code> if it has an implicit conversion to an interface or delegate type <code class="prettyprint">I0</code> and <code class="prettyprint">I0</code> is variance-convertible to <code class="prettyprint">I</code> (<a href="interfaces.md#variance-conversion">Variance conversion</a>). At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as a boxing conversion. Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</li>
</ul>

<p>If <code class="prettyprint">T</code> is known to be a reference type (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), the conversions above are all classified as implicit reference conversions (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>). If <code class="prettyprint">T</code> is not known to be a reference type, the conversions above are classified as boxing conversions (<a href="conversions.md#boxing-conversions">Boxing conversions</a>).</p>

<h3 id="user-defined-implicit-conversions">User-defined implicit conversions</h3>

<p>A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion. The exact rules for evaluating user-defined implicit conversions are described in <a href="conversions.md#processing-of-user-defined-implicit-conversions">Processing of user-defined implicit conversions</a>.</p>

<h3 id="anonymous-function-conversions-and-method-group-conversions">Anonymous function conversions and method group conversions</h3>

<p>Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types. Anonymous function conversions are described in more detail in <a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a> and method group conversions in <a href="conversions.md#method-group-conversions">Method group conversions</a>.</p>

<h2 id="explicit-conversions">Explicit conversions</h2>

<p>The following conversions are classified as explicit conversions:</p>

<ul>
<li> All implicit conversions.</li>
<li> Explicit numeric conversions.</li>
<li> Explicit enumeration conversions.</li>
<li> Explicit nullable conversions.</li>
<li> Explicit reference conversions.</li>
<li> Explicit interface conversions.</li>
<li> Unboxing conversions.</li>
<li> Explicit dynamic conversions</li>
<li> User-defined explicit conversions.</li>
</ul>

<p>Explicit conversions can occur in cast expressions (<a href="expressions.md#cast-expressions">Cast expressions</a>).</p>

<p>The set of explicit conversions includes all implicit conversions. This means that redundant cast expressions are allowed.</p>

<p>The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</p>

<h3 id="explicit-numeric-conversions">Explicit numeric conversions</h3>

<p>The explicit numeric conversions are the conversions from a <em>numeric_type</em> to another <em>numeric_type</em> for which an implicit numeric conversion (<a href="conversions.md#implicit-numeric-conversions">Implicit numeric conversions</a>) does not already exist:</p>

<ul>
<li> From <code class="prettyprint">sbyte</code> to <code class="prettyprint">byte</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">byte</code> to <code class="prettyprint">sbyte</code> and <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">short</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">ushort</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">int</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">uint</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">long</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">ulong</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">char</code>.</li>
<li> From <code class="prettyprint">char</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, or <code class="prettyprint">short</code>.</li>
<li> From <code class="prettyprint">float</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">double</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From <code class="prettyprint">decimal</code> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, or <code class="prettyprint">double</code>.</li>
</ul>

<p>Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any <em>numeric_type</em> to any other <em>numeric_type</em> using a cast expression (<a href="expressions.md#cast-expressions">Cast expressions</a>).</p>

<p>The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown. An explicit numeric conversion is processed as follows:</p>

<ul>
<li> For a conversion from an integral type to another integral type, the processing depends on the overflow checking context (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>) in which the conversion takes place:

<ul>
<li>In a <code class="prettyprint">checked</code> context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a <code class="prettyprint">System.OverflowException</code> if the value of the source operand is outside the range of the destination type.</li>
<li>In an <code class="prettyprint">unchecked</code> context, the conversion always succeeds, and proceeds as follows.

<ul>
<li>If the source type is larger than the destination type, then the source value is truncated by discarding its &ldquo;extra&rdquo; most significant bits. The result is then treated as a value of the destination type.</li>
<li>If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type. Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned. The result is then treated as a value of the destination type.</li>
<li>If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</li>
</ul></li>
</ul></li>
<li> For a conversion from <code class="prettyprint">decimal</code> to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion. If the resulting integral value is outside the range of the destination type, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
<li> For a conversion from <code class="prettyprint">float</code> or <code class="prettyprint">double</code> to an integral type, the processing depends on the overflow checking context (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>) in which the conversion takes place:

<ul>
<li>In a <code class="prettyprint">checked</code> context, the conversion proceeds as follows:

<ul>
<li>If the value of the operand is NaN or infinite, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
<li>Otherwise, the source operand is rounded towards zero to the nearest integral value. If this integral value is within the range of the destination type then this value is the result of the conversion.</li>
<li>Otherwise, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
</ul></li>
<li>In an <code class="prettyprint">unchecked</code> context, the conversion always succeeds, and proceeds as follows.

<ul>
<li>If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</li>
<li>Otherwise, the source operand is rounded towards zero to the nearest integral value. If this integral value is within the range of the destination type then this value is the result of the conversion.</li>
<li>Otherwise, the result of the conversion is an unspecified value of the destination type.</li>
</ul></li>
</ul></li>
<li> For a conversion from <code class="prettyprint">double</code> to <code class="prettyprint">float</code>, the <code class="prettyprint">double</code> value is rounded to the nearest <code class="prettyprint">float</code> value. If the <code class="prettyprint">double</code> value is too small to represent as a <code class="prettyprint">float</code>, the result becomes positive zero or negative zero. If the <code class="prettyprint">double</code> value is too large to represent as a <code class="prettyprint">float</code>, the result becomes positive infinity or negative infinity. If the <code class="prettyprint">double</code> value is NaN, the result is also NaN.</li>
<li> For a conversion from <code class="prettyprint">float</code> or <code class="prettyprint">double</code> to <code class="prettyprint">decimal</code>, the source value is converted to <code class="prettyprint">decimal</code> representation and rounded to the nearest number after the 28th decimal place if required (<a href="types.md#the-decimal-type">The decimal type</a>). If the source value is too small to represent as a <code class="prettyprint">decimal</code>, the result becomes zero. If the source value is NaN, infinity, or too large to represent as a <code class="prettyprint">decimal</code>, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
<li> For a conversion from <code class="prettyprint">decimal</code> to <code class="prettyprint">float</code> or <code class="prettyprint">double</code>, the <code class="prettyprint">decimal</code> value is rounded to the nearest <code class="prettyprint">double</code> or <code class="prettyprint">float</code> value. While this conversion may lose precision, it never causes an exception to be thrown.</li>
</ul>

<h3 id="explicit-enumeration-conversions">Explicit enumeration conversions</h3>

<p>The explicit enumeration conversions are:</p>

<ul>
<li> From <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code> to any <em>enum_type</em>.</li>
<li> From any <em>enum_type</em> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">decimal</code>.</li>
<li> From any <em>enum_type</em> to any other <em>enum_type</em>.</li>
</ul>

<p>An explicit enumeration conversion between two types is processed by treating any participating <em>enum_type</em> as the underlying type of that <em>enum_type</em>, and then performing an implicit or explicit numeric conversion between the resulting types. For example, given an <em>enum_type</em> <code class="prettyprint">E</code> with and underlying type of <code class="prettyprint">int</code>, a conversion from <code class="prettyprint">E</code> to <code class="prettyprint">byte</code> is processed as an explicit numeric conversion (<a href="conversions.md#explicit-numeric-conversions">Explicit numeric conversions</a>) from <code class="prettyprint">int</code> to <code class="prettyprint">byte</code>, and a conversion from <code class="prettyprint">byte</code> to <code class="prettyprint">E</code> is processed as an implicit numeric conversion (<a href="conversions.md#implicit-numeric-conversions">Implicit numeric conversions</a>) from <code class="prettyprint">byte</code> to <code class="prettyprint">int</code>.</p>

<h3 id="explicit-nullable-conversions">Explicit nullable conversions</h3>

<p><strong><em>Explicit nullable conversions</em></strong> permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types. For each of the predefined explicit conversions that convert from a non-nullable value type <code class="prettyprint">S</code> to a non-nullable value type <code class="prettyprint">T</code> (<a href="conversions.md#identity-conversion">Identity conversion</a>, <a href="conversions.md#implicit-numeric-conversions">Implicit numeric conversions</a>, <a href="conversions.md#implicit-enumeration-conversions">Implicit enumeration conversions</a>, <a href="conversions.md#explicit-numeric-conversions">Explicit numeric conversions</a>, and <a href="conversions.md#explicit-enumeration-conversions">Explicit enumeration conversions</a>), the following nullable conversions exist:</p>

<ul>
<li> An explicit conversion from <code class="prettyprint">S?</code> to <code class="prettyprint">T?</code>.</li>
<li> An explicit conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T?</code>.</li>
<li> An explicit conversion from <code class="prettyprint">S?</code> to <code class="prettyprint">T</code>.</li>
</ul>

<p>Evaluation of a nullable conversion based on an underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> proceeds as follows:</p>

<ul>
<li> If the nullable conversion is from <code class="prettyprint">S?</code> to <code class="prettyprint">T?</code>:

<ul>
<li>If the source value is null (<code class="prettyprint">HasValue</code> property is false), the result is the null value of type <code class="prettyprint">T?</code>.</li>
<li>Otherwise, the conversion is evaluated as an unwrapping from <code class="prettyprint">S?</code> to <code class="prettyprint">S</code>, followed by the underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>, followed by a wrapping from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code>.</li>
</ul></li>
<li> If the nullable conversion is from <code class="prettyprint">S</code> to <code class="prettyprint">T?</code>, the conversion is evaluated as the underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> followed by a wrapping from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code>.</li>
<li> If the nullable conversion is from <code class="prettyprint">S?</code> to <code class="prettyprint">T</code>, the conversion is evaluated as an unwrapping from <code class="prettyprint">S?</code> to <code class="prettyprint">S</code> followed by the underlying conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>.</li>
</ul>

<p>Note that an attempt to unwrap a nullable value will throw an exception if the value is <code class="prettyprint">null</code>.</p>

<h3 id="explicit-reference-conversions">Explicit reference conversions</h3>

<p>The explicit reference conversions are:</p>

<ul>
<li> From <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code> to any other <em>reference_type</em>.</li>
<li> From any <em>class_type</em> <code class="prettyprint">S</code> to any <em>class_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> is a base class of <code class="prettyprint">T</code>.</li>
<li> From any <em>class_type</em> <code class="prettyprint">S</code> to any <em>interface_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> is not sealed and provided <code class="prettyprint">S</code> does not implement <code class="prettyprint">T</code>.</li>
<li> From any <em>interface_type</em> <code class="prettyprint">S</code> to any <em>class_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">T</code> is not sealed or provided <code class="prettyprint">T</code> implements <code class="prettyprint">S</code>.</li>
<li> From any <em>interface_type</em> <code class="prettyprint">S</code> to any <em>interface_type</em> <code class="prettyprint">T</code>, provided <code class="prettyprint">S</code> is not derived from <code class="prettyprint">T</code>.</li>
<li> From an <em>array_type</em> <code class="prettyprint">S</code> with an element type <code class="prettyprint">SE</code> to an <em>array_type</em> <code class="prettyprint">T</code> with an element type <code class="prettyprint">TE</code>, provided all of the following are true:

<ul>
<li><code class="prettyprint">S</code> and <code class="prettyprint">T</code> differ only in element type. In other words, <code class="prettyprint">S</code> and <code class="prettyprint">T</code> have the same number of dimensions.</li>
<li>Both <code class="prettyprint">SE</code> and <code class="prettyprint">TE</code> are *reference_type*s.</li>
<li>An explicit reference conversion exists from <code class="prettyprint">SE</code> to <code class="prettyprint">TE</code>.</li>
</ul></li>
<li> From <code class="prettyprint">System.Array</code> and the interfaces it implements to any <em>array_type</em>.</li>
<li> From a single-dimensional array type <code class="prettyprint">S[]</code> to <code class="prettyprint">System.Collections.Generic.IList&lt;T&gt;</code> and its base interfaces, provided that there is an explicit reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>.</li>
<li> From <code class="prettyprint">System.Collections.Generic.IList&lt;S&gt;</code> and its base interfaces to a single-dimensional array type <code class="prettyprint">T[]</code>, provided that there is an explicit identity or reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code>.</li>
<li> From <code class="prettyprint">System.Delegate</code> and the interfaces it implements to any <em>delegate_type</em>.</li>
<li> From a reference type to a reference type <code class="prettyprint">T</code> if it has an explicit reference conversion to a reference type <code class="prettyprint">T0</code> and <code class="prettyprint">T0</code> has an identity conversion <code class="prettyprint">T</code>.</li>
<li> From a reference type to an interface or delegate type <code class="prettyprint">T</code> if it has an explicit reference conversion to an interface or delegate type <code class="prettyprint">T0</code> and either <code class="prettyprint">T0</code> is variance-convertible to <code class="prettyprint">T</code> or <code class="prettyprint">T</code> is variance-convertible to <code class="prettyprint">T0</code> (<a href="interfaces.md#variance-conversion">Variance conversion</a>).</li>
<li> From <code class="prettyprint">D&lt;S1...Sn&gt;</code> to <code class="prettyprint">D&lt;T1...Tn&gt;</code> where <code class="prettyprint">D&lt;X1...Xn&gt;</code> is a generic delegate type, <code class="prettyprint">D&lt;S1...Sn&gt;</code> is not compatible with or identical to <code class="prettyprint">D&lt;T1...Tn&gt;</code>, and for each type parameter <code class="prettyprint">Xi</code> of <code class="prettyprint">D</code> the following holds:

<ul>
<li>If <code class="prettyprint">Xi</code> is invariant, then <code class="prettyprint">Si</code> is identical to <code class="prettyprint">Ti</code>.</li>
<li>If <code class="prettyprint">Xi</code> is covariant, then there is an implicit or explicit identity or reference conversion from <code class="prettyprint">Si</code> to <code class="prettyprint">Ti</code>.</li>
<li>If <code class="prettyprint">Xi</code> is contravariant, then <code class="prettyprint">Si</code> and <code class="prettyprint">Ti</code> are either identical or both reference types.</li>
</ul></li>
<li> Explicit conversions involving type parameters that are known to be reference types. For more details on explicit conversions involving type parameters, see <a href="conversions.md#explicit-conversions-involving-type-parameters">Explicit conversions involving type parameters</a>.</li>
</ul>

<p>The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</p>

<p>For an explicit reference conversion to succeed at run-time, the value of the source operand must be <code class="prettyprint">null</code>, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) or boxing conversion (<a href="conversions.md#boxing-conversions">Boxing conversions</a>). If an explicit reference conversion fails, a <code class="prettyprint">System.InvalidCastException</code> is thrown.</p>

<p>Reference conversions, implicit or explicit, never change the referential identity of the object being converted. In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</p>

<h3 id="unboxing-conversions">Unboxing conversions</h3>

<p>An unboxing conversion permits a reference type to be explicitly converted to a <em>value_type</em>. An unboxing conversion exists from the types <code class="prettyprint">object</code>, <code class="prettyprint">dynamic</code> and <code class="prettyprint">System.ValueType</code> to any <em>non_nullable_value_type</em>, and from any <em>interface_type</em> to any <em>non_nullable_value_type</em> that implements the <em>interface_type</em>. Furthermore type <code class="prettyprint">System.Enum</code> can be unboxed to any <em>enum_type</em>.</p>

<p>An unboxing conversion exists from a reference type to a <em>nullable_type</em> if an unboxing conversion exists from the reference type to the underlying <em>non_nullable_value_type</em> of the <em>nullable_type</em>.</p>

<p>A value type <code class="prettyprint">S</code> has an unboxing conversion from an interface type <code class="prettyprint">I</code> if it has an unboxing conversion from an interface type <code class="prettyprint">I0</code> and <code class="prettyprint">I0</code> has an identity conversion to <code class="prettyprint">I</code>.</p>

<p>A value type <code class="prettyprint">S</code> has an unboxing conversion from an interface type <code class="prettyprint">I</code> if it has an unboxing conversion from an interface or delegate type <code class="prettyprint">I0</code> and either <code class="prettyprint">I0</code> is variance-convertible to <code class="prettyprint">I</code> or <code class="prettyprint">I</code> is variance-convertible to <code class="prettyprint">I0</code> (<a href="interfaces.md#variance-conversion">Variance conversion</a>).</p>

<p>An unboxing operation consists of first checking that the object instance is a boxed value of the given <em>value_type</em>, and then copying the value out of the instance. Unboxing a null reference to a <em>nullable_type</em> produces the null value of the <em>nullable_type</em>. A struct can be unboxed from the type <code class="prettyprint">System.ValueType</code>, since that is a base class for all structsÂ (<a href="structs.md#inheritance">Inheritance</a>).</p>

<p>Unboxing conversions are described further in <a href="types.md#unboxing-conversions">Unboxing conversions</a>.</p>

<h3 id="explicit-dynamic-conversions">Explicit dynamic conversions</h3>

<p>An explicit dynamic conversion exists from an expression of type <code class="prettyprint">dynamic</code> to any type <code class="prettyprint">T</code>. The conversion is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to <code class="prettyprint">T</code>. If no conversion is found, a run-time exception is thrown.</p>

<p>If dynamic binding of the conversion is not desired, the expression can be first converted to <code class="prettyprint">object</code>, and then to the desired type.</p>

<p>Assume the following class is defined:
&ldquo;`csharp
class C
{
    int i;</p>

<p>public C(int i) { this.i = i; }</p>

<p>public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
&rdquo;`</p>

<p>The following example illustrates explicit dynamic conversions:
&ldquo;`csharp
object o  = &quot;1&rdquo;;
dynamic d = &ldquo;2&rdquo;;</p>

<p>var c1 = &copy;o; // Compiles, but explicit reference conversion fails
var c2 = &copy;d; // Compiles and user defined conversion succeeds
&ldquo;`</p>

<p>The best conversion of <code class="prettyprint">o</code> to <code class="prettyprint">C</code> is found at compile-time to be an explicit reference conversion. This fails at run-time, because <code class="prettyprint">&quot;1&quot;</code> is not in fact a <code class="prettyprint">C</code>. The conversion of <code class="prettyprint">d</code> to <code class="prettyprint">C</code> however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of <code class="prettyprint">d</code> &ndash; <code class="prettyprint">string</code> &ndash; to <code class="prettyprint">C</code> is found, and succeeds.</p>

<h3 id="explicit-conversions-involving-type-parameters">Explicit conversions involving type parameters</h3>

<p>The following explicit conversions exist for a given type parameter <code class="prettyprint">T</code>:</p>

<ul>
<li> From the effective base class <code class="prettyprint">C</code> of <code class="prettyprint">T</code> to <code class="prettyprint">T</code> and from any base class of <code class="prettyprint">C</code> to <code class="prettyprint">T</code>. At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as an unboxing conversion. Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</li>
<li> From any interface type to <code class="prettyprint">T</code>. At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as an unboxing conversion. Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</li>
<li> From <code class="prettyprint">T</code> to any <em>interface_type</em> <code class="prettyprint">I</code> provided there is not already an implicit conversion from <code class="prettyprint">T</code> to <code class="prettyprint">I</code>. At run-time, if <code class="prettyprint">T</code> is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion. Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</li>
<li> From a type parameter <code class="prettyprint">U</code> to <code class="prettyprint">T</code>, provided <code class="prettyprint">T</code> depends on <code class="prettyprint">U</code> (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). At run-time, if <code class="prettyprint">U</code> is a value type, then <code class="prettyprint">T</code> and <code class="prettyprint">U</code> are necessarily the same type and no conversion is performed. Otherwise, if <code class="prettyprint">T</code> is a value type, the conversion is executed as an unboxing conversion. Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</li>
</ul>

<p>If <code class="prettyprint">T</code> is known to be a reference type, the conversions above are all classified as explicit reference conversions (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>). If <code class="prettyprint">T</code> is not known to be a reference type, the conversions above are classified as unboxing conversions (<a href="conversions.md#unboxing-conversions">Unboxing conversions</a>).</p>

<p>The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising. The reason for this rule is to prevent confusion and make the semantics of such conversions clear. For example, consider the following declaration:
<code class="prettyprint">csharp
class X&lt;T&gt;
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
</code></p>

<p>If the direct explicit conversion of <code class="prettyprint">t</code> to <code class="prettyprint">int</code> were permitted, one might easily expect that <code class="prettyprint">X&lt;int&gt;.F(7)</code> would returnÂ <code class="prettyprint">7L</code>. However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time. In order to make the semantics clear, the above example must instead be written:
<code class="prettyprint">csharp
class X&lt;T&gt;
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
</code></p>

<p>This code will now compile but executing <code class="prettyprint">X&lt;int&gt;.F(7)</code> would then throw an exception at run-time, since a boxed <code class="prettyprint">int</code> cannot be converted directly to a <code class="prettyprint">long</code>.</p>

<h3 id="user-defined-explicit-conversions">User-defined explicit conversions</h3>

<p>A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion. The exact rules for evaluating user-defined explicit conversions are described in <a href="conversions.md#processing-of-user-defined-explicit-conversions">Processing of user-defined explicit conversions</a>.</p>

<h2 id="standard-conversions">Standard conversions</h2>

<p>The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</p>

<h3 id="standard-implicit-conversions">Standard implicit conversions</h3>

<p>The following implicit conversions are classified as standard implicit conversions:</p>

<ul>
<li> Identity conversions (<a href="conversions.md#identity-conversion">Identity conversion</a>)</li>
<li> Implicit numeric conversions (<a href="conversions.md#implicit-numeric-conversions">Implicit numeric conversions</a>)</li>
<li> Implicit nullable conversions (<a href="conversions.md#implicit-nullable-conversions">Implicit nullable conversions</a>)</li>
<li> Implicit reference conversions (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>)</li>
<li> Boxing conversions (<a href="conversions.md#boxing-conversions">Boxing conversions</a>)</li>
<li> Implicit constant expression conversions (<a href="conversions.md#implicit-dynamic-conversions">Implicit dynamic conversions</a>)</li>
<li> Implicit conversions involving type parameters (<a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a>)</li>
</ul>

<p>The standard implicit conversions specifically exclude user-defined implicit conversions.</p>

<h3 id="standard-explicit-conversions">Standard explicit conversions</h3>

<p>The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists. In other words, if a standard implicit conversion exists from a type <code class="prettyprint">A</code> to a type <code class="prettyprint">B</code>, then a standard explicit conversion exists from type <code class="prettyprint">A</code> to type <code class="prettyprint">B</code> and from type <code class="prettyprint">B</code> to type <code class="prettyprint">A</code>.</p>

<h2 id="user-defined-conversions">User-defined conversions</h2>

<p>C# allows the pre-defined implicit and explicit conversions to be augmented by <strong><em>user-defined conversions</em></strong>. User-defined conversions are introduced by declaring conversion operators (<a href="classes.md#conversion-operators">Conversion operators</a>) in class and struct types.</p>

<h3 id="permitted-user-defined-conversions">Permitted user-defined conversions</h3>

<p>C# permits only certain user-defined conversions to be declared. In particular, it is not possible to redefine an already existing implicit or explicit conversion.</p>

<p>For a given source type <code class="prettyprint">S</code> and target type <code class="prettyprint">T</code>, if <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are nullable types, let <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> refer to their underlying types, otherwise <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are equal to <code class="prettyprint">S</code> and <code class="prettyprint">T</code> respectively. A class or struct is permitted to declare a conversion from a source type <code class="prettyprint">S</code> to a target type <code class="prettyprint">T</code> only if all of the following are true:</p>

<ul>
<li> <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are different types.</li>
<li> Either <code class="prettyprint">S0</code> or <code class="prettyprint">T0</code> is the class or struct type in which the operator declaration takes place.</li>
<li> Neither <code class="prettyprint">S0</code> nor <code class="prettyprint">T0</code> is an <em>interface_type</em>.</li>
<li> Excluding user-defined conversions, a conversion does not exist from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> or from <code class="prettyprint">T</code> to <code class="prettyprint">S</code>.</li>
</ul>

<p>The restrictions that apply to user-defined conversions are discussed further in <a href="classes.md#conversion-operators">Conversion operators</a>.</p>

<h3 id="lifted-conversion-operators">Lifted conversion operators</h3>

<p>Given a user-defined conversion operator that converts from a non-nullable value type <code class="prettyprint">S</code> to a non-nullable value type <code class="prettyprint">T</code>, a <strong><em>lifted conversion operator</em></strong> exists that converts from <code class="prettyprint">S?</code> to <code class="prettyprint">T?</code>. This lifted conversion operator performs an unwrapping from <code class="prettyprint">S?</code> to <code class="prettyprint">S</code> followed by the user-defined conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> followed by a wrapping from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code>, except that a null valued <code class="prettyprint">S?</code> converts directly to a null valued <code class="prettyprint">T?</code>.</p>

<p>A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator. The term &quot;user-defined conversion&rdquo; applies to the use of both user-defined and lifted conversion operators.</p>

<h3 id="evaluation-of-user-defined-conversions">Evaluation of user-defined conversions</h3>

<p>A user-defined conversion converts a value from its type, called the <strong><em>source type</em></strong>, to another type, called the <strong><em>target type</em></strong>. Evaluation of a user-defined conversion centers on finding the <strong><em>most specific</em></strong> user-defined conversion operator for the particular source and target types. This determination is broken into several steps:</p>

<ul>
<li> Finding the set of classes and structs from which user-defined conversion operators will be considered. This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes). For the purposes of this step, if either the source or target type is a <em>nullable_type</em>, their underlying type is used instead.</li>
<li> From that set of types, determining which user-defined and lifted conversion operators are applicable. For a conversion operator to be applicable, it must be possible to perform a standard conversion (<a href="conversions.md#standard-conversions">Standard conversions</a>) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</li>
<li> From the set of applicable user-defined operators, determining which operator is unambiguously the most specific. In general terms, the most specific operator is the operator whose operand type is &ldquo;closest&rdquo; to the source type and whose result type is &ldquo;closest&rdquo; to the target type. User-defined conversion operators are preferred over lifted conversion operators. The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</li>
</ul>

<p>Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</p>

<ul>
<li> First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</li>
<li> Next, invoking the user-defined or lifted conversion operator to perform the conversion.</li>
<li> Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</li>
</ul>

<p>Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator. In other words, a conversion from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code> will never first execute a user-defined conversion from <code class="prettyprint">S</code> to <code class="prettyprint">X</code> and then execute a user-defined conversion from <code class="prettyprint">X</code> to <code class="prettyprint">T</code>.</p>

<p>Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections. The definitions make use of the following terms:</p>

<ul>
<li> If a standard implicit conversion (<a href="conversions.md#standard-implicit-conversions">Standard implicit conversions</a>) exists from a type <code class="prettyprint">A</code> to a type <code class="prettyprint">B</code>, and if neither <code class="prettyprint">A</code> nor <code class="prettyprint">B</code> are <em>interface_type*s, then <code class="prettyprint">A</code> is said to be *</em><em>encompassed by</em>** <code class="prettyprint">B</code>, and <code class="prettyprint">B</code> is said to <strong><em>encompass</em></strong> <code class="prettyprint">A</code>.</li>
<li> The <strong><em>most encompassing type</em></strong> in a set of types is the one type that encompasses all other types in the set. If no single type encompasses all other types, then the set has no most encompassing type. In more intuitive terms, the most encompassing type is the &ldquo;largest&rdquo; type in the setâ€”the one type to which each of the other types can be implicitly converted.</li>
<li> The <strong><em>most encompassed type</em></strong> in a set of types is the one type that is encompassed by all other types in the set. If no single type is encompassed by all other types, then the set has no most encompassed type. In more intuitive terms, the most encompassed type is the &ldquo;smallest&rdquo; type in the setâ€”the one type that can be implicitly converted to each of the other types.</li>
</ul>

<h3 id="processing-of-user-defined-implicit-conversions">Processing of user-defined implicit conversions</h3>

<p>A user-defined implicit conversion from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code> is processed as follows:</p>

<ul>
<li> Determine the types <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code>. If <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are nullable types, <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are their underlying types, otherwise <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are equal to <code class="prettyprint">S</code> and <code class="prettyprint">T</code> respectively.</li>
<li> Find the set of types, <code class="prettyprint">D</code>, from which user-defined conversion operators will be considered. This set consists of <code class="prettyprint">S0</code> (if <code class="prettyprint">S0</code> is a class or struct), the base classes of <code class="prettyprint">S0</code> (if <code class="prettyprint">S0</code> is a class), and <code class="prettyprint">T0</code> (if <code class="prettyprint">T0</code> is a class or struct).</li>
<li> Find the set of applicable user-defined and lifted conversion operators, <code class="prettyprint">U</code>. This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in <code class="prettyprint">D</code> that convert from a type encompassing <code class="prettyprint">S</code> to a type encompassed by <code class="prettyprint">T</code>. If <code class="prettyprint">U</code> is empty, the conversion is undefined and a compile-time error occurs.</li>
<li> Find the most specific source type, <code class="prettyprint">SX</code>, of the operators in <code class="prettyprint">U</code>:

<ul>
<li>If any of the operators in <code class="prettyprint">U</code> convert from <code class="prettyprint">S</code>, then <code class="prettyprint">SX</code> is <code class="prettyprint">S</code>.</li>
<li>Otherwise, <code class="prettyprint">SX</code> is the most encompassed type in the combined set of source types of the operators in <code class="prettyprint">U</code>. If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Find the most specific target type, <code class="prettyprint">TX</code>, of the operators in <code class="prettyprint">U</code>:

<ul>
<li>If any of the operators in <code class="prettyprint">U</code> convert to <code class="prettyprint">T</code>, then <code class="prettyprint">TX</code> is <code class="prettyprint">T</code>.</li>
<li>Otherwise, <code class="prettyprint">TX</code> is the most encompassing type in the combined set of target types of the operators in <code class="prettyprint">U</code>. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Find the most specific conversion operator:

<ul>
<li>If <code class="prettyprint">U</code> contains exactly one user-defined conversion operator that converts from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>, then this is the most specific conversion operator.</li>
<li>Otherwise, if <code class="prettyprint">U</code> contains exactly one lifted conversion operator that converts from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>, then this is the most specific conversion operator.</li>
<li>Otherwise, the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Finally, apply the conversion:

<ul>
<li>If <code class="prettyprint">S</code> is not <code class="prettyprint">SX</code>, then a standard implicit conversion from <code class="prettyprint">S</code> to <code class="prettyprint">SX</code> is performed.</li>
<li>The most specific conversion operator is invoked to convert from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>.</li>
<li>If <code class="prettyprint">TX</code> is not <code class="prettyprint">T</code>, then a standard implicit conversion from <code class="prettyprint">TX</code> to <code class="prettyprint">T</code> is performed.</li>
</ul></li>
</ul>

<h3 id="processing-of-user-defined-explicit-conversions">Processing of user-defined explicit conversions</h3>

<p>A user-defined explicit conversion from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code> is processed as follows:</p>

<ul>
<li> Determine the types <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code>. If <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are nullable types, <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are their underlying types, otherwise <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are equal to <code class="prettyprint">S</code> and <code class="prettyprint">T</code> respectively.</li>
<li> Find the set of types, <code class="prettyprint">D</code>, from which user-defined conversion operators will be considered. This set consists of <code class="prettyprint">S0</code> (if <code class="prettyprint">S0</code> is a class or struct), the base classes of <code class="prettyprint">S0</code> (if <code class="prettyprint">S0</code> is a class), <code class="prettyprint">T0</code> (if <code class="prettyprint">T0</code> is a class or struct), and the base classes of <code class="prettyprint">T0</code> (if <code class="prettyprint">T0</code> is a class).</li>
<li> Find the set of applicable user-defined and lifted conversion operators, <code class="prettyprint">U</code>. This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in <code class="prettyprint">D</code> that convert from a type encompassing or encompassed by <code class="prettyprint">S</code> to a type encompassing or encompassed by <code class="prettyprint">T</code>. If <code class="prettyprint">U</code> is empty, the conversion is undefined and a compile-time error occurs.</li>
<li> Find the most specific source type, <code class="prettyprint">SX</code>, of the operators in <code class="prettyprint">U</code>:

<ul>
<li>If any of the operators in <code class="prettyprint">U</code> convert from <code class="prettyprint">S</code>, then <code class="prettyprint">SX</code> is <code class="prettyprint">S</code>.</li>
<li>Otherwise, if any of the operators in <code class="prettyprint">U</code> convert from types that encompass <code class="prettyprint">S</code>, then <code class="prettyprint">SX</code> is the most encompassed type in the combined set of source types of those operators. If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, <code class="prettyprint">SX</code> is the most encompassing type in the combined set of source types of the operators in <code class="prettyprint">U</code>. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Find the most specific target type, <code class="prettyprint">TX</code>, of the operators in <code class="prettyprint">U</code>:

<ul>
<li>If any of the operators in <code class="prettyprint">U</code> convert to <code class="prettyprint">T</code>, then <code class="prettyprint">TX</code> is <code class="prettyprint">T</code>.</li>
<li>Otherwise, if any of the operators in <code class="prettyprint">U</code> convert to types that are encompassed by <code class="prettyprint">T</code>, then <code class="prettyprint">TX</code> is the most encompassing type in the combined set of target types of those operators. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, <code class="prettyprint">TX</code> is the most encompassed type in the combined set of target types of the operators in <code class="prettyprint">U</code>. If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Find the most specific conversion operator:

<ul>
<li>If <code class="prettyprint">U</code> contains exactly one user-defined conversion operator that converts from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>, then this is the most specific conversion operator.</li>
<li>Otherwise, if <code class="prettyprint">U</code> contains exactly one lifted conversion operator that converts from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>, then this is the most specific conversion operator.</li>
<li>Otherwise, the conversion is ambiguous and a compile-time error occurs.</li>
</ul></li>
<li> Finally, apply the conversion:

<ul>
<li>If <code class="prettyprint">S</code> is not <code class="prettyprint">SX</code>, then a standard explicit conversion from <code class="prettyprint">S</code> to <code class="prettyprint">SX</code> is performed.</li>
<li>The most specific user-defined conversion operator is invoked to convert from <code class="prettyprint">SX</code> to <code class="prettyprint">TX</code>.</li>
<li>If <code class="prettyprint">TX</code> is not <code class="prettyprint">T</code>, then a standard explicit conversion from <code class="prettyprint">TX</code> to <code class="prettyprint">T</code> is performed.</li>
</ul></li>
</ul>

<h2 id="anonymous-function-conversions">Anonymous function conversions</h2>

<p>An <em>anonymous_method_expression</em> or <em>lambda_expression</em> is classified as an anonymous function (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>). The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type. Specifically, an anonymous function <code class="prettyprint">F</code> is compatible with a delegate type <code class="prettyprint">D</code> provided:</p>

<ul>
<li> If <code class="prettyprint">F</code> contains an <em>anonymous_function_signature</em>, then <code class="prettyprint">D</code> and <code class="prettyprint">F</code> have the same number of parameters.</li>
<li> If <code class="prettyprint">F</code> does not contain an <em>anonymous_function_signature</em>, then <code class="prettyprint">D</code> may have zero or more parameters of any type, as long as no parameter of <code class="prettyprint">D</code> has the <code class="prettyprint">out</code> parameter modifier.</li>
<li> If <code class="prettyprint">F</code> has an explicitly typed parameter list, each parameter in <code class="prettyprint">D</code> has the same type and modifiers as the corresponding parameter in <code class="prettyprint">F</code>.</li>
<li> If <code class="prettyprint">F</code> has an implicitly typed parameter list, <code class="prettyprint">D</code> has no <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</li>
<li> If the body of <code class="prettyprint">F</code> is an expression, and either <code class="prettyprint">D</code> has a <code class="prettyprint">void</code> return type or <code class="prettyprint">F</code> is async and <code class="prettyprint">D</code> has the return type <code class="prettyprint">Task</code>, then when each parameter of <code class="prettyprint">F</code> is given the type of the corresponding parameter in <code class="prettyprint">D</code>, the body of <code class="prettyprint">F</code> is a valid expression (wrt <a href="expressions.md#expressions">Expressions</a>) that would be permitted as a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>).</li>
<li> If the body of <code class="prettyprint">F</code> is a statement block, and either <code class="prettyprint">D</code> has a <code class="prettyprint">void</code> return type or <code class="prettyprint">F</code> is async and <code class="prettyprint">D</code> has the return type <code class="prettyprint">Task</code>, then when each parameter of <code class="prettyprint">F</code> is given the type of the corresponding parameter in <code class="prettyprint">D</code>, the body of <code class="prettyprint">F</code> is a valid statement block (wrt <a href="statements.md#blocks">Blocks</a>) in which no <code class="prettyprint">return</code> statement specifies an expression.</li>
<li> If the body of <code class="prettyprint">F</code> is an expression, and <em>either</em> <code class="prettyprint">F</code> is non-async and <code class="prettyprint">D</code> has a non-void return type <code class="prettyprint">T</code>, <em>or</em> <code class="prettyprint">F</code> is async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Task&lt;T&gt;</code>, then when each parameter of <code class="prettyprint">F</code> is given the type of the corresponding parameter in <code class="prettyprint">D</code>, the body of <code class="prettyprint">F</code> is a valid expression (wrt <a href="expressions.md#expressions">Expressions</a>) that is implicitly convertible to <code class="prettyprint">T</code>.</li>
<li> If the body of <code class="prettyprint">F</code> is a statement block, and <em>either</em> <code class="prettyprint">F</code> is non-async and <code class="prettyprint">D</code> has a non-void return type <code class="prettyprint">T</code>, <em>or</em> <code class="prettyprint">F</code> is async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Task&lt;T&gt;</code>, then when each parameter of <code class="prettyprint">F</code> is given the type of the corresponding parameter in <code class="prettyprint">D</code>, the body of <code class="prettyprint">F</code> is a valid statement block (wrt <a href="statements.md#blocks">Blocks</a>) with a non-reachable end point in which each <code class="prettyprint">return</code> statement specifies an expression that is implicitly convertible to <code class="prettyprint">T</code>.</li>
</ul>

<p>For the purpose of brevity, this section uses the short form for the task types <code class="prettyprint">Task</code> and <code class="prettyprint">Task&lt;T&gt;</code> (<a href="classes.md#async-functions">Async functions</a>).</p>

<p>A lambda expression <code class="prettyprint">F</code> is compatible with an expression tree type <code class="prettyprint">Expression&lt;D&gt;</code> if <code class="prettyprint">F</code> is compatible with the delegate type <code class="prettyprint">D</code>. Note that this does not apply to anonymous methods, only lambda expressions.</p>

<p>Certain lambda expressions cannot be converted to expression tree types: Even though the conversion <em>exists</em>, it fails at compile-time. This is the case if the lambda expression:</p>

<ul>
<li> Has a <em>block</em> body</li>
<li> Contains simple or compound assignment operators</li>
<li> Contains a dynamically bound expression</li>
<li> Is async</li>
</ul>

<p>The examples that follow use a generic delegate type <code class="prettyprint">Func&lt;A,R&gt;</code> which represents a function that takes an argument of type <code class="prettyprint">A</code> and returns a value of type <code class="prettyprint">R</code>:
<code class="prettyprint">csharp
delegate R Func&lt;A,R&gt;(A arg);
</code></p>

<p>In the assignments
&ldquo;`csharp
Func<int,int> f1 = x =&gt; x + 1;                 // Ok</p>

<p>Func<int,double> f2 = x =&gt; x + 1;              // Ok</p>

<p>Func<double,int> f3 = x =&gt; x + 1;              // Error</p>

<p>Func<int, Task<int>&gt; f4 = async x =&gt; x + 1;    // Ok
&rdquo;`
the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</p>

<p>The first assignment successfully converts the anonymous function to the delegate type <code class="prettyprint">Func&lt;int,int&gt;</code> because, when <code class="prettyprint">x</code> is given type <code class="prettyprint">int</code>, <code class="prettyprint">x+1</code> is a valid expression that is implicitly convertible to type <code class="prettyprint">int</code>.</p>

<p>Likewise, the second assignment successfully converts the anonymous function to the delegate type <code class="prettyprint">Func&lt;int,double&gt;</code> because the result of <code class="prettyprint">x+1</code> (of type <code class="prettyprint">int</code>) is implicitly convertible to type <code class="prettyprint">double</code>.</p>

<p>However, the third assignment is a compile-time error because, when <code class="prettyprint">x</code> is given type <code class="prettyprint">double</code>, the result of <code class="prettyprint">x+1</code> (of type <code class="prettyprint">double</code>) is not implicitly convertible to type <code class="prettyprint">int</code>.</p>

<p>The fourth assignment successfully converts the anonymous async function to the delegate type <code class="prettyprint">Func&lt;int, Task&lt;int&gt;&gt;</code> because the result of <code class="prettyprint">x+1</code> (of type <code class="prettyprint">int</code>) is implicitly convertible to the result type <code class="prettyprint">int</code> of the task type <code class="prettyprint">Task&lt;int&gt;</code>.</p>

<p>Anonymous functions may influence overload resolution, and participate in type inference. See <a href="expressions.md#function-members">Function members</a> for further details.</p>

<h3 id="evaluation-of-anonymous-function-conversions-to-delegate-types">Evaluation of anonymous function conversions to delegate types</h3>

<p>Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation. When the delegate is invoked, the body of the anonymous function is executed. The code in the body is executed using the set of captured outer variables referenced by the delegate.</p>

<p>The invocation list of a delegate produced from an anonymous function contains a single entry. The exact target object and target method of the delegate are unspecified. In particular, it is unspecified whether the target object of the delegate is <code class="prettyprint">null</code>, the <code class="prettyprint">this</code> value of the enclosing function member, or some other object.</p>

<p>Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance. The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments. This rule permits code such as the following to be optimized.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="kt">double</span> <span class="nf">Function</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">double</span><span class="p">[]</span> <span class="nf">Apply</span><span class="p">(</span><span class="kt">double</span><span class="p">[]</span> <span class="n">a</span><span class="p">,</span> <span class="n">Function</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span><span class="p">[]</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">double</span><span class="p">[]</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span><span class="p">[]</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="p">=</span> <span class="nf">Apply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="n">b</span> <span class="p">=</span> <span class="nf">Apply</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method. Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</p>

<h3 id="evaluation-of-anonymous-function-conversions-to-expression-tree-types">Evaluation of anonymous function conversions to expression tree types</h3>

<p>Conversion of an anonymous function to an expression tree type produces an expression tree (<a href="types.md#expression-tree-types">Expression tree types</a>). More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself. The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</p>

<h3 id="implementation-example">Implementation example</h3>

<p>This section describes a possible implementation of anonymous function conversions in terms of other C# constructs. The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible. It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</p>

<p>The remainder of this section gives several examples of code that contains anonymous functions with different characteristics. For each example, a corresponding translation to code that uses only other C# constructs is provided. In the examples, the identifier <code class="prettyprint">D</code> is assumed by represent the following delegate type:
<code class="prettyprint">csharp
public delegate void D();
</code></p>

<p>The simplest form of an anonymous function is one that captures no outer variables:
<code class="prettyprint">csharp
class Test
{
    static void F() {
        D d = () =&gt; { Console.WriteLine(&quot;test&quot;); };
    }
}
</code></p>

<p>This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:
&ldquo;`csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }</p>

<p>static void __Method1() {
        Console.WriteLine(&quot;test&rdquo;);
    }
}
&ldquo;`</p>

<p>In the following example, the anonymous function references instance members of <code class="prettyprint">this</code>:
&rdquo;`csharp
class Test
{
    int x;</p>

<p>void F() {
        D d = () =&gt; { Console.WriteLine(x); };
    }
}
&ldquo;`</p>

<p>This can be translated to a compiler generated instance method containing the code of the anonymous function:
&rdquo;`csharp
class Test
{
    int x;</p>

<p>void F() {
        D d = new D(__Method1);
    }</p>

<p>void __Method1() {
        Console.WriteLine(x);
    }
}
&ldquo;`</p>

<p>In this example, the anonymous function captures a local variable:
<code class="prettyprint">csharp
class Test
{
    void F() {
        int y = 123;
        D d = () =&gt; { Console.WriteLine(y); };
    }
}
</code></p>

<p>The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate. This can be achieved by &quot;hoisting&rdquo; the local variable into a field of a compiler generated class. Instantiation of the local variable (<a href="expressions.md#instantiation-of-local-variables">Instantiation of local variables</a>) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class. Furthermore, the anonymous function becomes an instance method of the compiler generated class:
&ldquo;`csharp
class Test
{
    void F() {
        <strong>Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(</strong>locals1.__Method1);
    }</p>

<p>class __Locals1
    {
        public int y;</p>

<p>public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
&rdquo;`</p>

<p>Finally, the following anonymous function captures <code class="prettyprint">this</code> as well as two local variables with different lifetimes:
&ldquo;`csharp
class Test
{
    int x;</p>

<p>void F() {
        int y = 123;
        for (int i = 0; i &lt; 10; i++) {
            int z = i * 2;
            D d = () =&gt; { Console.WriteLine(x + y + z); };
        }
    }
}
&rdquo;`</p>

<p>Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes. An instance of <code class="prettyprint">__Locals2</code>, the compiler generated class for the inner statement block, contains the local variable <code class="prettyprint">z</code> and a field that references an instance of <code class="prettyprint">__Locals1</code>.  An instance of <code class="prettyprint">__Locals1</code>, the compiler generated class for the outer statement block, contains the local variable <code class="prettyprint">y</code> and a field that references <code class="prettyprint">this</code> of the enclosing function member. With these data structures it is possible to reach all captured outer variables through an instance of <code class="prettyprint">__Local2</code>, and the code of the anonymous function can thus be implemented as an instance method of that class.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">__Locals1</span> <span class="n">__locals1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">__Locals1</span><span class="p">();</span>
        <span class="n">__locals1</span><span class="p">.</span><span class="n">__this</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="n">__locals1</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="m">123</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">__Locals2</span> <span class="n">__locals2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">__Locals2</span><span class="p">();</span>
            <span class="n">__locals2</span><span class="p">.</span><span class="n">__locals1</span> <span class="p">=</span> <span class="n">__locals1</span><span class="p">;</span>
            <span class="n">__locals2</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">i</span> <span class="p">*</span> <span class="m">2</span><span class="p">;</span>
            <span class="n">D</span> <span class="n">d</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">__locals2</span><span class="p">.</span><span class="n">__Method1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Locals1</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Test</span> <span class="n">__this</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Locals2</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">__Locals1</span> <span class="n">__locals1</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">__Method1</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">__locals1</span><span class="p">.</span><span class="n">__this</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">__locals1</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">z</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects. The advantage of this approach is that it allows the &ldquo;lifted&rdquo; local variables to be shared between delegates and expression trees.</p>

<h2 id="method-group-conversions">Method group conversions</h2>

<p>An implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from a method group (<a href="expressions.md#expression-classifications">Expression classifications</a>) to a compatible delegate type. Given a delegate type <code class="prettyprint">D</code> and an expression <code class="prettyprint">E</code> that is classified as a method group, an implicit conversion exists from <code class="prettyprint">E</code> to <code class="prettyprint">D</code> if <code class="prettyprint">E</code> contains at least one method that is applicable in its normal form (<a href="expressions.md#applicable-function-member">Applicable function member</a>) to an argument list constructed by use of the parameter types and modifiers of <code class="prettyprint">D</code>, as described in the following.</p>

<p>The compile-time application of a conversion from a method group <code class="prettyprint">E</code> to a delegate type <code class="prettyprint">D</code> is described in the following. Note that the existence of an implicit conversion from <code class="prettyprint">E</code> to <code class="prettyprint">D</code> does not guarantee that the compile-time application of the conversion will succeed without error.</p>

<ul>
<li> A single method <code class="prettyprint">M</code> is selected corresponding to a method invocation (<a href="expressions.md#method-invocations">Method invocations</a>) of the form <code class="prettyprint">E(A)</code>, with the following modifications:

<ul>
<li>The argument list <code class="prettyprint">A</code> is a list of expressions, each classified as a variable and with the type and modifier (<code class="prettyprint">ref</code> or <code class="prettyprint">out</code>) of the corresponding parameter in the <em>formal_parameter_list</em> of <code class="prettyprint">D</code>.</li>
<li>The candidate methods considered are only those methods that are applicable in their normal form (<a href="expressions.md#applicable-function-member">Applicable function member</a>), not those applicable only in their expanded form.</li>
</ul></li>
<li> If the algorithm of <a href="expressions.md#method-invocations">Method invocations</a> produces an error, then a compile-time error occurs. Otherwise the algorithm produces a single best method <code class="prettyprint">M</code> having the same number of parameters as <code class="prettyprint">D</code> and the conversion is considered to exist.</li>
<li> The selected method <code class="prettyprint">M</code> must be compatible (<a href="delegates.md#delegate-compatibility">Delegate compatibility</a>) with the delegate type <code class="prettyprint">D</code>, or otherwise, a compile-time error occurs.</li>
<li> If the selected method <code class="prettyprint">M</code> is an instance method, the instance expression associated with <code class="prettyprint">E</code> determines the target object of the delegate.</li>
<li> If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</li>
<li> The result of the conversion is a value of typeÂ <code class="prettyprint">D</code>, namely a newly created delegate that refers to the selected method and target object.</li>
<li> Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of <a href="expressions.md#method-invocations">Method invocations</a> fails to find an instance method but succeeds in processing the invocation of <code class="prettyprint">E(A)</code> as an extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). A delegate thus created captures the extension method as well as its first argument.</li>
</ul>

<p>The following example demonstrates method group conversions:
&ldquo;`csharp
delegate string D1(object o);</p>

<p>delegate object D2(string s);</p>

<p>delegate object D3();</p>

<p>delegate string D4(object o, params object[] a);</p>

<p>delegate string D5(int i);</p>

<p>class Test
{
    static string F(object o) {&hellip;}</p>

<p>static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error &ndash; not applicable
        D4 d4 = F;            // Error &ndash; not applicable in normal form
        D5 d5 = F;            // Error &ndash; applicable but not compatible</p>

<p>}
}
&rdquo;`</p>

<p>The assignment to <code class="prettyprint">d1</code> implicitly converts the method group <code class="prettyprint">F</code> to a value of type <code class="prettyprint">D1</code>.</p>

<p>The assignment to <code class="prettyprint">d2</code> shows how it is possible to create a delegate to a method that has less derived (contra-variant) parameter types and a more derived (covariant) return type.</p>

<p>The assignment to <code class="prettyprint">d3</code> shows how no conversion exists if the method is not applicable.</p>

<p>The assignment to <code class="prettyprint">d4</code> shows how the method must be applicable in its normal form.</p>

<p>The assignment to <code class="prettyprint">d5</code> shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</p>

<p>As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion. Thus, the example
<code class="prettyprint">csharp
object obj = new EventHandler(myDialog.OkClick);
</code>
could instead be written
<code class="prettyprint">csharp
object obj = (EventHandler)myDialog.OkClick;
</code></p>

<p>Method groups may influence overload resolution, and participate in type inference. See <a href="expressions.md#function-members">Function members</a> for further details.</p>

<p>The run-time evaluation of a method group conversion proceeds as follows:</p>

<ul>
<li> If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with <code class="prettyprint">E</code>:

<ul>
<li>The instance expression is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li>If the instance expression is of a <em>reference_type</em>, the value computed by the instance expression becomes the target object. If the selected method is an instance method and the target object is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li>If the instance expression is of a <em>value_type</em>, a boxing operation (<a href="types.md#boxing-conversions">Boxing conversions</a>) is performed to convert the value to an object, and this object becomes the target object.</li>
</ul></li>
<li> Otherwise the selected method is part of a static method call, and the target object of the delegate is <code class="prettyprint">null</code>.</li>
<li> A new instance of the delegate type <code class="prettyprint">D</code> is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li> The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</li>
</ul>

          <h1 id="expressions">Expressions</h1>

<p>An expression is a sequence of operators and operands. This chapter defines the syntax, order of evaluation of operands and operators, and meaning of expressions.</p>

<h2 id="expression-classifications">Expression classifications</h2>

<p>An expression is classified as one of the following:</p>

<ul>
<li> A value. Every value has an associated type.</li>
<li> A variable. Every variable has an associated type, namely the declared type of the variable.</li>
<li> A namespace. An expression with this classification can only appear as the left hand side of a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>). In any other context, an expression classified as a namespace causes a compile-time error.</li>
<li> A type. An expression with this classification can only appear as the left hand side of a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), or as an operand for the <code class="prettyprint">as</code> operator (<a href="expressions.md#the-as-operator">The as operator</a>), the <code class="prettyprint">is</code> operator (<a href="expressions.md#the-is-operator">The is operator</a>), or the <code class="prettyprint">typeof</code> operator (<a href="expressions.md#the-typeof-operator">The typeof operator</a>). In any other context, an expression classified as a type causes a compile-time error.</li>
<li> A method group, which is a set of overloaded methods resulting from a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>). A method group may have an associated instance expression and an associated type argument list. When an instance method is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>). A method group is permitted in an <em>invocation_expression</em> (<a href="expressions.md#invocation-expressions">Invocation expressions</a>) , a <em>delegate_creation_expression</em> (<a href="expressions.md#delegate-creation-expressions">Delegate creation expressions</a>) and as the left hand side of an is operator, and can be implicitly converted to a compatible delegate type (<a href="conversions.md#method-group-conversions">Method group conversions</a>). In any other context, an expression classified as a method group causes a compile-time error.</li>
<li> A null literal. An expression with this classification can be implicitly converted to a reference type or nullable type.</li>
<li> An anonymous function. An expression with this classification can be implicitly converted to a compatible delegate type or expression tree type.</li>
<li> A property access. Every property access has an associated type, namely the type of the property. Furthermore, a property access may have an associated instance expression. When an accessor (the <code class="prettyprint">get</code> or <code class="prettyprint">set</code> block) of an instance property access is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
<li> An event access. Every event access has an associated type, namely the type of the event. Furthermore, an event access may have an associated instance expression. An event access may appear as the left hand operand of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators (<a href="expressions.md#event-assignment">Event assignment</a>). In any other context, an expression classified as an event access causes a compile-time error.</li>
<li> An indexer access. Every indexer access has an associated type, namely the element type of the indexer. Furthermore, an indexer access has an associated instance expression and an associated argument list. When an accessor (the <code class="prettyprint">get</code> or <code class="prettyprint">set</code> block) of an indexer access is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>), and the result of evaluating the argument list becomes the parameter list of the invocation.</li>
<li> Nothing. This occurs when the expression is an invocation of a method with a return type of <code class="prettyprint">void</code>. An expression classified as nothing is only valid in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>).</li>
</ul>

<p>The final result of an expression is never a namespace, type, method group, or event access. Rather, as noted above, these categories of expressions are intermediate constructs that are only permitted in certain contexts.</p>

<p>A property access or indexer access is always reclassified as a value by performing an invocation of the <em>get accessor</em> or the <em>set accessor</em>. The particular accessor is determined by the context of the property or indexer access: If the access is the target of an assignment, the <em>set accessor</em> is invoked to assign a new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). Otherwise, the <em>get accessor</em> is invoked to obtain the current value (<a href="expressions.md#values-of-expressions">Values of expressions</a>).</p>

<h3 id="values-of-expressions">Values of expressions</h3>

<p>Most of the constructs that involve an expression ultimately require the expression to denote a <strong><em>value</em></strong>. In such cases, if the actual expression denotes a namespace, a type, a method group, or nothing, a compile-time error occurs. However, if the expression denotes a property access, an indexer access, or a variable, the value of the property, indexer, or variable is implicitly substituted:</p>

<ul>
<li> The value of a variable is simply the value currently stored in the storage location identified by the variable. A variable must be considered definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before its value can be obtained, or otherwise a compile-time error occurs.</li>
<li> The value of a property access expression is obtained by invoking the <em>get accessor</em> of the property. If the property has no <em>get accessor</em>, a compile-time error occurs. Otherwise, a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is performed, and the result of the invocation becomes the value of the property access expression.</li>
<li> The value of an indexer access expression is obtained by invoking the <em>get accessor</em> of the indexer. If the indexer has no <em>get accessor</em>, a compile-time error occurs. Otherwise, a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is performed with the argument list associated with the indexer access expression, and the result of the invocation becomes the value of the indexer access expression.</li>
</ul>

<h2 id="static-and-dynamic-binding">Static and Dynamic Binding</h2>

<p>The process of determining the meaning of an operation based on the type or value of constituent expressions (arguments, operands, receivers) is often referred to as <strong><em>binding</em></strong>. For instance the meaning of a method call is determined based on the type of the receiver and arguments. The meaning of an operator is determined based on the type of its operands.</p>

<p>In C# the meaning of an operation is usually determined at compile-time, based on the compile-time type of its constituent expressions. Likewise, if an expression contains an error, the error is detected and reported by the compiler. This approach is known as <strong><em>static binding</em></strong>.</p>

<p>However, if an expression is a dynamic expression (i.e. has the type <code class="prettyprint">dynamic</code>) this indicates that any binding that it participates in should be based on its run-time type (i.e. the actual type of the object it denotes at run-time) rather than the type it has at compile-time. The binding of such an operation is therefore deferred until the time where the operation is to be executed during the running of the program. This is referred to as <strong><em>dynamic binding</em></strong>.</p>

<p>When an operation is dynamically bound, little or no checking is performed by the compiler. Instead if the run-time binding fails, errors are reported as exceptions at run-time.</p>

<p>The following operations in C# are subject to binding:</p>

<ul>
<li> Member access: <code class="prettyprint">e.M</code></li>
<li> Method invocation: <code class="prettyprint">e.M(e1, ..., eN)</code></li>
<li> Delegate invocaton:<code class="prettyprint">e(e1, ..., eN)</code></li>
<li> Element access: <code class="prettyprint">e[e1, ..., eN]</code></li>
<li> Object creation: <code class="prettyprint">new C(e1, ..., eN)</code></li>
<li> Overloaded unary operators: <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, <code class="prettyprint">true</code>, <code class="prettyprint">false</code></li>
<li> Overloaded binary operators: <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">||</code>, <code class="prettyprint">??</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">==</code>,<code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, <code class="prettyprint">&lt;=</code></li>
<li> Assignment operators: <code class="prettyprint">=</code>, <code class="prettyprint">+=</code>, <code class="prettyprint">-=</code>, <code class="prettyprint">*=</code>, <code class="prettyprint">/=</code>, <code class="prettyprint">%=</code>, <code class="prettyprint">&amp;=</code>, <code class="prettyprint">|=</code>, <code class="prettyprint">^=</code>, <code class="prettyprint">&lt;&lt;=</code>, <code class="prettyprint">&gt;&gt;=</code></li>
<li> Implicit and explicit conversions</li>
</ul>

<p>When no dynamic expressions are involved, C# defaults to static binding, which means that the compile-time types of constituent expressions are used in the selection process. However, when one of the constituent expressions in the operations listed above is a dynamic expression, the operation is instead dynamically bound.</p>

<h3 id="binding-time">Binding-time</h3>

<p>Static binding takes place at compile-time, whereas dynamic binding takes place at run-time. In the following sections, the term <strong><em>binding-time</em></strong> refers to either compile-time or run-time, depending on when the binding takes place.</p>

<p>The following example illustrates the notions of static and dynamic binding and of binding-time:
&ldquo;`csharp
object  o = 5;
dynamic d = 5;</p>

<p>Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
&rdquo;`</p>

<p>The first two calls are statically bound: the overload of <code class="prettyprint">Console.WriteLine</code> is picked based on the compile-time type of their argument. Thus, the binding-time is compile-time.</p>

<p>The third call is dynamically bound: the overload of <code class="prettyprint">Console.WriteLine</code> is picked based on the run-time type of its argument. This happens because the argument is a dynamic expression &ndash; its compile-time type is <code class="prettyprint">dynamic</code>. Thus, the binding-time for the third call is run-time.</p>

<h3 id="dynamic-binding">Dynamic binding</h3>

<p>The purpose of dynamic binding is to allow C# programs to interact with <strong><em>dynamic objects</em></strong>, i.e. objects that do not follow the normal rules of the C# type system. Dynamic objects may be objects from other programming languages with different types systems, or they may be objects that are programmatically setup to implement their own binding semantics for different operations.</p>

<p>The mechanism by which a dynamic object implements its own semantics is implementation defined. A given interface &ndash; again implementation defined &ndash; is implemented by dynamic objects to signal to the C# run-time that they have special semantics. Thus, whenever operations on a dynamic object are dynamically bound, their own binding semantics, rather than those of C# as specified in this document, take over.</p>

<p>While the purpose of dynamic binding is to allow interoperation with dynamic objects, C# allows dynamic binding on all objects, whether they are dynamic or not. This allows for a smoother integration of dynamic objects, as the results of operations on them may not themselves be dynamic objects, but are still of a type unknown to the programmer at compile-time. Also dynamic binding can help eliminate error-prone reflection-based code even when no objects involved are dynamic objects.</p>

<p>The following sections describe for each construct in the language exactly when dynamic binding is applied, what compile time checking &ndash; if any &ndash; is applied, and what the compile-time result and expression classification is.</p>

<h3 id="types-of-constituent-expressions">Types of constituent expressions</h3>

<p>When an operation is statically bound, the type of a constituent expression (e.g. a receiver, and argument, an index or an operand) is always considered to be the compile-time type of that expression.</p>

<p>When an operation is dynamically bound, the type of a constituent expression is determined in different ways depending on the compile-time type of the constituent expression:</p>

<ul>
<li> A constituent expression of compile-time type <code class="prettyprint">dynamic</code> is considered to have the type of the actual value that the expression evaluates to at runtime</li>
<li> A constituent expression whose compile-time type is a type parameter is considered to have the type which the type parameter is bound to at runtime</li>
<li> Otherwise the constituent expression is considered to have its compile-time type.</li>
</ul>

<h2 id="operators">Operators</h2>

<p>Expressions are constructed from <strong><em>operands</em></strong> and <strong><em>operators</em></strong>. The operators of an expression indicate which operations to apply to the operands. Examples of operators include <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, and <code class="prettyprint">new</code>. Examples of operands include literals, fields, local variables, and expressions.</p>

<p>There are three kinds of operators:</p>

<ul>
<li> Unary operators. The unary operators take one operand and use either prefix notation (such as <code class="prettyprint">--x</code>) or postfix notation (such as <code class="prettyprint">x++</code>).</li>
<li> Binary operators. The binary operators take two operands and all use infix notation (such as <code class="prettyprint">x + y</code>).</li>
<li> Ternary operator. Only one ternary operator, <code class="prettyprint">?:</code>, exists; it takes three operands and uses infix notation (<code class="prettyprint">c ? x : y</code>).</li>
</ul>

<p>The order of evaluation of operators in an expression is determined by the <strong><em>precedence</em></strong> and <strong><em>associativity</em></strong> of the operators (<a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>).</p>

<p>Operands in an expression are evaluated from left to right. For example, in <code class="prettyprint">F(i) + G(i++) * H(i)</code>, method <code class="prettyprint">F</code> is called using the old value of <code class="prettyprint">i</code>, then method <code class="prettyprint">G</code> is called with the old value of <code class="prettyprint">i</code>, and, finally, method <code class="prettyprint">H</code> is called with the new value of <code class="prettyprint">i</code>. This is separate from and unrelated to operator precedence.</p>

<p>Certain operators can be <strong><em>overloaded</em></strong>. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type (<a href="expressions.md#operator-overloading">Operator overloading</a>).</p>

<h3 id="operator-precedence-and-associativity">Operator precedence and associativity</h3>

<p>When an expression contains multiple operators, the <strong><em>precedence</em></strong> of the operators controls the order in which the individual operators are evaluated. For example, the expression <code class="prettyprint">x + y * z</code> is evaluated as <code class="prettyprint">x + (y * z)</code> because the <code class="prettyprint">*</code> operator has higher precedence than the binary <code class="prettyprint">+</code> operator. The precedence of an operator is established by the definition of its associated grammar production. For example, an <em>additive_expression</em> consists of a sequence of <em>multiplicative_expression*s separated by <code class="prettyprint">+</code> or <code class="prettyprint">-</code> operators, thus giving the <code class="prettyprint">+</code> and <code class="prettyprint">-</code> operators lower precedence than the `</em><code class="prettyprint">,</code>/<code class="prettyprint">, and</code>%` operators.</p>

<p>The following table summarizes all operators in order of precedence from highest to lowest:</p>

<table><thead>
<tr>
<th><strong>Section</strong></th>
<th><strong>Category</strong></th>
<th><strong>Operators</strong></th>
</tr>
</thead><tbody>
<tr>
<td><a href="expressions.md#primary-expressions">Primary expressions</a></td>
<td>Primary</td>
<td><code class="prettyprint">x.y</code>  <code class="prettyprint">f(x)</code>  <code class="prettyprint">a[x]</code>  <code class="prettyprint">x++</code>  <code class="prettyprint">x--</code>  <code class="prettyprint">new</code>  <code class="prettyprint">typeof</code>  <code class="prettyprint">default</code>  <code class="prettyprint">checked</code>  <code class="prettyprint">unchecked</code>  <code class="prettyprint">delegate</code></td>
</tr>
<tr>
<td><a href="expressions.md#unary-operators">Unary operators</a></td>
<td>Unary</td>
<td><code class="prettyprint">+</code>  <code class="prettyprint">*</code>  <code class="prettyprint">!</code>  <code class="prettyprint">~</code>  <code class="prettyprint">++x</code>  <code class="prettyprint">--x</code>  <code class="prettyprint">(T)x</code></td>
</tr>
<tr>
<td><a href="expressions.md#arithmetic-operators">Arithmetic operators</a></td>
<td>Multiplicative</td>
<td><code class="prettyprint">*</code>  <code class="prettyprint">/</code>  <code class="prettyprint">%</code></td>
</tr>
<tr>
<td><a href="expressions.md#arithmetic-operators">Arithmetic operators</a></td>
<td>Additive</td>
<td><code class="prettyprint">+</code>  <code class="prettyprint">-</code></td>
</tr>
<tr>
<td><a href="expressions.md#shift-operators">Shift operators</a></td>
<td>Shift</td>
<td><code class="prettyprint">&lt;&lt;</code>  <code class="prettyprint">&gt;&gt;</code></td>
</tr>
<tr>
<td><a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a></td>
<td>Relational and type testing</td>
<td><code class="prettyprint">&lt;</code>  <code class="prettyprint">&gt;</code>  <code class="prettyprint">&lt;=</code>  <code class="prettyprint">&gt;=</code>  <code class="prettyprint">is</code>  <code class="prettyprint">as</code></td>
</tr>
<tr>
<td><a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a></td>
<td>Equality</td>
<td><code class="prettyprint">==</code>  <code class="prettyprint">!=</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical AND</td>
<td><code class="prettyprint">&amp;</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical XOR</td>
<td><code class="prettyprint">^</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical OR</td>
<td>`\</td>
</tr>
<tr>
<td><a href="expressions.md#conditional-logical-operators">Conditional logical operators</a></td>
<td>Conditional AND</td>
<td><code class="prettyprint">&amp;&amp;</code></td>
</tr>
<tr>
<td><a href="expressions.md#conditional-logical-operators">Conditional logical operators</a></td>
<td>Conditional OR</td>
<td>`\</td>
</tr>
<tr>
<td><a href="expressions.md#the-null-coalescing-operator">The null coalescing operator</a></td>
<td>Null coalescing</td>
<td><code class="prettyprint">??</code></td>
</tr>
<tr>
<td><a href="expressions.md#conditional-operator">Conditional operator</a></td>
<td>Conditional</td>
<td><code class="prettyprint">?:</code></td>
</tr>
<tr>
<td><a href="expressions.md#assignment-operators">Assignment operators</a>, <a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a></td>
<td>Assignment and lambda expression</td>
<td><code class="prettyprint">=</code>  <code class="prettyprint">*=</code>  <code class="prettyprint">/=</code>  <code class="prettyprint">%=</code>  <code class="prettyprint">+=</code>  <code class="prettyprint">-=</code>  <code class="prettyprint">&lt;&lt;=</code>  <code class="prettyprint">&gt;&gt;=</code>  <code class="prettyprint">&amp;=</code>  <code class="prettyprint">^=</code>  `\</td>
</tr>
</tbody></table>

<p>When an operand occurs between two operators with the same precedence, the associativity of the operators controls the order in which the operations are performed:</p>

<ul>
<li> Except for the assignment operators and the null coalescing operator, all binary operators are <strong><em>left-associative</em></strong>, meaning that operations are performed from left to right. For example, <code class="prettyprint">x + y + z</code> is evaluated as <code class="prettyprint">(x + y) + z</code>.</li>
<li> The assignment operators, the null coalescing operator and the conditional operator (<code class="prettyprint">?:</code>) are <strong><em>right-associative</em></strong>, meaning that operations are performed from right to left. For example, <code class="prettyprint">x = y = z</code> is evaluated as <code class="prettyprint">x = (y = z)</code>.</li>
</ul>

<p>Precedence and associativity can be controlled using parentheses. For example, <code class="prettyprint">x + y * z</code> first multiplies <code class="prettyprint">y</code> by <code class="prettyprint">z</code> and then adds the result to <code class="prettyprint">x</code>, but <code class="prettyprint">(x + y) * z</code> first adds <code class="prettyprint">x</code> and <code class="prettyprint">y</code> and then multiplies the result by <code class="prettyprint">z</code>.</p>

<h3 id="operator-overloading">Operator overloading</h3>

<p>All unary and binary operators have predefined implementations that are automatically available in any expression. In addition to the predefined implementations, user-defined implementations can be introduced by including <code class="prettyprint">operator</code> declarations in classes and structs (<a href="classes.md#operators">Operators</a>). User-defined operator implementations always take precedence over predefined operator implementations: Only when no applicable user-defined operator implementations exist will the predefined operator implementations be considered, as described in <a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a> and <a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>.</p>

<p>The <strong><em>overloadable unary operators</em></strong> are:
<code class="prettyprint">csharp
+   -   !   ~   ++   --   true   false
</code></p>

<p>Although <code class="prettyprint">true</code> and <code class="prettyprint">false</code> are not used explicitly in expressions (and therefore are not included in the precedence table in <a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>), they are considered operators because they are invoked in several expression contexts: boolean expressions (<a href="expressions.md#boolean-expressions">Boolean expressions</a>) and expressions involving the conditional (<a href="expressions.md#conditional-operator">Conditional operator</a>), and conditional logical operators (<a href="expressions.md#conditional-logical-operators">Conditional logical operators</a>).</p>

<p>The <strong><em>overloadable binary operators</em></strong> are:
<code class="prettyprint">csharp
+   -   *   /   %   &amp;   |   ^   &lt;&lt;   &gt;&gt;   ==   !=   &gt;   &lt;   &gt;=   &lt;=
</code></p>

<p>Only the operators listed above can be overloaded. In particular, it is not possible to overload member access, method invocation, or the <code class="prettyprint">=</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">||</code>, <code class="prettyprint">??</code>, <code class="prettyprint">?:</code>, <code class="prettyprint">=&gt;</code>, <code class="prettyprint">checked</code>, <code class="prettyprint">unchecked</code>, <code class="prettyprint">new</code>, <code class="prettyprint">typeof</code>, <code class="prettyprint">default</code>, <code class="prettyprint">as</code>, and <code class="prettyprint">is</code> operators.</p>

<p>When a binary operator is overloaded, the corresponding assignment operator, if any, is also implicitly overloaded. For example, an overload of operator <code class="prettyprint">*</code> is also an overload of operator <code class="prettyprint">*=</code>. This is described further in <a href="expressions.md#compound-assignment">Compound assignment</a>. Note that the assignment operator itself (<code class="prettyprint">=</code>) cannot be overloaded. An assignment always performs a simple bit-wise copy of a value into a variable.</p>

<p>Cast operations, such as <code class="prettyprint">(T)x</code>, are overloaded by providing user-defined conversions (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>).</p>

<p>Element access, such as <code class="prettyprint">a[x]</code>, is not considered an overloadable operator. Instead, user-defined indexing is supported through indexers (<a href="classes.md#indexers">Indexers</a>).</p>

<p>In expressions, operators are referenced using operator notation, and in declarations, operators are referenced using functional notation. The following table shows the relationship between operator and functional notations for unary and binary operators. In the first entry, <em>op</em> denotes any overloadable unary prefix operator. In the second entry, <em>op</em> denotes the unary postfix <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators. In the third entry, <em>op</em> denotes any overloadable binary operator.</p>

<table><thead>
<tr>
<th><strong>Operator notation</strong></th>
<th><strong>Functional notation</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">op x</code></td>
<td><code class="prettyprint">operator op(x)</code></td>
</tr>
<tr>
<td><code class="prettyprint">x op</code></td>
<td><code class="prettyprint">operator op(x)</code></td>
</tr>
<tr>
<td><code class="prettyprint">x op y</code></td>
<td><code class="prettyprint">operator op(x,y)</code></td>
</tr>
</tbody></table>

<p>User-defined operator declarations always require at least one of the parameters to be of the class or struct type that contains the operator declaration. Thus, it is not possible for a user-defined operator to have the same signature as a predefined operator.</p>

<p>User-defined operator declarations cannot modify the syntax, precedence, or associativity of an operator. For example, the <code class="prettyprint">/</code> operator is always a binary operator, always has the precedence level specified in <a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>, and is always left-associative.</p>

<p>While it is possible for a user-defined operator to perform any computation it pleases, implementations that produce results other than those that are intuitively expected are strongly discouraged. For example, an implementation of <code class="prettyprint">operator ==</code> should compare the two operands for equality and return an appropriate <code class="prettyprint">bool</code> result.</p>

<p>The descriptions of individual operators in <a href="expressions.md#primary-expressions">Primary expressions</a> through <a href="expressions.md#conditional-logical-operators">Conditional logical operators</a> specify the predefined implementations of the operators and any additional rules that apply to each operator. The descriptions make use of the terms <strong><em>unary operator overload resolution</em></strong>, <strong><em>binary operator overload resolution</em></strong>, and <strong><em>numeric promotion</em></strong>, definitions of which are found in the following sections.</p>

<h3 id="unary-operator-overload-resolution">Unary operator overload resolution</h3>

<p>An operation of the form <code class="prettyprint">op x</code> or <code class="prettyprint">x op</code>, where <code class="prettyprint">op</code> is an overloadable unary operator, and <code class="prettyprint">x</code> is an expression of type <code class="prettyprint">X</code>, is processed as follows:</p>

<ul>
<li> The set of candidate user-defined operators provided by <code class="prettyprint">X</code> for the operation <code class="prettyprint">operator op(x)</code> is determined using the rules of <a href="expressions.md#candidate-user-defined-operators">Candidate user-defined operators</a>.</li>
<li> If the set of candidate user-defined operators is not empty, then this becomes the set of candidate operators for the operation. Otherwise, the predefined unary <code class="prettyprint">operator op</code> implementations, including their lifted forms, become the set of candidate operators for the operation. The predefined implementations of a given operator are specified in the description of the operator (<a href="expressions.md#primary-expressions">Primary expressions</a> and <a href="expressions.md#unary-operators">Unary operators</a>).</li>
<li> The overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a> are applied to the set of candidate operators to select the best operator with respect to the argument list <code class="prettyprint">(x)</code>, and this operator becomes the result of the overload resolution process. If overload resolution fails to select a single best operator, a binding-time error occurs.</li>
</ul>

<h3 id="binary-operator-overload-resolution">Binary operator overload resolution</h3>

<p>An operation of the form <code class="prettyprint">x op y</code>, where <code class="prettyprint">op</code> is an overloadable binary operator, <code class="prettyprint">x</code> is an expression of type <code class="prettyprint">X</code>, and <code class="prettyprint">y</code> is an expression of type <code class="prettyprint">Y</code>, is processed as follows:</p>

<ul>
<li> The set of candidate user-defined operators provided by <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> for the operation <code class="prettyprint">operator op(x,y)</code> is determined. The set consists of the union of the candidate operators provided by <code class="prettyprint">X</code> and the candidate operators provided by <code class="prettyprint">Y</code>, each determined using the rules of <a href="expressions.md#candidate-user-defined-operators">Candidate user-defined operators</a>. If <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> are the same type, or if <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> are derived from a common base type, then shared candidate operators only occur in the combined set once.</li>
<li> If the set of candidate user-defined operators is not empty, then this becomes the set of candidate operators for the operation. Otherwise, the predefined binary <code class="prettyprint">operator op</code> implementations, including their lifted forms,  become the set of candidate operators for the operation. The predefined implementations of a given operator are specified in the description of the operator (<a href="expressions.md#arithmetic-operators">Arithmetic operators</a> through <a href="expressions.md#conditional-logical-operators">Conditional logical operators</a>). For predefined enum and delegate operators, the only operators considered are those defined by an enum or delegate type that is the binding-time type of one of the operands.</li>
<li> The overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a> are applied to the set of candidate operators to select the best operator with respect to the argument list <code class="prettyprint">(x,y)</code>, and this operator becomes the result of the overload resolution process. If overload resolution fails to select a single best operator, a binding-time error occurs.</li>
</ul>

<h3 id="candidate-user-defined-operators">Candidate user-defined operators</h3>

<p>Given a type <code class="prettyprint">T</code> and an operation <code class="prettyprint">operator op(A)</code>, where <code class="prettyprint">op</code> is an overloadable operator and <code class="prettyprint">A</code> is an argument list, the set of candidate user-defined operators provided by <code class="prettyprint">T</code> for <code class="prettyprint">operator op(A)</code> is determined as follows:</p>

<ul>
<li> Determine the type <code class="prettyprint">T0</code>. If <code class="prettyprint">T</code> is a nullable type, <code class="prettyprint">T0</code> is its underlying type, otherwise <code class="prettyprint">T0</code> is equal to <code class="prettyprint">T</code>.</li>
<li> For all <code class="prettyprint">operator op</code> declarations in <code class="prettyprint">T0</code> and all lifted forms of such operators, if at least one operator is applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>) with respect to the argument list <code class="prettyprint">A</code>, then the set of candidate operators consists of all such applicable operators in <code class="prettyprint">T0</code>.</li>
<li> Otherwise, if <code class="prettyprint">T0</code> is <code class="prettyprint">object</code>, the set of candidate operators is empty.</li>
<li> Otherwise, the set of candidate operators provided by <code class="prettyprint">T0</code> is the set of candidate operators provided by the direct base class of <code class="prettyprint">T0</code>, or the effective base class of <code class="prettyprint">T0</code> if <code class="prettyprint">T0</code> is a type parameter.</li>
</ul>

<h3 id="numeric-promotions">Numeric promotions</h3>

<p>Numeric promotion consists of automatically performing certain implicit conversions of the operands of the predefined unary and binary numeric operators. Numeric promotion is not a distinct mechanism, but rather an effect of applying overload resolution to the predefined operators. Numeric promotion specifically does not affect evaluation of user-defined operators, although user-defined operators can be implemented to exhibit similar effects.</p>

<p>As an example of numeric promotion, consider the predefined implementations of the binary <code class="prettyprint">*</code> operator:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">uint</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">long</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">ulong</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">float</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">double</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">decimal</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>When overload resolution rules (<a href="expressions.md#overload-resolution">Overload resolution</a>) are applied to this set of operators, the effect is to select the first of the operators for which implicit conversions exist from the operand types. For example, for the operation <code class="prettyprint">b * s</code>, where <code class="prettyprint">b</code> is a <code class="prettyprint">byte</code> and <code class="prettyprint">s</code> is a <code class="prettyprint">short</code>, overload resolution selects <code class="prettyprint">operator *(int,int)</code> as the best operator. Thus, the effect is that <code class="prettyprint">b</code> and <code class="prettyprint">s</code> are converted to <code class="prettyprint">int</code>, and the type of the result is <code class="prettyprint">int</code>. Likewise, for the operation <code class="prettyprint">i * d</code>, where <code class="prettyprint">i</code> is an <code class="prettyprint">int</code> and <code class="prettyprint">d</code> is a <code class="prettyprint">double</code>, overload resolution selects <code class="prettyprint">operator *(double,double)</code> as the best operator.</p>

<h4 id="unary-numeric-promotions">Unary numeric promotions</h4>

<p>Unary numeric promotion occurs for the operands of the predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, and <code class="prettyprint">~</code> unary operators. Unary numeric promotion simply consists of converting operands of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, or <code class="prettyprint">char</code> to type <code class="prettyprint">int</code>. Additionally, for the unary <code class="prettyprint">-</code> operator, unary numeric promotion converts operands of type <code class="prettyprint">uint</code> to type <code class="prettyprint">long</code>.</p>

<h4 id="binary-numeric-promotions">Binary numeric promotions</h4>

<p>Binary numeric promotion occurs for the operands of the predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, and <code class="prettyprint">&lt;=</code> binary operators. Binary numeric promotion implicitly converts both operands to a common type which, in case of the non-relational operators, also becomes the result type of the operation. Binary numeric promotion consists of applying the following rules, in the order they appear here:</p>

<ul>
<li> If either operand is of type <code class="prettyprint">decimal</code>, the other operand is converted to type <code class="prettyprint">decimal</code>, or a binding-time error occurs if the other operand is of type <code class="prettyprint">float</code> or <code class="prettyprint">double</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">double</code>, the other operand is converted to type <code class="prettyprint">double</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">float</code>, the other operand is converted to type <code class="prettyprint">float</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">ulong</code>, the other operand is converted to type <code class="prettyprint">ulong</code>, or a binding-time error occurs if the other operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">long</code>, the other operand is converted to type <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">uint</code> and the other operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, or <code class="prettyprint">int</code>, both operands are converted to type <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">uint</code>, the other operand is converted to type <code class="prettyprint">uint</code>.</li>
<li> Otherwise, both operands are converted to type <code class="prettyprint">int</code>.</li>
</ul>

<p>Note that the first rule disallows any operations that mix the <code class="prettyprint">decimal</code> type with the <code class="prettyprint">double</code> and <code class="prettyprint">float</code> types. The rule follows from the fact that there are no implicit conversions between the <code class="prettyprint">decimal</code> type and the <code class="prettyprint">double</code> and <code class="prettyprint">float</code> types.</p>

<p>Also note that it is not possible for an operand to be of type <code class="prettyprint">ulong</code> when the other operand is of a signed integral type. The reason is that no integral type exists that can represent the full range of <code class="prettyprint">ulong</code> as well as the signed integral types.</p>

<p>In both of the above cases, a cast expression can be used to explicitly convert one operand to a type that is compatible with the other operand.</p>

<p>In the example
<code class="prettyprint">csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
</code>
a binding-time error occurs because a <code class="prettyprint">decimal</code> cannot be multiplied by a <code class="prettyprint">double</code>. The error is resolved by explicitly converting the second operand to <code class="prettyprint">decimal</code>, as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">decimal</span> <span class="nf">AddPercent</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">percent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="p">(</span><span class="kt">decimal</span><span class="p">)(</span><span class="m">1.0</span> <span class="p">+</span> <span class="n">percent</span> <span class="p">/</span> <span class="m">100.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="lifted-operators">Lifted operators</h3>

<p><strong><em>Lifted operators</em></strong> permit predefined and user-defined operators that operate on non-nullable value types to also be used with nullable forms of those types. Lifted operators are constructed from predefined and user-defined operators that meet certain requirements, as described in the following:</p>

<ul>
<li><p>For the unary operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">+</span>  <span class="p">++</span>  <span class="p">-</span>  <span class="p">--</span>  <span class="p">!</span>  <span class="p">~</span>
</code></pre>
<p>a lifted form of an operator exists if the operand and result types are both non-nullable value types. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to the operand and result types. The lifted operator produces a null value if the operand is null. Otherwise, the lifted operator unwraps the operand, applies the underlying operator, and wraps the result.</p></li>
<li><p>For the binary operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">+</span>  <span class="p">-</span>  <span class="p">*</span>  <span class="p">/</span>  <span class="p">%</span>  <span class="p">&amp;</span>  <span class="p">|</span>  <span class="p">^</span>  <span class="p">&lt;&lt;</span>  <span class="p">&gt;&gt;</span>
</code></pre>
<p>a lifted form of an operator exists if the operand and result types are all non-nullable value types. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand and result type. The lifted operator produces a null value if one or both operands are null (an exception being the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators of the <code class="prettyprint">bool?</code> type, as described in <a href="expressions.md#boolean-logical-operators">Boolean logical operators</a>). Otherwise, the lifted operator unwraps the operands, applies the underlying operator, and wraps the result.</p></li>
<li><p>For the equality operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">==</span>  <span class="p">!=</span>
</code></pre>
<p>a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is <code class="prettyprint">bool</code>. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand type. The lifted operator considers two null values equal, and a null value unequal to any non-null value. If both operands are non-null, the lifted operator unwraps the operands and applies the underlying operator to produce the <code class="prettyprint">bool</code> result.</p></li>
<li><p>For the relational operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">&lt;</span>  <span class="p">&gt;</span>  <span class="p">&lt;=</span>  <span class="p">&gt;=</span>
</code></pre>
<p>a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is <code class="prettyprint">bool</code>. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand type. The lifted operator produces the value <code class="prettyprint">false</code> if one or both operands are null. Otherwise, the lifted operator unwraps the operands and applies the underlying operator to produce the <code class="prettyprint">bool</code> result.</p></li>
</ul>

<h2 id="member-lookup">Member lookup</h2>

<p>A member lookup is the process whereby the meaning of a name in the context of a type is determined. A member lookup can occur as part of evaluating a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) in an expression. If the <em>simple_name</em> or <em>member_access</em> occurs as the <em>primary_expression</em> of an <em>invocation_expression</em> (<a href="expressions.md#method-invocations">Method invocations</a>), the member is said to be invoked.</p>

<p>If a member is a method or event, or if it is a constant, field or property of either a delegate type (<a href="delegates.md#delegates">Delegates</a>) or the type <code class="prettyprint">dynamic</code> (<a href="types.md#the-dynamic-type">The dynamic type</a>), then the member is said to be <em>invocable</em>.</p>

<p>Member lookup considers not only the name of a member but also the number of type parameters the member has and whether the member is accessible. For the purposes of member lookup, generic methods and nested generic types have the number of type parameters indicated in their respective declarations and all other members have zero type parameters.</p>

<p>A member lookup of a nameÂ <code class="prettyprint">N</code> with <code class="prettyprint">K</code>Â type parameters in a typeÂ <code class="prettyprint">T</code> is processed as follows:</p>

<ul>
<li> First, a set of accessible members namedÂ <code class="prettyprint">N</code> is determined:

<ul>
<li>If <code class="prettyprint">T</code> is a type parameter, then the set is the union of the sets of accessible members namedÂ <code class="prettyprint">N</code> in each of the types specified as a primary constraint or secondary constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) forÂ <code class="prettyprint">T</code>, along with the set of accessible members namedÂ <code class="prettyprint">N</code> in <code class="prettyprint">object</code>.</li>
<li>Otherwise, the set consists of all accessible (<a href="basic-concepts.md#member-access">Member access</a>) members namedÂ <code class="prettyprint">N</code> inÂ <code class="prettyprint">T</code>, including inherited members and the accessible members namedÂ <code class="prettyprint">N</code> in <code class="prettyprint">object</code>. If <code class="prettyprint">T</code> is a constructed type, the set of members is obtained by substituting type arguments as described in <a href="classes.md#members-of-constructed-types">Members of constructed types</a>. Members that include an <code class="prettyprint">override</code> modifier are excluded from the set.</li>
</ul></li>
<li> Next, if <code class="prettyprint">K</code> is zero, all nested types whose declarations include type parameters are removed. If <code class="prettyprint">K</code> is not zero, all members with a different number of type parameters are removed. Note that when <code class="prettyprint">K</code> is zero, methods having type parameters are not removed, since the type inference process (<a href="expressions.md#type-inference">Type inference</a>) might be able to infer the type arguments.</li>
<li> Next, if the member is <em>invoked</em>, all non-<em>invocable</em> members are removed from the set.</li>
<li> Next, members that are hidden by other members are removed from the set. For every member <code class="prettyprint">S.M</code> in the set, where <code class="prettyprint">S</code> is the type in which the memberÂ <code class="prettyprint">M</code> is declared, the following rules are applied:

<ul>
<li>If <code class="prettyprint">M</code> is a constant, field, property, event, or enumeration member, then all members declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a type declaration, then all non-types declared in a base type of <code class="prettyprint">S</code> are removed from the set, and all type declarations with the same number of type parameters as <code class="prettyprint">M</code> declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a method, then all non-method members declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
</ul></li>
<li> Next, interface members that are hidden by class members are removed from the set. This step only has an effect if <code class="prettyprint">T</code> is a type parameter and <code class="prettyprint">T</code> has both an effective base class other than <code class="prettyprint">object</code> and a non-empty effective interface set (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For every member <code class="prettyprint">S.M</code> in the set, where <code class="prettyprint">S</code> is the type in which the member <code class="prettyprint">M</code> is declared, the following rules are applied if <code class="prettyprint">S</code> is a class declaration other than <code class="prettyprint">object</code>:

<ul>
<li>If <code class="prettyprint">M</code> is a constant, field, property, event, enumeration member, or type declaration, then all members declared in an interface declaration are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a method, then all non-method members declared in an interface declaration are removed from the set, and all methods with the same signature as <code class="prettyprint">M</code> declared in an interface declaration are removed from the set.</li>
</ul></li>
<li> Finally, having removed hidden members, the result of the lookup is determined:

<ul>
<li>If the set consists of a single member that is not a method, then this member is the result of the lookup.</li>
<li>Otherwise, if the set contains only methods, then this group of methods is the result of the lookup.</li>
<li>Otherwise, the lookup is ambiguous, and a binding-time error occurs.</li>
</ul></li>
</ul>

<p>For member lookups in types other than type parameters and interfaces, and member lookups in interfaces that are strictly single-inheritance (each interface in the inheritance chain has exactly zero or one direct base interface), the effect of the lookup rules is simply that derived members hide base members with the same name or signature. Such single-inheritance lookups are never ambiguous. The ambiguities that can possibly arise from member lookups in multiple-inheritance interfaces are described in <a href="interfaces.md#interface-member-access">Interface member access</a>.</p>

<h3 id="base-types">Base types</h3>

<p>For purposes of member lookup, a type <code class="prettyprint">T</code> is considered to have the following base types:</p>

<ul>
<li> If <code class="prettyprint">T</code> is <code class="prettyprint">object</code>, then <code class="prettyprint">T</code> has no base type.</li>
<li> If <code class="prettyprint">T</code> is an <em>enum_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Enum</code>, <code class="prettyprint">System.ValueType</code>, and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>struct_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>class_type</em>, the base types of <code class="prettyprint">T</code> are the base classes of <code class="prettyprint">T</code>, including the class type <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is an <em>interface_type</em>, the base types of <code class="prettyprint">T</code> are the base interfaces of <code class="prettyprint">T</code> and the class type <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is an <em>array_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Array</code> and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>delegate_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Delegate</code> and <code class="prettyprint">object</code>.</li>
</ul>

<h2 id="function-members">Function members</h2>

<p>Function members are members that contain executable statements. Function members are always members of types and cannot be members of namespaces. C# defines the following categories of function members:</p>

<ul>
<li> Methods</li>
<li> Properties</li>
<li> Events</li>
<li> Indexers</li>
<li> User-defined operators</li>
<li> Instance constructors</li>
<li> Static constructors</li>
<li> Destructors</li>
</ul>

<p>Except for destructors and static constructors (which cannot be invoked explicitly), the statements contained in function members are executed through function member invocations. The actual syntax for writing a function member invocation depends on the particular function member category.</p>

<p>The argument list (<a href="expressions.md#argument-lists">Argument lists</a>) of a function member invocation provides actual values or variable references for the parameters of the function member.</p>

<p>Invocations of generic methods may employ type inference to determine the set of type arguments to pass to the method. This process is described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<p>Invocations of methods, indexers, operators and instance constructors employ overload resolution to determine which of a candidate set of function members to invoke. This process is described in <a href="expressions.md#overload-resolution">Overload resolution</a>.</p>

<p>Once a particular function member has been identified at binding-time, possibly through overload resolution, the actual run-time process of invoking the function member is described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The following table summarizes the processing that takes place in constructs involving the six categories of function members that can be explicitly invoked. In the table, <code class="prettyprint">e</code>, <code class="prettyprint">x</code>, <code class="prettyprint">y</code>, and <code class="prettyprint">value</code> indicate expressions classified as variables or values, <code class="prettyprint">T</code> indicates an expression classified as a type, <code class="prettyprint">F</code> is the simple name of a method, and <code class="prettyprint">P</code> is the simple name of a property.</p>

<table><thead>
<tr>
<th><strong>Construct</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Method invocation</td>
<td><code class="prettyprint">F(x,y)</code></td>
<td>Overload resolution is applied to select the best method <code class="prettyprint">F</code> in the containing class or struct. The method is invoked with the argument list <code class="prettyprint">(x,y)</code>. If the method is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.F(x,y)</code></td>
<td>Overload resolution is applied to select the best method <code class="prettyprint">F</code> in the class or struct <code class="prettyprint">T</code>. A binding-time error occurs if the method is not <code class="prettyprint">static</code>. The method is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.F(x,y)</code></td>
<td>Overload resolution is applied to select the best method F in the class, struct, or interface given by the type of <code class="prettyprint">e</code>. A binding-time error occurs if the method is <code class="prettyprint">static</code>. The method is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td>Property access</td>
<td><code class="prettyprint">P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the containing class or struct is invoked. A compile-time error occurs if <code class="prettyprint">P</code> is write-only. If <code class="prettyprint">P</code> is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the containing class or struct is invoked with the argument list <code class="prettyprint">(value)</code>. A compile-time error occurs if <code class="prettyprint">P</code> is read-only. If <code class="prettyprint">P</code> is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the class or struct <code class="prettyprint">T</code> is invoked. A compile-time error occurs if <code class="prettyprint">P</code> is not <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the class or struct <code class="prettyprint">T</code> is invoked with the argument list <code class="prettyprint">(value)</code>. A compile-time error occurs if <code class="prettyprint">P</code> is not <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is read-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">P</code> is <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(value)</code>. A binding-time error occurs if <code class="prettyprint">P</code> is <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is read-only.</td>
</tr>
<tr>
<td>Event access</td>
<td><code class="prettyprint">E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the containing class or struct is invoked. If <code class="prettyprint">E</code> is not static, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the containing class or struct is invoked. If <code class="prettyprint">E</code> is not static, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the class or struct <code class="prettyprint">T</code> is invoked. A binding-time error occurs if <code class="prettyprint">E</code> is not static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the class or struct <code class="prettyprint">T</code> is invoked. A binding-time error occurs if <code class="prettyprint">E</code> is not static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">E</code> is static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">E</code> is static.</td>
</tr>
<tr>
<td>Indexer access</td>
<td><code class="prettyprint">e[x,y]</code></td>
<td>Overload resolution is applied to select the best indexer in the class, struct, or interface given by the type of e. The <code class="prettyprint">get</code> accessor of the indexer is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y)</code>. A binding-time error occurs if the indexer is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e[x,y] = value</code></td>
<td>Overload resolution is applied to select the best indexer in the class, struct, or interface given by the type of <code class="prettyprint">e</code>. The <code class="prettyprint">set</code> accessor of the indexer is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y,value)</code>. A binding-time error occurs if the indexer is read-only.</td>
</tr>
<tr>
<td>Operator invocation</td>
<td><code class="prettyprint">-x</code></td>
<td>Overload resolution is applied to select the best unary operator in the class or struct given by the type of <code class="prettyprint">x</code>. The selected operator is invoked with the argument list <code class="prettyprint">(x)</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x + y</code></td>
<td>Overload resolution is applied to select the best binary operator in the classes or structs given by the types of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>. The selected operator is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td>Instance constructor invocation</td>
<td><code class="prettyprint">new T(x,y)</code></td>
<td>Overload resolution is applied to select the best instance constructor in the class or struct <code class="prettyprint">T</code>. The instance constructor is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
</tbody></table>

<h3 id="argument-lists">Argument lists</h3>

<p>Every function member and delegate invocation includes an argument list which provides actual values or variable references for the parameters of the function member. The syntax for specifying the argument list of a function member invocation depends on the function member category:</p>

<ul>
<li> For instance constructors, methods, indexers and delegates, the arguments are specified as an <em>argument_list</em>, as described below. For indexers, when invoking the <code class="prettyprint">set</code> accessor, the argument list additionally includes the expression specified as the right operand of the assignment operator.</li>
<li> For properties, the argument list is empty when invoking the <code class="prettyprint">get</code> accessor, and consists of the expression specified as the right operand of the assignment operator when invoking the <code class="prettyprint">set</code> accessor.</li>
<li> For events, the argument list consists of the expression specified as the right operand of the <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator.</li>
<li> For user-defined operators, the argument list consists of the single operand of the unary operator or the two operands of the binary operator.</li>
</ul>

<p>The arguments of properties (<a href="classes.md#properties">Properties</a>), events (<a href="classes.md#events">Events</a>), and user-defined operators (<a href="classes.md#operators">Operators</a>) are always passed as value parameters (<a href="classes.md#value-parameters">Value parameters</a>). The arguments of indexers (<a href="classes.md#indexers">Indexers</a>) are always passed as value parameters (<a href="classes.md#value-parameters">Value parameters</a>) or parameter arrays (<a href="classes.md#parameter-arrays">Parameter arrays</a>). Reference and output parameters are not supported for these categories of function members.</p>

<p>The arguments of an instance constructor, method, indexer or delegate invocation are specified as an <em>argument_list</em>:</p>
<pre class="highlight shell"><code>argument_list
    : argument <span class="o">(</span><span class="s1">','</span> argument<span class="o">)</span><span class="k">*</span>
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier <span class="s1">':'</span>
    ;

argument_value
    : expression
    | <span class="s1">'ref'</span> variable_reference
    | <span class="s1">'out'</span> variable_reference
    ;
</code></pre>
<p>An <em>argument_list</em> consists of one or more <em>argument*s, separated by commas. Each argument consists of an optional  *argument_name</em> followed by an <em>argument_value</em>. An <em>argument</em> with an <em>argument_name</em> is referred to as a <strong><em>named argument</em></strong>, whereas an <em>argument</em> without an <em>argument_name</em> is a <strong><em>positional argument</em></strong>. It is an error for a positional argument to appear after a named argument in an <em>argument_list</em>.</p>

<p>The <em>argument_value</em> can take one of the following forms:</p>

<ul>
<li> An <em>expression</em>, indicating that the argument is passed as a value parameter (<a href="classes.md#value-parameters">Value parameters</a>).</li>
<li> The keyword <code class="prettyprint">ref</code> followed by a <em>variable_reference</em> (<a href="variables.md#variable-references">Variable references</a>), indicating that the argument is passed as a reference parameter (<a href="classes.md#reference-parameters">Reference parameters</a>). A variable must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before it can be passed as a reference parameter. The keyword <code class="prettyprint">out</code> followed by a <em>variable_reference</em> (<a href="variables.md#variable-references">Variable references</a>), indicating that the argument is passed as an output parameter (<a href="classes.md#output-parameters">Output parameters</a>). A variable is considered definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) following a function member invocation in which the variable is passed as an output parameter.</li>
</ul>

<h4 id="corresponding-parameters">Corresponding parameters</h4>

<p>For each argument in an argument list there has to be a corresponding parameter in the function member or delegate being invoked.</p>

<p>The parameter list used in the following is determined as follows:</p>

<ul>
<li> For virtual methods and indexers defined in classes, the parameter list is picked from the most specific declaration or override of the function member, starting with the static type of the receiver, and searching through its base classes.</li>
<li> For interface methods and indexers, the parameter list is picked form the most specific definition of the member, starting with the interface type and searching through the base interfaces. If no unique parameter list is found, a parameter list with inaccessible names and no optional parameters is constructed, so that invocations cannot use named parameters or omit optional arguments.</li>
<li> For partial methods, the parameter list of the defining partial method declaration is used.</li>
<li> For all other function members and delegates there is only a single parameter list, which is the one used.</li>
</ul>

<p>The position of an argument or parameter is defined as the number of arguments or parameters preceding it in the argument list or parameter list.</p>

<p>The corresponding parameters for function member arguments are established as follows:</p>

<ul>
<li> Arguments in the <em>argument_list</em> of instance constructors, methods, indexers and delegates:

<ul>
<li>A positional argument where a fixed parameter occurs at the same position in the parameter list corresponds to that parameter.</li>
<li>A positional argument of a function member with a parameter array invoked in its normal form corresponds to the parameter  array, which must occur at the same position in the parameter list.</li>
<li>A positional argument of a function member with a parameter array invoked in its expanded form, where no fixed parameter occurs at the same position in the parameter list, corresponds to an element in the parameter array.</li>
<li>A named argument corresponds to the parameter of the same name in the parameter list.</li>
<li>For indexers, when invoking the <code class="prettyprint">set</code> accessor, the expression specified as the right operand of the assignment operator corresponds to the implicit <code class="prettyprint">value</code> parameter of the <code class="prettyprint">set</code> accessor declaration.</li>
</ul></li>
<li> For properties, when invoking the <code class="prettyprint">get</code> accessor there are no arguments. When invoking the <code class="prettyprint">set</code> accessor, the expression specified as the right operand of the assignment operator corresponds to the implicit <code class="prettyprint">value</code> parameter of the <code class="prettyprint">set</code> accessor declaration.</li>
<li> For user-defined unary operators (including conversions), the single operand corresponds to the single parameter of the operator declaration.</li>
<li> For user-defined binary operators, the left operand corresponds to the first parameter, and the right operand corresponds to the second parameter of the operator declaration.</li>
</ul>

<h4 id="run-time-evaluation-of-argument-lists">Run-time evaluation of argument lists</h4>

<p>During the run-time processing of a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>), the expressions or variable references of an argument list are evaluated in order, from left to right, as follows:</p>

<ul>
<li> For a value parameter, the argument expression is evaluated and an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the corresponding parameter type is performed. The resulting value becomes the initial value of the value parameter in the function member invocation.</li>
<li> For a reference or output parameter, the variable reference is evaluated and the resulting storage location becomes the storage location represented by the parameter in the function member invocation. If the variable reference given as a reference or output parameter is an array element of a <em>reference_type</em>, a run-time check is performed to ensure that the element type of the array is identical to the type of the parameter. If this check fails, a <code class="prettyprint">System.ArrayTypeMismatchException</code> is thrown.</li>
</ul>

<p>Methods, indexers, and instance constructors may declare their right-most parameter to be a parameter array (<a href="classes.md#parameter-arrays">Parameter arrays</a>). Such function members are invoked either in their normal form or in their expanded form depending on which is applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>):</p>

<ul>
<li> When a function member with a parameter array is invoked in its normal form, the argument given for the parameter array must be a single expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the parameter array type. In this case, the parameter array acts precisely like a value parameter.</li>
<li> When a function member with a parameter array is invoked in its expanded form, the invocation must specify zero or more positional arguments for the parameter array, where each argument is an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the element type of the parameter array. In this case, the invocation creates an instance of the parameter array type with a length corresponding to the number of arguments, initializes the elements of the array instance with the given argument values, and uses the newly created array instance as the actual argument.</li>
</ul>

<p>The expressions of an argument list are always evaluated in the order they are written. Thus, the example
&ldquo;`csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine(&quot;x = {0}, y = {1}, z = {2}&rdquo;, x, y, z);
    }</p>

<p>static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
<code class="prettyprint">
produces the output
</code>bash
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
&ldquo;`</p>

<p>The array co-variance rules (<a href="arrays.md#array-covariance">Array covariance</a>) permit a value of an array type <code class="prettyprint">A[]</code> to be a reference to an instance of an array type <code class="prettyprint">B[]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>. Because of these rules, when an array element of a <em>reference_type</em> is passed as a reference or output parameter, a run-time check is required to ensure that the actual element type of the array is identical to that of the parameter. In the example
&rdquo;`csharp
class Test
{
    static void F(ref object x) {&hellip;}</p>

<p>static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
&ldquo;<code class="prettyprint">
the second invocation of</code>F<code class="prettyprint">causes a</code>System.ArrayTypeMismatchException<code class="prettyprint">to be thrown because the actual element type of</code>b<code class="prettyprint">is</code>string<code class="prettyprint">and not</code>object`.</p>

<p>When a function member with a parameter array is invoked in its expanded form, the invocation is processed exactly as if an array creation expression with an array initializer (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) was inserted around the expanded parameters. For example, given the declaration
<code class="prettyprint">csharp
void F(int x, int y, params object[] args);
</code>
the following invocations of the expanded form of the method
<code class="prettyprint">csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, &quot;hello&quot;, 3.0);
</code>
correspond exactly to
<code class="prettyprint">csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, &quot;hello&quot;, 3.0});
</code></p>

<p>In particular, note that an empty array is created when there are zero arguments given for the parameter array.</p>

<p>When arguments are omitted from a function member with corresponding optional parameters, the default arguments of the function member declaration are implicitly passed. Because these are always constant, their evaluation will not impact the evaluation order of the remaining arguments.</p>

<h3 id="type-inference">Type inference</h3>

<p>When a generic method is called without specifying type arguments, a <strong><em>type inference</em></strong> process attempts to infer type arguments for the call. The presence of type inference allows a more convenient syntax to be used for calling a generic method, and allows the programmer to avoid specifying redundant type information. For example, given the method declaration:
&rdquo;`csharp
class Chooser
{
    static Random rand = new Random();</p>

<p>public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
<code class="prettyprint">
it is possible to invoke the `Choose` method without explicitly specifying a type argument:
</code>csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int></p>

<p>string s = Chooser.Choose(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;);        // Calls Choose<string>
&ldquo;`</p>

<p>Through type inference, the type arguments <code class="prettyprint">int</code> and <code class="prettyprint">string</code> are determined from the arguments to the method.</p>

<p>Type inference occurs as part of the binding-time processing of a method invocation (<a href="expressions.md#method-invocations">Method invocations</a>) and takes place before the overload resolution step of the invocation. When a particular method group is specified in a method invocation, and no type arguments are specified as part of the method invocation, type inference is applied to each generic method in the method group. If type inference succeeds, then the inferred type arguments are used to determine the types of arguments for subsequent overload resolution. If overload resolution chooses a generic method as the one to invoke, then the inferred type arguments are used as the actual type arguments for the invocation. If type inference for a particular method fails, that method does not participate in overload resolution. The failure of type inference, in and of itself, does not cause a binding-time error. However, it often leads to a binding-time error when overload resolution then fails to find any applicable methods.</p>

<p>If the supplied number of arguments is different than the number of parameters in the method, then inference immediately fails. Otherwise, assume that the generic method has the following signature:
<code class="prettyprint">csharp
Tr M&lt;X1,...,Xn&gt;(T1 x1, ..., Tm xm)
</code></p>

<p>With a method call of the form <code class="prettyprint">M(E1...Em)</code> the task of type inference is to find unique type arguments <code class="prettyprint">S1...Sn</code> for each of the type parameters <code class="prettyprint">X1...Xn</code> so that the call <code class="prettyprint">M&lt;S1...Sn&gt;(E1...Em)</code> becomes valid.</p>

<p>During the process of inference each type parameter <code class="prettyprint">Xi</code> is either <em>fixed</em> to a particular type <code class="prettyprint">Si</code> or <em>unfixed</em> with an associated set of <em>bounds</em>. Each of the bounds is some type <code class="prettyprint">T</code>. Initially each type variable <code class="prettyprint">Xi</code> is unfixed with an empty set of bounds.</p>

<p>Type inference takes place in phases. Each phase will try to infer type arguments for more type variables based on the findings of the previous phase. The first phase makes some initial inferences of bounds, whereas the second phase fixes type variables to specific types and infers further bounds. The second phase may have to be repeated a number of times.</p>

<p><em>Note:</em> Type inference takes place not only when a generic method is called. Type inference for conversion of method groups is described in <a href="expressions.md#type-inference-for-conversion-of-method-groups">Type inference for conversion of method groups</a> and finding the best common type of a set of expressions is described in <a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>.</p>

<h4 id="the-first-phase">The first phase</h4>

<p>For each of the method arguments <code class="prettyprint">Ei</code>:</p>

<ul>
<li>  If <code class="prettyprint">Ei</code> is an anonymous function, an <em>explicit parameter type inference</em> (<a href="expressions.md#explicit-parameter-type-inferences">Explicit parameter type inferences</a>) is made from <code class="prettyprint">Ei</code> to <code class="prettyprint">Ti</code></li>
<li>  Otherwise, if <code class="prettyprint">Ei</code> has a type <code class="prettyprint">U</code> and <code class="prettyprint">xi</code> is a value parameter then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Ti</code>.</li>
<li>  Otherwise, if <code class="prettyprint">Ei</code> has a type <code class="prettyprint">U</code> and <code class="prettyprint">xi</code> is a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter then an <em>exact inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Ti</code>.</li>
<li>  Otherwise, no inference is made for this argument.</li>
</ul>

<h4 id="the-second-phase">The second phase</h4>

<p>The second phase proceeds as follows:</p>

<ul>
<li>  All <em>unfixed</em> type variables <code class="prettyprint">Xi</code> which do not <em>depend on</em> (<a href="expressions.md#dependence">Dependence</a>) any <code class="prettyprint">Xj</code> are fixed (<a href="expressions.md#fixing">Fixing</a>).</li>
<li>  If no such type variables exist, all <em>unfixed</em> type variables <code class="prettyprint">Xi</code> are <em>fixed</em> for which all of the following hold:

<ul>
<li>  There is at least one type variable <code class="prettyprint">Xj</code> that depends on <code class="prettyprint">Xi</code></li>
<li>  <code class="prettyprint">Xi</code> has a non-empty set of bounds</li>
</ul></li>
<li>  If no such type variables exist and there are still <em>unfixed</em> type variables, type inference fails.</li>
<li>  Otherwise, if no further <em>unfixed</em> type variables exist, type inference succeeds.</li>
<li>  Otherwise, for all arguments <code class="prettyprint">Ei</code> with corresponding parameter type <code class="prettyprint">Ti</code> where the <em>output types</em> (<a href="expressions.md#output-types">Output types</a>) contain <em>unfixed</em> type variables <code class="prettyprint">Xj</code> but the <em>input types</em> (<a href="expressions.md#input-types">Input types</a>) do not, an <em>output type inference</em> (<a href="expressions.md#output-type-inferences">Output type inferences</a>) is made <em>from</em> <code class="prettyprint">Ei</code> <em>to</em> <code class="prettyprint">Ti</code>. Then the second phase is repeated.</li>
</ul>

<h4 id="input-types">Input types</h4>

<p>If <code class="prettyprint">E</code> is a method group or implicitly typed anonymous function and <code class="prettyprint">T</code> is a delegate type or expression tree type then all the parameter types of <code class="prettyprint">T</code> are <em>input types</em> of <code class="prettyprint">E</code> <em>with type</em> <code class="prettyprint">T</code>.</p>

<h4 id="output-types">Output types</h4>

<p>If <code class="prettyprint">E</code> is a method group or an anonymous function and <code class="prettyprint">T</code> is a delegate type or expression tree type then the return type of <code class="prettyprint">T</code> is an <em>output type of</em> <code class="prettyprint">E</code> <em>with type</em> <code class="prettyprint">T</code>.</p>

<h4 id="dependence">Dependence</h4>

<p>An <em>unfixed</em> type variable <code class="prettyprint">Xi</code> <em>depends directly on</em> an unfixed type variable <code class="prettyprint">Xj</code> if for some argument <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code> <code class="prettyprint">Xj</code> occurs in an <em>input type</em> of <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code> and <code class="prettyprint">Xi</code> occurs in an <em>output type</em> of <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code>.</p>

<p><code class="prettyprint">Xj</code> <em>depends on</em> <code class="prettyprint">Xi</code> if <code class="prettyprint">Xj</code> <em>depends directly on</em> <code class="prettyprint">Xi</code> or if <code class="prettyprint">Xi</code> <em>depends directly on</em> <code class="prettyprint">Xk</code> and <code class="prettyprint">Xk</code> <em>depends on</em> <code class="prettyprint">Xj</code>. Thus &quot;depends on&rdquo; is the transitive but not reflexive closure of &ldquo;depends directly on&rdquo;.</p>

<h4 id="output-type-inferences">Output type inferences</h4>

<p>An <em>output type inference</em> is made <em>from</em> an expression <code class="prettyprint">E</code> <em>to</em> a type <code class="prettyprint">T</code> in the following way:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an anonymous function with inferred return type  <code class="prettyprint">U</code> (<a href="expressions.md#inferred-return-type">Inferred return type</a>) and <code class="prettyprint">T</code> is a delegate type or expression tree type with return type <code class="prettyprint">Tb</code>, then a <em>lower-bound inference</em> (<a href="expressions.md#lower-bound-inferences">Lower-bound inferences</a>) is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Tb</code>.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is a method group and <code class="prettyprint">T</code> is a delegate type or expression tree type with parameter types <code class="prettyprint">T1...Tk</code> and return type <code class="prettyprint">Tb</code>, and overload resolution of <code class="prettyprint">E</code> with the types <code class="prettyprint">T1...Tk</code> yields a single method with return type <code class="prettyprint">U</code>, then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Tb</code>.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is an expression with type <code class="prettyprint">U</code>, then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">T</code>.</li>
<li> Otherwise, no inferences are made.</li>
</ul>

<h4 id="explicit-parameter-type-inferences">Explicit parameter type inferences</h4>

<p>An <em>explicit parameter type inference</em> is made <em>from</em> an expression <code class="prettyprint">E</code> <em>to</em> a type <code class="prettyprint">T</code> in the following way:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an explicitly typed anonymous function with parameter types <code class="prettyprint">U1...Uk</code> and <code class="prettyprint">T</code> is a delegate type or expression tree type with parameter types <code class="prettyprint">V1...Vk</code> then for each <code class="prettyprint">Ui</code> an <em>exact inference</em> (<a href="expressions.md#exact-inferences">Exact inferences</a>) is made <em>from</em> <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code>.</li>
</ul>

<h4 id="exact-inferences">Exact inferences</h4>

<p>An <em>exact inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li><p>If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of exact bounds for <code class="prettyprint">Xi</code>.</p></li>
<li><p>Otherwise, sets <code class="prettyprint">V1...Vk</code> and <code class="prettyprint">U1...Uk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> and <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code>  of the same rank</li>
<li> <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code> and <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code></li>
<li> <code class="prettyprint">V</code> is a constructed type <code class="prettyprint">C&lt;V1...Vk&gt;</code>and <code class="prettyprint">U</code> is a constructed type <code class="prettyprint">C&lt;U1...Uk&gt;</code></li>
</ul></li>
</ul>

<p>If any of these cases apply then an <em>exact inference</em> is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code>.</p>

<ul>
<li> Otherwise no inferences are made.</li>
</ul>

<h4 id="lower-bound-inferences">Lower-bound inferences</h4>

<p>A <em>lower-bound inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li> If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of lower bounds for <code class="prettyprint">Xi</code>.</li>
<li> Otherwise, if <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code>and <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code> then a lower bound inference is made from <code class="prettyprint">U1</code> to <code class="prettyprint">V1</code>.</li>
<li><p>Otherwise, sets <code class="prettyprint">U1...Uk</code> and <code class="prettyprint">V1...Vk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> and <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code> (or a type parameter whose effective base type is <code class="prettyprint">U1[...]</code>) of the same rank</li>
<li> <code class="prettyprint">V</code> is one of <code class="prettyprint">IEnumerable&lt;V1&gt;</code>, <code class="prettyprint">ICollection&lt;V1&gt;</code> or <code class="prettyprint">IList&lt;V1&gt;</code> and <code class="prettyprint">U</code> is a one-dimensional array type <code class="prettyprint">U1[]</code>(or a type parameter whose effective base type is <code class="prettyprint">U1[]</code>)</li>
<li> <code class="prettyprint">V</code> is a constructed class, struct, interface or delegate type <code class="prettyprint">C&lt;V1...Vk&gt;</code> and there is a unique type <code class="prettyprint">C&lt;U1...Uk&gt;</code> such that <code class="prettyprint">U</code> (or, if <code class="prettyprint">U</code> is a type parameter, its effective base class or any member of its effective interface set) is identical to, inherits from (directly or indirectly), or implements (directly or indirectly) <code class="prettyprint">C&lt;U1...Uk&gt;</code>.</li>
</ul>

<p>(The &ldquo;uniqueness&rdquo; restriction means that in the case interface <code class="prettyprint">C&lt;T&gt; {} class U: C&lt;X&gt;, C&lt;Y&gt; {}</code>, then no inference is made when inferring from <code class="prettyprint">U</code> to <code class="prettyprint">C&lt;T&gt;</code> because <code class="prettyprint">U1</code> could be <code class="prettyprint">X</code> or <code class="prettyprint">Y</code>.)</p></li>
</ul>

<p>If any of these cases apply then an inference is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code> as follows:</p>

<ul>
<li> If <code class="prettyprint">Ui</code> is not known to be a reference type then an <em>exact inference</em> is made</li>
<li> Otherwise, if <code class="prettyprint">U</code> is an array type then a <em>lower-bound inference</em> is made</li>
<li> Otherwise, if <code class="prettyprint">V</code> is <code class="prettyprint">C&lt;V1...Vk&gt;</code> then inference depends on the i-th type parameter of <code class="prettyprint">C</code>:

<ul>
<li> If it is covariant then a <em>lower-bound inference</em> is made.</li>
<li> If it is contravariant then an <em>upper-bound inference</em> is made.</li>
<li> If it is invariant then an <em>exact inference</em> is made.

<ul>
<li> Otherwise, no inferences are made.</li>
</ul></li>
</ul></li>
</ul>

<h4 id="upper-bound-inferences">Upper-bound inferences</h4>

<p>An <em>upper-bound inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li> If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of upper bounds for <code class="prettyprint">Xi</code>.</li>
<li><p>Otherwise, sets <code class="prettyprint">V1...Vk</code> and <code class="prettyprint">U1...Uk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code> and <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> of the same rank</li>
<li> <code class="prettyprint">U</code> is one of <code class="prettyprint">IEnumerable&lt;Ue&gt;</code>, <code class="prettyprint">ICollection&lt;Ue&gt;</code> or <code class="prettyprint">IList&lt;Ue&gt;</code> and <code class="prettyprint">V</code> is a one-dimensional array type <code class="prettyprint">Ve[]</code></li>
<li> <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code> and <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code></li>
<li> <code class="prettyprint">U</code> is constructed class, struct, interface or delegate type <code class="prettyprint">C&lt;U1...Uk&gt;</code> and <code class="prettyprint">V</code> is a class, struct, interface or delegate type which is identical to, inherits from (directly or indirectly), or implements (directly or indirectly) a unique type <code class="prettyprint">C&lt;V1...Vk&gt;</code></li>
</ul>

<p>(The &ldquo;uniqueness&rdquo; restriction means that if we have <code class="prettyprint">interface C&lt;T&gt;{} class V&lt;Z&gt;: C&lt;X&lt;Z&gt;&gt;, C&lt;Y&lt;Z&gt;&gt;{}</code>, then no inference is made when inferring from <code class="prettyprint">C&lt;U1&gt;</code> to <code class="prettyprint">V&lt;Q&gt;</code>. Inferences are not made from <code class="prettyprint">U1</code> to either <code class="prettyprint">X&lt;Q&gt;</code> or <code class="prettyprint">Y&lt;Q&gt;</code>.)</p></li>
</ul>

<p>If any of these cases apply then an inference is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code> as follows:
   *  If  <code class="prettyprint">Ui</code> is not known to be a reference type then an <em>exact inference</em> is made
   *  Otherwise, if <code class="prettyprint">V</code> is an array type then an <em>upper-bound inference</em> is made
   *  Otherwise, if <code class="prettyprint">U</code> is <code class="prettyprint">C&lt;U1...Uk&gt;</code> then inference depends on the i-th type parameter of <code class="prettyprint">C</code>:
      *  If it is covariant then an <em>upper-bound inference</em> is made.
      *  If it is contravariant then a <em>lower-bound inference</em> is made.
      *  If it is invariant then an <em>exact inference</em> is made.
*  Otherwise, no inferences are made.   </p>

<h4 id="fixing">Fixing</h4>

<p>An <em>unfixed</em> type variable <code class="prettyprint">Xi</code> with a set of bounds is <em>fixed</em> as follows:</p>

<ul>
<li> The set of <em>candidate types</em> <code class="prettyprint">Uj</code> starts out as the set of all types in the set of bounds for <code class="prettyprint">Xi</code>.</li>
<li> We then examine each bound for <code class="prettyprint">Xi</code> in turn: For each exact bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> which are not identical to <code class="prettyprint">U</code> are removed from the candidate set. For each lower bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> to which there is <em>not</em> an implicit conversion from <code class="prettyprint">U</code> are removed from the candidate set. For each upper bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> from which there is <em>not</em> an implicit conversion to <code class="prettyprint">U</code> are removed from the candidate set.</li>
<li> If among the remaining candidate types <code class="prettyprint">Uj</code> there is a unique type <code class="prettyprint">V</code> from which there is an implicit conversion to all the other candidate types, then <code class="prettyprint">Xi</code> is fixed to <code class="prettyprint">V</code>.</li>
<li> Otherwise, type inference fails.</li>
</ul>

<h4 id="inferred-return-type">Inferred return type</h4>

<p>The inferred return type of an anonymous function <code class="prettyprint">F</code> is used during type inference and overload resolution. The inferred return type can only be determined for an anonymous function where all parameter types are known, either because they are explicitly given, provided through an anonymous function conversion or inferred during type inference on an enclosing generic method invocation.</p>

<p>The <strong><em>inferred result type</em></strong> is determined as follows:</p>

<ul>
<li> If the body of <code class="prettyprint">F</code> is an <em>expression</em> that has a type, then the inferred result type of <code class="prettyprint">F</code> is the type of that expression.</li>
<li> If the body of <code class="prettyprint">F</code> is a <em>block</em> and the set of expressions in the block&rsquo;s <code class="prettyprint">return</code> statements has a best common type <code class="prettyprint">T</code> (<a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>), then the inferred result type of <code class="prettyprint">F</code> is <code class="prettyprint">T</code>.</li>
<li> Otherwise, a result type cannot be inferred for <code class="prettyprint">F</code>.</li>
</ul>

<p>The <strong><em>inferred return type</em></strong> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">F</code> is async and the body of <code class="prettyprint">F</code> is either an expression classified as nothing (<a href="expressions.md#expression-classifications">Expression classifications</a>), or a statement block where no return statements have expressions, the inferred return type is <code class="prettyprint">System.Threading.Tasks.Task</code></li>
<li> If <code class="prettyprint">F</code> is async and has an inferred result type <code class="prettyprint">T</code>, the inferred return type is <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code>.</li>
<li> If <code class="prettyprint">F</code> is non-async and has an inferred result type <code class="prettyprint">T</code>, the inferred return type is <code class="prettyprint">T</code>.</li>
<li> Otherwise a return type cannot be inferred for <code class="prettyprint">F</code>.</li>
</ul>

<p>As an example of type inference involving anonymous functions, consider the <code class="prettyprint">Select</code> extension method declared in the <code class="prettyprint">System.Linq.Enumerable</code> class:
<code class="prettyprint">csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;(
            this IEnumerable&lt;TSource&gt; source,
            Func&lt;TSource,TResult&gt; selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
</code></p>

<p>Assuming the <code class="prettyprint">System.Linq</code> namespace was imported with a <code class="prettyprint">using</code> clause, and given a class <code class="prettyprint">Customer</code> with a <code class="prettyprint">Name</code> property of type <code class="prettyprint">string</code>, the <code class="prettyprint">Select</code> method can be used to select the names of a list of customers:
<code class="prettyprint">csharp
List&lt;Customer&gt; customers = GetCustomerList();
IEnumerable&lt;string&gt; names = customers.Select(c =&gt; c.Name);
</code></p>

<p>The extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>) of <code class="prettyprint">Select</code> is processed by rewriting the invocation to a static method invocation:
<code class="prettyprint">csharp
IEnumerable&lt;string&gt; names = Enumerable.Select(customers, c =&gt; c.Name);
</code></p>

<p>Since type arguments were not explicitly specified, type inference is used to infer the type arguments. First, the <code class="prettyprint">customers</code> argument is related to the <code class="prettyprint">source</code> parameter, inferring <code class="prettyprint">T</code> to be <code class="prettyprint">Customer</code>. Then, using the anonymous function type inference process described above, <code class="prettyprint">c</code> is given type <code class="prettyprint">Customer</code>, and the expression <code class="prettyprint">c.Name</code> is related to the return type of the <code class="prettyprint">selector</code> parameter, inferring <code class="prettyprint">S</code> to be <code class="prettyprint">string</code>. Thus, the invocation is equivalent to
<code class="prettyprint">csharp
Sequence.Select&lt;Customer,string&gt;(customers, (Customer c) =&gt; c.Name)
</code>
and the result is of type <code class="prettyprint">IEnumerable&lt;string&gt;</code>.</p>

<p>The following example demonstrates how anonymous function type inference allows type information to &ldquo;flow&rdquo; between arguments in a generic method invocation. Given the method:
<code class="prettyprint">csharp
static Z F&lt;X,Y,Z&gt;(X value, Func&lt;X,Y&gt; f1, Func&lt;Y,Z&gt; f2) {
    return f2(f1(value));
}
</code></p>

<p>Type inference for the invocation:
<code class="prettyprint">csharp
double seconds = F(&quot;1:15:30&quot;, s =&gt; TimeSpan.Parse(s), t =&gt; t.TotalSeconds);
</code>
proceeds as follows: First, the argument <code class="prettyprint">&quot;1:15:30&quot;</code> is related to the <code class="prettyprint">value</code> parameter, inferring <code class="prettyprint">X</code> to be <code class="prettyprint">string</code>. Then, the parameter of the first anonymous function, <code class="prettyprint">s</code>, is given the inferred type <code class="prettyprint">string</code>, and the expression <code class="prettyprint">TimeSpan.Parse(s)</code> is related to the return type of <code class="prettyprint">f1</code>, inferring <code class="prettyprint">Y</code> to be <code class="prettyprint">System.TimeSpan</code>. Finally, the parameter of the second anonymous function, <code class="prettyprint">t</code>, is given the inferred type <code class="prettyprint">System.TimeSpan</code>, and the expression <code class="prettyprint">t.TotalSeconds</code> is related to the return type of <code class="prettyprint">f2</code>, inferring <code class="prettyprint">Z</code> to be <code class="prettyprint">double</code>. Thus, the result of the invocation is of type <code class="prettyprint">double</code>.</p>

<h4 id="type-inference-for-conversion-of-method-groups">Type inference for conversion of method groups</h4>

<p>Similar to calls of generic methods, type inference must also be applied when a method group <code class="prettyprint">M</code> containing a generic method is converted to a given delegate type <code class="prettyprint">D</code> (<a href="conversions.md#method-group-conversions">Method group conversions</a>). Given a method
<code class="prettyprint">csharp
Tr M&lt;X1...Xn&gt;(T1 x1 ... Tm xm)
</code>
and the method group <code class="prettyprint">M</code> being assigned to the delegate type <code class="prettyprint">D</code> the task of type inference is to find type arguments <code class="prettyprint">S1...Sn</code> so that the expression:
<code class="prettyprint">csharp
M&lt;S1...Sn&gt;
</code>
becomes compatible (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) with <code class="prettyprint">D</code>.</p>

<p>Unlike the type inference algorithm for generic method calls, in this case there are only argument <em>types</em>, no argument <em>expressions</em>. In particular, there are no anonymous functions and hence no need for multiple phases of inference.</p>

<p>Instead, all <code class="prettyprint">Xi</code> are considered <em>unfixed</em>, and a <em>lower-bound inference</em> is made <em>from</em> each argument type <code class="prettyprint">Uj</code> of <code class="prettyprint">D</code> <em>to</em> the corresponding parameter type <code class="prettyprint">Tj</code> of <code class="prettyprint">M</code>. If for any of the <code class="prettyprint">Xi</code> no bounds were found, type inference fails. Otherwise, all <code class="prettyprint">Xi</code> are <em>fixed</em> to corresponding <code class="prettyprint">Si</code>, which are the result of type inference.</p>

<h4 id="finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</h4>

<p>In some cases, a common type needs to be inferred for a set of expressions. In particular, the element types of implicitly typed arrays and the return types of anonymous functions with <em>block</em> bodies are found in this way.</p>

<p>Intuitively, given a set of expressions <code class="prettyprint">E1...Em</code> this inference should be equivalent to calling a method
<code class="prettyprint">csharp
Tr M&lt;X&gt;(X x1 ... X xm)
</code>
with the <code class="prettyprint">Ei</code> as arguments.</p>

<p>More precisely, the inference starts out with an <em>unfixed</em> type variable <code class="prettyprint">X</code>. <em>Output type inferences</em> are then made <em>from</em> each <code class="prettyprint">Ei</code> <em>to</em> <code class="prettyprint">X</code>. Finally, <code class="prettyprint">X</code> is <em>fixed</em> and, if successful, the resulting type <code class="prettyprint">S</code> is the resulting best common type for the expressions. If no such <code class="prettyprint">S</code> exists, the expressions have no best common type.</p>

<h3 id="overload-resolution">Overload resolution</h3>

<p>Overload resolution is a binding-time mechanism for selecting the best function member to invoke given an argument list and a set of candidate function members. Overload resolution selects the function member to invoke in the following distinct contexts within C#:</p>

<ul>
<li> Invocation of a method named in an <em>invocation_expression</em> (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> Invocation of an instance constructor named in an <em>object_creation_expression</em> (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>).</li>
<li> Invocation of an indexer accessor through an <em>element_access</em> (<a href="expressions.md#element-access">Element access</a>).</li>
<li> Invocation of a predefined or user-defined operator referenced in an expression (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a> and <a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>).</li>
</ul>

<p>Each of these contexts defines the set of candidate function members and the list of arguments in its own unique way, as described in detail in the sections listed above. For example, the set of candidates for a method invocation does not include methods marked <code class="prettyprint">override</code> (<a href="expressions.md#member-lookup">Member lookup</a>), and methods in a base class are not candidates if any method in a derived class is applicable (<a href="expressions.md#method-invocations">Method invocations</a>).</p>

<p>Once the candidate function members and the argument list have been identified, the selection of the best function member is the same in all cases:</p>

<ul>
<li> Given the set of applicable candidate function members, the best function member in that set is located. If the set contains only one function member, then that function member is the best function member. Otherwise, the best function member is the one function member that is better than all other function members with respect to the given argument list, provided that each function member is compared to all other function members using the rules in <a href="expressions.md#better-function-member">Better function member</a>. If there is not exactly one function member that is better than all other function members, then the function member invocation is ambiguous and a binding-time error occurs.</li>
</ul>

<p>The following sections define the exact meanings of the terms <strong><em>applicable function member</em></strong> and <strong><em>better function member</em></strong>.</p>

<h4 id="applicable-function-member">Applicable function member</h4>

<p>A function member is said to be an <strong><em>applicable function member</em></strong> with respect to an argument list <code class="prettyprint">A</code> when all of the following are true:</p>

<ul>
<li> Each argument in <code class="prettyprint">A</code> corresponds to a parameter in the function member declaration as described in <a href="expressions.md#corresponding-parameters">Corresponding parameters</a>, and any parameter to which no argument corresponds is an optional parameter.</li>
<li> For each argument in <code class="prettyprint">A</code>, the parameter passing mode of the argument (i.e., value, <code class="prettyprint">ref</code>, or <code class="prettyprint">out</code>) is identical to the parameter passing mode of the corresponding parameter, and

<ul>
<li> for a value parameter or a parameter array, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from the argument to the type of the corresponding parameter, or</li>
<li> for a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter, the type of the argument is identical to the type of the corresponding parameter. After all, a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter is an alias for the argument passed.</li>
</ul></li>
</ul>

<p>For a function member that includes a parameter array, if the function member is applicable by the above rules, it is said to be applicable in its <strong><em>normal form</em></strong>. If a function member that includes a parameter array is not applicable in its normal form, the function member may instead be applicable in its <strong><em>expanded form</em></strong>:</p>

<ul>
<li> The expanded form is constructed by replacing the parameter array in the function member declaration with zero or more value parameters of the element type of the parameter array such that the number of arguments in the argument list <code class="prettyprint">A</code> matches the total number of parameters. If <code class="prettyprint">A</code> has fewer arguments than the number of fixed parameters in the function member declaration, the expanded form of the function member cannot be constructed and is thus not applicable.</li>
<li> Otherwise, the expanded form is applicable if for each argument in <code class="prettyprint">A</code> the parameter passing mode of the argument is identical to the parameter passing mode of the corresponding parameter, and

<ul>
<li> for a fixed value parameter or a value parameter created by the expansion, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from the type of the argument to the type of the corresponding parameter, or</li>
<li> for a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter, the type of the argument is identical to the type of the corresponding parameter.</li>
</ul></li>
</ul>

<h4 id="better-function-member">Better function member</h4>

<p>For the purposes of determining the better function member, a stripped-down argument list A is constructed containing just the argument expressions themselves in the order they appear in the original argument list.</p>

<p>Parameter lists for each of the candidate function members are constructed in the following way:</p>

<ul>
<li> The expanded form is used if the function member was applicable only in the expanded form.</li>
<li> Optional parameters with no corresponding arguments are removed from the parameter list</li>
<li> The parameters are reordered so that they occur at the same position as the corresponding argument in the argument list.</li>
</ul>

<p>Given an argument list <code class="prettyprint">A</code> with a set of argument expressions <code class="prettyprint">{E1, E2, ..., En}</code> and two applicable function members <code class="prettyprint">Mp</code> and <code class="prettyprint">Mq</code> with parameter types <code class="prettyprint">{P1, P2, ..., Pn}</code> and <code class="prettyprint">{Q1, Q2, ..., Qn}</code>, <code class="prettyprint">Mp</code> is defined to be a <strong><em>better function member</em></strong> than <code class="prettyprint">Mq</code> if</p>

<ul>
<li> for each argument, the implicit conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Qx</code> is not better than the implicit conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Px</code>, and</li>
<li> for at least one argument, the conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Px</code> is better than the conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Qx</code>.</li>
</ul>

<p>When performing this evaluation, if <code class="prettyprint">Mp</code> or <code class="prettyprint">Mq</code> is applicable in its expanded form, then <code class="prettyprint">Px</code> or <code class="prettyprint">Qx</code> refers to a parameter in the expanded form of the parameter list.</p>

<p>In case the parameter type sequencesÂ <code class="prettyprint">{P1, P2, ..., Pn}</code> and <code class="prettyprint">{Q1, Q2, ..., Qn}</code> are equivalent (i.e. each <code class="prettyprint">Pi</code> has an identity conversion to the corresponding <code class="prettyprint">Qi</code>), the following tie-breaking rules are applied, in order, to determine the better function member.</p>

<ul>
<li> If <code class="prettyprint">Mp</code> is a non-generic method and <code class="prettyprint">Mq</code> is a generic method, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> is applicable in its normal form and <code class="prettyprint">Mq</code> has a <code class="prettyprint">params</code> array and is applicable only in its expanded form, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> has more declared parameters than <code class="prettyprint">Mq</code>, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>. This canÂ occur if both methodsÂ have <code class="prettyprint">params</code> arrays and are applicable only in their expanded forms.</li>
<li> Otherwise if all parameters of <code class="prettyprint">Mp</code> have a corresponding argument whereas default arguments need to be substituted for at least one optional parameter in <code class="prettyprint">Mq</code> then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> has more specific parameter types than <code class="prettyprint">Mq</code>, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>. Let <code class="prettyprint">{R1, R2, ..., Rn}</code> and <code class="prettyprint">{S1, S2, ..., Sn}</code> represent the uninstantiated and unexpanded parameter types of <code class="prettyprint">Mp</code> and <code class="prettyprint">Mq</code>. <code class="prettyprint">Mp</code>&lsquo;s parameter types are more specific than <code class="prettyprint">Mq</code>&rsquo;s if, for each parameter, <code class="prettyprint">Rx</code> is not less specific than <code class="prettyprint">Sx</code>, and, for at least one parameter, <code class="prettyprint">Rx</code> is more specific than <code class="prettyprint">Sx</code>:

<ul>
<li> A type parameter is less specific than a non-type parameter.</li>
<li> Recursively, a constructed type is more specific than another constructed typeÂ (with the same number of type arguments)Â if at least one type argument is more specific and no type argument is less specific than the corresponding type argument in the other.</li>
<li> An array type is more specific than another array type (with the same number of dimensions) if the element type of the first is more specific than the element type of the second.</li>
</ul></li>
<li> Otherwise if one member is a non-lifted operator and  the other is a lifted operator, the non-lifted one is better.</li>
<li> Otherwise, neither function member is better.</li>
</ul>

<h4 id="better-conversion-from-expression">Better conversion from expression</h4>

<p>Given an implicit conversion <code class="prettyprint">C1</code> that converts from an expression <code class="prettyprint">E</code> to a type <code class="prettyprint">T1</code>, and an implicit conversion <code class="prettyprint">C2</code> that converts from an expression <code class="prettyprint">E</code> to a type <code class="prettyprint">T2</code>, <code class="prettyprint">C1</code> is a <strong><em>better conversion</em></strong> than <code class="prettyprint">C2</code> if <code class="prettyprint">E</code> does not exactly match <code class="prettyprint">T2</code> and at least one of the following holds:</p>

<ul>
<li><code class="prettyprint">E</code> exactly matches <code class="prettyprint">T1</code> (<a href="expressions.md#exactly-matching-expression">Exactly matching Expression</a>)</li>
<li><code class="prettyprint">T1</code> is a better conversion target than <code class="prettyprint">T2</code> (<a href="expressions.md#better-conversion-target">Better conversion target</a>)</li>
</ul>

<h4 id="exactly-matching-expression">Exactly matching Expression</h4>

<p>Given an expression <code class="prettyprint">E</code> and a type <code class="prettyprint">T</code>, <code class="prettyprint">E</code> exactly matches <code class="prettyprint">T</code> if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">E</code> has a type <code class="prettyprint">S</code>, and an identity conversion exists from <code class="prettyprint">S</code> to <code class="prettyprint">T</code></li>
<li> <code class="prettyprint">E</code> is an anonymous function, <code class="prettyprint">T</code> is either a delegate type <code class="prettyprint">D</code> or an expression tree type <code class="prettyprint">Expression&lt;D&gt;</code> and one of the following holds:

<ul>
<li> An inferred return type <code class="prettyprint">X</code> exists for <code class="prettyprint">E</code> in the context of the parameter list of <code class="prettyprint">D</code> (<a href="expressions.md#inferred-return-type">Inferred return type</a>), and an identity conversion exists from <code class="prettyprint">X</code> to the return type of <code class="prettyprint">D</code></li>
<li> Either <code class="prettyprint">E</code> is non-async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Y</code> or <code class="prettyprint">E</code> is async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Task&lt;Y&gt;</code>, and one of the following holds:

<ul>
<li>The body of <code class="prettyprint">E</code> is an expression that exactly matches <code class="prettyprint">Y</code></li>
<li>The body of <code class="prettyprint">E</code> is a statement block where every return statement returns an expression that exactly matches <code class="prettyprint">Y</code></li>
</ul></li>
</ul></li>
</ul>

<h4 id="better-conversion-target">Better conversion target</h4>

<p>Given two different types <code class="prettyprint">T1</code> and <code class="prettyprint">T2</code>, <code class="prettyprint">T1</code> is a better conversion target than <code class="prettyprint">T2</code> if no implicit conversion from <code class="prettyprint">T2</code> to <code class="prettyprint">T1</code> exists, and at least one of the following holds:</p>

<ul>
<li> An implicit conversion from <code class="prettyprint">T1</code> to <code class="prettyprint">T2</code> exists</li>
<li> <code class="prettyprint">T1</code> is either a delegate type <code class="prettyprint">D1</code> or an expression tree type <code class="prettyprint">Expression&lt;D1&gt;</code>, <code class="prettyprint">T2</code> is either a delegate type <code class="prettyprint">D2</code> or an expression tree type <code class="prettyprint">Expression&lt;D2&gt;</code>, <code class="prettyprint">D1</code> has a return type <code class="prettyprint">S1</code> and one of the following holds:

<ul>
<li><code class="prettyprint">D2</code> is void returning</li>
<li><code class="prettyprint">D2</code> has a return type <code class="prettyprint">S2</code>, and <code class="prettyprint">S1</code> is a better conversion target than <code class="prettyprint">S2</code></li>
</ul></li>
<li> <code class="prettyprint">T1</code> is <code class="prettyprint">Task&lt;S1&gt;</code>, <code class="prettyprint">T2</code> is <code class="prettyprint">Task&lt;S2&gt;</code>, and <code class="prettyprint">S1</code> is a better conversion target than <code class="prettyprint">S2</code></li>
<li> <code class="prettyprint">T1</code> is <code class="prettyprint">S1</code> or <code class="prettyprint">S1?</code> where <code class="prettyprint">S1</code> is a signed integral type, and <code class="prettyprint">T2</code> is <code class="prettyprint">S2</code> or <code class="prettyprint">S2?</code> where <code class="prettyprint">S2</code> is an unsigned integral type. Specifically:

<ul>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">sbyte</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">byte</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">short</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">int</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">long</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">ulong</code></li>
</ul></li>
</ul>

<h4 id="overloading-in-generic-classes">Overloading in generic classes</h4>

<p>While signatures as declared must be unique, it is possible that substitution of type arguments results in identical signatures. In such cases, the tie-breaking rules of overload resolution above will pick the most specific member.</p>

<p>The following examples show overloads that are valid and invalid according to this rule:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">interface</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{...}</span>

<span class="k">interface</span> <span class="n">I2</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">G1</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="nf">F1</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">);</span>                  <span class="c1">// Overload resulotion for G&lt;int&gt;.F1</span>
    <span class="kt">int</span> <span class="nf">F1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>                <span class="c1">// will pick non-generic</span>

    <span class="k">void</span> <span class="nf">F2</span><span class="p">(</span><span class="n">I1</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">);</span>             <span class="c1">// Valid overload</span>
    <span class="k">void</span> <span class="nf">F2</span><span class="p">(</span><span class="n">I2</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">G2</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F3</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">,</span> <span class="n">V</span> <span class="n">v</span><span class="p">);</span>            <span class="c1">// Valid, but overload resolution for</span>
    <span class="k">void</span> <span class="nf">F3</span><span class="p">(</span><span class="n">V</span> <span class="n">v</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>            <span class="c1">// G2&lt;int,int&gt;.F3 will fail</span>

    <span class="k">void</span> <span class="nf">F4</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">,</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v</span><span class="p">);</span>        <span class="c1">// Valid, but overload resolution for    </span>
    <span class="k">void</span> <span class="nf">F4</span><span class="p">(</span><span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>        <span class="c1">// G2&lt;I1&lt;int&gt;,int&gt;.F4 will fail</span>

    <span class="k">void</span> <span class="nf">F5</span><span class="p">(</span><span class="n">U</span> <span class="n">u1</span><span class="p">,</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v2</span><span class="p">);</span>      <span class="c1">// Valid overload</span>
    <span class="k">void</span> <span class="nf">F5</span><span class="p">(</span><span class="n">V</span> <span class="n">v1</span><span class="p">,</span> <span class="n">U</span> <span class="n">u2</span><span class="p">);</span>

    <span class="k">void</span> <span class="nf">F6</span><span class="p">(</span><span class="k">ref</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>             <span class="c1">// valid overload</span>
    <span class="k">void</span> <span class="nf">F6</span><span class="p">(</span><span class="k">out</span> <span class="n">V</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</h3>

<p>For most dynamically bound operations the set of possible candidates for resolution is unknown at compile-time. In certain cases, however the candidate set is known at compile-time:</p>

<ul>
<li> Static method calls with dynamic arguments</li>
<li> Instance method calls where the receiver is not a dynamic expression</li>
<li> Indexer calls where the receiver is not a dynamic expression</li>
<li> Constructor calls with dynamic arguments</li>
</ul>

<p>In these cases a limited compile-time check is performed for each candidate to see if any of them could possibly apply at run-time.This check consists of the following steps:</p>

<ul>
<li> Partial type inference: Any type argument that does not depend directly or indirectly on an argument of type <code class="prettyprint">dynamic</code> is inferred using the rules of <a href="expressions.md#type-inference">Type inference</a>. The remaining type arguments are unknown.</li>
<li> Partial applicability check: Applicability is checked according to <a href="expressions.md#applicable-function-member">Applicable function member</a>, but ignoring parameters whose types are unknown.</li>
<li> If no candidate passes this test, a compile-time error occurs.</li>
</ul>

<h3 id="function-member-invocation">Function member invocation</h3>

<p>This section describes the process that takes place at run-time to invoke a particular function member. It is assumed that a binding-time process has already determined the particular member to invoke, possibly by applying overload resolution to a set of candidate function members.</p>

<p>For purposes of describing the invocation process, function members are divided into two categories:</p>

<ul>
<li> Static function members. These are instance constructors, static methods, static property accessors, and user-defined operators. Static function members are always non-virtual.</li>
<li> Instance function members. These are instance methods, instance property accessors, and indexer accessors. Instance function members are either non-virtual or virtual, and are always invoked on a particular instance. The instance is computed by an instance expression, and it becomes accessible within the function member as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
</ul>

<p>The run-time processing of a function member invocation consists of the following steps, where <code class="prettyprint">M</code> is the function member and, if <code class="prettyprint">M</code> is an instance member, <code class="prettyprint">E</code> is the instance expression:</p>

<ul>
<li><p>If <code class="prettyprint">M</code> is a static function member:</p>

<ul>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li><code class="prettyprint">M</code> is invoked.</li>
</ul></li>
<li><p>If <code class="prettyprint">M</code> is an instance function member declared in a <em>value_type</em>:</p>

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, then no further steps are executed.</li>
<li>If <code class="prettyprint">E</code> is not classified as a variable, then a temporary local variable of <code class="prettyprint">E</code>&rsquo;s type is created and the value of <code class="prettyprint">E</code> is assigned to that variable. <code class="prettyprint">E</code> is then reclassified as a reference to that temporary local variable. The temporary variable is accessible as <code class="prettyprint">this</code> within <code class="prettyprint">M</code>, but not in any other way. Thus, only when <code class="prettyprint">E</code> is a true variable is it possible for the caller to observe the changes that <code class="prettyprint">M</code> makes to <code class="prettyprint">this</code>.</li>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li><code class="prettyprint">M</code> is invoked. The variable referenced by <code class="prettyprint">E</code> becomes the variable referenced by <code class="prettyprint">this</code>.</li>
</ul></li>
<li><p>If <code class="prettyprint">M</code> is an instance function member declared in a <em>reference_type</em>:</p>

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, then no further steps are executed.</li>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li>If the type of <code class="prettyprint">E</code> is a <em>value_type</em>, a boxing conversion (<a href="types.md#boxing-conversions">Boxing conversions</a>) is performed to convert <code class="prettyprint">E</code> to type <code class="prettyprint">object</code>, and <code class="prettyprint">E</code> is considered to be of type <code class="prettyprint">object</code> in the following steps. In this case, <code class="prettyprint">M</code> could only be a member of <code class="prettyprint">System.Object</code>.</li>
<li>The value of <code class="prettyprint">E</code> is checked to be valid. If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li>The function member implementation to invoke is determined:

<ul>
<li>If the binding-time type of <code class="prettyprint">E</code> is an interface, the function member to invoke is the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>. This function member is determined by applying the interface mapping rules (<a href="interfaces.md#interface-mapping">Interface mapping</a>) to determine the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>.</li>
<li>Otherwise, if <code class="prettyprint">M</code> is a virtual function member, the function member to invoke is the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>. This function member is determined by applying the rules for determining the most derived implementation (<a href="classes.md#virtual-methods">Virtual methods</a>) of <code class="prettyprint">M</code> with respect to the run-time type of the instance referenced by <code class="prettyprint">E</code>.</li>
<li>Otherwise, <code class="prettyprint">M</code> is a non-virtual function member, and the function member to invoke is <code class="prettyprint">M</code> itself.</li>
</ul></li>
<li>The function member implementation determined in the step above is invoked. The object referenced by <code class="prettyprint">E</code> becomes the object referenced by <code class="prettyprint">this</code>.</li>
</ul></li>
</ul>

<h4 id="invocations-on-boxed-instances">Invocations on boxed instances</h4>

<p>A function member implemented in a <em>value_type</em> can be invoked through a boxed instance of that <em>value_type</em> in the following situations:</p>

<ul>
<li> When the function member is an <code class="prettyprint">override</code> of a method inherited from type <code class="prettyprint">object</code> and is invoked through an instance expression of type <code class="prettyprint">object</code>.</li>
<li> When the function member is an implementation of an interface function member and is invoked through an instance expression of an <em>interface_type</em>.</li>
<li> When the function member is invoked through a delegate.</li>
</ul>

<p>In these situations, the boxed instance is considered to contain a variable of the <em>value_type</em>, and this variable becomes the variable referenced by <code class="prettyprint">this</code> within the function member invocation. In particular, this means that when a function member is invoked on a boxed instance, it is possible for the function member to modify the value contained in the boxed instance.</p>

<h2 id="primary-expressions">Primary expressions</h2>

<p>Primary expressions include the simplest forms of expressions.</p>
<pre class="highlight shell"><code>primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
</code></pre>
<p>Primary expressions are divided between *array_creation_expression*s and *primary_no_array_creation_expression*s. Treating array-creation-expression in this way, rather than listing it along with the other simple expression forms, enables the grammar to disallow potentially confusing code such as
<code class="prettyprint">csharp
object o = new int[3][1];
</code>
which would otherwise be interpreted as
<code class="prettyprint">csharp
object o = (new int[3])[1];
</code></p>

<h3 id="literals">Literals</h3>

<p>A <em>primary_expression</em> that consists of a <em>literal</em> (<a href="lexical-structure.md#literals">Literals</a>) is classified as a value.</p>

<h3 id="interpolated-strings">Interpolated strings</h3>

<p>An <em>interpolated_string_expression</em> consists of a <code class="prettyprint">$</code> sign followed by a regular or verbatim string literal, wherein holes, delimited by <code class="prettyprint">{</code> and <code class="prettyprint">}</code>, enclose expressions and formatting specifications. An interpolated string expression is the result of an <em>interpolated_string_literal</em> that has been broken up into individual tokens, as described in <a href="lexical-structure.md#interpolated-string-literals">Interpolated string literals</a>.</p>
<pre class="highlight shell"><code>interpolated_string_expression
    : <span class="s1">'$'</span> interpolated_regular_string
    | <span class="s1">'$'</span> interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation <span class="o">(</span>interpolated_regular_string_mid interpolation<span class="o">)</span><span class="k">*</span>
    ;

interpolation
    : expression
    | expression <span class="s1">','</span> constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation <span class="o">(</span>interpolated_verbatim_string_mid interpolation<span class="o">)</span>+
    ;
</code></pre>
<p>The <em>constant_expression</em> in an interpolation must have an implicit conversion to <code class="prettyprint">int</code>.</p>

<p>An <em>interpolated_string_expression</em> is classified as a value. If it is immediately converted to <code class="prettyprint">System.IFormattable</code> or <code class="prettyprint">System.FormattableString</code> with an implicit interpolated string conversion (<a href="conversions.md#implicit-interpolated-string-conversions">Implicit interpolated string conversions</a>), the interpolated string expression has that type. Otherwise, it has the type <code class="prettyprint">string</code>.</p>

<p>If the type of an interpolated string is <code class="prettyprint">System.IFormattable</code> or <code class="prettyprint">System.FormattableString</code>, the meaning is a call to <code class="prettyprint">System.Runtime.CompilerServices.FormattableStringFactory.Create</code>. If the type is <code class="prettyprint">string</code>, the meaning of the expression is a call to <code class="prettyprint">string.Format</code>. In both cases, the argument list of the call consists of a format string literal with placeholders for each interpolation, and an argument for each expression corresponding to the place holders.</p>

<p>The format string literal is constructed as follows, where <code class="prettyprint">N</code> is the number of interpolations in the <em>interpolated_string_expression</em>:</p>

<ul>
<li> If an <em>interpolated_regular_string_whole</em> or an <em>interpolated_verbatim_string_whole</em> follows the <code class="prettyprint">$</code> sign, then the format string literal is that token.</li>
<li> Otherwise, the format string literal consists of: 

<ul>
<li> First the <em>interpolated_regular_string_start</em> or <em>interpolated_verbatim_string_start</em></li>
<li> Then for each number <code class="prettyprint">I</code> from <code class="prettyprint">0</code> to <code class="prettyprint">N-1</code>: 

<ul>
<li>The decimal representation of <code class="prettyprint">I</code></li>
<li>Then, if the corresponding <em>interpolation</em> has a <em>constant_expression</em>, a <code class="prettyprint">,</code> (comma) followed by the decimal representation of the value of the <em>constant_expression</em></li>
<li>Then the <em>interpolated_regular_string_mid</em>, <em>interpolated_regular_string_end</em>, <em>interpolated_verbatim_string_mid</em> or <em>interpolated_verbatim_string_end</em> immediately following the corresponding interpolation.</li>
</ul></li>
</ul></li>
</ul>

<p>The subsequent arguments are simply the <em>expressions</em> from the <em>interpolations</em> (if any), in order.</p>

<p>TODO: examples.</p>

<h3 id="simple-names">Simple names</h3>

<p>A <em>simple_name</em> consists of an identifier, optionally followed by a type argument list:</p>
<pre class="highlight shell"><code>simple_name
    : identifier type_argument_list?
    ;
</code></pre>
<p>A <em>simple_name</em> is either of the form <code class="prettyprint">I</code> or of the form <code class="prettyprint">I&lt;A1,...,Ak&gt;</code>, where <code class="prettyprint">I</code> is a single identifier and <code class="prettyprint">&lt;A1,...,Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">K</code> to be zero. The <em>simple_name</em> is evaluated and classified as follows:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and the <em>simple_name</em> appears within a <em>block</em> and if the <em>block</em>&rsquo;s (or an enclosing <em>block</em>&rsquo;s) local variable declaration space (<a href="basic-concepts.md#declarations">Declarations</a>) contains a local variable, parameter or constant with nameÂ <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that local variable, parameter or constant and is classified as a variable or value.</li>
<li> If <code class="prettyprint">K</code> is zero and the <em>simple_name</em> appears within the body of a generic method declaration and if that declaration includes a type parameter with nameÂ <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that type parameter.</li>
<li><p>Otherwise, for each instance typeÂ <code class="prettyprint">T</code> (<a href="classes.md#the-instance-type">The instance type</a>), starting with the instance type of the immediately enclosing type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and the declaration of <code class="prettyprint">T</code> includes a type parameter with nameÂ <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that type parameter.</li>
<li> Otherwise, if a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">T</code> with <code class="prettyprint">K</code>Â type arguments produces a match:

<ul>
<li>If <code class="prettyprint">T</code> is the instance type of the immediately enclosing class or struct type and the lookup identifies one or more methods, the result is a method group with an associated instance expression of <code class="prettyprint">this</code>. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li>Otherwise, if <code class="prettyprint">T</code> is the instance type of the immediately enclosing class or struct type, if the lookup identifies an instance member, and if the reference occurs within the body of an instance constructor, an instance method, or an instance accessor, the result is the same as a member access (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">this.I</code>. This can only happen when <code class="prettyprint">K</code> is zero.</li>
<li>Otherwise, the result is the same as a member access (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">T.I</code> or <code class="prettyprint">T.I&lt;A1,...,Ak&gt;</code>. In this case, it is a binding-time error for the <em>simple_name</em> to refer to an instance member.</li>
</ul></li>
</ul></li>
<li><p>Otherwise, for each namespaceÂ <code class="prettyprint">N</code>, starting with the namespace in which the <em>simple_name</em> occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and <code class="prettyprint">I</code> is the name of a namespace inÂ <code class="prettyprint">N</code>, then:

<ul>
<li>If the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with a namespace or type, then the <em>simple_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>simple_name</em> refers to the namespace named <code class="prettyprint">I</code> in <code class="prettyprint">N</code>.</li>
</ul></li>
<li> Otherwise, if <code class="prettyprint">N</code> contains an accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with a namespace or type, then the <em>simple_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the type constructed with the given type arguments.</li>
</ul></li>
<li> Otherwise, if the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration forÂ <code class="prettyprint">N</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the nameÂ <code class="prettyprint">I</code> with an imported namespace or type, then the <em>simple_name</em> refers to that namespace or type.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_static_directive*s of the namespace declaration contain exactly one accessible type or non-extension static membre having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the *simple_name</em> refers to that type or member constructed with the given type arguments.</li>
<li>Otherwise, if the namespaces and types imported by the <em>using_namespace_directive*s of the namespace declaration contain more than one accessible type or non-extension-method static member having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the *simple_name</em> is ambiguous and an error occurs.</li>
</ul></li>
</ul></li>
</ul>

<p>Note that this entire step is exactly parallel to the corresponding step in the processing of a <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>).</p>

<ul>
<li> Otherwise, the <em>simple_name</em> is undefined and a compile-time error occurs.</li>
</ul>

<h3 id="parenthesized-expressions">Parenthesized expressions</h3>

<p>A <em>parenthesized_expression</em> consists of an <em>expression</em> enclosed in parentheses.</p>
<pre class="highlight shell"><code>parenthesized_expression
    : <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>A <em>parenthesized_expression</em> is evaluated by evaluating the <em>expression</em> within the parentheses. If the <em>expression</em> within the parentheses denotes a namespace or type, a compile-time error occurs. Otherwise, the result of the <em>parenthesized_expression</em> is the result of the evaluation of the contained <em>expression</em>.</p>

<h3 id="member-access">Member access</h3>

<p>A <em>member_access</em> consists of a <em>primary_expression</em>, a <em>predefined_type</em>, or a <em>qualified_alias_member</em>, followed by a &ldquo;<code class="prettyprint">.</code>&rdquo; token, followed by an <em>identifier</em>, optionally followed by a <em>type_argument_list</em>.</p>
<pre class="highlight shell"><code>member_access
    : primary_expression <span class="s1">'.'</span> identifier type_argument_list?
    | predefined_type <span class="s1">'.'</span> identifier type_argument_list?
    | qualified_alias_member <span class="s1">'.'</span> identifier
    ;

predefined_type
    : <span class="s1">'bool'</span>   | <span class="s1">'byte'</span>  | <span class="s1">'char'</span>  | <span class="s1">'decimal'</span> | <span class="s1">'double'</span> | <span class="s1">'float'</span> | <span class="s1">'int'</span> | <span class="s1">'long'</span>
    | <span class="s1">'object'</span> | <span class="s1">'sbyte'</span> | <span class="s1">'short'</span> | <span class="s1">'string'</span>  | <span class="s1">'uint'</span>   | <span class="s1">'ulong'</span> | <span class="s1">'ushort'</span>
    ;
</code></pre>
<p>The <em>qualified_alias_member</em> production is defined in <a href="namespaces.md#namespace-alias-qualifiers">Namespace alias qualifiers</a>.</p>

<p>A <em>member_access</em> is either of the form <code class="prettyprint">E.I</code> or of the form <code class="prettyprint">E.I&lt;A1, ..., Ak&gt;</code>, where <code class="prettyprint">E</code> is a primary-expression, <code class="prettyprint">I</code> is a single identifier and <code class="prettyprint">&lt;A1, ..., Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">K</code> to be zero.</p>

<p>A <em>member_access</em> with a <em>primary_expression</em> of type <code class="prettyprint">dynamic</code> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compiler classifies the member access as a property access of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>member_access</em> are then applied at run-time, using the run-time type instead of the compile-time type of the <em>primary_expression</em>. If this run-time classification leads to a method group, then the member access must be the <em>primary_expression</em> of an <em>invocation_expression</em>.</p>

<p>The <em>member_access</em> is evaluated and classified as follows:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and <code class="prettyprint">E</code> is a namespace and <code class="prettyprint">E</code> contains a nested namespace with nameÂ <code class="prettyprint">I</code>, then the result is that namespace.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is a namespace and <code class="prettyprint">E</code> contains an accessible type having nameÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code>Â type parameters, then the result is that type constructed with the given type arguments.</li>
<li> If <code class="prettyprint">E</code> is a <em>predefined_type</em> or a <em>primary_expression</em> classified as a type, if <code class="prettyprint">E</code> is not a type parameter, and if a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">E</code> with <code class="prettyprint">K</code>Â type parameters produces a match, then <code class="prettyprint">E.I</code> is evaluated and classified as follows:

<ul>
<li> If <code class="prettyprint">I</code> identifies a type, then the result is that type constructed with the given type arguments.</li>
<li> If <code class="prettyprint">I</code> identifies one or more methods, then the result is a method group with no associated instance expression. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> property, then the result is a property access with no associated instance expression.</li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> field:

<ul>
<li>If the field is <code class="prettyprint">readonly</code> and the reference occurs outside the static constructor of the class or struct in which the field is declared, then the result is a value, namely the value of the static fieldÂ <code class="prettyprint">I</code> inÂ <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the static fieldÂ <code class="prettyprint">I</code> inÂ <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> event:

<ul>
<li>If the reference occurs within the class or struct in which the event is declared, and the event was declared without <em>event_accessor_declarations</em> (<a href="classes.md#events">Events</a>), then <code class="prettyprint">E.I</code> is processed exactly as if <code class="prettyprint">I</code> were a static field.</li>
<li>Otherwise, the result is an event access with no associated instance expression.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies a constant, then the result is a value, namely the value of that constant.</li>
<li>If <code class="prettyprint">I</code> identifies an enumeration member, then the result is a value, namely the value of that enumeration member.</li>
<li>Otherwise, <code class="prettyprint">E.I</code> is an invalid member reference, and a compile-time error occurs.</li>
</ul></li>
<li> If <code class="prettyprint">E</code> is a property access, indexer access, variable, or value, the type of which isÂ <code class="prettyprint">T</code>, and a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">T</code> with <code class="prettyprint">K</code>Â type arguments produces a match, then <code class="prettyprint">E.I</code> is evaluated and classified as follows:

<ul>
<li> First, if <code class="prettyprint">E</code> is a property or indexer access, then the value of the property or indexer access is obtained (<a href="expressions.md#values-of-expressions">Values of expressions</a>) and <code class="prettyprint">E</code> is reclassified as a value.</li>
<li> If <code class="prettyprint">I</code> identifies one or more methods, then the result is a method group with an associated instance expression of <code class="prettyprint">E</code>. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> If <code class="prettyprint">I</code> identifies an instance property,

<ul>
<li>If <code class="prettyprint">E</code> is <code class="prettyprint">this</code>, <code class="prettyprint">I</code> identifies an automatically implemented property (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>) without a setter, and the reference occurs within an instance constructor for a class or struct type <code class="prettyprint">T</code>, then the result is a variable, namely the hidden backing field for the auto-property given by <code class="prettyprint">I</code> in the instance of <code class="prettyprint">T</code> given by <code class="prettyprint">this</code>.</li>
<li>Otherwise, the result is a property access with an associated instance expression ofÂ <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">T</code> is a <em>class_type</em> and <code class="prettyprint">I</code> identifies an instance field of that <em>class_type</em>:

<ul>
<li>If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, then a <code class="prettyprint">System.NullReferenceException</code> is thrown.</li>
<li>Otherwise, if the field is <code class="prettyprint">readonly</code> and the reference occurs outside an instance constructor of the class in which the field is declared, then the result is a value, namely the value of the fieldÂ <code class="prettyprint">I</code> in the object referenced byÂ <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the fieldÂ <code class="prettyprint">I</code> in the object referenced byÂ <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">T</code> is a <em>struct_type</em> and <code class="prettyprint">I</code> identifies an instance field of that <em>struct_type</em>:

<ul>
<li>If <code class="prettyprint">E</code> is a value, or if the field is <code class="prettyprint">readonly</code> and the reference occurs outside an instance constructor of the struct in which the field is declared, then the result is a value, namely the value of the fieldÂ <code class="prettyprint">I</code> in the struct instance given byÂ <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the fieldÂ <code class="prettyprint">I</code> in the struct instance given byÂ <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies an instance event:

<ul>
<li>If the reference occurs within the class or struct in which the event is declared, and the event was declared without <em>event_accessor_declarations</em> (<a href="classes.md#events">Events</a>), and the reference does not occur as the left-hand side of a <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator, then <code class="prettyprint">E.I</code> is processed exactly as if <code class="prettyprint">I</code> was an instance field.</li>
<li>Otherwise, the result is an event access with an associated instance expression ofÂ <code class="prettyprint">E</code>.</li>
</ul></li>
</ul></li>
<li> Otherwise, an attempt is made to process <code class="prettyprint">E.I</code> as an extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). If this fails, <code class="prettyprint">E.I</code> is an invalid member reference, and a binding-time error occurs.</li>
</ul>

<h4 id="identical-simple-names-and-type-names">Identical simple names and type names</h4>

<p>In a member access of the form <code class="prettyprint">E.I</code>, if <code class="prettyprint">E</code> is a single identifier, and if the meaning of <code class="prettyprint">E</code> as a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) is a constant, field, property, local variable, or parameter with the same type as the meaning of <code class="prettyprint">E</code> as a <em>type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>), then both possible meanings of <code class="prettyprint">E</code> are permitted. The two possible meanings of <code class="prettyprint">E.I</code> are never ambiguous, since <code class="prettyprint">I</code> must necessarily be a member of the type <code class="prettyprint">E</code> in both cases. In other words, the rule simply permits access to the static members and nested types of <code class="prettyprint">E</code> where a compile-time error would otherwise have occurred. For example:
&ldquo;`csharp
struct Color
{
    public static readonly Color White = new Color(&hellip;);
    public static readonly Color Black = new Color(&hellip;);</p>

<p>public Color Complement() {&hellip;}
}</p>

<p>class A
{
    public Color Color;                // Field Color of type Color</p>

<p>void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }</p>

<p>static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
&rdquo;`</p>

<h4 id="grammar-ambiguities">Grammar ambiguities</h4>

<p>The productions for <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) and <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) can give rise to ambiguities in the grammar for expressions. For example, the statement:
<code class="prettyprint">bash
F(G&lt;A,B&gt;(7));
</code>
could be interpreted as a call to <code class="prettyprint">F</code> with two arguments, <code class="prettyprint">G &lt; A</code> and <code class="prettyprint">B &gt; (7)</code>. Alternatively, it could be interpreted as a call to <code class="prettyprint">F</code> with one argument, which is a call to a generic methodÂ <code class="prettyprint">G</code> with two type arguments and one regular argument.</p>

<p>If a sequence of tokens can be parsed (in context) as a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>), <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), or <em>pointer_member_access</em> (<a href="unsafe-code.md#pointer-member-access">Pointer member access</a>) ending with a <em>type_argument_list</em> (<a href="types.md#type-arguments">Type arguments</a>), the token immediately following the closing <code class="prettyprint">&gt;</code> token is examined. If it is one of
<code class="prettyprint">csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
</code>
then the <em>type_argument_list</em> is retained as part of the <em>simple_name</em>, <em>member_access</em> or <em>pointer_member_access</em> and any other possible parse of the sequence of tokens is discarded. Otherwise, the <em>type_argument_list</em> is not considered to be part of the <em>simple_name</em>, <em>member_access</em> or <em>pointer_member_access</em>, even if there is no other possible parse of the sequence of tokens. Note that these rules are not applied when parsing a <em>type_argument_list</em> in a <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>). The statement
<code class="prettyprint">csharp
F(G&lt;A,B&gt;(7));
</code>
will, according to this rule, be interpreted as a call to <code class="prettyprint">F</code> with one argument, which is a call to a generic method <code class="prettyprint">G</code> with two type arguments and one regular argument. The statements
<code class="prettyprint">csharp
F(G &lt; A, B &gt; 7);
F(G &lt; A, B &gt;&gt; 7);
</code>
will each be interpreted as a call to <code class="prettyprint">F</code> with two arguments. The statement
<code class="prettyprint">csharp
x = F &lt; A &gt; +y;
</code>
will be interpreted as a less than operator, greater than operator, and unary plus operator, as if the statement had been written <code class="prettyprint">x = (F &lt; A) &gt; (+y)</code>, instead of as a <em>simple_name</em> with a <em>type_argument_list</em> followed by a binary plus operator. In the statement
<code class="prettyprint">csharp
x = y is C&lt;T&gt; + z;
</code>
the tokens <code class="prettyprint">C&lt;T&gt;</code> are interpreted as a <em>namespace_or_type_name</em> with a <em>type_argument_list</em>.</p>

<h3 id="invocation-expressions">Invocation expressions</h3>

<p>An <em>invocation_expression</em> is used to invoke a method.</p>
<pre class="highlight shell"><code>invocation_expression
    : primary_expression <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>An <em>invocation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) if at least one of the following holds:</p>

<ul>
<li>The <em>primary_expression</em> has compile-time type <code class="prettyprint">dynamic</code>.</li>
<li>At least one argument of the optional <em>argument_list</em> has compile-time type <code class="prettyprint">dynamic</code> and the <em>primary_expression</em> does not have a delegate type.</li>
</ul>

<p>In this case the compiler classifies the <em>invocation_expression</em> as a value of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>invocation_expression</em> are then applied at run-time, using the run-time type instead of the compile-time type of those of the <em>primary_expression</em> and arguments which have the compile-time type <code class="prettyprint">dynamic</code>. If the <em>primary_expression</em> does not have compile-time type <code class="prettyprint">dynamic</code>, then the method invocation undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The <em>primary_expression</em> of an <em>invocation_expression</em> must be a method group or a value of a <em>delegate_type</em>. If the <em>primary_expression</em> is a method group, the <em>invocation_expression</em> is a method invocation (<a href="expressions.md#method-invocations">Method invocations</a>). If the <em>primary_expression</em> is a value of a <em>delegate_type</em>, the <em>invocation_expression</em> is a delegate invocation (<a href="expressions.md#delegate-invocations">Delegate invocations</a>). If the <em>primary_expression</em> is neither a method group nor a value of a <em>delegate_type</em>, a binding-time error occurs.</p>

<p>The optional <em>argument_list</em> (<a href="expressions.md#argument-lists">Argument lists</a>) provides values or variable references for the parameters of the method.</p>

<p>The result of evaluating an <em>invocation_expression</em> is classified as follows:</p>

<ul>
<li> If the <em>invocation_expression</em> invokes a method or delegate that returns <code class="prettyprint">void</code>, the result is nothing. An expression that is classified as nothing is permitted only in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>) or as the body of a <em>lambda_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>). Otherwise a binding-time error occurs.</li>
<li> Otherwise, the result is a value of the type returned by the method or delegate.</li>
</ul>

<h4 id="method-invocations">Method invocations</h4>

<p>For a method invocation, the <em>primary_expression</em> of the <em>invocation_expression</em> must be a method group. The method group identifies the one method to invoke or the set of overloaded methods from which to choose a specific method to invoke. In the latter case, determination of the specific method to invoke is based on the context provided by the types of the arguments in the <em>argument_list</em>.</p>

<p>The binding-time processing of a method invocation of the form <code class="prettyprint">M(A)</code>, where <code class="prettyprint">M</code> is a method group (possibly including a <em>type_argument_list</em>), and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> The set of candidate methods for the method invocation is constructed. For each method <code class="prettyprint">F</code> associated with the method group <code class="prettyprint">M</code>:

<ul>
<li> If <code class="prettyprint">F</code> is non-generic, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li><code class="prettyprint">M</code> has no type argument list, and</li>
<li><code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
<li> If <code class="prettyprint">F</code> is generic and <code class="prettyprint">M</code> has no type argument list, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li>Type inference (<a href="expressions.md#type-inference">Type inference</a>) succeeds, inferring a list of type arguments for the call, and</li>
<li>Once the inferred type arguments are substituted for the corresponding method type parameters, all constructed types in the parameter list of F satisfy their constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>), and the parameter list of <code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
<li> If <code class="prettyprint">F</code> is generic and <code class="prettyprint">M</code> includes a type argument list, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li><code class="prettyprint">F</code> has the same number of method type parameters as were supplied in the type argument list, and</li>
<li>Once the type arguments are substituted for the corresponding method type parameters, all constructed types in the parameter list of F satisfy their constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>), and the parameter list of <code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
</ul></li>
<li> The set of candidate methods is reduced to contain only methods from the most derived types: For each method <code class="prettyprint">C.F</code> in the set, where <code class="prettyprint">C</code> is the type in which the method <code class="prettyprint">F</code> is declared, all methods declared in a base type of <code class="prettyprint">C</code> are removed from the set. Furthermore, if <code class="prettyprint">C</code> is a class type other than <code class="prettyprint">object</code>, all methods declared in an interface type are removed from the set. (This latter rule only has affect when the method group was the result of a member lookup on a type parameter having an effective base class other than object and a non-empty effective interface set.)</li>
<li> If the resulting set of candidate methods is empty, then further processing along the following steps are abandoned, and instead an attempt is made to process the invocation as an extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). If this fails, then no applicable methods exist, and a binding-time error occurs.</li>
<li> The best method of the set of candidate methods is identified using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. If a single best method cannot be identified, the method invocation is ambiguous, and a binding-time error occurs. When performing overload resolution, the parameters of a generic method are considered after substituting the type arguments (supplied or inferred) for the corresponding method type parameters.</li>
<li> Final validation of the chosen best method is performed:

<ul>
<li>The method is validated in the context of the method group: If the best method is a static method, the method group must have resulted from a <em>simple_name</em> or a <em>member_access</em> through a type. If the best method is an instance method, the method group must have resulted from a <em>simple_name</em>, a <em>member_access</em> through a variable or value, or a <em>base_access</em>. If neither of these requirements is true, a binding-time error occurs.</li>
<li>If the best method is a generic method, the type arguments (supplied or inferred) are checked against the constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>) declared on the generic method. If any type argument does not satisfy the corresponding constraint(s) on the type parameter, a binding-time error occurs.</li>
</ul></li>
</ul>

<p>Once a method has been selected and validated at binding-time by the above steps, the actual run-time invocation is processed according to the rules of function member invocation described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The intuitive effect of the resolution rules described above is as follows: To locate the particular method invoked by a method invocation, start with the type indicated by the method invocation and proceed up the inheritance chain until at least one applicable, accessible, non-override method declaration is found. Then perform type inference and overload resolution on the set of applicable, accessible, non-override methods declared in that type and invoke the method thus selected. If no method was found, try instead to process the invocation as an extension method invocation.</p>

<h4 id="extension-method-invocations">Extension method invocations</h4>

<p>In a method invocation (<a href="expressions.md#invocations-on-boxed-instances">Invocations on boxed instances</a>) of one of the forms
&ldquo;`csharp
expr . identifier ( )</p>

<p>expr . identifier ( args )</p>

<p>expr . identifier &lt; typeargs &gt; ( )</p>

<p>expr . identifier &lt; typeargs &gt; ( args )
&rdquo;<code class="prettyprint">
if the normal processing of the invocation finds no applicable methods, an attempt is made to process the construct as an extension method invocation. If *expr* or any of the *args* has compile-time type</code>dynamic`, extension methods will not apply.</p>

<p>The objective is to find the best <em>type_name</em> <code class="prettyprint">C</code>, so that the corresponding static method invocation can take place:
&ldquo;`csharp
C . identifier ( expr )</p>

<p>C . identifier ( expr , args )</p>

<p>C . identifier &lt; typeargs &gt; ( expr )</p>

<p>C . identifier &lt; typeargs &gt; ( expr , args )
&rdquo;`</p>

<p>An extension method <code class="prettyprint">Ci.Mj</code> is <strong><em>eligible</em></strong> if:</p>

<ul>
<li> <code class="prettyprint">Ci</code> is a non-generic, non-nested class</li>
<li> The name of <code class="prettyprint">Mj</code> is <em>identifier</em></li>
<li> <code class="prettyprint">Mj</code> is accessible and applicable when applied to the arguments as a static method as shown above</li>
<li> An implicit identity, reference or boxing conversion exists from <em>expr</em> to the type of the first parameter of <code class="prettyprint">Mj</code>.</li>
</ul>

<p>The search for <code class="prettyprint">C</code> proceeds as follows:</p>

<ul>
<li> Starting with the closest enclosing namespace declaration, continuing with each enclosing namespace declaration, and ending with the containing compilation unit, successive attempts are made to find a candidate set of extension methods:

<ul>
<li>If the given namespace or compilation unit directly contains non-generic type declarations <code class="prettyprint">Ci</code> with eligible extension methods <code class="prettyprint">Mj</code>, then the set of those extension methods is the candidate set.</li>
<li>If types <code class="prettyprint">Ci</code> imported by <em>using_static_declarations</em> and directly declared in namespaces imported by *using_namespace_directive*s in the given namespace or compilation unit directly contain eligible extension methods <code class="prettyprint">Mj</code>, then the set of those extension methods is the candidate set.</li>
</ul></li>
<li> If no candidate set is found in any enclosing namespace declaration or compilation unit, a compile-time error occurs.</li>
<li> Otherwise, overload resolution is applied to the candidate set as described in (<a href="expressions.md#overload-resolution">Overload resolution</a>). If no single best method is found, a compile-time error occurs.</li>
<li> <code class="prettyprint">C</code> is the type within which the best method is declared as an extension method.</li>
</ul>

<p>Using <code class="prettyprint">C</code> as a target, the method call is then processed as a static method invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>).</p>

<p>The preceding rules mean that instance methods take precedence over extension methods, that extension methods available in inner namespace declarations take precedence over extension methods available in outer namespace declarations, and that extension methods declared directly in a namespace take precedence over extension methods imported into that same namespace with a using namespace directive. For example:
&ldquo;`csharp
public static class E
{
    public static void F(this object obj, int i) { }</p>

<p>public static void F(this object obj, string s) { }
}</p>

<p>class A { }</p>

<p>class B
{
    public void F(int i) { }
}</p>

<p>class C
{
    public void F(object obj) { }
}</p>

<p>class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F(&quot;hello&rdquo;);        // E.F(object, string)</p>

<p>b.F(1);              // B.F(int)
        b.F(&ldquo;hello&rdquo;);        // E.F(object, string)</p>

<p>c.F(1);              // C.F(object)
        c.F(&ldquo;hello&rdquo;);        // C.F(object)
    }
}
&ldquo;`</p>

<p>In the example, <code class="prettyprint">B</code>&rsquo;s method takes precedence over the first extension method, and <code class="prettyprint">C</code>&rsquo;s method takes precedence over both extension methods.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.G({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">H</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.H({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N1</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">D</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"D.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"D.G({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N2</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">N1</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">E</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"E.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Test</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="m">1.F</span><span class="p">();</span>
            <span class="m">2.</span><span class="nf">G</span><span class="p">();</span>
            <span class="m">3.</span><span class="nf">H</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The output of this example is:
<code class="prettyprint">bash
E.F(1)
D.G(2)
C.H(3)
</code>
<code class="prettyprint">D.G</code> takes precendece over <code class="prettyprint">C.G</code>, and <code class="prettyprint">E.F</code> takes precedence over both <code class="prettyprint">D.F</code> and <code class="prettyprint">C.F</code>.</p>

<h4 id="delegate-invocations">Delegate invocations</h4>

<p>For a delegate invocation, the <em>primary_expression</em> of the <em>invocation_expression</em> must be a value of a <em>delegate_type</em>. Furthermore, considering the <em>delegate_type</em> to be a function member with the same parameter list as the <em>delegate_type</em>, the <em>delegate_type</em> must be applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>) with respect to the <em>argument_list</em> of the <em>invocation_expression</em>.</p>

<p>The run-time processing of a delegate invocation of the form <code class="prettyprint">D(A)</code>, where <code class="prettyprint">D</code> is a <em>primary_expression</em> of a <em>delegate_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> <code class="prettyprint">D</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li> The value of <code class="prettyprint">D</code> is checked to be valid. If the value of <code class="prettyprint">D</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li> Otherwise, <code class="prettyprint">D</code> is a reference to a delegate instance. Function member invocations (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) are performed on each of the callable entities in the invocation list of the delegate. For callable entities consisting of an instance and instance method, the instance for the invocation is the instance contained in the callable entity.</li>
</ul>

<h3 id="element-access">Element access</h3>

<p>An <em>element_access</em> consists of a <em>primary_no_array_creation_expression</em>, followed by a &rdquo;<code class="prettyprint">[</code>&ldquo; token, followed by an <em>argument_list</em>, followed by a &rdquo;<code class="prettyprint">]</code>&ldquo; token. The <em>argument_list</em> consists of one or more *argument*s, separated by commas.</p>
<pre class="highlight shell"><code>element_access
    : primary_no_array_creation_expression <span class="s1">'['</span> expression_list <span class="s1">']'</span>
    ;
</code></pre>
<p>The <em>argument_list</em> of an <em>element_access</em> is not allowed to contain <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> arguments.</p>

<p>An <em>element_access</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) if at least one of the following holds:</p>

<ul>
<li>The <em>primary_no_array_creation_expression</em> has compile-time type <code class="prettyprint">dynamic</code>.</li>
<li>At least one expression of the <em>argument_list</em> has compile-time type <code class="prettyprint">dynamic</code> and the <em>primary_no_array_creation_expression</em> does not have an array type.</li>
</ul>

<p>In this case the compiler classifies the <em>element_access</em> as a value of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>element_access</em> are then applied at run-time, using the run-time type instead of the compile-time type of those of the <em>primary_no_array_creation_expression</em> and <em>argument_list</em> expressions which have the compile-time type <code class="prettyprint">dynamic</code>. If the <em>primary_no_array_creation_expression</em> does not have compile-time type <code class="prettyprint">dynamic</code>, then the element access undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>If the <em>primary_no_array_creation_expression</em> of an <em>element_access</em> is a value of an <em>array_type</em>, the <em>element_access</em> is an array access (<a href="expressions.md#array-access">Array access</a>). Otherwise, the <em>primary_no_array_creation_expression</em> must be a variable or value of a class, struct, or interface type that has one or more indexer members, in which case the <em>element_access</em> is an indexer access (<a href="expressions.md#indexer-access">Indexer access</a>).</p>

<h4 id="array-access">Array access</h4>

<p>For an array access, the <em>primary_no_array_creation_expression</em> of the <em>element_access</em> must be a value of an <em>array_type</em>. Furthermore, the <em>argument_list</em> of an array access is not allowed to contain named arguments.The number of expressions in the <em>argument_list</em> must be the same as the rank of the <em>array_type</em>, and each expression must be of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, or must be implicitly convertible to one or more of these types.</p>

<p>The result of evaluating an array access is a variable of the element type of the array, namely the array element selected by the value(s) of the expression(s) in the <em>argument_list</em>.</p>

<p>The run-time processing of an array access of the form <code class="prettyprint">P[A]</code>, where <code class="prettyprint">P</code> is a <em>primary_no_array_creation_expression</em> of an <em>array_type</em> and <code class="prettyprint">A</code> is an <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> <code class="prettyprint">P</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li> The index expressions of the <em>argument_list</em> are evaluated in order, from left to right. Following evaluation of each index expression, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to one of the following types is performed: <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>. The first type in this list for which an implicit conversion exists is chosen. For instance, if the index expression is of type <code class="prettyprint">short</code> then an implicit conversion to <code class="prettyprint">int</code> is performed, since implicit conversions from <code class="prettyprint">short</code> to <code class="prettyprint">int</code> and from <code class="prettyprint">short</code> to <code class="prettyprint">long</code> are possible. If evaluation of an index expression or the subsequent implicit conversion causes an exception, then no further index expressions are evaluated and no further steps are executed.</li>
<li> The value of <code class="prettyprint">P</code> is checked to be valid. If the value of <code class="prettyprint">P</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li> The value of each expression in the <em>argument_list</em> is checked against the actual bounds of each dimension of the array instance referenced by <code class="prettyprint">P</code>. If one or more values are out of range, a <code class="prettyprint">System.IndexOutOfRangeException</code> is thrown and no further steps are executed.</li>
<li> The location of the array element given by the index expression(s) is computed, and this location becomes the result of the array access.</li>
</ul>

<h4 id="indexer-access">Indexer access</h4>

<p>For an indexer access, the <em>primary_no_array_creation_expression</em> of the <em>element_access</em> must be a variable or value of a class, struct, or interface type, and this type must implement one or more indexers that are applicable with respect to the <em>argument_list</em> of the <em>element_access</em>.</p>

<p>The binding-time processing of an indexer access of the form <code class="prettyprint">P[A]</code>, where <code class="prettyprint">P</code> is a <em>primary_no_array_creation_expression</em> of a class, struct, or interface type <code class="prettyprint">T</code>, and <code class="prettyprint">A</code> is an <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> The set of indexers provided by <code class="prettyprint">T</code> is constructed. The set consists of all indexers declared in <code class="prettyprint">T</code> or a base type of <code class="prettyprint">T</code> that are not <code class="prettyprint">override</code> declarations and are accessible in the current context (<a href="basic-concepts.md#member-access">Member access</a>).</li>
<li> The set is reduced to those indexers that are applicable and not hidden by other indexers. The following rules are applied to each indexer <code class="prettyprint">S.I</code> in the set, where <code class="prettyprint">S</code> is the type in which the indexer <code class="prettyprint">I</code> is declared:

<ul>
<li>If <code class="prettyprint">I</code> is not applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>), then <code class="prettyprint">I</code> is removed from the set.</li>
<li>If <code class="prettyprint">I</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>), then all indexers declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">I</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>) and <code class="prettyprint">S</code> is a class type other than <code class="prettyprint">object</code>, all indexers declared in an interface are removed from the set.</li>
</ul></li>
<li> If the resulting set of candidate indexers is empty, then no applicable indexers exist, and a binding-time error occurs.</li>
<li> The best indexer of the set of candidate indexers is identified using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. If a single best indexer cannot be identified, the indexer access is ambiguous, and a binding-time error occurs.</li>
<li> The index expressions of the <em>argument_list</em> are evaluated in order, from left to right. The result of processing the indexer access is an expression classified as an indexer access. The indexer access expression references the indexer determined in the step above, and has an associated instance expression of <code class="prettyprint">P</code> and an associated argument list of <code class="prettyprint">A</code>.</li>
</ul>

<p>Depending on the context in which it is used, an indexer access causes invocation of either the <em>get accessor</em> or the <em>set accessor</em> of the indexer. If the indexer access is the target of an assignment, the <em>set accessor</em> is invoked to assign a new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). In all other cases, the <em>get accessor</em> is invoked to obtain the current value (<a href="expressions.md#values-of-expressions">Values of expressions</a>).</p>

<h3 id="this-access">This access</h3>

<p>A <em>this_access</em> consists of the reserved word <code class="prettyprint">this</code>.</p>
<pre class="highlight shell"><code>this_access
    : <span class="s1">'this'</span>
    ;
</code></pre>
<p>A <em>this_access</em> is permitted only in the <em>block</em> of an instance constructor, an instance method, or an instance accessor. It has one of the following meanings:</p>

<ul>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance constructor of a class, it is classified as a value. The type of the value is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the class within which the usage occurs, and the value is a reference to the object being constructed.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance method or instance accessor of a class, it is classified as a value. The type of the value is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the class within which the usage occurs, and the value is a reference to the object for which the method or accessor was invoked.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance constructor of a struct, it is classified as a variable. The type of the variable is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the struct within which the usage occurs, and the variable represents the struct being constructed. The <code class="prettyprint">this</code> variable of an instance constructor of a struct behaves exactly the same as an <code class="prettyprint">out</code> parameter of the struct typeâ€”in particular, this means that the variable must be definitely assigned in every execution path of the instance constructor.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance method or instance accessor of a struct, it is classified as a variable. The type of the variable is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the struct within which the usage occurs.

<ul>
<li>If the method or accessor is not an iterator (<a href="classes.md#iterators">Iterators</a>), the <code class="prettyprint">this</code> variable represents the struct for which the method or accessor was invoked, and behaves exactly the same as a <code class="prettyprint">ref</code> parameter of the struct type.</li>
<li>If the method or accessor is an iterator, the <code class="prettyprint">this</code> variable represents a copy of the struct for which the method or accessor was invoked, and behaves exactly the same as a value parameter of the struct type.</li>
</ul></li>
</ul>

<p>Use of <code class="prettyprint">this</code> in a <em>primary_expression</em> in a context other than the ones listed above is a compile-time error. In particular, it is not possible to refer to <code class="prettyprint">this</code> in a static method, a static property accessor, or in a <em>variable_initializer</em> of a field declaration.</p>

<h3 id="base-access">Base access</h3>

<p>A <em>base_access</em> consists of the reserved word <code class="prettyprint">base</code> followed by either a &rdquo;<code class="prettyprint">.</code>&ldquo; token and an identifier or an <em>argument_list</em> enclosed in square brackets:</p>
<pre class="highlight shell"><code>base_access
    : <span class="s1">'base'</span> <span class="s1">'.'</span> identifier
    | <span class="s1">'base'</span> <span class="s1">'['</span> expression_list <span class="s1">']'</span>
    ;
</code></pre>
<p>A <em>base_access</em> is used to access base class members that are hidden by similarly named members in the current class or struct. A <em>base_access</em> is permitted only in the <em>block</em> of an instance constructor, an instance method, or an instance accessor. When <code class="prettyprint">base.I</code> occurs in a class or struct, <code class="prettyprint">I</code> must denote a member of the base class of that class or struct. Likewise, when <code class="prettyprint">base[E]</code> occurs in a class, an applicable indexer must exist in the base class.</p>

<p>At binding-time, <em>base_access</em> expressions of the form <code class="prettyprint">base.I</code> and <code class="prettyprint">base[E]</code> are evaluated exactly as if they were written <code class="prettyprint">((B)this).I</code> and <code class="prettyprint">((B)this)[E]</code>, where <code class="prettyprint">B</code> is the base class of the class or struct in which the construct occurs. Thus, <code class="prettyprint">base.I</code> and <code class="prettyprint">base[E]</code> correspond to <code class="prettyprint">this.I</code> and <code class="prettyprint">this[E]</code>, except <code class="prettyprint">this</code> is viewed as an instance of the base class.</p>

<p>When a <em>base_access</em> references a virtual function member (a method, property, or indexer), the determination of which function member to invoke at run-time (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is changed. The function member that is invoked is determined by finding the most derived implementation (<a href="classes.md#virtual-methods">Virtual methods</a>) of the function member with respect to <code class="prettyprint">B</code> (instead of with respect to the run-time type of <code class="prettyprint">this</code>, as would be usual in a non-base access). Thus, within an <code class="prettyprint">override</code> of a <code class="prettyprint">virtual</code> function member, a <em>base_access</em> can be used to invoke the inherited implementation of the function member. If the function member referenced by a <em>base_access</em> is abstract, a binding-time error occurs.</p>

<h3 id="postfix-increment-and-decrement-operators">Postfix increment and decrement operators</h3>
<pre class="highlight shell"><code>post_increment_expression
    : primary_expression <span class="s1">'++'</span>
    ;

post_decrement_expression
    : primary_expression <span class="s1">'--'</span>
    ;
</code></pre>
<p>The operand of a postfix increment or decrement operation must be an expression classified as a variable, a property access, or an indexer access. The result of the operation is a value of the same type as the operand.</p>

<p>If the <em>primary_expression</em> has the compile-time type <code class="prettyprint">dynamic</code> then the operator is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), the <em>post_increment_expression</em> or <em>post_decrement_expression</em> has the compile-time type <code class="prettyprint">dynamic</code> and the following rules are applied at run-time using the run-time type of the <em>primary_expression</em>.</p>

<p>If the operand of a postfix increment or decrement operation is a property or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>Unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. Predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators exist for the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, and any enum type. The predefined <code class="prettyprint">++</code> operators return the value produced by adding 1 to the operand, and the predefined <code class="prettyprint">--</code> operators return the value produced by subtracting 1 from the operand. In a <code class="prettyprint">checked</code> context, if the result of this addition or subtraction is outside the range of the result type and the result type is an integral type or enum type, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The run-time processing of a postfix increment or decrement operation of the form <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li>The value of <code class="prettyprint">x</code> is saved.</li>
<li>The selected operator is invoked with the saved value of <code class="prettyprint">x</code> as its argument.</li>
<li>The value returned by the operator is stored in the location given by the evaluation of <code class="prettyprint">x</code>.</li>
<li>The saved value of <code class="prettyprint">x</code> becomes the result of the operation.</li>
</ul></li>
<li>  If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor invocations.</li>
<li>The <code class="prettyprint">get</code> accessor of <code class="prettyprint">x</code> is invoked and the returned value is saved.</li>
<li>The selected operator is invoked with the saved value of <code class="prettyprint">x</code> as its argument.</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value returned by the operator as its <code class="prettyprint">value</code> argument.</li>
<li>The saved value of <code class="prettyprint">x</code> becomes the result of the operation.</li>
</ul></li>
</ul>

<p>The <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators also support prefix notation (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>). Typically, the result of <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> is the value of <code class="prettyprint">x</code> before the operation, whereas the result of <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> is the value of <code class="prettyprint">x</code> after the operation. In either case, <code class="prettyprint">x</code> itself has the same value after the operation.</p>

<p>An <code class="prettyprint">operator ++</code> or <code class="prettyprint">operator --</code> implementation can be invoked using either postfix or prefix notation. It is not possible to have separate operator implementations for the two notations.</p>

<h3 id="the-new-operator">The new operator</h3>

<p>The <code class="prettyprint">new</code> operator is used to create new instances of types.</p>

<p>There are three forms of <code class="prettyprint">new</code> expressions:</p>

<ul>
<li> Object creation expressions are used to create new instances of class types and value types.</li>
<li> Array creation expressions are used to create new instances of array types.</li>
<li> Delegate creation expressions are used to create new instances of delegate types.</li>
</ul>

<p>The <code class="prettyprint">new</code> operator implies creation of an instance of a type, but does not necessarily imply dynamic allocation of memory. In particular, instances of value types require no additional memory beyond the variables in which they reside, and no dynamic allocations occur when <code class="prettyprint">new</code> is used to create instances of value types.</p>

<h4 id="object-creation-expressions">Object creation expressions</h4>

<p>An <em>object_creation_expression</em> is used to create a new instance of a <em>class_type</em> or a <em>value_type</em>.</p>
<pre class="highlight shell"><code>object_creation_expression
    : <span class="s1">'new'</span> <span class="nb">type</span> <span class="s1">'('</span> argument_list? <span class="s1">')'</span> object_or_collection_initializer?
    | <span class="s1">'new'</span> <span class="nb">type </span>object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
</code></pre>
<p>The <em>type</em> of an <em>object_creation_expression</em> must be a <em>class_type</em>, a <em>value_type</em> or a <em>type_parameter</em>. The <em>type</em> cannot be an <code class="prettyprint">abstract</code> <em>class_type</em>.</p>

<p>The optional <em>argument_list</em> (<a href="expressions.md#argument-lists">Argument lists</a>) is permitted only if the <em>type</em> is a <em>class_type</em> or a <em>struct_type</em>.</p>

<p>An object creation expression can omit the constructor argument list and enclosing parentheses provided it includes an object initializer or collection initializer. Omitting the constructor argument list and enclosing parentheses is equivalent to specifying an empty argument list.</p>

<p>Processing of an object creation expression that includes an object initializer or collection initializer consists of first processing the instance constructor and then processing the member or element initializations specified by the object initializer (<a href="expressions.md#object-initializers">Object initializers</a>) or collection initializer (<a href="expressions.md#collection-initializers">Collection initializers</a>).</p>

<p>If any of the arguments in the optional <em>argument_list</em> has the compile-time type <code class="prettyprint">dynamic</code> then the <em>object_creation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) and the following rules are applied at run-time using the run-time type of those arguments of the <em>argument_list</em> that have the compile time type <code class="prettyprint">dynamic</code>. However, the object creation undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The binding-time processing of an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(A)</code>, where <code class="prettyprint">T</code> is a <em>class_type</em> or a <em>value_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">T</code> is a <em>value_type</em> and <code class="prettyprint">A</code> is not present:

<ul>
<li>The <em>object_creation_expression</em> is a default constructor invocation. The result of the <em>object_creation_expression</em> is a value of type <code class="prettyprint">T</code>, namely the default value for <code class="prettyprint">T</code> as defined in <a href="types.md#the-systemvaluetype-type">The System.ValueType type</a>.</li>
</ul></li>
<li>  Otherwise, if <code class="prettyprint">T</code> is a <em>type_parameter</em> and <code class="prettyprint">A</code> is not present:

<ul>
<li>If no value type constraint or constructor constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) has been specified for <code class="prettyprint">T</code>, a binding-time error occurs.</li>
<li>The result of the <em>object_creation_expression</em> is a value of the run-time type that the type parameter has been bound to, namely the result of invoking the default constructor of that type. The run-time type may be a reference type or a value type.</li>
</ul></li>
<li>  Otherwise, if <code class="prettyprint">T</code> is a <em>class_type</em> or a <em>struct_type</em>:

<ul>
<li>If <code class="prettyprint">T</code> is an <code class="prettyprint">abstract</code> <em>class_type</em>, a compile-time error occurs.</li>
<li>The instance constructor to invoke is determined using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors declared in <code class="prettyprint">T</code> which are applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>). If the set of candidate instance constructors is empty, or if a single best instance constructor cannot be identified, a binding-time error occurs.</li>
<li>The result of the <em>object_creation_expression</em> is a value of type <code class="prettyprint">T</code>, namely the value produced by invoking the instance constructor determined in the step above.</li>
</ul></li>
<li> Otherwise, the <em>object_creation_expression</em> is invalid, and a binding-time error occurs.</li>
</ul>

<p>Even if the <em>object_creation_expression</em> is dynamically bound, the compile-time type is still <code class="prettyprint">T</code>.</p>

<p>The run-time processing of an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(A)</code>, where <code class="prettyprint">T</code> is <em>class_type</em> or a <em>struct_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">T</code> is a <em>class_type</em>:

<ul>
<li>A new instance of class <code class="prettyprint">T</code> is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li>All fields of the new instance are initialized to their default values (<a href="variables.md#default-values">Default values</a>).</li>
<li>The instance constructor is invoked according to the rules of function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>). A reference to the newly allocated instance is automatically passed to the instance constructor and the instance can be accessed from within that constructor as <code class="prettyprint">this</code>.</li>
</ul></li>
<li>  If <code class="prettyprint">T</code> is a <em>struct_type</em>:

<ul>
<li>An instance of type <code class="prettyprint">T</code> is created by allocating a temporary local variable. Since an instance constructor of a <em>struct_type</em> is required to definitely assign a value to each field of the instance being created, no initialization of the temporary variable is necessary.</li>
<li>The instance constructor is invoked according to the rules of function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>). A reference to the newly allocated instance is automatically passed to the instance constructor and the instance can be accessed from within that constructor as <code class="prettyprint">this</code>.</li>
</ul></li>
</ul>

<h4 id="object-initializers">Object initializers</h4>

<p>An <strong><em>object initializer</em></strong> specifies values for zero or more fields, properties or indexed elements of an object.</p>
<pre class="highlight shell"><code>object_initializer
    : <span class="s1">'{'</span> member_initializer_list? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> member_initializer_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

member_initializer_list
    : member_initializer <span class="o">(</span><span class="s1">','</span> member_initializer<span class="o">)</span><span class="k">*</span>
    ;

member_initializer
    : initializer_target <span class="s1">'='</span> initializer_value
    ;

initializer_target
    : identifier
    | <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
</code></pre>
<p>An object initializer consists of a sequence of member initializers, enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas. Each <em>member_initializer</em> designates a target for the initialization. An <em>identifier</em> must name an accessible field or property of the object being initialized, whereas an <em>argument_list</em> enclosed in square brackets must specify arguments for an accessible indexer on the object being initialized. It is an error for an object initializer to include more than one member initializer for the same field or property.</p>

<p>Each <em>initializer_target</em> is followed by an equals sign and either an expression, an object initializer or a collection initializer. It is not possible for expressions within the object initializer to refer to the newly created object it is initializing.</p>

<p>A member initializer that specifies an expression after the equals sign is processed in the same way as an assignment (<a href="expressions.md#simple-assignment">Simple assignment</a>) to the target.</p>

<p>A member initializer that specifies an object initializer after the equals sign is a <strong><em>nested object initializer</em></strong>, i.e. an initialization of an embedded object. Instead of assigning a new value to the field or property, the assignments in the nested object initializer are treated as assignments to members of the field or property. Nested object initializers cannot be applied to properties with a value type, or to read-only fields with a value type.</p>

<p>A member initializer that specifies a collection initializer after the equals sign is an initialization of an embedded collection. Instead of assigning a new collection to the target field, property or indexer, the elements given in the initializer are added to the collection referenced by the target. The target must be of a collection type that satisfies the requirements specified in <a href="expressions.md#collection-initializers">Collection initializers</a>.</p>

<p>The arguments to an index initializer will always be evaluated exactly once. Thus, even if the arguments end up never getting used (e.g. because of an empty nested initializer), they will be evaluated for their side effects.</p>

<p>The following class represents a point with two coordinates:
&rdquo;`csharp
public class Point
{
    int x, y;</p>

<p>public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
&ldquo;`</p>

<p>An instance of <code class="prettyprint">Point</code> can be created and initialized as follows:
<code class="prettyprint">csharp
Point a = new Point { X = 0, Y = 1 };
</code>
which has the same effect as
<code class="prettyprint">csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
</code>
where <code class="prettyprint">__a</code> is an otherwise invisible and inaccessible temporary variable. The following class represents a rectangle created from two points:
&rdquo;`csharp
public class Rectangle
{
    Point p1, p2;</p>

<p>public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
&ldquo;`</p>

<p>An instance of <code class="prettyprint">Rectangle</code> can be created and initialized as follows:
<code class="prettyprint">csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
</code>
which has the same effect as
<code class="prettyprint">csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
</code>
where <code class="prettyprint">__r</code>, <code class="prettyprint">__p1</code> and <code class="prettyprint">__p2</code> are temporary variables that are otherwise invisible and inaccessible.</p>

<p>If <code class="prettyprint">Rectangle</code>&rsquo;s constructor allocates the two embedded <code class="prettyprint">Point</code> instances
&rdquo;`csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();</p>

<p>public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
<code class="prettyprint">
the following construct can be used to initialize the embedded `Point` instances instead of assigning new instances:
</code>csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
<code class="prettyprint">
which has the same effect as
</code>csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
&ldquo;`</p>

<p>Given an appropriate definition of C, the following example:
<code class="prettyprint">csharp
var c = new C {
    x = true,
    y = { a = &quot;Hello&quot; },
    z = { 1, 2, 3 },
    [&quot;x&quot;] = 5,
    [0,0] = { &quot;a&quot;, &quot;b&quot; },
    [1,2] = {}
};
</code>
is equivalent to this series of assignments:
<code class="prettyprint">csharp
C __c = new C();
__c.x = true;
__c.y.a = &quot;Hello&quot;;
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = &quot;x&quot;;
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add(&quot;a&quot;);
__c[__i2,__i3].Add(&quot;b&quot;);
int __i4 = 1, __i5 = 2;
var c = __c;
</code>
where <code class="prettyprint">__c</code>, etc., are generated variables that are invisible and inaccessible to the source code. Note that the arguments for <code class="prettyprint">[0,0]</code> are evaluated only once, and the arguments for <code class="prettyprint">[1,2]</code> are evaluated once even though they are never used.</p>

<h4 id="collection-initializers">Collection initializers</h4>

<p>A collection initializer specifies the elements of a collection.</p>
<pre class="highlight shell"><code>collection_initializer
    : <span class="s1">'{'</span> element_initializer_list <span class="s1">'}'</span>
    | <span class="s1">'{'</span> element_initializer_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

element_initializer_list
    : element_initializer <span class="o">(</span><span class="s1">','</span> element_initializer<span class="o">)</span><span class="k">*</span>
    ;

element_initializer
    : non_assignment_expression
    | <span class="s1">'{'</span> expression_list <span class="s1">'}'</span>
    ;

expression_list
    : expression <span class="o">(</span><span class="s1">','</span> expression<span class="o">)</span><span class="k">*</span>
    ;
</code></pre>
<p>A collection initializer consists of a sequence of element initializers, enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas. Each element initializer specifies an element to be added to the collection object being initialized, and consists of a list of expressions enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas.  A single-expression element initializer can be written without braces, but cannot then be an assignment expression, to avoid ambiguity with member initializers. The <em>non_assignment_expression</em> production is defined in <a href="expressions.md#expression">Expression</a>.</p>

<p>The following is an example of an object creation expression that includes a collection initializer:
<code class="prettyprint">csharp
List&lt;int&gt; digits = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
</code></p>

<p>The collection object to which a collection initializer is applied must be of a type that implements <code class="prettyprint">System.Collections.IEnumerable</code> or a compile-time error occurs. For each specified element in order, the collection initializer invokes an <code class="prettyprint">Add</code> method on the target object with the expression list of the element initializer as argument list, applying normal member lookup and overload resolution for each invocation. Thus, the collection object must have an applicable instance or extension method with the name <code class="prettyprint">Add</code> for each element initializer.</p>

<p>The following class represents a contact with a name and a list of phone numbers:
&rdquo;`csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();</p>

<p>public string Name { get { return name; } set { name = value; } }</p>

<p>public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
&ldquo;`</p>

<p>A <code class="prettyprint">List&lt;Contact&gt;</code> can be created and initialized as follows:
<code class="prettyprint">csharp
var contacts = new List&lt;Contact&gt; {
    new Contact {
        Name = &quot;Chris Smith&quot;,
        PhoneNumbers = { &quot;206-555-0101&quot;, &quot;425-882-8080&quot; }
    },
    new Contact {
        Name = &quot;Bob Harris&quot;,
        PhoneNumbers = { &quot;650-555-0199&quot; }
    }
};
</code>
which has the same effect as
<code class="prettyprint">csharp
var __clist = new List&lt;Contact&gt;();
Contact __c1 = new Contact();
__c1.Name = &quot;Chris Smith&quot;;
__c1.PhoneNumbers.Add(&quot;206-555-0101&quot;);
__c1.PhoneNumbers.Add(&quot;425-882-8080&quot;);
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = &quot;Bob Harris&quot;;
__c2.PhoneNumbers.Add(&quot;650-555-0199&quot;);
__clist.Add(__c2);
var contacts = __clist;
</code>
where <code class="prettyprint">__clist</code>, <code class="prettyprint">__c1</code> and <code class="prettyprint">__c2</code> are temporary variables that are otherwise invisible and inaccessible.</p>

<h4 id="array-creation-expressions">Array creation expressions</h4>

<p>An <em>array_creation_expression</em> is used to create a new instance of an <em>array_type</em>.</p>
<pre class="highlight shell"><code>array_creation_expression
    : <span class="s1">'new'</span> non_array_type <span class="s1">'['</span> expression_list <span class="s1">']'</span> rank_specifier<span class="k">*</span> array_initializer?
    | <span class="s1">'new'</span> array_type array_initializer
    | <span class="s1">'new'</span> rank_specifier array_initializer
    ;
</code></pre>
<p>An array creation expression of the first form allocates an array instance of the type that results from deleting each of the individual expressions from the expression list. For example, the array creation expression <code class="prettyprint">new int[10,20]</code> produces an array instance of type <code class="prettyprint">int[,]</code>, and the array creation expression <code class="prettyprint">new int[10][,]</code> produces an array of type <code class="prettyprint">int[][,]</code>. Each expression in the expression list must be of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code>, or implicitly convertible to one or more of these types. The value of each expression determines the length of the corresponding dimension in the newly allocated array instance. Since the length of an array dimension must be nonnegative, it is a compile-time error to have a <em>constant_expression</em> with a negative value in the expression list.</p>

<p>Except in an unsafe context (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>), the layout of arrays is unspecified.</p>

<p>If an array creation expression of the first form includes an array initializer, each expression in the expression list must be a constant and the rank and dimension lengths specified by the expression list must match those of the array initializer.</p>

<p>In an array creation expression of the second or third form, the rank of the specified array type or rank specifier must match that of the array initializer. The individual dimension lengths are inferred from the number of elements in each of the corresponding nesting levels of the array initializer. Thus, the expression
<code class="prettyprint">csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
</code>
exactly corresponds to
<code class="prettyprint">csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
</code></p>

<p>An array creation expression of the third form is referred to as an <strong><em>implicitly typed array creation expression</em></strong>. It is similar to the second form, except that the element type of the array is not explicitly given, but determined as the best common type (<a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>) of the set of expressions in the array initializer. For a multidimensional array, i.e., one where the <em>rank_specifier</em> contains at least one comma, this set comprises all *expression*s found in nested *array_initializer*s.</p>

<p>Array initializers are described further in <a href="arrays.md#array-initializers">Array initializers</a>.</p>

<p>The result of evaluating an array creation expression is classified as a value, namely a reference to the newly allocated array instance. The run-time processing of an array creation expression consists of the following steps:</p>

<ul>
<li> The dimension length expressions of the <em>expression_list</em> are evaluated in order, from left to right. Following evaluation of each expression, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to one of the following types is performed: <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>. The first type in this list for which an implicit conversion exists is chosen. If evaluation of an expression or the subsequent implicit conversion causes an exception, then no further expressions are evaluated and no further steps are executed.</li>
<li> The computed values for the dimension lengths are validated as follows. If one or more of the values are less than zero, a <code class="prettyprint">System.OverflowException</code> is thrown and no further steps are executed.</li>
<li> An array instance with the given dimension lengths is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li> All elements of the new array instance are initialized to their default values (<a href="variables.md#default-values">Default values</a>).</li>
<li> If the array creation expression contains an array initializer, then each expression in the array initializer is evaluated and assigned to its corresponding array element. The evaluations and assignments are performed in the order the expressions are written in the array initializerâ€”in other words, elements are initialized in increasing index order, with the rightmost dimension increasing first. If evaluation of a given expression or the subsequent assignment to the corresponding array element causes an exception, then no further elements are initialized (and the remaining elements will thus have their default values).</li>
</ul>

<p>An array creation expression permits instantiation of an array with elements of an array type, but the elements of such an array must be manually initialized. For example, the statement
<code class="prettyprint">csharp
int[][] a = new int[100][];
</code>
creates a single-dimensional array with 100 elements of type <code class="prettyprint">int[]</code>. The initial value of each element is <code class="prettyprint">null</code>. It is not possible for the same array creation expression to also instantiate the sub-arrays, and the statement
<code class="prettyprint">csharp
int[][] a = new int[100][5];        // Error
</code>
results in a compile-time error. Instantiation of the sub-arrays must instead be performed manually, as in
<code class="prettyprint">csharp
int[][] a = new int[100][];
for (int i = 0; i &lt; 100; i++) a[i] = new int[5];
</code></p>

<p>When an array of arrays has a &quot;rectangular&rdquo; shape, that is when the sub-arrays are all of the same length, it is more efficient to use a multi-dimensional array. In the example above, instantiation of the array of arrays creates 101 objectsâ€”one outer array and 100 sub-arrays. In contrast,
<code class="prettyprint">csharp
int[,] = new int[100, 5];
</code>
creates only a single object, a two-dimensional array, and accomplishes the allocation in a single statement.</p>

<p>The following are examples of implicitly typed array creation expressions:
&ldquo;`csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]</p>

<p>var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]</p>

<p>var c = new[,] { { &quot;hello&rdquo;, null }, { &ldquo;world&rdquo;, &ldquo;!&rdquo; } };   // string[,]</p>

<p>var d = new[] { 1, &ldquo;one&rdquo;, 2, &ldquo;two&rdquo; };                     // Error
&ldquo;`</p>

<p>The last expression causes a compile-time error because neither <code class="prettyprint">int</code> nor <code class="prettyprint">string</code> is implicitly convertible to the other, and so there is no best common type. An explicitly typed array creation expression must be used in this case, for example specifying the type to be <code class="prettyprint">object[]</code>. Alternatively, one of the elements can be cast to a common base type, which would then become the inferred element type.</p>

<p>Implicitly typed array creation expressions can be combined with anonymous object initializers (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) to create anonymously typed data structures. For example:
<code class="prettyprint">csharp
var contacts = new[] {
    new {
        Name = &quot;Chris Smith&quot;,
        PhoneNumbers = new[] { &quot;206-555-0101&quot;, &quot;425-882-8080&quot; }
    },
    new {
        Name = &quot;Bob Harris&quot;,
        PhoneNumbers = new[] { &quot;650-555-0199&quot; }
    }
};
</code></p>

<h4 id="delegate-creation-expressions">Delegate creation expressions</h4>

<p>A <em>delegate_creation_expression</em> is used to create a new instance of a <em>delegate_type</em>.</p>
<pre class="highlight shell"><code>delegate_creation_expression
    : <span class="s1">'new'</span> delegate_type <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>The argument of a delegate creation expression must be a method group, an anonymous function or a value of either the compile time type <code class="prettyprint">dynamic</code> or a <em>delegate_type</em>. If the argument is a method group, it identifies the method and, for an instance method, the object for which to create a delegate. If the argument is an anonymous function it directly defines the parameters and method body of the delegate target. If the argument is a value it identifies a delegate instance of which to create a copy.</p>

<p>If the <em>expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, the <em>delegate_creation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), and the rules below are applied at run-time using the run-time type of the <em>expression</em>. Otherwise the rules are applied at compile-time.</p>

<p>The binding-time processing of a <em>delegate_creation_expression</em> of the form <code class="prettyprint">new D(E)</code>, where <code class="prettyprint">D</code> is a <em>delegate_type</em> and <code class="prettyprint">E</code> is an <em>expression</em>, consists of the following steps:</p>

<ul>
<li> If <code class="prettyprint">E</code> is a method group, the delegate creation expression is processed in the same way as a method group conversion (<a href="conversions.md#method-group-conversions">Method group conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li> If <code class="prettyprint">E</code> is an anonymous function, the delegate creation expression is processed in the same way as an anonymous function conversion (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li> If <code class="prettyprint">E</code> is a value, <code class="prettyprint">E</code> must be compatible (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) with <code class="prettyprint">D</code>, and the result is a reference to a newly created delegate of type <code class="prettyprint">D</code> that refers to the same invocation list as <code class="prettyprint">E</code>. If <code class="prettyprint">E</code> is not compatible with <code class="prettyprint">D</code>, a compile-time error occurs.</li>
</ul>

<p>The run-time processing of a <em>delegate_creation_expression</em> of the form <code class="prettyprint">new D(E)</code>, where <code class="prettyprint">D</code> is a <em>delegate_type</em> and <code class="prettyprint">E</code> is an <em>expression</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">E</code> is a method group, the delegate creation expression is evaluated as a method group conversion (<a href="conversions.md#method-group-conversions">Method group conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li>  If <code class="prettyprint">E</code> is an anonymous function, the delegate creation is evaluated as an anonymous function conversion from <code class="prettyprint">E</code> to <code class="prettyprint">D</code> (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</li>
<li>  If <code class="prettyprint">E</code> is a value of a <em>delegate_type</em>:

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li>If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li>A new instance of the delegate type <code class="prettyprint">D</code> is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li>The new delegate instance is initialized with the same invocation list as the delegate instance given by <code class="prettyprint">E</code>.</li>
</ul></li>
</ul>

<p>The invocation list of a delegate is determined when the delegate is instantiated and then remains constant for the entire lifetime of the delegate. In other words, it is not possible to change the target callable entities of a delegate once it has been created. When two delegates are combined or one is removed from another (<a href="delegates.md#delegate-declarations">Delegate declarations</a>), a new delegate results; no existing delegate has its contents changed.</p>

<p>It is not possible to create a delegate that refers to a property, indexer, user-defined operator, instance constructor, destructor, or static constructor.</p>

<p>As described above, when a delegate is created from a method group, the formal parameter list and return type of the delegate determine which of the overloaded methods to select. In the example
&rdquo;`csharp
delegate double DoubleFunc(double x);</p>

<p>class A
{
    DoubleFunc f = new DoubleFunc(Square);</p>

<p>static float Square(float x) {
        return x * x;
    }</p>

<p>static double Square(double x) {
        return x * x;
    }
}
&ldquo;<code class="prettyprint">
the</code>A.f<code class="prettyprint">field is initialized with a delegate that refers to the second</code>Square<code class="prettyprint">method because that method exactly matches the formal parameter list and return type of</code>DoubleFunc<code class="prettyprint">. Had the second</code>Square` method not been present, a compile-time error would have occurred.</p>

<h4 id="anonymous-object-creation-expressions">Anonymous object creation expressions</h4>

<p>An <em>anonymous_object_creation_expression</em> is used to create an object of an anonymous type.</p>
<pre class="highlight shell"><code>anonymous_object_creation_expression
    : <span class="s1">'new'</span> anonymous_object_initializer
    ;

anonymous_object_initializer
    : <span class="s1">'{'</span> member_declarator_list? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> member_declarator_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

member_declarator_list
    : member_declarator <span class="o">(</span><span class="s1">','</span> member_declarator<span class="o">)</span><span class="k">*</span>
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier <span class="s1">'='</span> expression
    ;
</code></pre>
<p>An anonymous object initializer declares an anonymous type and returns an instance of that type. An anonymous type is a nameless class type that inherits directly from <code class="prettyprint">object</code>. The members of an anonymous type are a sequence of read-only properties inferred from the anonymous object initializer used to create an instance of the type. Specifically, an anonymous object initializer of the form
<code class="prettyprint">csharp
new { p1 = e1, p2 = e2, ..., pn = en }
</code>
declares an anonymous type of the form
&rdquo;`csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    &hellip;
    private readonly Tn fn;</p>

<p>public __Anonymous1(T1 a1, T2 a2, &hellip;, Tn an) {
        f1 = a1;
        f2 = a2;
        &hellip;
        fn = an;
    }</p>

<p>public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    &hellip;
    public Tn pn { get { return fn; } }</p>

<p>public override bool Equals(object __o) { &hellip; }
    public override int GetHashCode() { &hellip; }
}
&ldquo;<code class="prettyprint">
where each</code>Tx<code class="prettyprint">is the type of the corresponding expression</code>ex`. The expression used in a <em>member_declarator</em> must have a type. Thus, it is a compile-time error for an expression in a <em>member_declarator</em> to be null or an anonymous function. It is also a compile-time error for the expression to have an unsafe type.</p>

<p>The names of an anonymous type and of the parameter to its <code class="prettyprint">Equals</code> method are automatically generated by the compiler and cannot be referenced in program text.</p>

<p>Within the same program, two anonymous object initializers that specify a sequence of properties of the same names and compile-time types in the same order will produce instances of the same anonymous type.</p>

<p>In the example
<code class="prettyprint">csharp
var p1 = new { Name = &quot;Lawnmower&quot;, Price = 495.00 };
var p2 = new { Name = &quot;Shovel&quot;, Price = 26.95 };
p1 = p2;
</code>
the assignment on the last line is permitted because <code class="prettyprint">p1</code> and <code class="prettyprint">p2</code> are of the same anonymous type.</p>

<p>The <code class="prettyprint">Equals</code> and <code class="prettyprint">GetHashcode</code> methods on anonymous types override the methods inherited from <code class="prettyprint">object</code>, and are defined in terms of the <code class="prettyprint">Equals</code> and <code class="prettyprint">GetHashcode</code> of the properties, so that two instances of the same anonymous type are equal if and only if all their properties are equal.</p>

<p>A member declarator can be abbreviated to a simple name (<a href="expressions.md#type-inference">Type inference</a>), a member access (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>), a base access (<a href="expressions.md#base-access">Base access</a>) or a null-conditional member access (<a href="expressions.md#null-conditional-expressions-as-projection-initializers">Null-conditional expressions as projection initializers</a>). This is called a <strong><em>projection initializer</em></strong> and is shorthand for a declaration of and assignment to a property with the same name. Specifically, member declarators of the forms
<code class="prettyprint">csharp
identifier
expr.identifier
</code>
are precisely equivalent to the following, respectively:
<code class="prettyprint">csharp
identifier = identifier
identifier = expr.identifier
</code></p>

<p>Thus, in a projection initializer the <em>identifier</em> selects both the value and the field or property to which the value is assigned. Intuitively, a projection initializer projects not just a value, but also the name of the value.</p>

<h3 id="the-typeof-operator">The typeof operator</h3>

<p>The <code class="prettyprint">typeof</code> operator is used to obtain the <code class="prettyprint">System.Type</code> object for a type.</p>
<pre class="highlight shell"><code>typeof_expression
    : <span class="s1">'typeof'</span> <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span>
    | <span class="s1">'typeof'</span> <span class="s1">'('</span> unbound_type_name <span class="s1">')'</span>
    | <span class="s1">'typeof'</span> <span class="s1">'('</span> <span class="s1">'void'</span> <span class="s1">')'</span>
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier <span class="s1">'::'</span> identifier generic_dimension_specifier?
    | unbound_type_name <span class="s1">'.'</span> identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : <span class="s1">'&lt;'</span> comma<span class="k">*</span> <span class="s1">'&gt;'</span>
    ;

comma
    : <span class="s1">','</span>
    ;
</code></pre>
<p>The first form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <em>type</em>. The result of an expression of this form is the <code class="prettyprint">System.Type</code> object for the indicated type. There is only one <code class="prettyprint">System.Type</code> object for any given type. This means that for a typeÂ <code class="prettyprint">T</code>, <code class="prettyprint">typeof(T) == typeof(T)</code> is always true. The <em>type</em> cannot be <code class="prettyprint">dynamic</code>.</p>

<p>The second form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <em>unbound_type_name</em>. An <em>unbound_type_name</em> is very similar to a <em>type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) except that an <em>unbound_type_name</em> contains <em>generic_dimension_specifier*s where a *type_name</em> contains <em>type_argument_list*s. When the operand of a *typeof_expression</em> is a sequence of tokens that satisfies the grammars of both <em>unbound_type_name</em> and <em>type_name</em>, namely when it contains neither a <em>generic_dimension_specifier</em> nor a <em>type_argument_list</em>, the sequence of tokens is considered to be a <em>type_name</em>. The meaning of an <em>unbound_type_name</em> is determined as follows:</p>

<ul>
<li> Convert the sequence of tokens to a <em>type_name</em> by replacing each <em>generic_dimension_specifier</em> with a <em>type_argument_list</em> having the same number of commas and the keyword <code class="prettyprint">object</code> as each <em>type_argument</em>.</li>
<li> Evaluate the resulting <em>type_name</em>, while ignoring all type parameter constraints.</li>
<li> The <em>unbound_type_name</em> resolves to the unbound generic type associated with the resulting constructed type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>).</li>
</ul>

<p>The result of the <em>typeof_expression</em> is the <code class="prettyprint">System.Type</code> object for the resulting unbound generic type.</p>

<p>The third form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <code class="prettyprint">void</code> keyword. The result of an expression of this form is the <code class="prettyprint">System.Type</code> object that represents the absence of a type. The type object returned by <code class="prettyprint">typeof(void)</code> is distinct from the type object returned for any type. This special type object is useful in class libraries that allow reflection ontoÂ methods in the language, where those methods wish to have a way to represent the return type of any method, including void methods, with an instance of <code class="prettyprint">System.Type</code>.</p>

<p>The <code class="prettyprint">typeof</code> operator can be used on a type parameter. The result is the <code class="prettyprint">System.Type</code> object for the run-time type that was bound to the type parameter. The <code class="prettyprint">typeof</code> operator can also be used on a constructed type or an unbound generic type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>). The <code class="prettyprint">System.Type</code> object for an unbound generic type is not the same as the <code class="prettyprint">System.Type</code> object of the instance type. The instance type is always a closed constructed type at run-time so its <code class="prettyprint">System.Type</code> object depends on the run-time type arguments in use, while the unbound generic type has no type arguments.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>&gt;),
            typeof(X&lt;&gt;)
        };
        for (int i = 0; i &lt; t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}</p>

<p>class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
<code class="prettyprint">
produces the following output:
</code>bash
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X<code class="prettyprint">1[System.Int32]
X</code>1[X<code class="prettyprint">1[System.Int32]]
X</code>1[T]
&ldquo;`</p>

<p>Note that <code class="prettyprint">int</code> and <code class="prettyprint">System.Int32</code> are the same type.</p>

<p>Also note that the result of <code class="prettyprint">typeof(X&lt;&gt;)</code> does not depend on the type argument but the result of <code class="prettyprint">typeof(X&lt;T&gt;)</code> does.</p>

<h3 id="the-checked-and-unchecked-operators">The checked and unchecked operators</h3>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators are used to control the <strong><em>overflow checking context</em></strong> for integral-type arithmetic operations and conversions.</p>
<pre class="highlight shell"><code>checked_expression
    : <span class="s1">'checked'</span> <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;

unchecked_expression
    : <span class="s1">'unchecked'</span> <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>The <code class="prettyprint">checked</code> operator evaluates the contained expression in a checked context, and the <code class="prettyprint">unchecked</code> operator evaluates the contained expression in an unchecked context. A <em>checked_expression</em> or <em>unchecked_expression</em> corresponds exactly to a <em>parenthesized_expression</em> (<a href="expressions.md#parenthesized-expressions">Parenthesized expressions</a>), except that the contained expression is evaluated in the given overflow checking context.</p>

<p>The overflow checking context can also be controlled through the <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements (<a href="statements.md#the-checked-and-unchecked-statements">The checked and unchecked statements</a>).</p>

<p>The following operations are affected by the overflow checking context established by the <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements:</p>

<ul>
<li> The predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> unary operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a> and <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>), when the operand is of an integral type.</li>
<li> The predefined <code class="prettyprint">-</code> unary operator (<a href="expressions.md#unary-minus-operator">Unary minus operator</a>), when the operand is of an integral type.</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, and <code class="prettyprint">/</code> binary operators (<a href="expressions.md#arithmetic-operators">Arithmetic operators</a>), when both operands are of integral types.</li>
<li> Explicit numeric conversions (<a href="conversions.md#explicit-numeric-conversions">Explicit numeric conversions</a>) from one integral type to another integral type, or from <code class="prettyprint">float</code> or <code class="prettyprint">double</code> to an integral type.</li>
</ul>

<p>When one of the above operations produce a result that is too large to represent in the destination type, the context in which the operation is performed controls the resulting behavior:</p>

<ul>
<li> In a <code class="prettyprint">checked</code> context, if the operation is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>), a compile-time error occurs. Otherwise, when the operation is performed at run-time, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
<li> In an <code class="prettyprint">unchecked</code> context, the result is truncated by discarding any high-order bits that do not fit in the destination type.</li>
</ul>

<p>For non-constant expressions (expressions that are evaluated at run-time) that are not enclosed by any <code class="prettyprint">checked</code> or <code class="prettyprint">unchecked</code> operators or statements, the default overflow checking context is <code class="prettyprint">unchecked</code> unless external factors (such as compiler switches and execution environment configuration) call for <code class="prettyprint">checked</code> evaluation.</p>

<p>For constant expressions (expressions that can be fully evaluated at compile-time), the default overflow checking context is always <code class="prettyprint">checked</code>. Unless a constant expression is explicitly placed in an <code class="prettyprint">unchecked</code> context, overflows that occur during the compile-time evaluation of the expression always cause compile-time errors.</p>

<p>The body of an anonymous function is not affected by <code class="prettyprint">checked</code> or <code class="prettyprint">unchecked</code> contexts in which the anonymous function occurs.</p>

<p>In the example
&rdquo;`csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;</p>

<p>static int F() {
        return checked(x * y);      // Throws OverflowException
    }</p>

<p>static int G() {
        return unchecked(x * y);    // Returns -727379968
    }</p>

<p>static int H() {
        return x * y;               // Depends on default
    }
}
&ldquo;<code class="prettyprint">
no compile-time errors are reported since neither of the expressions can be evaluated at compile-time. At run-time, the</code>F<code class="prettyprint">method throws a</code>System.OverflowException<code class="prettyprint">, and the</code>G<code class="prettyprint">method returns -727379968 (the lower 32 bits of the out-of-range result). The behavior of the</code>H<code class="prettyprint">method depends on the default overflow checking context for the compilation, but it is either the same as</code>F<code class="prettyprint">or the same as</code>G`.</p>

<p>In the example
&rdquo;`csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;</p>

<p>static int F() {
        return checked(x * y);      // Compile error, overflow
    }</p>

<p>static int G() {
        return unchecked(x * y);    // Returns -727379968
    }</p>

<p>static int H() {
        return x * y;               // Compile error, overflow
    }
}
&ldquo;<code class="prettyprint">
the overflows that occur when evaluating the constant expressions in</code>F<code class="prettyprint">and</code>H<code class="prettyprint">cause compile-time errors to be reported because the expressions are evaluated in a</code>checked<code class="prettyprint">context. An overflow also occurs when evaluating the constant expression in</code>G<code class="prettyprint">, but since the evaluation takes place in an</code>unchecked` context, the overflow is not reported.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators only affect the overflow checking context for those operations that are textually contained within the &rdquo;<code class="prettyprint">(</code>&ldquo; and &rdquo;<code class="prettyprint">)</code>&ldquo; tokens. The operators have no effect on function members that are invoked as a result of evaluating the contained expression. In the example
&rdquo;`csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }</p>

<p>static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
&ldquo;<code class="prettyprint">
the use of</code>checked<code class="prettyprint">in</code>F<code class="prettyprint">does not affect the evaluation of</code>x * y<code class="prettyprint">in</code>Multiply<code class="prettyprint">, so</code>x * y` is evaluated in the default overflow checking context.</p>

<p>The <code class="prettyprint">unchecked</code> operator is convenient when writing constants of the signed integral types in hexadecimal notation. For example:
&rdquo;`csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);</p>

<p>public const int HighBit = unchecked((int)0x80000000);
}
&ldquo;`</p>

<p>Both of the hexadecimal constants above are of type <code class="prettyprint">uint</code>. Because the constants are outside the <code class="prettyprint">int</code> range, without the <code class="prettyprint">unchecked</code> operator, the casts to <code class="prettyprint">int</code> would produce compile-time errors.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements allow programmers to control certain aspects of some numeric calculations. However, the behavior of some numeric operators depends on their operands&rsquo; data types. For example, multiplying two decimals always results in an exception on overflow even within an explicitly <code class="prettyprint">unchecked</code> construct. Similarly, multiplying two floats never results in an exception on overflow even within an explicitly <code class="prettyprint">checked</code> construct. In addition, other operators are never affected by the mode of checking, whether default or explicit.</p>

<h3 id="default-value-expressions">Default value expressions</h3>

<p>A default value expression is used to obtain the default value (<a href="variables.md#default-values">Default values</a>) of a type. Typically a default value expression is used for type parameters, since it may not be known if the type parameter is a value type or a reference type. (No conversion exists from the <code class="prettyprint">null</code> literal to a type parameter unless the type parameter is known to be a reference type.)</p>
<pre class="highlight shell"><code>default_value_expression
    : <span class="s1">'default'</span> <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span>
    ;
</code></pre>
<p>If the <em>type</em> in a <em>default_value_expression</em> evaluates at run-time to a reference type, the result is <code class="prettyprint">null</code> converted to that type. If the <em>type</em> in a <em>default_value_expression</em> evaluates at run-time to a value type, the result is the <em>value_type</em>&lsquo;s default value (<a href="types.md#default-constructors">Default constructors</a>).</p>

<p>A <em>default_value_expression</em> is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>) if the type is a reference type or a type parameter that is known to be a reference type (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). In addition, a <em>default_value_expression</em> is a constant expression if the type is one of the following value types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, or any enumeration type.</p>

<h3 id="nameof-expressions">Nameof expressions</h3>

<p>A <em>nameof_expression</em> is used to obtain the name of a program entity as a constant string.</p>
<pre class="highlight shell"><code>nameof_expression
    : <span class="s1">'nameof'</span> <span class="s1">'('</span> named_entity <span class="s1">')'</span>
    ;

named_entity
    : simple_name
    | named_entity_target <span class="s1">'.'</span> identifier type_argument_list?
    ;

named_entity_target
    : <span class="s1">'this'</span>
    | <span class="s1">'base'</span>
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
</code></pre>
<p>Grammatically speaking, the <em>named_entity</em> operand is always an expression. Because <code class="prettyprint">nameof</code> is not a reserved keyword, a nameof expression is always syntactically ambiguous with an invocation of the simple name <code class="prettyprint">nameof</code>. For compatibility reasons, if a name lookup (<a href="expressions.md#simple-names">Simple names</a>) of the name <code class="prettyprint">nameof</code> succeeds, the expression is treated as an <em>invocation_expression</em> &ndash; regardless of whether the invocation is legal. Otherwise it is a <em>nameof_expression</em>.</p>

<p>The meaning of the <em>named_entity</em> of a <em>nameof_expression</em> is the meaning of it as an expression; that is, either as a <em>simple_name</em>, a <em>base_access</em> or a <em>member_access</em>. However, where the lookup described in <a href="expressions.md#simple-names">Simple names</a> and <a href="expressions.md#member-access">Member access</a> results in an error because an instance member was found in a static context, a <em>nameof_expression</em> produces no such error.</p>

<p>It is a compile-time error for a <em>named_entity</em> designating a method group to have a <em>type_argument_list</em>. It is a compile time error for a <em>named_entity_target</em> to have the type <code class="prettyprint">dynamic</code>.</p>

<p>A <em>nameof_expression</em> is a constant expression of type <code class="prettyprint">string</code>, and has no effect at runtime. Specifically, its <em>named_entity</em> is not evaluated, and is ignored for the purposes of definite assignment analysis (<a href="variables.md#general-rules-for-simple-expressions">General rules for simple expressions</a>). Its value is the last identifier of the <em>named_entity</em> before the optional final <em>type_argument_list</em>, transformed in the following way:</p>

<ul>
<li>The prefix &rdquo;<code class="prettyprint">@</code>&ldquo;, if used, is removed.</li>
<li>Each <em>unicode_escape_sequence</em> is transformed into its corresponding Unicode character.</li>
<li>Any <em>formatting_characters</em> are removed.</li>
</ul>

<p>These are the same transformations applied in <a href="lexical-structure.md#identifiers">Identifiers</a> when testing equality between identifiers.</p>

<p>TODO: examples</p>

<h3 id="anonymous-method-expressions">Anonymous method expressions</h3>

<p>An <em>anonymous_method_expression</em> is one of two ways of defining an anonymous function. These are further described in <a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>.</p>

<h2 id="unary-operators">Unary operators</h2>

<p>The <code class="prettyprint">?</code>, <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, cast, and <code class="prettyprint">await</code> operators are called the unary operators.</p>
<pre class="highlight shell"><code>unary_expression
    : primary_expression
    | null_conditional_expression
    | <span class="s1">'+'</span> unary_expression
    | <span class="s1">'-'</span> unary_expression
    | <span class="s1">'!'</span> unary_expression
    | <span class="s1">'~'</span> unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
</code></pre>
<p>If the operand of a <em>unary_expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, it is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the <em>unary_expression</em> is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of the operand.</p>

<h3 id="null-conditional-operator">Null-conditional operator</h3>

<p>The null-conditional operator applies a list of operations to its operand only if that operand is non-null. Otherwise the result of applying the operator is <code class="prettyprint">null</code>.</p>
<pre class="highlight shell"><code>null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'.'</span> identifier type_argument_list?
    | null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    | null_conditional_operations <span class="s1">'.'</span> identifier type_argument_list?
    | null_conditional_operations <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    | null_conditional_operations <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>The list of operations can include member access and element access operations (which may themselves be null-conditional), as well as invocation.</p>

<p>For example, the expression <code class="prettyprint">a.b?[0]?.c()</code> is a <em>null_conditional_expression</em> with a <em>primary_expression</em> <code class="prettyprint">a.b</code> and <em>null_conditional_operations</em> <code class="prettyprint">?[0]</code> (null-conditional element access), <code class="prettyprint">?.c</code> (null-conditional member access) and <code class="prettyprint">()</code> (invocation).</p>

<p>For a <em>null_conditional_expression</em> <code class="prettyprint">E</code> with a <em>primary_expression</em> <code class="prettyprint">P</code>, let <code class="prettyprint">E0</code> be the expression obtained by textually removing the leading <code class="prettyprint">?</code> from each of the <em>null_conditional_operations</em> of <code class="prettyprint">E</code> that have one. Conceptually, <code class="prettyprint">E0</code> is the expression that will be evaluated if none of the null checks represented by the <code class="prettyprint">?</code>s do find a <code class="prettyprint">null</code>.</p>

<p>Also, let <code class="prettyprint">E1</code> be the expression obtained by textually removing the leading <code class="prettyprint">?</code> from just the first of the <em>null_conditional_operations</em> in <code class="prettyprint">E</code>. This may lead to a <em>primary-expression</em> (if there was just one <code class="prettyprint">?</code>) or to another <em>null_conditional_expression</em>.</p>

<p>For example, if <code class="prettyprint">E</code> is the expression <code class="prettyprint">a.b?[0]?.c()</code>, then <code class="prettyprint">E0</code> is the expression <code class="prettyprint">a.b[0].c()</code> and <code class="prettyprint">E1</code> is the expression <code class="prettyprint">a.b[0]?.c()</code>.</p>

<p>If <code class="prettyprint">E0</code> is classified as nothing, then <code class="prettyprint">E</code> is classified as nothing. Otherwise E is classified as a value.</p>

<p><code class="prettyprint">E0</code> and <code class="prettyprint">E1</code> are used to determine the meaning of <code class="prettyprint">E</code>:</p>

<ul>
<li> If <code class="prettyprint">E</code> occurs as a <em>statement_expression</em> the meaning of <code class="prettyprint">E</code> is the same as the statement</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">if</span> <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">E1</span><span class="p">;</span>
</code></pre>
<p>except that P is evaluated only once.</p>

<ul>
<li><p>Otherwise, if <code class="prettyprint">E0</code> is classified as nothing a compile-time error occurs.</p></li>
<li><p>Otherwise, let <code class="prettyprint">T0</code> be the type of <code class="prettyprint">E0</code>.</p>

<ul>
<li> If <code class="prettyprint">T0</code> is a type parameter that is not known to be a reference type or a non-nullable value type, a compile-time error occurs.</li>
<li> If <code class="prettyprint">T0</code> is a non-nullable value type, then the type of <code class="prettyprint">E</code> is <code class="prettyprint">T0?</code>, and the meaning of <code class="prettyprint">E</code> is the same as</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>  <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span><span class="n">T0</span><span class="p">?)</span><span class="k">null</span> <span class="p">:</span> <span class="n">E1</span>
</code></pre>
<p>except that <code class="prettyprint">P</code> is evaluated only once.
*  Otherwise the type of E is T0, and the meaning of E is the same as</p>
<pre class="highlight csharp tab-csharp"><code>  <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">E1</span>
</code></pre>
<p>except that <code class="prettyprint">P</code> is evaluated only once.</p></li>
</ul>

<p>If <code class="prettyprint">E1</code> is itself a <em>null_conditional_expression</em>, then these rules are applied again, nesting the tests for <code class="prettyprint">null</code> until there are no further <code class="prettyprint">?</code>&rsquo;s, and the expression has been reduced all the way down to the primary-expression <code class="prettyprint">E0</code>.</p>

<p>For example, if the expression <code class="prettyprint">a.b?[0]?.c()</code> occurs as a statement-expression, as in the statement:
<code class="prettyprint">csharp
a.b?[0]?.c();
</code>
its meaning is equivalent to:
<code class="prettyprint">csharp
if (a.b != null) a.b[0]?.c();
</code>
which again is equivalent to:
<code class="prettyprint">csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
</code>
Except that <code class="prettyprint">a.b</code> and <code class="prettyprint">a.b[0]</code> are evaluated only once.</p>

<p>If it occurs in a context where its value is used, as in:
<code class="prettyprint">csharp
var x = a.b?[0]?.c();
</code>
and assuming that the type of the final invocation is not a non-nullable value type, its meaning is equivalent to:
<code class="prettyprint">csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
</code>
except that <code class="prettyprint">a.b</code> and <code class="prettyprint">a.b[0]</code> are evaluated only once.</p>

<h4 id="null-conditional-expressions-as-projection-initializers">Null-conditional expressions as projection initializers</h4>

<p>A null-conditional expression is only allowed as a <em>member_declarator</em> in an <em>anonymous_object_creation_expression</em> (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) if it ends with an (optionally null-conditional) member access. Grammatically, this requirement can be expressed as:</p>
<pre class="highlight shell"><code>null_conditional_member_access
    : primary_expression null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'.'</span> identifier type_argument_list?
    | primary_expression null_conditional_operations <span class="s1">'.'</span> identifier type_argument_list?
    ;
</code></pre>
<p>This is a special case of the grammar for <em>null_conditional_expression</em> above. The production for <em>member_declarator</em> in <a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a> then includes only <em>null_conditional_member_access</em>.</p>

<h4 id="null-conditional-expressions-as-statement-expressions">Null-conditional expressions as statement expressions</h4>

<p>A null-conditional expression is only allowed as a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>) if it ends with an invocation. Grammatically, this requirement can be expressed as:</p>
<pre class="highlight shell"><code>null_conditional_invocation_expression
    : primary_expression null_conditional_operations <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>This is a special case of the grammar for <em>null_conditional_expression</em> above. The production for <em>statement_expression</em> in <a href="statements.md#expression-statements">Expression statements</a> then includes only <em>null_conditional_invocation_expression</em>.</p>

<h3 id="unary-plus-operator">Unary plus operator</h3>

<p>For an operation of the form <code class="prettyprint">+x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined unary plus operators are:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">uint</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">long</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">ulong</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">float</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">double</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">decimal</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>For each of these operators, the result is simply the value of the operand.</p>

<h3 id="unary-minus-operator">Unary minus operator</h3>

<p>For an operation of the form <code class="prettyprint">-x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined negation operators are:</p>

<ul>
<li> Integer negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is computed by subtracting <code class="prettyprint">x</code> from zero. If the value of of <code class="prettyprint">x</code> is the smallest representable value of the operand type (-2^31 for <code class="prettyprint">int</code> or -2^63 for <code class="prettyprint">long</code>), then the mathematical negation of <code class="prettyprint">x</code> is not representable within the operand type. If this occurs within a <code class="prettyprint">checked</code> context, a <code class="prettyprint">System.OverflowException</code> is thrown; if it occurs within an <code class="prettyprint">unchecked</code> context, the result is the value of the operand and the overflow is not reported.</p>

<p>If the operand of the negation operator is of type <code class="prettyprint">uint</code>, it is converted to type <code class="prettyprint">long</code>, and the type of the result is <code class="prettyprint">long</code>. An exception is the rule that permits the <code class="prettyprint">int</code> value -2147483648 (-2^31) to be written as a decimal integer literal (<a href="lexical-structure.md#integer-literals">Integer literals</a>).</p>

<p>If the operand of the negation operator is of type <code class="prettyprint">ulong</code>, a compile-time error occurs. An exception is the rule that permits the <code class="prettyprint">long</code> value -9223372036854775808 (-2^63) to be written as a decimal integer literal (<a href="lexical-structure.md#integer-literals">Integer literals</a>).</p>

<ul>
<li> Floating-point negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is the value of <code class="prettyprint">x</code> with its sign inverted. If <code class="prettyprint">x</code> is NaN, the result is also NaN.</p>

<ul>
<li> Decimal negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is computed by subtracting <code class="prettyprint">x</code> from zero. Decimal negation is equivalent to using the unary minus operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="logical-negation-operator">Logical negation operator</h3>

<p>For an operation of the form <code class="prettyprint">!x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. Only one predefined logical negation operator exists:
<code class="prettyprint">csharp
bool operator !(bool x);
</code></p>

<p>This operator computes the logical negation of the operand: If the operand is <code class="prettyprint">true</code>, the result is <code class="prettyprint">false</code>. If the operand is <code class="prettyprint">false</code>, the result is <code class="prettyprint">true</code>.</p>

<h3 id="bitwise-complement-operator">Bitwise complement operator</h3>

<p>For an operation of the form <code class="prettyprint">~x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined bitwise complement operators are:
<code class="prettyprint">csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
</code></p>

<p>For each of these operators, the result of the operation is the bitwise complement of <code class="prettyprint">x</code>.</p>

<p>Every enumeration type <code class="prettyprint">E</code> implicitly provides the following bitwise complement operator:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">E</span> <span class="k">operator</span> <span class="p">~(</span><span class="n">E</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result of evaluating <code class="prettyprint">~x</code>, where <code class="prettyprint">x</code> is an expression of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, is exactly the same as evaluating <code class="prettyprint">(E)(~(U)x)</code>, except that the conversion to <code class="prettyprint">E</code> is always performed as if in an <code class="prettyprint">unchecked</code> context (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>).</p>

<h3 id="prefix-increment-and-decrement-operators">Prefix increment and decrement operators</h3>
<pre class="highlight shell"><code>pre_increment_expression
    : <span class="s1">'++'</span> unary_expression
    ;

pre_decrement_expression
    : <span class="s1">'--'</span> unary_expression
    ;
</code></pre>
<p>The operand of a prefix increment or decrement operation must be an expression classified as a variable, a property access, or an indexer access. The result of the operation is a value of the same type as the operand.</p>

<p>If the operand of a prefix increment or decrement operation is a property or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>Unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. Predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators exist for the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, and any enum type. The predefined <code class="prettyprint">++</code> operators return the value produced by adding 1 to the operand, and the predefined <code class="prettyprint">--</code> operators return the value produced by subtracting 1 from the operand. In a <code class="prettyprint">checked</code> context, if the result of this addition or subtraction is outside the range of the result type and the result type is an integral type or enum type, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The run-time processing of a prefix increment or decrement operation of the form <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li>The selected operator is invoked with the value of <code class="prettyprint">x</code> as its argument.</li>
<li>The value returned by the operator is stored in the location given by the evaluation of <code class="prettyprint">x</code>.</li>
<li>The value returned by the operator becomes the result of the operation.</li>
</ul></li>
<li>  If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor invocations.</li>
<li>The <code class="prettyprint">get</code> accessor of <code class="prettyprint">x</code> is invoked.</li>
<li>The selected operator is invoked with the value returned by the <code class="prettyprint">get</code> accessor as its argument.</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value returned by the operator as its <code class="prettyprint">value</code> argument.</li>
<li>The value returned by the operator becomes the result of the operation.</li>
</ul></li>
</ul>

<p>The <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators also support postfix notation (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>). Typically, the result of <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> is the value of <code class="prettyprint">x</code> before the operation, whereas the result of <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> is the value of <code class="prettyprint">x</code> after the operation. In either case, <code class="prettyprint">x</code> itself has the same value after the operation.</p>

<p>An <code class="prettyprint">operator++</code> or <code class="prettyprint">operator--</code> implementation can be invoked using either postfix or prefix notation. It is not possible to have separate operator implementations for the two notations.</p>

<h3 id="cast-expressions">Cast expressions</h3>

<p>A <em>cast_expression</em> is used to explicitly convert an expression to a given type.</p>
<pre class="highlight shell"><code>cast_expression
    : <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span> unary_expression
    ;
</code></pre>
<p>A <em>cast_expression</em> of the form <code class="prettyprint">(T)E</code>, where <code class="prettyprint">T</code> is a <em>type</em> and <code class="prettyprint">E</code> is a <em>unary_expression</em>, performs an explicit conversion (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) of the value of <code class="prettyprint">E</code> to type <code class="prettyprint">T</code>. If no explicit conversion exists from <code class="prettyprint">E</code> to <code class="prettyprint">T</code>, a binding-time error occurs. Otherwise, the result is the value produced by the explicit conversion. The result is always classified as a value, even if <code class="prettyprint">E</code> denotes a variable.</p>

<p>The grammar for a <em>cast_expression</em> leads to certain syntactic ambiguities. For example, the expression <code class="prettyprint">(x)-y</code> could either be interpreted as a <em>cast_expression</em> (a cast of <code class="prettyprint">-y</code> to type <code class="prettyprint">x</code>) or as an <em>additive_expression</em> combined with a <em>parenthesized_expression</em> (which computes the value <code class="prettyprint">x - y)</code>.</p>

<p>To resolve <em>cast_expression</em> ambiguities, the following rule exists: A sequence of one or more <em>token*s (<a href="lexical-structure.md#white-space">White space</a>) enclosed in parentheses is considered the start of a *cast_expression</em> only if at least one of the following are true:</p>

<ul>
<li> The sequence of tokens is correct grammar for a <em>type</em>, but not for an <em>expression</em>.</li>
<li> The sequence of tokens is correct grammar for a <em>type</em>, and the token immediately following the closing parentheses is the token &rdquo;<code class="prettyprint">~</code>&ldquo;, the token &rdquo;<code class="prettyprint">!</code>&ldquo;, the token &rdquo;<code class="prettyprint">(</code>&ldquo;, an <em>identifier</em> (<a href="lexical-structure.md#unicode-character-escape-sequences">Unicode character escape sequences</a>), a <em>literal</em> (<a href="lexical-structure.md#literals">Literals</a>), or any <em>keyword</em> (<a href="lexical-structure.md#keywords">Keywords</a>) except <code class="prettyprint">as</code> and <code class="prettyprint">is</code>.</li>
</ul>

<p>The term &quot;correct grammar&rdquo; above means only that the sequence of tokens must conform to the particular grammatical production. It specifically does not consider the actual meaning of any constituent identifiers. For example, if <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are identifiers, then <code class="prettyprint">x.y</code> is correct grammar for a type, even if <code class="prettyprint">x.y</code> doesn&rsquo;t actually denote a type.</p>

<p>From the disambiguation rule it follows that, if <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are identifiers, <code class="prettyprint">(x)y</code>, <code class="prettyprint">(x)(y)</code>, and <code class="prettyprint">(x)(-y)</code> are *cast_expression*s, but <code class="prettyprint">(x)-y</code> is not, even if <code class="prettyprint">x</code> identifies a type. However, if <code class="prettyprint">x</code> is a keyword that identifies a predefined type (such as <code class="prettyprint">int</code>), then all four forms are *cast_expression*s (because such a keyword could not possibly be an expression by itself).</p>

<h3 id="await-expressions">Await expressions</h3>

<p>The await operator is used to suspend evaluation of the enclosing async function until the asynchronous operation represented by the operand has completed.</p>
<pre class="highlight shell"><code>await_expression
    : <span class="s1">'await'</span> unary_expression
    ;
</code></pre>
<p>An <em>await_expression</em> is only allowed in the body of an async function (<a href="classes.md#iterators">Iterators</a>). Within the nearest enclosing async function, an <em>await_expression</em> may not occur in these places:</p>

<ul>
<li> Inside a nested (non-async) anonymous function</li>
<li> Inside the block of a <em>lock_statement</em></li>
<li> In an unsafe context</li>
</ul>

<p>Note that an <em>await_expression</em> cannot occur in most places within a <em>query_expression</em>, because those are syntactically transformed to use non-async lambda expressions.</p>

<p>Inside of an async function, <code class="prettyprint">await</code> cannot be used as an identifier. There is therefore no syntactic ambiguity between await-expressions and various expressions involving identifiers. Outside of async functions, <code class="prettyprint">await</code> acts as a normal identifier.</p>

<p>The operand of an <em>await_expression</em> is called the <strong><em>task</em></strong>. It represents an asynchronous operation that may or may not be complete at the time the <em>await_expression</em> is evaluated. The purpose of the await operator is to suspend execution of the enclosing async function until the awaited task is complete, and then obtain its outcome.</p>

<h4 id="awaitable-expressions">Awaitable expressions</h4>

<p>The task of an await expression is required to be <strong><em>awaitable</em></strong>. An expression <code class="prettyprint">t</code> is awaitable if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">t</code> is of compile time type <code class="prettyprint">dynamic</code></li>
<li> <code class="prettyprint">t</code> has an accessible instance or extension method called <code class="prettyprint">GetAwaiter</code> with no parameters and no type parameters, and a return type <code class="prettyprint">A</code> for which all of the following hold:

<ul>
<li><code class="prettyprint">A</code> implements the interface <code class="prettyprint">System.Runtime.CompilerServices.INotifyCompletion</code> (hereafter known as <code class="prettyprint">INotifyCompletion</code> for brevity)</li>
<li><code class="prettyprint">A</code> has an accessible, readable instance property <code class="prettyprint">IsCompleted</code> of type <code class="prettyprint">bool</code></li>
<li><code class="prettyprint">A</code> has an accessible instance method <code class="prettyprint">GetResult</code> with no parameters and no type parameters</li>
</ul></li>
</ul>

<p>The purpose of the <code class="prettyprint">GetAwaiter</code> method is to obtain an <strong><em>awaiter</em></strong> for the task. The type <code class="prettyprint">A</code> is called the <strong><em>awaiter type</em></strong> for the await expression.</p>

<p>The purpose of the <code class="prettyprint">IsCompleted</code> property is to determine if the task is already complete. If so, there is no need to suspend evaluation.</p>

<p>The purpose of the <code class="prettyprint">INotifyCompletion.OnCompleted</code> method is to sign up a &ldquo;continuation&rdquo; to the task; i.e. a delegate (of type <code class="prettyprint">System.Action</code>) that will be invoked once the task is complete.</p>

<p>The purpose of the <code class="prettyprint">GetResult</code> method is to obtain the outcome of the task once it is complete. This outcome may be successful completion, possibly with a result value, or it may be an exception which is thrown by the <code class="prettyprint">GetResult</code> method.</p>

<h4 id="classification-of-await-expressions">Classification of await expressions</h4>

<p>The expression <code class="prettyprint">await t</code> is classified the same way as the expression <code class="prettyprint">(t).GetAwaiter().GetResult()</code>. Thus, if the return type of <code class="prettyprint">GetResult</code> is <code class="prettyprint">void</code>, the <em>await_expression</em> is classified as nothing. If it has a non-void return type <code class="prettyprint">T</code>, the <em>await_expression</em> is classified as a value of type <code class="prettyprint">T</code>.</p>

<h4 id="runtime-evaluation-of-await-expressions">Runtime evaluation of await expressions</h4>

<p>At runtime, the expression <code class="prettyprint">await t</code> is evaluated as follows:</p>

<ul>
<li> An awaiter <code class="prettyprint">a</code> is obtained by evaluating the expression <code class="prettyprint">(t).GetAwaiter()</code>.</li>
<li> A <code class="prettyprint">bool</code> <code class="prettyprint">b</code> is obtained by evaluating the expression <code class="prettyprint">(a).IsCompleted</code>.</li>
<li> If <code class="prettyprint">b</code> is <code class="prettyprint">false</code> then evaluation depends on whether <code class="prettyprint">a</code> implements the interface <code class="prettyprint">System.Runtime.CompilerServices.ICriticalNotifyCompletion</code> (hereafter known as <code class="prettyprint">ICriticalNotifyCompletion</code> for brevity). This check is done at binding time; i.e. at runtime if <code class="prettyprint">a</code> has the compile time type <code class="prettyprint">dynamic</code>, and at compile time otherwise. Let <code class="prettyprint">r</code> denote the resumption delegate (<a href="classes.md#iterators">Iterators</a>):

<ul>
<li>If <code class="prettyprint">a</code> does not implement <code class="prettyprint">ICriticalNotifyCompletion</code>, then the expression 
<code class="prettyprint">(a as (INotifyCompletion)).OnCompleted(r)</code> is evaluated.</li>
<li>If <code class="prettyprint">a</code> does implement <code class="prettyprint">ICriticalNotifyCompletion</code>, then the expression 
<code class="prettyprint">(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)</code> is evaluated.</li>
<li>Evaluation is then suspended, and control is returned to the current caller of the async function.</li>
</ul></li>
<li> Either immediately after (if <code class="prettyprint">b</code> was <code class="prettyprint">true</code>), or upon later invocation of the resumption delegate (if <code class="prettyprint">b</code> was <code class="prettyprint">false</code>), the expression <code class="prettyprint">(a).GetResult()</code> is evaluated. If it returns a value, that value is the result of the <em>await_expression</em>. Otherwise the result is nothing.</li>
</ul>

<p>An awaiter&rsquo;s implementation of the interface methods <code class="prettyprint">INotifyCompletion.OnCompleted</code> and <code class="prettyprint">ICriticalNotifyCompletion.UnsafeOnCompleted</code> should cause the delegate <code class="prettyprint">r</code> to be invoked at most once. Otherwise, the behavior of the enclosing async function is undefined.</p>

<h2 id="arithmetic-operators">Arithmetic operators</h2>

<p>The <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">+</code>, and <code class="prettyprint">-</code> operators are called the arithmetic operators.</p>
<pre class="highlight shell"><code>multiplicative_expression
    : unary_expression
    | multiplicative_expression <span class="s1">'*'</span> unary_expression
    | multiplicative_expression <span class="s1">'/'</span> unary_expression
    | multiplicative_expression <span class="s1">'%'</span> unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression <span class="s1">'+'</span> multiplicative_expression
    | additive_expression <span class="s1">'-'</span> multiplicative_expression
    ;
</code></pre>
<p>If an operand of an arithmetic operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<h3 id="multiplication-operator">Multiplication operator</h3>

<p>For an operation of the form <code class="prettyprint">x * y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined multiplication operators are listed below. The operators all compute the product of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the product is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The product is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x * y</code>. If the result is too large for the destination type, <code class="prettyprint">z</code> is infinity. If the result is too small for the destination type, <code class="prettyprint">z</code> is zero.</p>

<p>|      |      |      |     |     |      |      |     |
   |:&mdash;-:|&mdash;&ndash;:|:&mdash;-:|:&mdash;:|:&mdash;:|:&mdash;-:|:&mdash;-:|:&mdash;-|
   |      | +y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | +x   | +z   | -z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | -z   | +z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | </p>

<ul>
<li> Decimal multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. If the result value is too small to represent in the <code class="prettyprint">decimal</code> format, the result is zero. The scale of the result, before any rounding, is the sum of the scales of the two operands.</p>

<p>Decimal multiplication is equivalent to using the multiplication operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="division-operator">Division operator</h3>

<p>For an operation of the form <code class="prettyprint">x / y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined division operators are listed below. The operators all compute the quotient of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown.</p>

<p>The division rounds the result towards zero. Thus the absolute value of the result is the largest possible integer that is less than or equal to the absolute value of the quotient of the two operands. The result is zero or positive when the two operands have the same sign and zero or negative when the two operands have opposite signs.</p>

<p>If the left operand is the smallest representable <code class="prettyprint">int</code> or <code class="prettyprint">long</code> value and the right operand is <code class="prettyprint">-1</code>, an overflow occurs. In a <code class="prettyprint">checked</code> context, this causes a <code class="prettyprint">System.ArithmeticException</code> (or a subclass thereof) to be thrown. In an <code class="prettyprint">unchecked</code> context, it is implementation-defined as to whether a <code class="prettyprint">System.ArithmeticException</code> (or a subclass thereof) is thrown or the overflow goes unreported with the resulting value being that of the left operand.</p>

<ul>
<li> Floating-point division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The quotient is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x / y</code>. If the result is too large for the destination type, <code class="prettyprint">z</code> is infinity. If the result is too small for the destination type, <code class="prettyprint">z</code> is zero.</p>

<p>|      |      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | +y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | +z   | -z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | -z   | +z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown. If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. If the result value is too small to represent in the <code class="prettyprint">decimal</code> format, the result is zero. The scale of the result is the smallest scale that will preserve a result equal to the nearest representantable decimal value to the true mathematical result.</p>

<p>Decimal division is equivalent to using the division operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="remainder-operator">Remainder operator</h3>

<p>For an operation of the form <code class="prettyprint">x % y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined remainder operators are listed below. The operators all compute the remainder of the division between <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The result of <code class="prettyprint">x % y</code> is the value produced by <code class="prettyprint">x - (x / y) * y</code>. If <code class="prettyprint">y</code> is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown.</p>

<p>If the left operand is the smallest <code class="prettyprint">int</code> or <code class="prettyprint">long</code> value and the right operand is <code class="prettyprint">-1</code>, a <code class="prettyprint">System.OverflowException</code> is thrown. In no case does <code class="prettyprint">x % y</code> throw an exception where <code class="prettyprint">x / y</code> would not throw an exception.</p>

<ul>
<li> Floating-point remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x % y</code> and is computed as <code class="prettyprint">x - n * y</code>, where <code class="prettyprint">n</code> is the largest possible integer that is less than or equal to <code class="prettyprint">x / y</code>. This method of computing the remainder is analogous to that used for integer operands, but differs from the IEEE 754 definition (in which <code class="prettyprint">n</code> is the integer closest to <code class="prettyprint">x / y</code>).</p>

<p>|      |      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | +y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | +z   | +z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands, and the sign of the result, if non-zero, is the same as that of <code class="prettyprint">x</code>.</p>

<p>Decimal remainder is equivalent to using the remainder operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="addition-operator">Addition operator</h3>

<p>For an operation of the form <code class="prettyprint">x + y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined addition operators are listed below. For numeric and enumeration types, the predefined addition operators compute the sum of the two operands. When one or both operands are of type string, the predefined addition operators concatenate the string representation of the operands.</p>

<ul>
<li> Integer addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the sum is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The sum is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are nonzero finite values, and <code class="prettyprint">z</code> is the result of <code class="prettyprint">x + y</code>. If <code class="prettyprint">x</code> and <code class="prettyprint">y</code> have the same magnitude but opposite signs, <code class="prettyprint">z</code> is positive zero. If <code class="prettyprint">x + y</code> is too large to represent in the destination type, <code class="prettyprint">z</code> is an infinity with the same sign as <code class="prettyprint">x + y</code>.</p>

<p>|      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands.</p>

<p>Decimal addition is equivalent to using the addition operator of type <code class="prettyprint">System.Decimal</code>.</p>

<ul>
<li> Enumeration addition. Every enumeration type implicitly provides the following predefined operators, where <code class="prettyprint">E</code> is the enum type, and <code class="prettyprint">U</code> is the underlying type of <code class="prettyprint">E</code>:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">E</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">);</span>
   <span class="n">E</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">U</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>At run-time these operators are evaluated exactly as <code class="prettyprint">(E)((U)x + (U)y)</code>.</p>

<ul>
<li> String concatenation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">object</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">object</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>These overloads of the binary <code class="prettyprint">+</code> operator perform string concatenation. If an operand of string concatenation is <code class="prettyprint">null</code>, an empty string is substituted. Otherwise, any non-string argument is converted to its string representation by invoking the virtual <code class="prettyprint">ToString</code> method inherited from type <code class="prettyprint">object</code>. If <code class="prettyprint">ToString</code> returns <code class="prettyprint">null</code>, an empty string is substituted.</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

   <span class="k">class</span> <span class="nc">Test</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
           <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"s = &gt;"</span> <span class="p">+</span> <span class="n">s</span> <span class="p">+</span> <span class="s">"&lt;"</span><span class="p">);</span>        <span class="c1">// displays s = &gt;&lt;</span>
           <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"i = "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>               <span class="c1">// displays i = 1</span>
           <span class="kt">float</span> <span class="n">f</span> <span class="p">=</span> <span class="m">1.2300E+15F</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"f = "</span> <span class="p">+</span> <span class="n">f</span><span class="p">);</span>               <span class="c1">// displays f = 1.23E+15</span>
           <span class="kt">decimal</span> <span class="n">d</span> <span class="p">=</span> <span class="m">2.900</span><span class="n">m</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"d = "</span> <span class="p">+</span> <span class="n">d</span><span class="p">);</span>               <span class="c1">// displays d = 2.900</span>
       <span class="p">}</span>
   <span class="p">}</span>
</code></pre>
<p>The result of the string concatenation operator is a string that consists of the characters of the left operand followed by the characters of the right operand. The string concatenation operator never returns a <code class="prettyprint">null</code> value. A <code class="prettyprint">System.OutOfMemoryException</code> may be thrown if there is not enough memory available to allocate the resulting string.</p>

<ul>
<li> Delegate combination. Every delegate type implicitly provides the following predefined operator, where <code class="prettyprint">D</code> is the delegate type:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">D</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">D</span> <span class="n">x</span><span class="p">,</span> <span class="n">D</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The binary <code class="prettyprint">+</code> operator performs delegate combination when both operands are of some delegate type <code class="prettyprint">D</code>. (If the operands have different delegate types, a binding-time error occurs.) If the first operand is <code class="prettyprint">null</code>, the result of the operation is the value of the second operand (even if that is also <code class="prettyprint">null</code>). Otherwise, if the second operand is <code class="prettyprint">null</code>, then the result of the operation is the value of the first operand. Otherwise, the result of the operation is a new delegate instance that, when invoked, invokes the first operand and then invokes the second operand. For examples of delegate combination, see <a href="expressions.md#subtraction-operator">Subtraction operator</a> and <a href="delegates.md#delegate-invocation">Delegate invocation</a>. Since <code class="prettyprint">System.Delegate</code> is not a delegate type, <code class="prettyprint">operator</code>Â <code class="prettyprint">+</code> is not defined for it.</p>

<h3 id="subtraction-operator">Subtraction operator</h3>

<p>For an operation of the form <code class="prettyprint">x - y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined subtraction operators are listed below. The operators all subtract <code class="prettyprint">y</code> from <code class="prettyprint">x</code>.</p>

<ul>
<li> Integer subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the difference is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The difference is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaNs. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are nonzero finite values, and <code class="prettyprint">z</code> is the result of <code class="prettyprint">x - y</code>. If <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are equal, <code class="prettyprint">z</code> is positive zero. If <code class="prettyprint">x - y</code> is too large to represent in the destination type, <code class="prettyprint">z</code> is an infinity with the same sign as <code class="prettyprint">x - y</code>.</p>

<p>|      |      |      |      |      |      |     |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;:|
   | NaN  | y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | </p>

<ul>
<li> Decimal subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands.</p>

<p>Decimal subtraction is equivalent to using the subtraction operator of type <code class="prettyprint">System.Decimal</code>.</p>

<ul>
<li> Enumeration subtraction. Every enumeration type implicitly provides the following predefined operator, where <code class="prettyprint">E</code> is the enum type, and <code class="prettyprint">U</code> is the underlying type of <code class="prettyprint">E</code>:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">U</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>This operator is evaluated exactly as <code class="prettyprint">(U)((U)x - (U)y)</code>. In other words, the operator computes the difference between the ordinal values of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, and the type of the result is the underlying type of the enumeration.</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">E</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>This operator is evaluated exactly as <code class="prettyprint">(E)((U)x - y)</code>. In other words, the operator subtracts a value from the underlying type of the enumeration, yielding a value of the enumeration.</p>

<ul>
<li> Delegate removal. Every delegate type implicitly provides the following predefined operator, where <code class="prettyprint">D</code> is the delegate type:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">D</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">D</span> <span class="n">x</span><span class="p">,</span> <span class="n">D</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The binary <code class="prettyprint">-</code> operator performs delegate removal when both operands are of some delegate type <code class="prettyprint">D</code>. If the operands have different delegate types, a binding-time error occurs. If the first operand is <code class="prettyprint">null</code>, the result of the operation is <code class="prettyprint">null</code>. Otherwise, if the second operand is <code class="prettyprint">null</code>, then the result of the operation is the value of the first operand. Otherwise, both operands represent invocation lists (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) having one or more entries, and the result is a new invocation list consisting of the first operand&rsquo;s list with the second operand&rsquo;s entries removed from it, provided the second operand&rsquo;s list is a proper contiguous sublist of the first&rsquo;s.     (To determine sublist equality, corresponding entries are compared as for the delegate equality operator (<a href="expressions.md#delegate-equality-operators">Delegate equality operators</a>).) Otherwise, the result is the value of the left operand. Neither of the operands&rsquo; lists is changed in the process. If the second operand&rsquo;s list matches multiple sublists of contiguous entries in the first operand&rsquo;s list, the right-most matching sublist of contiguous entries is removed. If removal results in an empty list, the result is <code class="prettyprint">null</code>. For example:</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">delegate</span> <span class="k">void</span> <span class="nf">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

   <span class="k">class</span> <span class="nc">C</span>
   <span class="p">{</span>
       <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
       <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">class</span> <span class="nc">Test</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> 
           <span class="n">D</span> <span class="n">cd1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M1</span><span class="p">);</span>
           <span class="n">D</span> <span class="n">cd2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M2</span><span class="p">);</span>
           <span class="n">D</span> <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>   <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span><span class="p">;</span>                      <span class="c1">// =&gt; M1 + M2 + M2</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>                <span class="c1">// =&gt; M2 + M1</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M1</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M2</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M2 + M2 + M1</span>
       <span class="p">}</span>
   <span class="p">}</span>
</code></pre>
<h2 id="shift-operators">Shift operators</h2>

<p>The <code class="prettyprint">&lt;&lt;</code> and <code class="prettyprint">&gt;&gt;</code> operators are used to perform bit shifting operations.</p>
<pre class="highlight shell"><code>shift_expression
    : additive_expression
    | shift_expression <span class="s1">'&lt;&lt;'</span> additive_expression
    | shift_expression right_shift additive_expression
    ;
</code></pre>
<p>If an operand of a <em>shift_expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x &lt;&lt; count</code> or <code class="prettyprint">x &gt;&gt; count</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>When declaring an overloaded shift operator, the type of the first operand must always be the class or struct containing the operator declaration, and the type of the second operand must always be <code class="prettyprint">int</code>.</p>

<p>The predefined shift operators are listed below.</p>

<ul>
<li> Shift left:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre>
<p>The <code class="prettyprint">&lt;&lt;</code> operator shifts <code class="prettyprint">x</code> left by a number of bits computed as described below.</p>

<p>The high-order bits outside the range of the result type of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted left, and the low-order empty bit positions are set to zero.</p>

<ul>
<li> Shift right:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre>
<p>The <code class="prettyprint">&gt;&gt;</code> operator shifts <code class="prettyprint">x</code> right by a number of bits computed as described below.</p>

<p>When <code class="prettyprint">x</code> is of type <code class="prettyprint">int</code> or <code class="prettyprint">long</code>, the low-order bits of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted right, and the high-order empty bit positions are set to zero if <code class="prettyprint">x</code> is non-negative and set to one if <code class="prettyprint">x</code> is negative.</p>

<p>When <code class="prettyprint">x</code> is of type <code class="prettyprint">uint</code> or <code class="prettyprint">ulong</code>, the low-order bits of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted right, and the high-order empty bit positions are set to zero.</p>

<p>For the predefined operators, the number of bits to shift is computed as follows:</p>

<ul>
<li> When the type of <code class="prettyprint">x</code> is <code class="prettyprint">int</code> or <code class="prettyprint">uint</code>, the shift count is given by the low-order five bits of <code class="prettyprint">count</code>. In other words, the shift count is computed from <code class="prettyprint">count &amp; 0x1F</code>.</li>
<li> When the type of <code class="prettyprint">x</code> is <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code>, the shift count is given by the low-order six bits of <code class="prettyprint">count</code>. In other words, the shift count is computed from <code class="prettyprint">count &amp; 0x3F</code>.</li>
</ul>

<p>If the resulting shift count is zero, the shift operators simply return the value of <code class="prettyprint">x</code>.</p>

<p>Shift operations never cause overflows and produce the same results in <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> contexts.</p>

<p>When the left operand of the <code class="prettyprint">&gt;&gt;</code> operator is of a signed integral type, the operator performs an arithmetic shift right wherein the value of the most significant bit (the sign bit) of the operand is propagated to the high-order empty bit positions. When the left operand of the <code class="prettyprint">&gt;&gt;</code> operator is of an unsigned integral type, the operator performs a logical shift right wherein high-order empty bit positions are always set to zero. To perform the opposite operation of that inferred from the operand type, explicit casts can be used. For example, if <code class="prettyprint">x</code> is a variable of type <code class="prettyprint">int</code>, the operation <code class="prettyprint">unchecked((int)((uint)x &gt;&gt; y))</code> performs a logical shift right of <code class="prettyprint">x</code>.</p>

<h2 id="relational-and-type-testing-operators">Relational and type-testing operators</h2>

<p>The <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, <code class="prettyprint">&gt;=</code>, <code class="prettyprint">is</code> and <code class="prettyprint">as</code> operators are called the relational and type-testing operators.</p>
<pre class="highlight shell"><code>relational_expression
    : shift_expression
    | relational_expression <span class="s1">'&lt;'</span> shift_expression
    | relational_expression <span class="s1">'&gt;'</span> shift_expression
    | relational_expression <span class="s1">'&lt;='</span> shift_expression
    | relational_expression <span class="s1">'&gt;='</span> shift_expression
    | relational_expression <span class="s1">'is'</span> <span class="nb">type</span>
    | relational_expression <span class="s1">'as'</span> <span class="nb">type</span>
    ;

equality_expression
    : relational_expression
    | equality_expression <span class="s1">'=='</span> relational_expression
    | equality_expression <span class="s1">'!='</span> relational_expression
    ;
</code></pre>
<p>The <code class="prettyprint">is</code> operator is described in <a href="expressions.md#the-is-operator">The is operator</a> and the <code class="prettyprint">as</code> operator is described in <a href="expressions.md#the-as-operator">The as operator</a>.</p>

<p>The <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code> and <code class="prettyprint">&gt;=</code> operators are <strong><em>comparison operators</em></strong>.</p>

<p>If an operand of a comparison operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x</code> <em>op</em> <code class="prettyprint">y</code>, where <em>op</em> is a comparison operator, overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined comparison operators are described in the following sections. All predefined comparison operators return a result of type <code class="prettyprint">bool</code>, as described in the following table.</p>

<table><thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>Result</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">x == y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x != y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is not equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &lt; y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is less than <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &gt; y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is greater than <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &lt;= y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is less than or equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &gt;= y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is greater than or equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
</tbody></table>

<h3 id="integer-comparison-operators">Integer comparison operators</h3>

<p>The predefined integer comparison operators are:
&ldquo;`csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);</p>

<p>bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);</p>

<p>bool operator &lt;(int x, int y);
bool operator &lt;(uint x, uint y);
bool operator &lt;(long x, long y);
bool operator &lt;(ulong x, ulong y);</p>

<p>bool operator &gt;(int x, int y);
bool operator &gt;(uint x, uint y);
bool operator &gt;(long x, long y);
bool operator &gt;(ulong x, ulong y);</p>

<p>bool operator &lt;=(int x, int y);
bool operator &lt;=(uint x, uint y);
bool operator &lt;=(long x, long y);
bool operator &lt;=(ulong x, ulong y);</p>

<p>bool operator &gt;=(int x, int y);
bool operator &gt;=(uint x, uint y);
bool operator &gt;=(long x, long y);
bool operator &gt;=(ulong x, ulong y);
&rdquo;`</p>

<p>Each of these operators compares the numeric values of the two integer operands and returns a <code class="prettyprint">bool</code> value that indicates whether the particular relation is <code class="prettyprint">true</code> or <code class="prettyprint">false</code>.</p>

<h3 id="floating-point-comparison-operators">Floating-point comparison operators</h3>

<p>The predefined floating-point comparison operators are:
&ldquo;`csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);</p>

<p>bool operator !=(float x, float y);
bool operator !=(double x, double y);</p>

<p>bool operator &lt;(float x, float y);
bool operator &lt;(double x, double y);</p>

<p>bool operator &gt;(float x, float y);
bool operator &gt;(double x, double y);</p>

<p>bool operator &lt;=(float x, float y);
bool operator &lt;=(double x, double y);</p>

<p>bool operator &gt;=(float x, float y);
bool operator &gt;=(double x, double y);
&rdquo;`</p>

<p>The operators compare the operands according to the rules of the IEEE 754 standard:</p>

<ul>
<li> If either operand is NaN, the result is <code class="prettyprint">false</code> for all operators except <code class="prettyprint">!=</code>, for which the result is <code class="prettyprint">true</code>. For any two operands, <code class="prettyprint">x != y</code> always produces the same result as <code class="prettyprint">!(x == y)</code>. However, when one or both operands are NaN, the <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">&gt;=</code> operators do not produce the same results as the logical negation of the opposite operator. For example, if either of <code class="prettyprint">x</code> and <code class="prettyprint">y</code> is NaN, then <code class="prettyprint">x &lt; y</code> is <code class="prettyprint">false</code>, but <code class="prettyprint">!(x &gt;= y)</code> is <code class="prettyprint">true</code>.</li>
<li> When neither operand is NaN, the operators compare the values of the two floating-point operands with respect to the ordering</li>
</ul>
<pre class="highlight shell"><code>   -inf &lt; -max &lt; ... &lt; -min &lt; -0.0 <span class="o">==</span> +0.0 &lt; +min &lt; ... &lt; +max &lt; +inf
</code></pre>
<p>where <code class="prettyprint">min</code> and <code class="prettyprint">max</code> are the smallest and largest positive finite values that can be represented in the given floating-point format. Notable effects of this ordering are:
   * Negative and positive zeros are considered equal.
   * A negative infinity is considered less than all other values, but equal to another negative infinity.
   * A positive infinity is considered greater than all other values, but equal to another positive infinity.</p>

<h3 id="decimal-comparison-operators">Decimal comparison operators</h3>

<p>The predefined decimal comparison operators are:
<code class="prettyprint">csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator &lt;(decimal x, decimal y);
bool operator &gt;(decimal x, decimal y);
bool operator &lt;=(decimal x, decimal y);
bool operator &gt;=(decimal x, decimal y);
</code></p>

<p>Each of these operators compares the numeric values of the two decimal operands and returns a <code class="prettyprint">bool</code> value that indicates whether the particular relation is <code class="prettyprint">true</code> or <code class="prettyprint">false</code>. Each decimal comparison is equivalent to using the corresponding relational or equality operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="boolean-equality-operators">Boolean equality operators</h3>

<p>The predefined boolean equality operators are:
<code class="prettyprint">csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
</code></p>

<p>The result of <code class="prettyprint">==</code> is <code class="prettyprint">true</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code> or if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">false</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">!=</code> is <code class="prettyprint">false</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code> or if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">false</code>. Otherwise, the result is <code class="prettyprint">true</code>. When the operands are of type <code class="prettyprint">bool</code>, the <code class="prettyprint">!=</code> operator produces the same result as the <code class="prettyprint">^</code> operator.</p>

<h3 id="enumeration-comparison-operators">Enumeration comparison operators</h3>

<p>Every enumeration type implicitly provides the following predefined comparison operators:
<code class="prettyprint">csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator &lt;(E x, E y);
bool operator &gt;(E x, E y);
bool operator &lt;=(E x, E y);
bool operator &gt;=(E x, E y);
</code></p>

<p>The result of evaluating <code class="prettyprint">x op y</code>, where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are expressions of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, and <code class="prettyprint">op</code> is one of the comparison operators, is exactly the same as evaluating <code class="prettyprint">((U)x) op ((U)y)</code>. In other words, the enumeration type comparison operators simply compare the underlying integral values of the two operands.</p>

<h3 id="reference-type-equality-operators">Reference type equality operators</h3>

<p>The predefined reference type equality operators are:
<code class="prettyprint">csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
</code></p>

<p>The operators return the result of comparing the two references for equality or non-equality.</p>

<p>Since the predefined reference type equality operators accept operands of type <code class="prettyprint">object</code>, they apply to all types that do not declare applicable <code class="prettyprint">operator ==</code> and <code class="prettyprint">operator !=</code> members. Conversely, any applicable user-defined equality operators effectively hide the predefined reference type equality operators.</p>

<p>The predefined reference type equality operators require one of the following:</p>

<ul>
<li> Both operands are a value of a type known to be a <em>reference_type</em> or the literal <code class="prettyprint">null</code>. Furthermore, an explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from the type of either operand to the type of the other operand.</li>
<li> One operand is a value of type <code class="prettyprint">T</code> where <code class="prettyprint">T</code> is a <em>type_parameter</em> and the other operand is the literal <code class="prettyprint">null</code>. Furthermore <code class="prettyprint">T</code> does not have the value type constraint.</li>
</ul>

<p>Unless one of these conditions are true, a binding-time error occurs. Notable implications of these rules are:</p>

<ul>
<li> It is a binding-time error to use the predefined reference type equality operators to compare two references that are known to be different at binding-time. For example, if the binding-time types of the operands are two class types <code class="prettyprint">A</code> and <code class="prettyprint">B</code>, and if neither <code class="prettyprint">A</code> nor <code class="prettyprint">B</code> derives from the other, then it would be impossible for the two operands to reference the same object. Thus, the operation is considered a binding-time error.</li>
<li> The predefined reference type equality operators do not permit value type operands to be compared. Therefore, unless a struct type declares its own equality operators, it is not possible to compare values of that struct type.</li>
<li> The predefined reference type equality operators never cause boxing operations to occur for their operands. It would be meaningless to perform such boxing operations, since references to the newly allocated boxed instances would necessarily differ from all other references.</li>
<li> If an operand of a type parameter type <code class="prettyprint">T</code> is compared to <code class="prettyprint">null</code>, and the run-time type of <code class="prettyprint">T</code> is a value type, the result of the comparison is <code class="prettyprint">false</code>.</li>
</ul>

<p>The following example checks whether an argument of an unconstrained type parameter type is <code class="prettyprint">null</code>.
<code class="prettyprint">csharp
class C&lt;T&gt;
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
</code></p>

<p>The <code class="prettyprint">x == null</code> construct is permitted even though <code class="prettyprint">T</code> could represent a value type, and the result is simply defined to be <code class="prettyprint">false</code> when <code class="prettyprint">T</code> is a value type.</p>

<p>For an operation of the form <code class="prettyprint">x == y</code> or <code class="prettyprint">x != y</code>, if any applicable <code class="prettyprint">operator ==</code> or <code class="prettyprint">operator !=</code> exists, the operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) rules will select that operator instead of the predefined reference type equality operator. However, it is always possible to select the predefined reference type equality operator by explicitly casting one or both of the operands to type <code class="prettyprint">object</code>. The example
&ldquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        string s = &quot;Test&rdquo;;
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
<code class="prettyprint">
produces the output
</code>bash
True
False
False
False
&ldquo;`</p>

<p>The <code class="prettyprint">s</code> and <code class="prettyprint">t</code> variables refer to two distinct <code class="prettyprint">string</code> instances containing the same characters. The first comparison outputs <code class="prettyprint">True</code> because the predefined string equality operator (<a href="expressions.md#string-equality-operators">String equality operators</a>) is selected when both operands are of type <code class="prettyprint">string</code>. The remaining comparisons all output <code class="prettyprint">False</code> because the predefined reference type equality operator is selected when one or both of the operands are of type <code class="prettyprint">object</code>.</p>

<p>Note that the above technique is not meaningful for value types. The example
<code class="prettyprint">csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
</code>
outputs <code class="prettyprint">False</code> because the casts create references to two separate instances of boxed <code class="prettyprint">int</code> values.</p>

<h3 id="string-equality-operators">String equality operators</h3>

<p>The predefined string equality operators are:
<code class="prettyprint">csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
</code></p>

<p>Two <code class="prettyprint">string</code> values are considered equal when one of the following is true:</p>

<ul>
<li> Both values are <code class="prettyprint">null</code>.</li>
<li> Both values are non-null references to string instances that have identical lengths and identical characters in each character position.</li>
</ul>

<p>The string equality operators compare string values rather than string references. When two separate string instances contain the exact same sequence of characters, the values of the strings are equal, but the references are different. As described in <a href="expressions.md#reference-type-equality-operators">Reference type equality operators</a>, the reference type equality operators can be used to compare string references instead of string values.</p>

<h3 id="delegate-equality-operators">Delegate equality operators</h3>

<p>Every delegate type implicitly provides the following predefined comparison operators:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">x</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">x</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>Two delegate instances are considered equal as follows:</p>

<ul>
<li> If either of the delegate instances is <code class="prettyprint">null</code>, they are equal if and only if both are <code class="prettyprint">null</code>.</li>
<li> If the delegates have different run-time type they are never equal.</li>
<li> If both of the delegate instances have an invocation list (<a href="delegates.md#delegate-declarations">Delegate declarations</a>), those instances are equal if and only if their invocation lists are the same length, and each entry in one&rsquo;s invocation list is equal (as defined below) to the corresponding entry, in order, in the other&rsquo;s invocation list.</li>
</ul>

<p>The following rules govern the equality of invocation list entries:</p>

<ul>
<li> If two invocation list entries both refer to the same static method then the entries are equal.</li>
<li> If two invocation list entries both refer to the same non-static method on the same target object (as defined by the reference equality operators) then the entries are equal.</li>
<li> Invocation list entries produced from evaluation of semantically identical *anonymous_method_expression*s or *lambda_expression*s with the same (possibly empty) set of captured outer variable instances are permitted (but not required) to be equal.</li>
</ul>

<h3 id="equality-operators-and-null">Equality operators and null</h3>

<p>The <code class="prettyprint">==</code> and <code class="prettyprint">!=</code> operators permit one operand to be a value of a nullable type and the other to be the <code class="prettyprint">null</code> literal, even if no predefined or user-defined operator (in unlifted or lifted form) exists for the operation.</p>

<p>For an operation of one of the forms
<code class="prettyprint">csharp
x == null
null == x
x != null
null != x
</code>
where <code class="prettyprint">x</code> is an expression of a nullable type, if operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) fails to find an applicable operator, the result is instead computed from the <code class="prettyprint">HasValue</code> property of <code class="prettyprint">x</code>. Specifically, the first two forms are translated into <code class="prettyprint">!x.HasValue</code>, and last two forms are translated into <code class="prettyprint">x.HasValue</code>.</p>

<h3 id="the-is-operator">The is operator</h3>

<p>The <code class="prettyprint">is</code> operator is used to dynamically check if the run-time type of an object is compatible with a given type. The result of the operation <code class="prettyprint">E is T</code>, where <code class="prettyprint">E</code> is an expression and <code class="prettyprint">T</code> is a type, is a boolean value indicating whether <code class="prettyprint">E</code> can successfully be converted to type <code class="prettyprint">T</code> by a reference conversion, a boxing conversion, or an unboxing conversion. The operation is evaluated as follows, after type arguments have been substituted for all type parameters:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an anonymous function, a compile-time error occurs</li>
<li> If <code class="prettyprint">E</code> is a method group or the <code class="prettyprint">null</code> literal, of if the type of <code class="prettyprint">E</code> is a reference type or a nullable type and the value of <code class="prettyprint">E</code> is null, the result is false.</li>
<li> Otherwise, let <code class="prettyprint">D</code> represent the dynamic type of <code class="prettyprint">E</code> as follows:

<ul>
<li>If the type of <code class="prettyprint">E</code> is a reference type, <code class="prettyprint">D</code> is the run-time type of the instance reference by <code class="prettyprint">E</code>.</li>
<li>If the type of <code class="prettyprint">E</code> is a nullable type, <code class="prettyprint">D</code> is the underlying type of that nullable type.</li>
<li>If the type of <code class="prettyprint">E</code> is a non-nullable value type, <code class="prettyprint">D</code> is the type of <code class="prettyprint">E</code>.</li>
</ul></li>
<li> The result of the operation depends on <code class="prettyprint">D</code> and <code class="prettyprint">T</code> as follows:

<ul>
<li>If <code class="prettyprint">T</code> is a reference type, the result is true if <code class="prettyprint">D</code> and <code class="prettyprint">T</code> are the same type, if <code class="prettyprint">D</code> is a reference type and an implicit reference conversion from <code class="prettyprint">D</code> to <code class="prettyprint">T</code> exists, or if <code class="prettyprint">D</code> is a value type and a boxing conversion from <code class="prettyprint">D</code> to <code class="prettyprint">T</code> exists.</li>
<li>If <code class="prettyprint">T</code> is a nullable type, the result is true if <code class="prettyprint">D</code> is the underlying type of <code class="prettyprint">T</code>.</li>
<li>If <code class="prettyprint">T</code> is a non-nullable value type, the result is true if <code class="prettyprint">D</code> and <code class="prettyprint">T</code> are the same type.</li>
<li>Otherwise, the result is false.</li>
</ul></li>
</ul>

<p>Note that user defined conversions, are not considered by the <code class="prettyprint">is</code> operator.</p>

<h3 id="the-as-operator">The as operator</h3>

<p>The <code class="prettyprint">as</code> operator is used to explicitly convert a value to a given reference type or nullable type. Unlike a cast expression (<a href="expressions.md#cast-expressions">Cast expressions</a>), the <code class="prettyprint">as</code> operator never throws an exception. Instead, if the indicated conversion is not possible, the resulting value is <code class="prettyprint">null</code>.</p>

<p>In an operation of the form <code class="prettyprint">E as T</code>, <code class="prettyprint">E</code> must be an expression and <code class="prettyprint">T</code> must be a reference type, a type parameter known to be a reference type, or a nullable type. Furthermore, at least one of the following must be true, or otherwise a compile-time error occurs:</p>

<ul>
<li> An identity (<a href="conversions.md#identity-conversion">Identity conversion</a>), implicit nullable (<a href="conversions.md#implicit-nullable-conversions">Implicit nullable conversions</a>), implicit reference (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>), boxing (<a href="conversions.md#boxing-conversions">Boxing conversions</a>), explicit nullable (<a href="conversions.md#explicit-nullable-conversions">Explicit nullable conversions</a>), explicit reference (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>), or unboxing (<a href="conversions.md#unboxing-conversions">Unboxing conversions</a>) conversion exists from <code class="prettyprint">E</code> to <code class="prettyprint">T</code>.</li>
<li> The type of <code class="prettyprint">E</code> or <code class="prettyprint">T</code> is an open type.</li>
<li> <code class="prettyprint">E</code> is the <code class="prettyprint">null</code> literal.</li>
</ul>

<p>If the compile-time type of <code class="prettyprint">E</code> is not <code class="prettyprint">dynamic</code>, the operation <code class="prettyprint">E as T</code> produces the same result as
<code class="prettyprint">csharp
E is T ? (T)(E) : (T)null
</code>
except that <code class="prettyprint">E</code> is only evaluated once. The compiler can be expected to optimize <code class="prettyprint">E as T</code> to perform at most one dynamic type check as opposed to the two dynamic type checks implied by the expansion above.</p>

<p>If the compile-time type of <code class="prettyprint">E</code> is <code class="prettyprint">dynamic</code>, unlike the cast operator the <code class="prettyprint">as</code> operator is not dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). Therefore the expansion in this case is:
<code class="prettyprint">csharp
E is T ? (T)(object)(E) : (T)null
</code></p>

<p>Note that some conversions, such as user defined conversions, are not possible with the <code class="prettyprint">as</code> operator and should instead be performed using cast expressions.</p>

<p>In the example
&rdquo;`csharp
class X
{</p>

<p>public string F(object o) {
        return o as string;        // OK, string is a reference type
    }</p>

<p>public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }</p>

<p>public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
&ldquo;<code class="prettyprint">
the type parameter</code>T<code class="prettyprint">of</code>G<code class="prettyprint">is known to be a reference type, because it has the class constraint. The type parameter</code>U<code class="prettyprint">of</code>H<code class="prettyprint">is not however; hence the use of the</code>as<code class="prettyprint">operator in</code>H` is disallowed.</p>

<h2 id="logical-operators">Logical operators</h2>

<p>The <code class="prettyprint">&amp;</code>, <code class="prettyprint">^</code>, and <code class="prettyprint">|</code> operators are called the logical operators.</p>
<pre class="highlight shell"><code>and_expression
    : equality_expression
    | and_expression <span class="s1">'&amp;'</span> equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression <span class="s1">'^'</span> and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression <span class="s1">'|'</span> exclusive_or_expression
    ;
</code></pre>
<p>If an operand of a logical operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x op y</code>, where <code class="prettyprint">op</code> is one of the logical operators, overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined logical operators are described in the following sections.</p>

<h3 id="integer-logical-operators">Integer logical operators</h3>

<p>The predefined integer logical operators are:
&rdquo;`csharp
int operator &amp;(int x, int y);
uint operator &amp;(uint x, uint y);
long operator &amp;(long x, long y);
ulong operator &amp;(ulong x, ulong y);</p>

<p>int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);</p>

<p>int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
&ldquo;`</p>

<p>The <code class="prettyprint">&amp;</code> operator computes the bitwise logical <code class="prettyprint">AND</code> of the two operands, the <code class="prettyprint">|</code> operator computes the bitwise logical <code class="prettyprint">OR</code> of the two operands, and the <code class="prettyprint">^</code> operator computes the bitwise logical exclusive <code class="prettyprint">OR</code> of the two operands. No overflows are possible from these operations.</p>

<h3 id="enumeration-logical-operators">Enumeration logical operators</h3>

<p>Every enumeration type <code class="prettyprint">E</code> implicitly provides the following predefined logical operators:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">E</span> <span class="k">operator</span> <span class="p">&amp;(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
<span class="n">E</span> <span class="k">operator</span> <span class="p">|(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
<span class="n">E</span> <span class="k">operator</span> <span class="p">^(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The result of evaluating <code class="prettyprint">x op y</code>, where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are expressions of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, and <code class="prettyprint">op</code> is one of the logical operators, is exactly the same as evaluating <code class="prettyprint">(E)((U)x op (U)y)</code>. In other words, the enumeration type logical operators simply perform the logical operation on the underlying type of the two operands.</p>

<h3 id="boolean-logical-operators">Boolean logical operators</h3>

<p>The predefined boolean logical operators are:
<code class="prettyprint">csharp
bool operator &amp;(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
</code></p>

<p>The result of <code class="prettyprint">x &amp; y</code> is <code class="prettyprint">true</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">x | y</code> is <code class="prettyprint">true</code> if either <code class="prettyprint">x</code> or <code class="prettyprint">y</code> is <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">x ^ y</code> is <code class="prettyprint">true</code> if <code class="prettyprint">x</code> is <code class="prettyprint">true</code> and <code class="prettyprint">y</code> is <code class="prettyprint">false</code>, or <code class="prettyprint">x</code> is <code class="prettyprint">false</code> and <code class="prettyprint">y</code> is <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>. When the operands are of type <code class="prettyprint">bool</code>, the <code class="prettyprint">^</code> operator computes the same result as the <code class="prettyprint">!=</code> operator.</p>

<h3 id="nullable-boolean-logical-operators">Nullable boolean logical operators</h3>

<p>The nullable boolean type <code class="prettyprint">bool?</code> can represent three values, <code class="prettyprint">true</code>, <code class="prettyprint">false</code>, and <code class="prettyprint">null</code>, and is conceptually similar to the three-valued type used for boolean expressions in SQL. To ensure that the results produced by the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators for <code class="prettyprint">bool?</code> operands are consistent with SQL&rsquo;s three-valued logic, the following predefined operators are provided:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">bool</span><span class="p">?</span> <span class="k">operator</span> <span class="p">&amp;(</span><span class="kt">bool</span><span class="p">?</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span><span class="p">?</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span><span class="p">?</span> <span class="k">operator</span> <span class="p">|(</span><span class="kt">bool</span><span class="p">?</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span><span class="p">?</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The following table lists the results produced by these operators for all combinations of the values <code class="prettyprint">true</code>, <code class="prettyprint">false</code>, and <code class="prettyprint">null</code>.</p>

<p>| <code class="prettyprint">x</code>     | <code class="prettyprint">y</code>     | <code class="prettyprint">x &amp; y</code> | <code class="prettyprint">x \| y</code>|
|:&mdash;&mdash;-:|:&mdash;&mdash;-:|:&mdash;&mdash;-:|:&mdash;&mdash;-:|
| <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">true</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">true</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | 
| <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | </p>

<h2 id="conditional-logical-operators">Conditional logical operators</h2>

<p>The <code class="prettyprint">&amp;&amp;</code> and <code class="prettyprint">||</code> operators are called the conditional logical operators. They are also called the &quot;short-circuiting&rdquo; logical operators.</p>
<pre class="highlight shell"><code>conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression <span class="s1">'&amp;&amp;'</span> inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression <span class="s1">'||'</span> conditional_and_expression
    ;
</code></pre>
<p>The <code class="prettyprint">&amp;&amp;</code> and <code class="prettyprint">||</code> operators are conditional versions of the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> corresponds to the operation <code class="prettyprint">x &amp; y</code>, except that <code class="prettyprint">y</code> is evaluated only if <code class="prettyprint">x</code> is not <code class="prettyprint">false</code>.</li>
<li> The operation <code class="prettyprint">x || y</code> corresponds to the operation <code class="prettyprint">x | y</code>, except that <code class="prettyprint">y</code> is evaluated only if <code class="prettyprint">x</code> is not <code class="prettyprint">true</code>.</li>
</ul>

<p>If an operand of a conditional logical operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>An operation of the form <code class="prettyprint">x &amp;&amp; y</code> or <code class="prettyprint">x || y</code> is processed by applying overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) as if the operation was written <code class="prettyprint">x &amp; y</code> or <code class="prettyprint">x | y</code>. Then,</p>

<ul>
<li> If overload resolution fails to find a single best operator, or if overload resolution selects one of the predefined integer logical operators, a binding-time error occurs.</li>
<li> Otherwise, if the selected operator is one of the predefined boolean logical operators (<a href="expressions.md#boolean-logical-operators">Boolean logical operators</a>) or nullable boolean logical operators (<a href="expressions.md#nullable-boolean-logical-operators">Nullable boolean logical operators</a>), the operation is processed as described in <a href="expressions.md#boolean-conditional-logical-operators">Boolean conditional logical operators</a>.</li>
<li> Otherwise, the selected operator is a user-defined operator, and the operation is processed as described in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a>.</li>
</ul>

<p>It is not possible to directly overload the conditional logical operators. However, because the conditional logical operators are evaluated in terms of the regular logical operators, overloads of the regular logical operators are, with certain restrictions, also considered overloads of the conditional logical operators. This is described further in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a>.</p>

<h3 id="boolean-conditional-logical-operators">Boolean conditional logical operators</h3>

<p>When the operands of <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> are of type <code class="prettyprint">bool</code>, or when the operands are of types that do not define an applicable <code class="prettyprint">operator &amp;</code> or <code class="prettyprint">operator |</code>, but do define implicit conversions to <code class="prettyprint">bool</code>, the operation is processed as follows:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> is evaluated as <code class="prettyprint">x ? y : false</code>. In other words, <code class="prettyprint">x</code> is first evaluated and converted to type <code class="prettyprint">bool</code>. Then, if <code class="prettyprint">x</code> is <code class="prettyprint">true</code>, <code class="prettyprint">y</code> is evaluated and converted to type <code class="prettyprint">bool</code>, and this becomes the result of the operation. Otherwise, the result of the operation is <code class="prettyprint">false</code>.</li>
<li> The operation <code class="prettyprint">x || y</code> is evaluated as <code class="prettyprint">x ? true : y</code>. In other words, <code class="prettyprint">x</code> is first evaluated and converted to type <code class="prettyprint">bool</code>. Then, if <code class="prettyprint">x</code> is <code class="prettyprint">true</code>, the result of the operation is <code class="prettyprint">true</code>. Otherwise, <code class="prettyprint">y</code> is evaluated and converted to type <code class="prettyprint">bool</code>, and this becomes the result of the operation.</li>
</ul>

<h3 id="user-defined-conditional-logical-operators">User-defined conditional logical operators</h3>

<p>When the operands of <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> are of types that declare an applicable user-defined <code class="prettyprint">operator &amp;</code> or <code class="prettyprint">operator |</code>, both of the following must be true, where <code class="prettyprint">T</code> is the type in which the selected operator is declared:</p>

<ul>
<li> The return type and the type of each parameter of the selected operator must be <code class="prettyprint">T</code>. In other words, the operator must compute the logical <code class="prettyprint">AND</code> or the logical <code class="prettyprint">OR</code> of two operands of type <code class="prettyprint">T</code>, and must return a result of type <code class="prettyprint">T</code>.</li>
<li> <code class="prettyprint">T</code> must contain declarations of <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>.</li>
</ul>

<p>A binding-time error occurs if either of these requirements is not satisfied. Otherwise, the <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> operation is evaluated by combining the user-defined <code class="prettyprint">operator true</code> or <code class="prettyprint">operator false</code> with the selected user-defined operator:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> is evaluated as <code class="prettyprint">T.false(x) ? x : T.&amp;(x, y)</code>, where <code class="prettyprint">T.false(x)</code> is an invocation of the <code class="prettyprint">operator false</code> declared in <code class="prettyprint">T</code>, and <code class="prettyprint">T.&amp;(x, y)</code> is an invocation of the selected <code class="prettyprint">operator &amp;</code>. In other words, <code class="prettyprint">x</code> is first evaluated and <code class="prettyprint">operator false</code> is invoked on the result to determine if <code class="prettyprint">x</code> is definitely false. Then, if <code class="prettyprint">x</code> is definitely false, the result of the operation is the value previously computed for <code class="prettyprint">x</code>. Otherwise, <code class="prettyprint">y</code> is evaluated, and the selected <code class="prettyprint">operator &amp;</code> is invoked on the value previously computed for <code class="prettyprint">x</code> and the value computed for <code class="prettyprint">y</code> to produce the result of the operation.</li>
<li> The operation <code class="prettyprint">x || y</code> is evaluated as <code class="prettyprint">T.true(x) ? x : T.|(x, y)</code>, where <code class="prettyprint">T.true(x)</code> is an invocation of the <code class="prettyprint">operator true</code> declared in <code class="prettyprint">T</code>, and <code class="prettyprint">T.|(x,y)</code> is an invocation of the selected <code class="prettyprint">operator|</code>. In other words, <code class="prettyprint">x</code> is first evaluated and <code class="prettyprint">operator true</code> is invoked on the result to determine if <code class="prettyprint">x</code> is definitely true. Then, if <code class="prettyprint">x</code> is definitely true, the result of the operation is the value previously computed for <code class="prettyprint">x</code>. Otherwise, <code class="prettyprint">y</code> is evaluated, and the selected <code class="prettyprint">operator |</code> is invoked on the value previously computed for <code class="prettyprint">x</code> and the value computed for <code class="prettyprint">y</code> to produce the result of the operation.</li>
</ul>

<p>In either of these operations, the expression given by <code class="prettyprint">x</code> is only evaluated once, and the expression given by <code class="prettyprint">y</code> is either not evaluated or evaluated exactly once.</p>

<p>For an example of a type that implements <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>, see <a href="structs.md#database-boolean-type">Database boolean type</a>.</p>

<h2 id="the-null-coalescing-operator">The null coalescing operator</h2>

<p>The <code class="prettyprint">??</code> operator is called the null coalescing operator.</p>
<pre class="highlight shell"><code>null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression <span class="s1">'??'</span> null_coalescing_expression
    ;
</code></pre>
<p>A null coalescing expression of the form <code class="prettyprint">a ?? b</code> requires <code class="prettyprint">a</code> to be of a nullable type or reference type. If <code class="prettyprint">a</code> is non-null, the result of <code class="prettyprint">a ?? b</code> is <code class="prettyprint">a</code>; otherwise, the result is <code class="prettyprint">b</code>. The operation evaluates <code class="prettyprint">b</code> only if <code class="prettyprint">a</code> is null.</p>

<p>The null coalescing operator is right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a ?? b ?? c</code> is evaluated as <code class="prettyprint">a ?? (b ?? c)</code>. In general terms, an expression of the form <code class="prettyprint">E1 ?? E2 ?? ... ?? En</code> returns the first of the operands that is non-null, or null if all operands are null.</p>

<p>The type of the expression <code class="prettyprint">a ?? b</code> depends on which implicit conversions are available on the operands. In order of preference, the type of <code class="prettyprint">a ?? b</code> is <code class="prettyprint">A0</code>, <code class="prettyprint">A</code>, or <code class="prettyprint">B</code>, where <code class="prettyprint">A</code> is the type of <code class="prettyprint">a</code> (provided that <code class="prettyprint">a</code> has a type), <code class="prettyprint">B</code> is the type of <code class="prettyprint">b</code> (provided that <code class="prettyprint">b</code> has a type), and <code class="prettyprint">A0</code> is the underlying type of <code class="prettyprint">A</code> if <code class="prettyprint">A</code> is a nullable type, or <code class="prettyprint">A</code> otherwise. Specifically, <code class="prettyprint">a ?? b</code> is processed as follows:</p>

<ul>
<li> If <code class="prettyprint">A</code> exists and is not a nullable type or a reference type, a compile-time error occurs.</li>
<li> If <code class="prettyprint">b</code> is a dynamic expression, the result type is <code class="prettyprint">dynamic</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is converted to dynamic, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">A</code> exists and is a nullable type and an implicit conversion exists from <code class="prettyprint">b</code> to <code class="prettyprint">A0</code>, the result type is <code class="prettyprint">A0</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is unwrapped to type <code class="prettyprint">A0</code>, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and converted to type <code class="prettyprint">A0</code>, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">A</code> exists and an implicit conversion exists from <code class="prettyprint">b</code> to <code class="prettyprint">A</code>, the result type is <code class="prettyprint">A</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and converted to type <code class="prettyprint">A</code>, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">b</code> has a type <code class="prettyprint">B</code> and an implicit conversion exists from <code class="prettyprint">a</code> to <code class="prettyprint">B</code>, the result type is <code class="prettyprint">B</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is unwrapped to type <code class="prettyprint">A0</code> (if <code class="prettyprint">A</code> exists and is nullable) and converted to type <code class="prettyprint">B</code>, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and becomes the result.</li>
<li> Otherwise, <code class="prettyprint">a</code> and <code class="prettyprint">b</code> are incompatible, and a compile-time error occurs.</li>
</ul>

<h2 id="conditional-operator">Conditional operator</h2>

<p>The <code class="prettyprint">?:</code> operator is called the conditional operator. It is at times also called the ternary operator.</p>
<pre class="highlight shell"><code>conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression <span class="s1">'?'</span> expression <span class="s1">':'</span> expression
    ;
</code></pre>
<p>A conditional expression of the form <code class="prettyprint">b ? x : y</code> first evaluates the condition <code class="prettyprint">b</code>. Then, if <code class="prettyprint">b</code> is <code class="prettyprint">true</code>, <code class="prettyprint">x</code> is evaluated and becomes the result of the operation. Otherwise, <code class="prettyprint">y</code> is evaluated and becomes the result of the operation. A conditional expression never evaluates both <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<p>The conditional operator is right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a ? b : c ? d : e</code> is evaluated as <code class="prettyprint">a ? b : (c ? d : e)</code>.</p>

<p>The first operand of the <code class="prettyprint">?:</code> operator must be an expression that can be implicitly converted to <code class="prettyprint">bool</code>, or an expression of a type that implements <code class="prettyprint">operator true</code>. If neither of these requirements is satisfied, a compile-time error occurs.</p>

<p>The second and third operands, <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, of the <code class="prettyprint">?:</code> operator control the type of the conditional expression.</p>

<ul>
<li> If <code class="prettyprint">x</code> has type <code class="prettyprint">X</code> and <code class="prettyprint">y</code> has type <code class="prettyprint">Y</code> then

<ul>
<li>If an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from <code class="prettyprint">X</code> to <code class="prettyprint">Y</code>, but not from <code class="prettyprint">Y</code> to <code class="prettyprint">X</code>, then <code class="prettyprint">Y</code> is the type of the conditional expression.</li>
<li>If an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from <code class="prettyprint">Y</code> to <code class="prettyprint">X</code>, but not from <code class="prettyprint">X</code> to <code class="prettyprint">Y</code>, then <code class="prettyprint">X</code> is the type of the conditional expression.</li>
<li>Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul></li>
<li> If only one of <code class="prettyprint">x</code> and <code class="prettyprint">y</code> has a type, and both <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, of are implicitly convertible to that type, then that is the type of the conditional expression.</li>
<li> Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul>

<p>The run-time processing of a conditional expression of the form <code class="prettyprint">b ? x : y</code> consists of the following steps:</p>

<ul>
<li> First, <code class="prettyprint">b</code> is evaluated, and the <code class="prettyprint">bool</code> value of <code class="prettyprint">b</code> is determined:

<ul>
<li>If an implicit conversion from the type of <code class="prettyprint">b</code> to <code class="prettyprint">bool</code> exists, then this implicit conversion is performed to produce a <code class="prettyprint">bool</code> value.</li>
<li>Otherwise, the <code class="prettyprint">operator true</code> defined by the type of <code class="prettyprint">b</code> is invoked to produce a <code class="prettyprint">bool</code> value.</li>
</ul></li>
<li> If the <code class="prettyprint">bool</code> value produced by the step above is <code class="prettyprint">true</code>, then <code class="prettyprint">x</code> is evaluated and converted to the type of the conditional expression, and this becomes the result of the conditional expression.</li>
<li> Otherwise, <code class="prettyprint">y</code> is evaluated and converted to the type of the conditional expression, and this becomes the result of the conditional expression.</li>
</ul>

<h2 id="anonymous-function-expressions">Anonymous function expressions</h2>

<p>An <strong><em>anonymous function</em></strong> is an expression that represents an &ldquo;in-line&rdquo; method definition. An anonymous function does not have a value or type in and of itself, but is convertible to a compatible delegate or expression tree type. The evaluation of an anonymous function conversion depends on the target type of the conversion: If it is a delegate type, the conversion evaluates to a delegate value referencing the method which the anonymous function defines. If it is an expression tree type, the conversion evaluates to an expression tree which represents the structure of the method as an object structure.</p>

<p>For historical reasons there are two syntactic flavors of anonymous functions, namely *lambda_expression*s and *anonymous_method_expression*s. For almost all purposes, *lambda_expression*s are more concise and expressive than *anonymous_method_expression*s, which remain in the language for backwards compatibility.</p>
<pre class="highlight shell"><code>lambda_expression
    : anonymous_function_signature <span class="s1">'=&gt;'</span> anonymous_function_body
    ;

anonymous_method_expression
    : <span class="s1">'delegate'</span> explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : <span class="s1">'('</span> explicit_anonymous_function_parameter_list? <span class="s1">')'</span>
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter <span class="o">(</span><span class="s1">','</span> explicit_anonymous_function_parameter<span class="o">)</span><span class="k">*</span>
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? <span class="nb">type </span>identifier
    ;

anonymous_function_parameter_modifier
    : <span class="s1">'ref'</span>
    | <span class="s1">'out'</span>
    ;

implicit_anonymous_function_signature
    : <span class="s1">'('</span> implicit_anonymous_function_parameter_list? <span class="s1">')'</span>
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter <span class="o">(</span><span class="s1">','</span> implicit_anonymous_function_parameter<span class="o">)</span><span class="k">*</span>
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
</code></pre>
<p>The <code class="prettyprint">=&gt;</code> operator has the same precedence as assignment (<code class="prettyprint">=</code>) and is right-associative.</p>

<p>An anonymous function with the <code class="prettyprint">async</code> modifier is an async function and follows the rules described in <a href="classes.md#iterators">Iterators</a>.</p>

<p>The parameters of an anonymous function in the form of a <em>lambda_expression</em> can be explicitly or implicitly typed. In an explicitly typed parameter list, the type of each parameter is explicitly stated. In an implicitly typed parameter list, the types of the parameters are inferred from the context in which the anonymous function occursâ€”specifically, when the anonymous function is converted to a compatible delegate type or expression tree type, that type provides the parameter types (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</p>

<p>In an anonymous function with a single, implicitly typed parameter, the parentheses may be omitted from the parameter list. In other words, an anonymous function of the form
<code class="prettyprint">csharp
( param ) =&gt; expr
</code>
can be abbreviated to
<code class="prettyprint">csharp
param =&gt; expr
</code></p>

<p>The parameter list of an anonymous function in the form of an <em>anonymous_method_expression</em> is optional. If given, the parameters must be explicitly typed. If not, the anonymous function is convertible to a delegate with any parameter list not containing <code class="prettyprint">out</code> parameters.</p>

<p>A <em>block</em> body of an anonymous function is reachable (<a href="statements.md#end-points-and-reachability">End points and reachability</a>) unless the anonymous function occurs inside an unreachable statement.</p>

<p>Some examples of anonymous functions follow below:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span>                              <span class="c1">// Implicitly typed, expression body</span>
<span class="n">x</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>                  <span class="c1">// Implicitly typed, statement body</span>
<span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span>                        <span class="c1">// Explicitly typed, expression body</span>
<span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>            <span class="c1">// Explicitly typed, statement body</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">y</span>                         <span class="c1">// Multiple parameters</span>
<span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">()</span>               <span class="c1">// No parameters</span>
<span class="k">async</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="n">t1</span> <span class="p">+</span> <span class="k">await</span> <span class="n">t2</span>    <span class="c1">// Async</span>
<span class="k">delegate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>      <span class="c1">// Anonymous method expression</span>
<span class="k">delegate</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">// Parameter list omitted</span>
</code></pre>
<p>The behavior of *lambda_expression*s and *anonymous_method_expression*s is the same except for the following points:</p>

<ul>
<li> *anonymous_method_expression*s permit the parameter list to be omitted entirely, yielding convertibility to delegate types of any list of value parameters.</li>
<li> *lambda_expression*s permit parameter types to be omitted and inferred whereas *anonymous_method_expression*s require parameter types to be explicitly stated.</li>
<li> The body of a <em>lambda_expression</em> can be an expression or a statement block whereas the body of an <em>anonymous_method_expression</em> must be a statement block.</li>
<li> Only *lambda_expression*s have conversions to compatible expression tree types (<a href="types.md#expression-tree-types">Expression tree types</a>).</li>
</ul>

<h3 id="anonymous-function-signatures">Anonymous function signatures</h3>

<p>The optional <em>anonymous_function_signature</em> of an anonymous function defines the names and optionally the types of the formal parameters for the anonymous function. The scope of the parameters of the anonymous function is the <em>anonymous_function_body</em>. (<a href="basic-concepts.md#scopes">Scopes</a>) Together with the parameter list (if given) the anonymous-method-body constitutes a declaration space (<a href="basic-concepts.md#declarations">Declarations</a>). It is thus a compile-time error for the name of a parameter of the anonymous function to match the name of a local variable, local constant or parameter whose scope includes the <em>anonymous_method_expression</em> or <em>lambda_expression</em>.</p>

<p>If an anonymous function has an <em>explicit_anonymous_function_signature</em>, then the set of compatible delegate types and expression tree types is restricted to those that have the same parameter types and modifiers in the same order. In contrast to method group conversions (<a href="conversions.md#method-group-conversions">Method group conversions</a>), contra-variance of anonymous function parameter types is not supported. If an anonymous function does not have an <em>anonymous_function_signature</em>, then the set of compatible delegate types and expression tree types is restricted to those that have no <code class="prettyprint">out</code> parameters.</p>

<p>Note that an <em>anonymous_function_signature</em> cannot include attributes or a parameter array. Nevertheless, an <em>anonymous_function_signature</em> may be compatible with a delegate type whose parameter list contains a parameter array.</p>

<p>Note also that conversion to an expression tree type, even if compatible, may still fail at compile-time (<a href="types.md#expression-tree-types">Expression tree types</a>).</p>

<h3 id="anonymous-function-bodies">Anonymous function bodies</h3>

<p>The body (<em>expression</em> or <em>block</em>) of an anonymous function is subject to the following rules:</p>

<ul>
<li> If the anonymous function includes a signature, the parameters specified in the signature are available in the body. If the anonymous function has no signature it can be converted to a delegate type or expression type having parameters (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>), but the parameters cannot be accessed in the body.</li>
<li> Except for <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters specified in the signature (if any) of the nearest enclosing anonymous function, it is a compile-time error for the body to access a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</li>
<li> When the type of <code class="prettyprint">this</code> is a struct type, it is a compile-time error for the body to access <code class="prettyprint">this</code>. This is true whether the access is explicit (as in <code class="prettyprint">this.x</code>) or implicit (as in <code class="prettyprint">x</code> where <code class="prettyprint">x</code> is an instance member of the struct). This rule simply prohibits such access and does not affect whether member lookup results in a member of the struct.</li>
<li> The body has access to the outer variables (<a href="expressions.md#outer-variables">Outer variables</a>) of the anonymous function. Access of an outer variable will reference the instance of the variable that is active at the time the <em>lambda_expression</em> or <em>anonymous_method_expression</em> is evaluated (<a href="expressions.md#evaluation-of-anonymous-function-expressions">Evaluation of anonymous function expressions</a>).</li>
<li> It is a compile-time error for the body to contain a <code class="prettyprint">goto</code> statement, <code class="prettyprint">break</code> statement, or <code class="prettyprint">continue</code> statement whose target is outside the body or within the body of a contained anonymous function.</li>
<li> A <code class="prettyprint">return</code> statement in the body returns control from an invocation of the nearest enclosing anonymous function, not from the enclosing function member. An expression specified in a <code class="prettyprint">return</code> statement must be implicitly convertible to the return type of the delegate type or expression tree type to which the nearest enclosing <em>lambda_expression</em> or <em>anonymous_method_expression</em> is converted (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</li>
</ul>

<p>It is explicitly unspecified whether there is any way to execute the block of an anonymous function other than through evaluation and invocation of the <em>lambda_expression</em> or <em>anonymous_method_expression</em>. In particular, the compiler may choose to implement an anonymous function by synthesizing one or more named methods or types. The names of any such synthesized elements must be of a form reserved for compiler use.</p>

<h3 id="overload-resolution-and-anonymous-functions">Overload resolution and anonymous functions</h3>

<p>Anonymous functions in an argument list participate in type inference and overload resolution. Please refer to <a href="expressions.md#type-inference">Type inference</a> and <a href="expressions.md#overload-resolution">Overload resolution</a> for the exact rules.</p>

<p>The following example illustrates the effect of anonymous functions on overload resolution.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">ItemList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Sum</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">item</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="n">sum</span> <span class="p">+=</span> <span class="nf">selector</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">double</span> <span class="nf">Sum</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">item</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="n">sum</span> <span class="p">+=</span> <span class="nf">selector</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">ItemList&lt;T&gt;</code> class has two <code class="prettyprint">Sum</code> methods. Each takes a <code class="prettyprint">selector</code> argument, which extracts the value to sum over from a list item. The extracted value can be either an <code class="prettyprint">int</code> or a <code class="prettyprint">double</code> and the resulting sum is likewise either an <code class="prettyprint">int</code> or a <code class="prettyprint">double</code>.</p>

<p>The <code class="prettyprint">Sum</code> methods could for example be used to compute sums from a list of detail lines in an order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Detail</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">UnitCount</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">UnitPrice</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">ComputeSums</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ItemList</span><span class="p">&lt;</span><span class="n">Detail</span><span class="p">&gt;</span> <span class="n">orderDetails</span> <span class="p">=</span> <span class="nf">GetOrderDetails</span><span class="p">(...);</span>
    <span class="kt">int</span> <span class="n">totalUnits</span> <span class="p">=</span> <span class="n">orderDetails</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitCount</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">orderTotal</span> <span class="p">=</span> <span class="n">orderDetails</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitPrice</span> <span class="p">*</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitCount</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>In the first invocation of <code class="prettyprint">orderDetails.Sum</code>, both <code class="prettyprint">Sum</code> methods are applicable because the anonymous function <code class="prettyprint">d =&gt; d. UnitCount</code> is compatible with both <code class="prettyprint">Func&lt;Detail,int&gt;</code> and <code class="prettyprint">Func&lt;Detail,double&gt;</code>. However, overload resolution picks the first <code class="prettyprint">Sum</code> method because the conversion to <code class="prettyprint">Func&lt;Detail,int&gt;</code> is better than the conversion to <code class="prettyprint">Func&lt;Detail,double&gt;</code>.</p>

<p>In the second invocation of <code class="prettyprint">orderDetails.Sum</code>, only the second <code class="prettyprint">Sum</code> method is applicable because the anonymous function <code class="prettyprint">d =&gt; d.UnitPrice * d.UnitCount</code> produces a value of type <code class="prettyprint">double</code>. Thus, overload resolution picks the second <code class="prettyprint">Sum</code> method for that invocation.</p>

<h3 id="anonymous-functions-and-dynamic-binding">Anonymous functions and dynamic binding</h3>

<p>An anonymous function cannot be a receiver, argument or operand of a dynamically bound operation.</p>

<h3 id="outer-variables">Outer variables</h3>

<p>Any local variable, value parameter, or parameter array whose scope includes the <em>lambda_expression</em> or <em>anonymous_method_expression</em> is called an <strong><em>outer variable</em></strong> of the anonymous function. In an instance function member of a class, the <code class="prettyprint">this</code> value is considered a value parameter and is an outer variable of any anonymous function contained within the function member.</p>

<h4 id="captured-outer-variables">Captured outer variables</h4>

<p>When an outer variable is referenced by an anonymous function, the outer variable is said to have been <strong><em>captured</em></strong> by the anonymous function. Ordinarily, the lifetime of a local variable is limited to execution of the block or statement with which it is associated (<a href="variables.md#local-variables">Local variables</a>). However, the lifetime of a captured outer variable is extended at least until the delegate or expression tree created from the anonymous function becomes eligible for garbage collection.</p>

<p>In the example
&ldquo;`csharp
using System;</p>

<p>delegate int D();</p>

<p>class Test
{
    static D F() {
        int x = 0;
        D result = () =&gt; ++x;
        return result;
    }</p>

<p>static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
<code class="prettyprint">
the local variable `x` is captured by the anonymous function, and the lifetime of `x` is extended at least until the delegate returned from `F` becomes eligible for garbage collection (which doesn&#39;t happen until the very end of the program). Since each invocation of the anonymous function operates on the same instance of `x`, the output of the example is:
</code>bash
1
2
3
&rdquo;`</p>

<p>When a local variable or a value parameter is captured by an anonymous function, the local variable or parameter is no longer considered to be a fixed variable (<a href="unsafe-code.md#fixed-and-moveable-variables">Fixed and moveable variables</a>), but is instead considered to be a moveable variable. Thus any <code class="prettyprint">unsafe</code> code that takes the address of a captured outer variable must first use the <code class="prettyprint">fixed</code> statement to fix the variable.</p>

<p>Note that unlike an uncaptured variable, a captured local variable can be simultaneously exposed to multiple threads of execution.</p>

<h4 id="instantiation-of-local-variables">Instantiation of local variables</h4>

<p>A local variable is considered to be <strong><em>instantiated</em></strong> when execution enters the scope of the variable. For example, when the following method is invoked, the local variable <code class="prettyprint">x</code> is instantiated and initialized three timesâ€”once for each iteration of the loop.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="n">i</span> <span class="p">*</span> <span class="m">2</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>However, moving the declaration of <code class="prettyprint">x</code> outside the loop results in a single instantiation of <code class="prettyprint">x</code>:
<code class="prettyprint">csharp
static void F() {
    int x;
    for (int i = 0; i &lt; 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
</code></p>

<p>When not captured, there is no way to observe exactly how often a local variable is instantiatedâ€”because the lifetimes of the instantiations are disjoint, it is possible for each instantation to simply use the same storage location. However, when an anonymous function captures a local variable, the effects of instantiation become apparent.</p>

<p>The example
&ldquo;`csharp
using System;</p>

<p>delegate void D();</p>

<p>class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i &lt; 3; i++) {
            int x = i * 2 + 1;
            result[i] = () =&gt; { Console.WriteLine(x); };
        }
        return result;
    }</p>

<p>static void Main() {
        foreach (D d in F()) d();
    }
}
<code class="prettyprint">
produces the output:
</code>bash
1
3
5
&rdquo;`</p>

<p>However, when the declaration of <code class="prettyprint">x</code> is moved outside the loop:
<code class="prettyprint">csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i &lt; 3; i++) {
        x = i * 2 + 1;
        result[i] = () =&gt; { Console.WriteLine(x); };
    }
    return result;
}
</code>
the output is:
<code class="prettyprint">bash
5
5
5
</code></p>

<p>If a for-loop declares an iteration variable, that variable itself is considered to be declared outside of the loop. Thus, if the example is changed to capture the iteration variable itself:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="n">D</span><span class="p">[]</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D</span><span class="p">[]</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>only one instance of the iteration variable is captured, which produces the output:
<code class="prettyprint">bash
3
3
3
</code></p>

<p>It is possible for anonymous function delegates to share some captured variables yet have separate instances of others. For example, if <code class="prettyprint">F</code> is changed to
<code class="prettyprint">csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i &lt; 3; i++) {
        int y = 0;
        result[i] = () =&gt; { Console.WriteLine(&quot;{0} {1}&quot;, ++x, ++y); };
    }
    return result;
}
</code>
the three delegates capture the same instance of <code class="prettyprint">x</code> but separate instances of <code class="prettyprint">y</code>, and the output is:
<code class="prettyprint">bash
1 1
2 1
3 1
</code></p>

<p>Separate anonymous functions can capture the same instance of an outer variable. In the example:
&ldquo;`csharp
using System;</p>

<p>delegate void Setter(int value);</p>

<p>delegate int Getter();</p>

<p>class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) =&gt; { x = value; };
        Getter g = () =&gt; { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
<code class="prettyprint">
the two anonymous functions capture the same instance of the local variable `x`, and they can thus &quot;communicate&quot; through that variable. The output of the example is:
</code>bash
5
10
&rdquo;`</p>

<h3 id="evaluation-of-anonymous-function-expressions">Evaluation of anonymous function expressions</h3>

<p>An anonymous function <code class="prettyprint">F</code> must always be converted to a delegate type <code class="prettyprint">D</code> or an expression tree type <code class="prettyprint">E</code>, either directly or through the execution of a delegate creation expression <code class="prettyprint">new D(F)</code>. This conversion determines the result of the anonymous function, as described in <a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>.</p>

<h2 id="query-expressions">Query expressions</h2>

<p><strong><em>Query expressions</em></strong> provide a language integrated syntax for queries that is similar to relational and hierarchical query languages such as SQL and XQuery.</p>
<pre class="highlight shell"><code>query_expression
    : from_clause query_body
    ;

from_clause
    : <span class="s1">'from'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : <span class="s1">'let'</span> identifier <span class="s1">'='</span> expression
    ;

where_clause
    : <span class="s1">'where'</span> boolean_expression
    ;

join_clause
    : <span class="s1">'join'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression <span class="s1">'on'</span> expression <span class="s1">'equals'</span> expression
    ;

join_into_clause
    : <span class="s1">'join'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression <span class="s1">'on'</span> expression <span class="s1">'equals'</span> expression <span class="s1">'into'</span> identifier
    ;

orderby_clause
    : <span class="s1">'orderby'</span> orderings
    ;

orderings
    : ordering <span class="o">(</span><span class="s1">','</span> ordering<span class="o">)</span><span class="k">*</span>
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : <span class="s1">'ascending'</span>
    | <span class="s1">'descending'</span>
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : <span class="s1">'select'</span> expression
    ;

group_clause
    : <span class="s1">'group'</span> expression <span class="s1">'by'</span> expression
    ;

query_continuation
    : <span class="s1">'into'</span> identifier query_body
    ;
</code></pre>
<p>A query expression begins with a <code class="prettyprint">from</code> clause and ends with either a <code class="prettyprint">select</code> or <code class="prettyprint">group</code> clause. The initial <code class="prettyprint">from</code> clause can be followed by zero or more <code class="prettyprint">from</code>, <code class="prettyprint">let</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code> or <code class="prettyprint">orderby</code> clauses. Each <code class="prettyprint">from</code> clause is a generator introducing a <strong><em>range variable</em></strong> which ranges over the elements of a <strong><em>sequence</em></strong>. Each <code class="prettyprint">let</code> clause introduces a range variable representing a value computed by means of previous range variables. Each <code class="prettyprint">where</code> clause is a filter that excludes items from the result. Each <code class="prettyprint">join</code> clause compares specified keys of the source sequence with keys of another sequence, yielding matching pairs. Each <code class="prettyprint">orderby</code> clause reorders items according to specified criteria.The final <code class="prettyprint">select</code> or <code class="prettyprint">group</code> clause specifies the shape of the result in terms of the range variables. Finally, an <code class="prettyprint">into</code> clause can be used to &ldquo;splice&rdquo; queries by treating the results of one query as a generator in a subsequent query.</p>

<h3 id="ambiguities-in-query-expressions">Ambiguities in query expressions</h3>

<p>Query expressions contain a number of &ldquo;contextual keywords&rdquo;, i.e., identifiers that have special meaning in a given context. Specifically these are <code class="prettyprint">from</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code>, <code class="prettyprint">on</code>, <code class="prettyprint">equals</code>, <code class="prettyprint">into</code>, <code class="prettyprint">let</code>, <code class="prettyprint">orderby</code>, <code class="prettyprint">ascending</code>, <code class="prettyprint">descending</code>, <code class="prettyprint">select</code>, <code class="prettyprint">group</code> and <code class="prettyprint">by</code>. In order to avoid ambiguities in query expressions caused by mixed use of these identifiers as keywords or simple names, these identifiers are considered keywords when occurring anywhere within a query expression.</p>

<p>For this purpose, a query expression is any expression that starts with &ldquo;<code class="prettyprint">from dentifier</code>&rdquo; followed by any token except &ldquo;<code class="prettyprint">;</code>&rdquo;, &ldquo;<code class="prettyprint">=</code>&rdquo; or &ldquo;<code class="prettyprint">,</code>&rdquo;.</p>

<p>In order to use these words as identifiers within a query expression, they can be prefixed with &ldquo;<code class="prettyprint">@</code>&rdquo; (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<h3 id="query-expression-translation">Query expression translation</h3>

<p>The C# language does not specify the execution semantics of query expressions. Rather, query expressions are translated into invocations of methods that adhere to the <em>query expression pattern</em> (<a href="expressions.md#the-query-expression-pattern">The query expression pattern</a>). Specifically, query expressions are translated into invocations of methods named <code class="prettyprint">Where</code>, <code class="prettyprint">Select</code>, <code class="prettyprint">SelectMany</code>, <code class="prettyprint">Join</code>, <code class="prettyprint">GroupJoin</code>, <code class="prettyprint">OrderBy</code>, <code class="prettyprint">OrderByDescending</code>, <code class="prettyprint">ThenBy</code>, <code class="prettyprint">ThenByDescending</code>, <code class="prettyprint">GroupBy</code>, and <code class="prettyprint">Cast</code>.These methods are expected to have particular signatures and result types, as described in <a href="expressions.md#the-query-expression-pattern">The query expression pattern</a>. These methods can be instance methods of the object being queried or extension methods that are external to the object, and they implement the actual execution of the query.</p>

<p>The translation from query expressions to method invocations is a syntactic mapping that occurs before any type binding or overload resolution has been performed. The translation is guaranteed to be syntactically correct, but it is not guaranteed to produce semantically correct C# code. Following translation of query expressions, the resulting method invocations are processed as regular method invocations, and this may in turn uncover errors, for example if the methods do not exist, if arguments have wrong types, or if the methods are generic and type inference fails.</p>

<p>A query expression is processed by repeatedly applying the following translations until no further reductions are possible. The translations are listed in order of application: each section assumes that the translations in the preceding sections have been performed exhaustively, and once exhausted, a section will not later be revisited in the processing of the same query expression.</p>

<p>Assignment to range variables is not allowed in query expressions. However a C# implementation is permitted to not always enforce this restriction, since this may sometimes not be possible with the syntactic translation scheme presented here.</p>

<p>Certain translations inject range variables with transparent identifiers denoted by <code class="prettyprint">*</code>. The special properties of transparent identifiers are discussed further in <a href="expressions.md#transparent-identifiers">Transparent identifiers</a>.</p>

<h4 id="select-and-groupby-clauses-with-continuations">Select and groupby clauses with continuations</h4>

<p>A query expression with a continuation
<code class="prettyprint">csharp
from ... into x ...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( from ... ) ...
</code></p>

<p>The translations in the following sections assume that queries have no <code class="prettyprint">into</code> continuations.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
</code>
is translated into
<code class="prettyprint">csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
GroupBy(c =&gt; c.Country).
Select(g =&gt; new { Country = g.Key, CustCount = g.Count() })
</code></p>

<h4 id="explicit-range-variable-types">Explicit range variable types</h4>

<p>A <code class="prettyprint">from</code> clause that explicitly specifies a range variable type
<code class="prettyprint">csharp
from T x in e
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . Cast &lt; T &gt; ( )
</code></p>

<p>A <code class="prettyprint">join</code> clause that explicitly specifies a range variable type
<code class="prettyprint">bash
join T x in e on k1 equals k2
</code>
is translated into
<code class="prettyprint">bash
join x in ( e ) . Cast &lt; T &gt; ( ) on k1 equals k2
</code></p>

<p>The translations in the following sections assume that queries have no explicit range variable types.</p>

<p>The example
<code class="prettyprint">csharp
from Customer c in customers
where c.City == &quot;London&quot;
select c
</code>
is translated into
<code class="prettyprint">csharp
from c in customers.Cast&lt;Customer&gt;()
where c.City == &quot;London&quot;
select c
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
Cast&lt;Customer&gt;().
Where(c =&gt; c.City == &quot;London&quot;)
</code></p>

<p>Explicit range variable types are useful for querying collections that implement the non-generic <code class="prettyprint">IEnumerable</code> interface, but not the generic <code class="prettyprint">IEnumerable&lt;T&gt;</code> interface. In the example above, this would be the case if <code class="prettyprint">customers</code> were of type <code class="prettyprint">ArrayList</code>.</p>

<h4 id="degenerate-query-expressions">Degenerate query expressions</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e select x
</code>
is translated into
<code class="prettyprint">csharp
( e ) . Select ( x =&gt; x )
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
select c
</code>
is translated into
<code class="prettyprint">csharp
customers.Select(c =&gt; c)
</code></p>

<p>A degenerate query expression is one that trivially selects the elements of the source. A later phase of the translation removes degenerate queries introduced by other translation steps by replacing them with their source. It is important however to ensure that the result of a query expression is never the source object itself, as that would reveal the type and identity of the source to the client of the query. Therefore this step protects degenerate queries written directly in source code by explicitly calling <code class="prettyprint">Select</code> on the source. It is then up to the implementers of <code class="prettyprint">Select</code> and other query operators to ensure that these methods never return the source object itself.</p>

<h4 id="from-let-where-join-and-orderby-clauses">From, let, where, join and orderby clauses</h4>

<p>A query expression with a second <code class="prettyprint">from</code> clause followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
from x2 in e2
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . SelectMany( x1 =&gt; e2 , ( x1 , x2 ) =&gt; v )
</code></p>

<p>A query expression with a second <code class="prettyprint">from</code> clause followed by something other than a <code class="prettyprint">select</code> clause:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">from</span> <span class="n">x1</span> <span class="k">in</span> <span class="n">e1</span>
<span class="k">from</span> <span class="n">x2</span> <span class="k">in</span> <span class="n">e2</span>
<span class="p">...</span>
</code></pre>
<p>is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . SelectMany( x1 =&gt; e2 , ( x1 , x2 ) =&gt; new { x1 , x2 } )
...
</code></p>

<p>A query expression with a <code class="prettyprint">let</code> clause
<code class="prettyprint">csharp
from x in e
let y = f
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e ) . Select ( x =&gt; new { x , y = f } )
...
</code></p>

<p>A query expression with a <code class="prettyprint">where</code> clause
<code class="prettyprint">csharp
from x in e
where f
...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . Where ( x =&gt; f )
...
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause without an <code class="prettyprint">into</code> followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . Join( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , x2 ) =&gt; v )
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause without an <code class="prettyprint">into</code> followed by something other than a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . Join( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , x2 ) =&gt; new { x1 , x2 })
...
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause with an <code class="prettyprint">into</code> followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . GroupJoin( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , g ) =&gt; v )
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause with an <code class="prettyprint">into</code> followed by something other than a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . GroupJoin( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , g ) =&gt; new { x1 , g })
...
</code></p>

<p>A query expression with an <code class="prettyprint">orderby</code> clause
<code class="prettyprint">csharp
from x in e
orderby k1 , k2 , ..., kn
...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . 
OrderBy ( x =&gt; k1 ) . 
ThenBy ( x =&gt; k2 ) .
... .
ThenBy ( x =&gt; kn )
...
</code></p>

<p>If an ordering clause specifies a <code class="prettyprint">descending</code> direction indicator, an invocation of <code class="prettyprint">OrderByDescending</code> or <code class="prettyprint">ThenByDescending</code> is produced instead.</p>

<p>The following translations assume that there are no <code class="prettyprint">let</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code> or <code class="prettyprint">orderby</code> clauses, and no more than the one initial <code class="prettyprint">from</code> clause in each query expression.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders,
     (c,o) =&gt; new { c.Name, o.OrderID, o.Total }
)
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(x =&gt; x.o.Total).
Select(x =&gt; new { x.c.Name, x.o.OrderID, x.o.Total })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from o in orders
let t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity)
where t &gt;= 1000
select new { o.OrderID, Total = t }
</code>
is translated into
<code class="prettyprint">csharp
from * in orders.
    Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) })
where t &gt;= 1000 
select new { o.OrderID, Total = t }
</code>
the final translation of which is
<code class="prettyprint">csharp
orders.
Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) }).
Where(x =&gt; x.t &gt;= 1000).
Select(x =&gt; new { x.o.OrderID, Total = x.t })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
customers.Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, o) =&gt; new { c.Name, o.OrderDate, o.Total })
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n &gt;= 10
select new { c.Name, OrderCount = n }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    GroupJoin(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
        (c, co) =&gt; new { c, co })
let n = co.Count()
where n &gt;= 10 
select new { c.Name, OrderCount = n }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
GroupJoin(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, co) =&gt; new { c, co }).
Select(x =&gt; new { x, n = x.co.Count() }).
Where(y =&gt; y.n &gt;= 10).
Select(y =&gt; new { y.x.c.Name, OrderCount = y.n)
</code>
where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are compiler generated identifiers that are otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
</code>
has the final translation
<code class="prettyprint">csharp
orders.
OrderBy(o =&gt; o.Customer.Name).
ThenByDescending(o =&gt; o.Total)
</code></p>

<h4 id="select-clauses">Select clauses</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e select v
</code>
is translated into
<code class="prettyprint">csharp
( e ) . Select ( x =&gt; v )
</code>
except when v is the identifier x, the translation is simply
<code class="prettyprint">csharp
( e )
</code></p>

<p>For example
<code class="prettyprint">csharp
from c in customers.Where(c =&gt; c.City == &quot;London&quot;)
select c
</code>
is simply translated into
<code class="prettyprint">csharp
customers.Where(c =&gt; c.City == &quot;London&quot;)
</code></p>

<h4 id="groupby-clauses">Groupby clauses</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e group v by k
</code>
is translated into
<code class="prettyprint">csharp
( e ) . GroupBy ( x =&gt; k , x =&gt; v )
</code>
except when v is the identifier x, the translation is
<code class="prettyprint">csharp
( e ) . GroupBy ( x =&gt; k )
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
group c.Name by c.Country
</code>
is translated into
<code class="prettyprint">csharp
customers.
GroupBy(c =&gt; c.Country, c =&gt; c.Name)
</code></p>

<h4 id="transparent-identifiers">Transparent identifiers</h4>

<p>Certain translations inject range variables with <strong><em>transparent identifiers</em></strong> denoted by <code class="prettyprint">*</code>. Transparent identifiers are not a proper language feature; they exist only as an intermediate step in the query expression translation process.</p>

<p>When a query translation injects a transparent identifier, further translation steps propagate the transparent identifier into anonymous functions and anonymous object initializers. In those contexts, transparent identifiers have the following behavior:</p>

<ul>
<li> When a transparent identifier occurs as a parameter in an anonymous function, the members of the associated anonymous type are automatically in scope in the body of the anonymous function.</li>
<li> When a member with a transparent identifier is in scope, the members of that member are in scope as well.</li>
<li> When a transparent identifier occurs as a member declarator in an anonymous object initializer, it introduces a member with a transparent identifier.</li>
<li> In the translation steps described above, transparent identifiers are always introduced together with anonymous types, with the intent of capturing multiple range variables as members of a single object. An implementation of C# is permitted to use a different mechanism than anonymous types to group together multiple range variables. The following translation examples assume that anonymous types are used, and show how transparent identifiers can be translated away.</li>
</ul>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
</code></p>

<p>which is further translated into
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(* =&gt; o.Total).
Select(* =&gt; new { c.Name, o.Total })
</code>
which, when transparent identifiers are erased, is equivalent to
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(x =&gt; x.o.Total).
Select(x =&gt; new { x.c.Name, x.o.Total })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID, 
        (c, o) =&gt; new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
</code>
which is further reduced to
<code class="prettyprint">csharp
customers.
Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID, (c, o) =&gt; new { c, o }).
Join(details, * =&gt; o.OrderID, d =&gt; d.OrderID, (*, d) =&gt; new { *, d }).
Join(products, * =&gt; d.ProductID, p =&gt; p.ProductID, (*, p) =&gt; new { *, p }).
Select(* =&gt; new { c.Name, o.OrderDate, p.ProductName })
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, o) =&gt; new { c, o }).
Join(details, x =&gt; x.o.OrderID, d =&gt; d.OrderID,
    (x, d) =&gt; new { x, d }).
Join(products, y =&gt; y.d.ProductID, p =&gt; p.ProductID,
    (y, p) =&gt; new { y, p }).
Select(z =&gt; new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
</code>
where <code class="prettyprint">x</code>, <code class="prettyprint">y</code>, and <code class="prettyprint">z</code> are compiler generated identifiers that are otherwise invisible and inaccessible.</p>

<h3 id="the-query-expression-pattern">The query expression pattern</h3>

<p>The <strong><em>Query expression pattern</em></strong> establishes a pattern of methods that types can implement to support query expressions. Because query expressions are translated to method invocations by means of a syntactic mapping, types have considerable flexibility in how they implement the query expression pattern. For example, the methods of the pattern can be implemented as instance methods or as extension methods because the two have the same invocation syntax, and the methods can request delegates or expression trees because anonymous functions are convertible to both.</p>

<p>The recommended shape of a generic type <code class="prettyprint">C&lt;T&gt;</code> that supports the query expression pattern is shown below. A generic type is used in order to illustrate the proper relationships between parameter and result types, but it is possible to implement the pattern for non-generic types as well.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="n">R</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">arg1</span><span class="p">);</span>

<span class="k">delegate</span> <span class="n">R</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">arg2</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Cast</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">Where</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">predicate</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">Select</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">SelectMany</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;&gt;</span> <span class="n">selector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">Join</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">inner</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">outerKeySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">innerKeySelector</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">GroupJoin</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">inner</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">outerKeySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">innerKeySelector</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">OrderBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">OrderByDescending</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">GroupBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;&gt;</span> <span class="n">GroupBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;</span> <span class="n">elementSelector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ThenBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ThenByDescending</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">K</span> <span class="n">Key</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The methods above use the generic delegate types <code class="prettyprint">Func&lt;T1,R&gt;</code> and <code class="prettyprint">Func&lt;T1,T2,R&gt;</code>, but they could equally well have used other delegate or expression tree types with the same relationships in parameter and result types.</p>

<p>Notice the recommended relationship between <code class="prettyprint">C&lt;T&gt;</code> and <code class="prettyprint">O&lt;T&gt;</code> which ensures that the <code class="prettyprint">ThenBy</code> and <code class="prettyprint">ThenByDescending</code> methods are available only on the result of an <code class="prettyprint">OrderBy</code> or <code class="prettyprint">OrderByDescending</code>. Also notice the recommended shape of the result of <code class="prettyprint">GroupBy</code> &ndash; a sequence of sequences, where each inner sequence has an additional <code class="prettyprint">Key</code> property.</p>

<p>The <code class="prettyprint">System.Linq</code> namespace provides an implementation of the query operator pattern for any type that implements the <code class="prettyprint">System.Collections.Generic.IEnumerable&lt;T&gt;</code> interface.</p>

<h2 id="assignment-operators">Assignment operators</h2>

<p>The assignment operators assign a new value to a variable, a property, an event, or an indexer element.</p>
<pre class="highlight shell"><code>assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : <span class="s1">'='</span>
    | <span class="s1">'+='</span>
    | <span class="s1">'-='</span>
    | <span class="s1">'*='</span>
    | <span class="s1">'/='</span>
    | <span class="s1">'%='</span>
    | <span class="s1">'&amp;='</span>
    | <span class="s1">'|='</span>
    | <span class="s1">'^='</span>
    | <span class="s1">'&lt;&lt;='</span>
    | right_shift_assignment
    ;
</code></pre>
<p>The left operand of an assignment must be an expression classified as a variable, a property access, an indexer access, or an event access.</p>

<p>The <code class="prettyprint">=</code> operator is called the <strong><em>simple assignment operator</em></strong>. It assigns the value of the right operand to the variable, property, or indexer element given by the left operand. The left operand of the simple assignment operator may not be an event access (except as described in <a href="classes.md#field-like-events">Field-like events</a>). The simple assignment operator is described in <a href="expressions.md#simple-assignment">Simple assignment</a>.</p>

<p>The assignment operators other than the <code class="prettyprint">=</code> operator are called the <strong><em>compound assignment operators</em></strong>. These operators perform the indicated operation on the two operands, and then assign the resulting value to the variable, property, or indexer element given by the left operand. The compound assignment operators are described in <a href="expressions.md#compound-assignment">Compound assignment</a>.</p>

<p>The <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators with an event access expression as the left operand are called the <em>event assignment operators</em>. No other assignment operator is valid with an event access as the left operand. The event assignment operators are described in <a href="expressions.md#event-assignment">Event assignment</a>.</p>

<p>The assignment operators are right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a = b = c</code> is evaluated as <code class="prettyprint">a = (b = c)</code>.</p>

<h3 id="simple-assignment">Simple assignment</h3>

<p>The <code class="prettyprint">=</code> operator is called the simple assignment operator.</p>

<p>If the left operand of a simple assignment is of the form <code class="prettyprint">E.P</code> or <code class="prettyprint">E[Ei]</code> where <code class="prettyprint">E</code> has the compile-time type <code class="prettyprint">dynamic</code>, then the assignment is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the assignment expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time based on the run-time type of <code class="prettyprint">E</code>.</p>

<p>In a simple assignment, the right operand must be an expression that is implicitly convertible to the type of the left operand. The operation assigns the value of the right operand to the variable, property, or indexer element given by the left operand.</p>

<p>The result of a simple assignment expression is the value assigned to the left operand. The result has the same type as the left operand and is always classified as a value.</p>

<p>If the left operand is a property or indexer access, the property or indexer must have a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>The run-time processing of a simple assignment of the form <code class="prettyprint">x = y</code> consists of the following steps:</p>

<ul>
<li> If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li><code class="prettyprint">y</code> is evaluated and, if required, converted to the type of <code class="prettyprint">x</code> through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li>If the variable given by <code class="prettyprint">x</code> is an array element of a <em>reference_type</em>, a run-time check is performed to ensure that the value computed for <code class="prettyprint">y</code> is compatible with the array instance of which <code class="prettyprint">x</code> is an element. The check succeeds if <code class="prettyprint">y</code> is <code class="prettyprint">null</code>, or if an implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from the actual type of the instance referenced by <code class="prettyprint">y</code> to the actual element type of the array instance containing <code class="prettyprint">x</code>. Otherwise, a <code class="prettyprint">System.ArrayTypeMismatchException</code> is thrown.</li>
<li>The value resulting from the evaluation and conversion of <code class="prettyprint">y</code> is stored into the location given by the evaluation of <code class="prettyprint">x</code>.</li>
</ul></li>
<li> If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">set</code> accessor invocation.</li>
<li><code class="prettyprint">y</code> is evaluated and, if required, converted to the type of <code class="prettyprint">x</code> through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value computed for <code class="prettyprint">y</code> as its <code class="prettyprint">value</code> argument.</li>
</ul></li>
</ul>

<p>The array co-variance rules (<a href="arrays.md#array-covariance">Array covariance</a>) permit a value of an array type <code class="prettyprint">A[]</code> to be a reference to an instance of an array type <code class="prettyprint">B[]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>. Because of these rules, assignment to an array element of a <em>reference_type</em> requires a run-time check to ensure that the value being assigned is compatible with the array instance. In the example
&ldquo;`csharp
string[] sa = new string[10];
object[] oa = sa;</p>

<p>oa[0] = null;               // Ok
oa[1] = &quot;Hello&rdquo;;            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
&ldquo;<code class="prettyprint">
the last assignment causes a</code>System.ArrayTypeMismatchException<code class="prettyprint">to be thrown because an instance of</code>ArrayList<code class="prettyprint">cannot be stored in an element of a</code>string[]`.</p>

<p>When a property or indexer declared in a <em>struct_type</em> is the target of an assignment, the instance expression associated with the property or indexer access must be classified as a variable. If the instance expression is classified as a value, a binding-time error occurs. Because of <a href="expressions.md#member-access">Member access</a>, the same rule also applies to fields.</p>

<p>Given the declarations:
&rdquo;`csharp
struct Point
{
    int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }</p>

<p>public int X {
        get { return x; }
        set { x = value; }
    }</p>

<p>public int Y {
        get { return y; }
        set { y = value; }
    }
}</p>

<p>struct Rectangle
{
    Point a, b;</p>

<p>public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }</p>

<p>public Point A {
        get { return a; }
        set { a = value; }
    }</p>

<p>public Point B {
        get { return b; }
        set { b = value; }
    }
}
<code class="prettyprint">
in the example
</code>csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
<code class="prettyprint">
the assignments to `p.X`, `p.Y`, `r.A`, and `r.B` are permitted because `p` and `r` are variables. However, in the example
</code>csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
&ldquo;<code class="prettyprint">
the assignments are all invalid, since</code>r.A<code class="prettyprint">and</code>r.B` are not variables.</p>

<h3 id="compound-assignment">Compound assignment</h3>

<p>If the left operand of a compound assignment is of the form <code class="prettyprint">E.P</code> or <code class="prettyprint">E[Ei]</code> where <code class="prettyprint">E</code> has the compile-time type <code class="prettyprint">dynamic</code>, then the assignment is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the assignment expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time based on the run-time type of <code class="prettyprint">E</code>.</p>

<p>An operation of the form <code class="prettyprint">x op= y</code> is processed by applying binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) as if the operation was written <code class="prettyprint">x op y</code>. Then,</p>

<ul>
<li> If the return type of the selected operator is implicitly convertible to the type of <code class="prettyprint">x</code>, the operation is evaluated as <code class="prettyprint">x = x op y</code>, except that <code class="prettyprint">x</code> is evaluated only once.</li>
<li> Otherwise, if the selected operator is a predefined operator, if the return type of the selected operator is explicitly convertible to the type of <code class="prettyprint">x</code>, and if <code class="prettyprint">y</code> is implicitly convertible to the type of <code class="prettyprint">x</code> or the operator is a shift operator, then the operation is evaluated as <code class="prettyprint">x = (T)(x op y)</code>, where <code class="prettyprint">T</code> is the type of <code class="prettyprint">x</code>, except that <code class="prettyprint">x</code> is evaluated only once.</li>
<li> Otherwise, the compound assignment is invalid, and a binding-time error occurs.</li>
</ul>

<p>The term &quot;evaluated only once&rdquo; means that in the evaluation of <code class="prettyprint">x op y</code>, the results of any constituent expressions of <code class="prettyprint">x</code> are temporarily saved and then reused when performing the assignment to <code class="prettyprint">x</code>. For example, in the assignment <code class="prettyprint">A()[B()] += C()</code>, where <code class="prettyprint">A</code> is a method returning <code class="prettyprint">int[]</code>, and <code class="prettyprint">B</code> and <code class="prettyprint">C</code> are methods returning <code class="prettyprint">int</code>, the methods are invoked only once, in the order <code class="prettyprint">A</code>, <code class="prettyprint">B</code>, <code class="prettyprint">C</code>.</p>

<p>When the left operand of a compound assignment is a property access or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> accessor and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>The second rule above permits <code class="prettyprint">x op= y</code> to be evaluated as <code class="prettyprint">x = (T)(x op y)</code> in certain contexts. The rule exists such that the predefined operators can be used as compound operators when the left operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, or <code class="prettyprint">char</code>. Even when both arguments are of one of those types, the predefined operators produce a result of type <code class="prettyprint">int</code>, as described in <a href="expressions.md#binary-numeric-promotions">Binary numeric promotions</a>. Thus, without a cast it would not be possible to assign the result to the left operand.</p>

<p>The intuitive effect of the rule for predefined operators is simply that <code class="prettyprint">x op= y</code> is permitted if both of <code class="prettyprint">x op y</code> and <code class="prettyprint">x = y</code> are permitted. In the example
&ldquo;`csharp
byte b = 0;
char ch = &lsquo;\0&rsquo;;
int i = 0;</p>

<p>b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok</p>

<p>ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
&rdquo;`
the intuitive reason for each error is that a corresponding simple assignment would also have been an error.</p>

<p>This also means that compound assignment operations support lifted operations. In the example
<code class="prettyprint">csharp
int? i = 0;
i += 1;             // Ok
</code>
the lifted operator <code class="prettyprint">+(int?,int?)</code> is used.</p>

<h3 id="event-assignment">Event assignment</h3>

<p>If the left operand of a <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator is classified as an event access, then the expression is evaluated as follows:</p>

<ul>
<li> The instance expression, if any, of the event access is evaluated.</li>
<li> The right operand of the <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator is evaluated, and, if required, converted to the type of the left operand through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li> An event accessor of the event is invoked, with argument list consisting of the right operand, after evaluation and, if necessary, conversion. If the operator was <code class="prettyprint">+=</code>, the <code class="prettyprint">add</code> accessor is invoked; if the operator was <code class="prettyprint">-=</code>, the <code class="prettyprint">remove</code> accessor is invoked.</li>
</ul>

<p>An event assignment expression does not yield a value. Thus, an event assignment expression is valid only in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>).</p>

<h2 id="expression">Expression</h2>

<p>An <em>expression</em> is either a <em>non_assignment_expression</em> or an <em>assignment</em>.</p>
<pre class="highlight shell"><code>expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
</code></pre>
<h2 id="constant-expressions">Constant expressions</h2>

<p>A <em>constant_expression</em> is an expression that can be fully evaluated at compile-time.</p>
<pre class="highlight shell"><code>constant_expression
    : expression
    ;
</code></pre>
<p>A constant expression must be the <code class="prettyprint">null</code> literal or a value with one of  the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">object</code>, <code class="prettyprint">string</code>, or any enumeration type. Only the following constructs are permitted in constant expressions:</p>

<ul>
<li> Literals (including the <code class="prettyprint">null</code> literal).</li>
<li> References to <code class="prettyprint">const</code> members of class and struct types.</li>
<li> References to members of enumeration types.</li>
<li> References to <code class="prettyprint">const</code> parameters or local variables</li>
<li> Parenthesized sub-expressions, which are themselves constant expressions.</li>
<li> Cast expressions, provided the target type is one of the types listed above.</li>
<li> <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> expressions</li>
<li> Default value expressions</li>
<li> Nameof expressions</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, and <code class="prettyprint">~</code> unary operators.</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">||</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">&gt;=</code> binary operators, provided each operand is of a type listed above.</li>
<li> The <code class="prettyprint">?:</code> conditional operator.</li>
</ul>

<p>The following conversions are permitted in constant expressions:</p>

<ul>
<li> Identity conversions</li>
<li> Numeric conversions</li>
<li> Enumeration conversions</li>
<li> Constant expression conversions</li>
<li> Implicit and explicit reference conversions, provided that the source of the conversions is a constant expression that evaluates to the null value.</li>
</ul>

<p>Other conversions including boxing, unboxing and implicit reference conversions of non-null values are not permitted in constant expressions. For example:
<code class="prettyprint">csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = &quot;hello&quot;; // error: implicit reference conversion
}
</code>
the initialization of i is an error because a boxing conversion is required. The initialization of str is an error because an implicit reference conversion from a non-null value is required.</p>

<p>Whenever an expression fulfills the requirements listed above, the expression is evaluated at compile-time. This is true even if the expression is a sub-expression of a larger expression that contains non-constant constructs.</p>

<p>The compile-time evaluation of constant expressions uses the same rules as run-time evaluation of non-constant expressions, except that where run-time evaluation would have thrown an exception, compile-time evaluation causes a compile-time error to occur.</p>

<p>Unless a constant expression is explicitly placed in an <code class="prettyprint">unchecked</code> context, overflows that occur in integral-type arithmetic operations and conversions during the compile-time evaluation of the expression always cause compile-time errors (<a href="expressions.md#constant-expressions">Constant expressions</a>).</p>

<p>Constant expressions occur in the contexts listed below. In these contexts, a compile-time error occurs if an expression cannot be fully evaluated at compile-time.</p>

<ul>
<li> Constant declarations (<a href="classes.md#constants">Constants</a>).</li>
<li> Enumeration member declarations (<a href="enums.md#enum-members">Enum members</a>).</li>
<li> Default arguments of formal parameter lists (<a href="classes.md#method-parameters">Method parameters</a>)</li>
<li> <code class="prettyprint">case</code> labels of a <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>).</li>
<li> <code class="prettyprint">goto case</code> statements (<a href="statements.md#the-goto-statement">The goto statement</a>).</li>
<li> Dimension lengths in an array creation expression (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) that includes an initializer.</li>
<li> Attributes (<a href="attributes.md#attributes">Attributes</a>).</li>
</ul>

<p>An implicit constant expression conversion (<a href="conversions.md#implicit-constant-expression-conversions">Implicit constant expression conversions</a>) permits a constant expression of type <code class="prettyprint">int</code> to be converted to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code>, provided the value of the constant expression is within the range of the destination type.</p>

<h2 id="boolean-expressions">Boolean expressions</h2>

<p>A <em>boolean_expression</em> is an expression that yields a result of type <code class="prettyprint">bool</code>; either directly or through application of <code class="prettyprint">operator true</code> in certain contexts as specified in the following.</p>
<pre class="highlight shell"><code>boolean_expression
    : expression
    ;
</code></pre>
<p>The controlling conditional expression of an <em>if_statement</em> (<a href="statements.md#the-if-statement">The if statement</a>), <em>while_statement</em> (<a href="statements.md#the-while-statement">The while statement</a>), <em>do_statement</em> (<a href="statements.md#the-do-statement">The do statement</a>), or <em>for_statement</em> (<a href="statements.md#the-for-statement">The for statement</a>) is a <em>boolean_expression</em>. The controlling conditional expression of the <code class="prettyprint">?:</code> operator (<a href="expressions.md#conditional-operator">Conditional operator</a>) follows the same rules as a <em>boolean_expression</em>, but for reasons of operator precedence is classified as a <em>conditional_or_expression</em>.</p>

<p>A <em>boolean_expression</em> <code class="prettyprint">E</code> is required to be able to produce a value of type <code class="prettyprint">bool</code>, as follows:</p>

<ul>
<li> If <code class="prettyprint">E</code> is implicitly convertible to <code class="prettyprint">bool</code> then at runtime that implicit conversion is applied.</li>
<li> Otherwise, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is used to find a unique best implementation of operator <code class="prettyprint">true</code> on <code class="prettyprint">E</code>, and that implementation is applied at runtime.</li>
<li> If no such operator is found, a binding-time error occurs.</li>
</ul>

<p>The <code class="prettyprint">DBBool</code> struct type in <a href="structs.md#database-boolean-type">Database boolean type</a> provides an example of a type that implements <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>.</p>

          <h1 id="statements">Statements</h1>

<p>C# provides a variety of statements. Most of these statements will be familiar to developers who have programmed in C and C++.</p>
<pre class="highlight plaintext"><code>statement
    : labeled_statement
    | declaration_statement
    | embedded_statement
    ;

embedded_statement
    : block
    | empty_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | try_statement
    | checked_statement
    | unchecked_statement
    | lock_statement
    | using_statement
    | yield_statement
    | embedded_statement_unsafe
    ;
</code></pre>
<p>The <em>embedded_statement</em> nonterminal is used for statements that appear within other statements. The use of <em>embedded_statement</em> rather than <em>statement</em> excludes the use of declaration statements and labeled statements in these contexts. The example
<code class="prettyprint">csharp
void F(bool b) {
    if (b)
        int i = 44;
}
</code>
results in a compile-time error because an <code class="prettyprint">if</code> statement requires an <em>embedded_statement</em> rather than a <em>statement</em> for its if branch. If this code were permitted, then the variable <code class="prettyprint">i</code> would be declared, but it could never be used. Note, however, that by placing <code class="prettyprint">i</code>&lsquo;s declaration in a block, the example is valid.</p>

<h2 id="end-points-and-reachability">End points and reachability</h2>

<p>Every statement has an <strong><em>end point</em></strong>. In intuitive terms, the end point of a statement is the location that immediately follows the statement. The execution rules for composite statements (statements that contain embedded statements) specify the action that is taken when control reaches the end point of an embedded statement. For example, when control reaches the end point of a statement in a block, control is transferred to the next statement in the block.</p>

<p>If a statement can possibly be reached by execution, the statement is said to be <strong><em>reachable</em></strong>. Conversely, if there is no possibility that a statement will be executed, the statement is said to be <strong><em>unreachable</em></strong>.</p>

<p>In the example
<code class="prettyprint">csharp
void F() {
    Console.WriteLine(&quot;reachable&quot;);
    goto Label;
    Console.WriteLine(&quot;unreachable&quot;);
    Label:
    Console.WriteLine(&quot;reachable&quot;);
}
</code>
the second invocation of <code class="prettyprint">Console.WriteLine</code> is unreachable because there is no possibility that the statement will be executed.</p>

<p>A warning is reported if the compiler determines that a statement is unreachable. It is specifically not an error for a statement to be unreachable.</p>

<p>To determine whether a particular statement or end point is reachable, the compiler performs flow analysis according to the reachability rules defined for each statement. The flow analysis takes into account the values of constant expressions (<a href="expressions.md#constant-expressions">Constant expressions</a>) that control the behavior of statements, but the possible values of non-constant expressions are not considered. In other words, for purposes of control flow analysis, a non-constant expression of a given type is considered to have any possible value of that type.</p>

<p>In the example
<code class="prettyprint">csharp
void F() {
    const int i = 1;
    if (i == 2) Console.WriteLine(&quot;unreachable&quot;);
}
</code>
the boolean expression of the <code class="prettyprint">if</code> statement is a constant expression because both operands of the <code class="prettyprint">==</code> operator are constants. As the constant expression is evaluated at compile-time, producing the value <code class="prettyprint">false</code>, the <code class="prettyprint">Console.WriteLine</code> invocation is considered unreachable. However, if <code class="prettyprint">i</code> is changed to be a local variable
<code class="prettyprint">csharp
void F() {
    int i = 1;
    if (i == 2) Console.WriteLine(&quot;reachable&quot;);
}
</code>
the <code class="prettyprint">Console.WriteLine</code> invocation is considered reachable, even though, in reality, it will never be executed.</p>

<p>The <em>block</em> of a function member is always considered reachable. By successively evaluating the reachability rules of each statement in a block, the reachability of any given statement can be determined.</p>

<p>In the example
<code class="prettyprint">csharp
void F(int x) {
    Console.WriteLine(&quot;start&quot;);
    if (x &lt; 0) Console.WriteLine(&quot;negative&quot;);
}
</code>
the reachability of the second <code class="prettyprint">Console.WriteLine</code> is determined as follows:</p>

<ul>
<li> The first <code class="prettyprint">Console.WriteLine</code> expression statement is reachable because the block of the <code class="prettyprint">F</code> method is reachable.</li>
<li> The end point of the first <code class="prettyprint">Console.WriteLine</code> expression statement is reachable because that statement is reachable.</li>
<li> The <code class="prettyprint">if</code> statement is reachable because the end point of the first <code class="prettyprint">Console.WriteLine</code> expression statement is reachable.</li>
<li> The second <code class="prettyprint">Console.WriteLine</code> expression statement is reachable because the boolean expression of the <code class="prettyprint">if</code> statement does not have the constant value <code class="prettyprint">false</code>.</li>
</ul>

<p>There are two situations in which it is a compile-time error for the end point of a statement to be reachable:</p>

<ul>
<li> Because the <code class="prettyprint">switch</code> statement does not permit a switch section to &ldquo;fall through&rdquo; to the next switch section, it is a compile-time error for the end point of the statement list of a switch section to be reachable. If this error occurs, it is typically an indication that a <code class="prettyprint">break</code> statement is missing.</li>
<li> It is a compile-time error for the end point of the block of a function member that computes a value to be reachable. If this error occurs, it typically is an indication that a <code class="prettyprint">return</code> statement is missing.</li>
</ul>

<h2 id="blocks">Blocks</h2>

<p>A <em>block</em> permits multiple statements to be written in contexts where a single statement is allowed.</p>
<pre class="highlight plaintext"><code>block
    : '{' statement_list? '}'
    ;
</code></pre>
<p>A <em>block</em> consists of an optional <em>statement_list</em> (<a href="statements.md#statement-lists">Statement lists</a>), enclosed in braces. If the statement list is omitted, the block is said to be empty.</p>

<p>A block may contain declaration statements (<a href="statements.md#declaration-statements">Declaration statements</a>). The scope of a local variable or constant declared in a block is the block.</p>

<p>A block is executed as follows:</p>

<ul>
<li> If the block is empty, control is transferred to the end point of the block.</li>
<li> If the block is not empty, control is transferred to the statement list. When and if control reaches the end point of the statement list, control is transferred to the end point of the block.</li>
</ul>

<p>The statement list of a block is reachable if the block itself is reachable.</p>

<p>The end point of a block is reachable if the block is empty or if the end point of the statement list is reachable.</p>

<p>A <em>block</em> that contains one or more <code class="prettyprint">yield</code> statements (<a href="statements.md#the-yield-statement">The yield statement</a>) is called an iterator block. Iterator blocks are used to implement function members as iterators (<a href="classes.md#iterators">Iterators</a>). Some additional restrictions apply to iterator blocks:</p>

<ul>
<li> It is a compile-time error for a <code class="prettyprint">return</code> statement to appear in an iterator block (but <code class="prettyprint">yield return</code> statements are permitted).</li>
<li> It is a compile-time error for an iterator block to contain an unsafe context (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>). An iterator block always defines a safe context, even when its declaration is nested in an unsafe context.</li>
</ul>

<h3 id="statement-lists">Statement lists</h3>

<p>A <strong><em>statement list</em></strong> consists of one or more statements written in sequence. Statement lists occur in *block*s (<a href="statements.md#blocks">Blocks</a>) and in *switch_block*s (<a href="statements.md#the-switch-statement">The switch statement</a>).</p>
<pre class="highlight plaintext"><code>statement_list
    : statement+
    ;
</code></pre>
<p>A statement list is executed by transferring control to the first statement. When and if control reaches the end point of a statement, control is transferred to the next statement. When and if control reaches the end point of the last statement, control is transferred to the end point of the statement list.</p>

<p>A statement in a statement list is reachable if at least one of the following is true:</p>

<ul>
<li> The statement is the first statement and the statement list itself is reachable.</li>
<li> The end point of the preceding statement is reachable.</li>
<li> The statement is a labeled statement and the label is referenced by a reachable <code class="prettyprint">goto</code> statement.</li>
</ul>

<p>The end point of a statement list is reachable if the end point of the last statement in the list is reachable.</p>

<h2 id="the-empty-statement">The empty statement</h2>

<p>An <em>empty_statement</em> does nothing.</p>
<pre class="highlight plaintext"><code>empty_statement
    : ';'
    ;
</code></pre>
<p>An empty statement is used when there are no operations to perform in a context where a statement is required.</p>

<p>Execution of an empty statement simply transfers control to the end point of the statement. Thus, the end point of an empty statement is reachable if the empty statement is reachable.</p>

<p>An empty statement can be used when writing a <code class="prettyprint">while</code> statement with a null body:
&ldquo;`csharp
bool ProcessMessage() {&hellip;}</p>

<p>void ProcessMessages() {
    while (ProcessMessage())
        ;
}
&rdquo;`</p>

<p>Also, an empty statement can be used to declare a label just before the closing &ldquo;<code class="prettyprint">}</code>&rdquo; of a block:
<code class="prettyprint">csharp
void F() {
    ...
    if (done) goto exit;
    ...
    exit: ;
}
</code></p>

<h2 id="labeled-statements">Labeled statements</h2>

<p>A <em>labeled_statement</em> permits a statement to be prefixed by a label. Labeled statements are permitted in blocks, but are not permitted as embedded statements.</p>
<pre class="highlight plaintext"><code>labeled_statement
    : identifier ':' statement
    ;
</code></pre>
<p>A labeled statement declares a label with the name given by the <em>identifier</em>. The scope of a label is the whole block in which the label is declared, including any nested blocks. It is a compile-time error for two labels with the same name to have overlapping scopes.</p>

<p>A label can be referenced from <code class="prettyprint">goto</code> statements (<a href="statements.md#the-goto-statement">The goto statement</a>) within the scope of the label. This means that <code class="prettyprint">goto</code> statements can transfer control within blocks and out of blocks, but never into blocks.</p>

<p>Labels have their own declaration space and do not interfere with other identifiers. The example
<code class="prettyprint">csharp
int F(int x) {
    if (x &gt;= 0) goto x;
    x = -x;
    x: return x;
}
</code>
is valid and uses the name <code class="prettyprint">x</code> as both a parameter and a label.</p>

<p>Execution of a labeled statement corresponds exactly to execution of the statement following the label.</p>

<p>In addition to the reachability provided by normal flow of control, a labeled statement is reachable if the label is referenced by a reachable <code class="prettyprint">goto</code> statement. (Exception: If a <code class="prettyprint">goto</code> statement is inside a <code class="prettyprint">try</code> that includes a <code class="prettyprint">finally</code> block, and the labeled statement is outside the <code class="prettyprint">try</code>, and the end point of the <code class="prettyprint">finally</code> block is unreachable, then the labeled statement is not reachable from that <code class="prettyprint">goto</code> statement.)</p>

<h2 id="declaration-statements">Declaration statements</h2>

<p>A <em>declaration_statement</em> declares a local variable or constant. Declaration statements are permitted in blocks, but are not permitted as embedded statements.</p>
<pre class="highlight plaintext"><code>declaration_statement
    : local_variable_declaration ';'
    | local_constant_declaration ';'
    ;
</code></pre>
<h3 id="local-variable-declarations">Local variable declarations</h3>

<p>A <em>local_variable_declaration</em> declares one or more local variables.</p>
<pre class="highlight plaintext"><code>local_variable_declaration
    : local_variable_type local_variable_declarators
    ;

local_variable_type
    : type
    | 'var'
    ;

local_variable_declarators
    : local_variable_declarator
    | local_variable_declarators ',' local_variable_declarator
    ;

local_variable_declarator
    : identifier
    | identifier '=' local_variable_initializer
    ;

local_variable_initializer
    : expression
    | array_initializer
    | local_variable_initializer_unsafe
    ;
</code></pre>
<p>The <em>local_variable_type</em> of a <em>local_variable_declaration</em> either directly specifies the type of the variables introduced by the declaration, or indicates with the identifier <code class="prettyprint">var</code> that the type should be inferred based on an initializer. The type is followed by a list of <em>local_variable_declarator*s, each of which introduces a new variable. A *local_variable_declarator</em> consists of an <em>identifier</em> that names the variable, optionally followed by an &ldquo;<code class="prettyprint">=</code>&rdquo; token and a <em>local_variable_initializer</em> that gives the initial value of the variable.</p>

<p>In the context of a local variable declaration, the identifier var acts as a contextual keyword (<a href="lexical-structure.md#keywords">Keywords</a>).When the <em>local_variable_type</em> is specified as <code class="prettyprint">var</code> and no type named <code class="prettyprint">var</code> is in scope, the declaration is an <strong><em>implicitly typed local variable declaration</em></strong>, whose type is inferred from the type of the associated initializer expression. Implicitly typed local variable declarations are subject to the following restrictions:</p>

<ul>
<li> The <em>local_variable_declaration</em> cannot include multiple *local_variable_declarator*s.</li>
<li> The <em>local_variable_declarator</em> must include a <em>local_variable_initializer</em>.</li>
<li> The <em>local_variable_initializer</em> must be an <em>expression</em>.</li>
<li> The initializer <em>expression</em> must have a compile-time type.</li>
<li> The initializer <em>expression</em> cannot refer to the declared variable itself</li>
</ul>

<p>The following are examples of incorrect implicitly typed local variable declarations:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">var</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// Error, no initializer to infer type from</span>
<span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>   <span class="c1">// Error, array initializer not permitted</span>
<span class="kt">var</span> <span class="n">z</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>        <span class="c1">// Error, null does not have a type</span>
<span class="kt">var</span> <span class="n">u</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>  <span class="c1">// Error, anonymous functions do not have a type</span>
<span class="kt">var</span> <span class="n">v</span> <span class="p">=</span> <span class="n">v</span><span class="p">++;</span>         <span class="c1">// Error, initializer cannot refer to variable itself</span>
</code></pre>
<p>The value of a local variable is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>), and the value of a local variable is modified using an <em>assignment</em> (<a href="expressions.md#assignment-operators">Assignment operators</a>). A local variable must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) at each location where its value is obtained.</p>

<p>The scope of a local variable declared in a <em>local_variable_declaration</em> is the block in which the declaration occurs. It is an error to refer to a local variable in a textual position that precedes the <em>local_variable_declarator</em> of the local variable. Within the scope of a local variable, it is a compile-time error to declare another local variable or constant with the same name.</p>

<p>A local variable declaration that declares multiple variables is equivalent to multiple declarations of single variables with the same type. Furthermore, a variable initializer in a local variable declaration corresponds exactly to an assignment statement that is inserted immediately after the declaration.</p>

<p>The example
<code class="prettyprint">csharp
void F() {
    int x = 1, y, z = x * 2;
}
</code>
corresponds exactly to
<code class="prettyprint">csharp
void F() {
    int x; x = 1;
    int y;
    int z; z = x * 2;
}
</code></p>

<p>In an implicitly typed local variable declaration, the type of the local variable being declared is taken to be the same as the type of the expression used to initialize the variable. For example:
<code class="prettyprint">csharp
var i = 5;
var s = &quot;Hello&quot;;
var d = 1.0;
var numbers = new int[] {1, 2, 3};
var orders = new Dictionary&lt;int,Order&gt;();
</code></p>

<p>The implicitly typed local variable declarations above are precisely equivalent to the following explicitly typed declarations:
<code class="prettyprint">csharp
int i = 5;
string s = &quot;Hello&quot;;
double d = 1.0;
int[] numbers = new int[] {1, 2, 3};
Dictionary&lt;int,Order&gt; orders = new Dictionary&lt;int,Order&gt;();
</code></p>

<h3 id="local-constant-declarations">Local constant declarations</h3>

<p>A <em>local_constant_declaration</em> declares one or more local constants.</p>
<pre class="highlight plaintext"><code>local_constant_declaration
    : 'const' type constant_declarators
    ;

constant_declarators
    : constant_declarator (',' constant_declarator)*
    ;

constant_declarator
    : identifier '=' constant_expression
    ;
</code></pre>
<p>The <em>type</em> of a <em>local_constant_declaration</em> specifies the type of the constants introduced by the declaration. The type is followed by a list of <em>constant_declarator*s, each of which introduces a new constant. A *constant_declarator</em> consists of an <em>identifier</em> that names the constant, followed by an &ldquo;<code class="prettyprint">=</code>&rdquo; token, followed by a <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>) that gives the value of the constant.</p>

<p>The <em>type</em> and <em>constant_expression</em> of a local constant declaration must follow the same rules as those of a constant member declaration (<a href="classes.md#constants">Constants</a>).</p>

<p>The value of a local constant is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>).</p>

<p>The scope of a local constant is the block in which the declaration occurs. It is an error to refer to a local constant in a textual position that precedes its <em>constant_declarator</em>. Within the scope of a local constant, it is a compile-time error to declare another local variable or constant with the same name.</p>

<p>A local constant declaration that declares multiple constants is equivalent to multiple declarations of single constants with the same type.</p>

<h2 id="expression-statements">Expression statements</h2>

<p>An <em>expression_statement</em> evaluates a given expression. The value computed by the expression, if any, is discarded.</p>
<pre class="highlight plaintext"><code>expression_statement
    : statement_expression ';'
    ;

statement_expression
    : invocation_expression
    | null_conditional_invocation_expression
    | object_creation_expression
    | assignment
    | post_increment_expression
    | post_decrement_expression
    | pre_increment_expression
    | pre_decrement_expression
    | await_expression
    ;
</code></pre>
<p>Not all expressions are permitted as statements. In particular, expressions such as <code class="prettyprint">x + y</code> and <code class="prettyprint">x == 1</code> that merely compute a value (which will be discarded), are not permitted as statements.</p>

<p>Execution of an <em>expression_statement</em> evaluates the contained expression and then transfers control to the end point of the <em>expression_statement</em>. The end point of an <em>expression_statement</em> is reachable if that <em>expression_statement</em> is reachable.</p>

<h2 id="selection-statements">Selection statements</h2>

<p>Selection statements select one of a number of possible statements for execution based on the value of some expression.</p>
<pre class="highlight plaintext"><code>selection_statement
    : if_statement
    | switch_statement
    ;
</code></pre>
<h3 id="the-if-statement">The if statement</h3>

<p>The <code class="prettyprint">if</code> statement selects a statement for execution based on the value of a boolean expression.</p>
<pre class="highlight plaintext"><code>if_statement
    : 'if' '(' boolean_expression ')' embedded_statement
    | 'if' '(' boolean_expression ')' embedded_statement 'else' embedded_statement
    ;
</code></pre>
<p>An <code class="prettyprint">else</code> part is associated with the lexically nearest preceding <code class="prettyprint">if</code> that is allowed by the syntax. Thus, an <code class="prettyprint">if</code> statement of the form
<code class="prettyprint">csharp
if (x) if (y) F(); else G();
</code>
is equivalent to
<code class="prettyprint">csharp
if (x) {
    if (y) {
        F();
    }
    else {
        G();
    }
}
</code></p>

<p>An <code class="prettyprint">if</code> statement is executed as follows:</p>

<ul>
<li> The <em>boolean_expression</em> (<a href="expressions.md#boolean-expressions">Boolean expressions</a>) is evaluated.</li>
<li> If the boolean expression yields <code class="prettyprint">true</code>, control is transferred to the first embedded statement. When and if control reaches the end point of that statement, control is transferred to the end point of the <code class="prettyprint">if</code> statement.</li>
<li> If the boolean expression yields <code class="prettyprint">false</code> and if an <code class="prettyprint">else</code> part is present, control is transferred to the second embedded statement. When and if control reaches the end point of that statement, control is transferred to the end point of the <code class="prettyprint">if</code> statement.</li>
<li> If the boolean expression yields <code class="prettyprint">false</code> and if an <code class="prettyprint">else</code> part is not present, control is transferred to the end point of the <code class="prettyprint">if</code> statement.</li>
</ul>

<p>The first embedded statement of an <code class="prettyprint">if</code> statement is reachable if the <code class="prettyprint">if</code> statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">false</code>.</p>

<p>The second embedded statement of an <code class="prettyprint">if</code> statement, if present, is reachable if the <code class="prettyprint">if</code> statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">true</code>.</p>

<p>The end point of an <code class="prettyprint">if</code> statement is reachable if the end point of at least one of its embedded statements is reachable. In addition, the end point of an <code class="prettyprint">if</code> statement with no <code class="prettyprint">else</code> part is reachable if the <code class="prettyprint">if</code> statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">true</code>.</p>

<h3 id="the-switch-statement">The switch statement</h3>

<p>The switch statement selects for execution a statement list having an associated switch label that corresponds to the value of the switch expression.</p>
<pre class="highlight plaintext"><code>switch_statement
    : 'switch' '(' expression ')' switch_block
    ;

switch_block
    : '{' switch_section* '}'
    ;

switch_section
    : switch_label+ statement_list
    ;

switch_label
    : 'case' constant_expression ':'
    | 'default' ':'
    ;
</code></pre>
<p>A <em>switch_statement</em> consists of the keyword <code class="prettyprint">switch</code>, followed by a parenthesized expression (called the switch expression), followed by a <em>switch_block</em>. The <em>switch_block</em> consists of zero or more <em>switch_section*s, enclosed in braces. Each *switch_section</em> consists of one or more <em>switch_label*s followed by a *statement_list</em> (<a href="statements.md#statement-lists">Statement lists</a>).</p>

<p>The <strong><em>governing type</em></strong> of a <code class="prettyprint">switch</code> statement is established by the switch expression.</p>

<ul>
<li> If the type of the switch expression is <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">char</code>, <code class="prettyprint">string</code>, or an <em>enum_type</em>, or if it is the nullable type corresponding to one of these types, then that is the governing type of the <code class="prettyprint">switch</code> statement.</li>
<li> Otherwise, exactly one user-defined implicit conversion (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>) must exist from the type of the switch expression to one of the following possible governing types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">string</code>, or,  a nullable type corresponding to one of those types.</li>
<li> Otherwise, if no such implicit conversion exists, or if more than one such implicit conversion exists, a compile-time error occurs.</li>
</ul>

<p>The constant expression of each <code class="prettyprint">case</code> label must denote a value that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the governing type of the <code class="prettyprint">switch</code> statement. A compile-time error occurs if two or more <code class="prettyprint">case</code> labels in the same <code class="prettyprint">switch</code> statement specify the same constant value.</p>

<p>There can be at most one <code class="prettyprint">default</code> label in a switch statement.</p>

<p>A <code class="prettyprint">switch</code> statement is executed as follows:</p>

<ul>
<li> The switch expression is evaluated and converted to the governing type.</li>
<li> If one of the constants specified in a <code class="prettyprint">case</code> label in the same <code class="prettyprint">switch</code> statement is equal to the value of the switch expression, control is transferred to the statement list following the matched <code class="prettyprint">case</code> label.</li>
<li> If none of the constants specified in <code class="prettyprint">case</code> labels in the same <code class="prettyprint">switch</code> statement is equal to the value of the switch expression, and if a <code class="prettyprint">default</code> label is present, control is transferred to the statement list following the <code class="prettyprint">default</code> label.</li>
<li> If none of the constants specified in <code class="prettyprint">case</code> labels in the same <code class="prettyprint">switch</code> statement is equal to the value of the switch expression, and if no <code class="prettyprint">default</code> label is present, control is transferred to the end point of the <code class="prettyprint">switch</code> statement.</li>
</ul>

<p>If the end point of the statement list of a switch section is reachable, a compile-time error occurs. This is known as the &ldquo;no fall through&rdquo; rule. The example
<code class="prettyprint">csharp
switch (i) {
case 0:
    CaseZero();
    break;
case 1:
    CaseOne();
    break;
default:
    CaseOthers();
    break;
}
</code>
is valid because no switch section has a reachable end point. Unlike C and C++, execution of a switch section is not permitted to &ldquo;fall through&rdquo; to the next switch section, and the example
<code class="prettyprint">csharp
switch (i) {
case 0:
    CaseZero();
case 1:
    CaseZeroOrOne();
default:
    CaseAny();
}
</code>
results in a compile-time error. When execution of a switch section is to be followed by execution of another switch section, an explicit <code class="prettyprint">goto case</code> or <code class="prettyprint">goto default</code> statement must be used:
<code class="prettyprint">csharp
switch (i) {
case 0:
    CaseZero();
    goto case 1;
case 1:
    CaseZeroOrOne();
    goto default;
default:
    CaseAny();
    break;
}
</code></p>

<p>Multiple labels are permitted in a <em>switch_section</em>. The example
<code class="prettyprint">csharp
switch (i) {
case 0:
    CaseZero();
    break;
case 1:
    CaseOne();
    break;
case 2:
default:
    CaseTwo();
    break;
}
</code>
is valid. The example does not violate the &ldquo;no fall through&rdquo; rule because the labels <code class="prettyprint">case 2:</code> and <code class="prettyprint">default:</code> are part of the same <em>switch_section</em>.</p>

<p>The &ldquo;no fall through&rdquo; rule prevents a common class of bugs that occur in C and C++ when <code class="prettyprint">break</code> statements are accidentally omitted. In addition, because of this rule, the switch sections of a <code class="prettyprint">switch</code> statement can be arbitrarily rearranged without affecting the behavior of the statement. For example, the sections of the <code class="prettyprint">switch</code> statement above can be reversed without affecting the behavior of the statement:
<code class="prettyprint">csharp
switch (i) {
default:
    CaseAny();
    break;
case 1:
    CaseZeroOrOne();
    goto default;
case 0:
    CaseZero();
    goto case 1;
}
</code></p>

<p>The statement list of a switch section typically ends in a <code class="prettyprint">break</code>, <code class="prettyprint">goto case</code>, or <code class="prettyprint">goto default</code> statement, but any construct that renders the end point of the statement list unreachable is permitted. For example, a <code class="prettyprint">while</code> statement controlled by the boolean expression <code class="prettyprint">true</code> is known to never reach its end point. Likewise, a <code class="prettyprint">throw</code> or <code class="prettyprint">return</code> statement always transfers control elsewhere and never reaches its end point. Thus, the following example is valid:
<code class="prettyprint">csharp
switch (i) {
case 0:
    while (true) F();
case 1:
    throw new ArgumentException();
case 2:
    return;
}
</code></p>

<p>The governing type of a <code class="prettyprint">switch</code> statement may be the type <code class="prettyprint">string</code>. For example:
<code class="prettyprint">csharp
void DoCommand(string command) {
    switch (command.ToLower()) {
    case &quot;run&quot;:
        DoRun();
        break;
    case &quot;save&quot;:
        DoSave();
        break;
    case &quot;quit&quot;:
        DoQuit();
        break;
    default:
        InvalidCommand(command);
        break;
    }
}
</code></p>

<p>Like the string equality operators (<a href="expressions.md#string-equality-operators">String equality operators</a>), the <code class="prettyprint">switch</code> statement is case sensitive and will execute a given switch section only if the switch expression string exactly matches a <code class="prettyprint">case</code> label constant.</p>

<p>When the governing type of a <code class="prettyprint">switch</code> statement is <code class="prettyprint">string</code>, the value <code class="prettyprint">null</code> is permitted as a case label constant.</p>

<p>The <em>statement_list*s of a *switch_block</em> may contain declaration statements (<a href="statements.md#declaration-statements">Declaration statements</a>). The scope of a local variable or constant declared in a switch block is the switch block.</p>

<p>The statement list of a given switch section is reachable if the <code class="prettyprint">switch</code> statement is reachable and at least one of the following is true:</p>

<ul>
<li> The switch expression is a non-constant value.</li>
<li> The switch expression is a constant value that matches a <code class="prettyprint">case</code> label in the switch section.</li>
<li> The switch expression is a constant value that doesn&rsquo;t match any <code class="prettyprint">case</code> label, and the switch section contains the <code class="prettyprint">default</code> label.</li>
<li> A switch label of the switch section is referenced by a reachable <code class="prettyprint">goto case</code> or <code class="prettyprint">goto default</code> statement.</li>
</ul>

<p>The end point of a <code class="prettyprint">switch</code> statement is reachable if at least one of the following is true:</p>

<ul>
<li> The <code class="prettyprint">switch</code> statement contains a reachable <code class="prettyprint">break</code> statement that exits the <code class="prettyprint">switch</code> statement.</li>
<li> The <code class="prettyprint">switch</code> statement is reachable, the switch expression is a non-constant value, and no <code class="prettyprint">default</code> label is present.</li>
<li> The <code class="prettyprint">switch</code> statement is reachable, the switch expression is a constant value that doesn&rsquo;t match any <code class="prettyprint">case</code> label, and no <code class="prettyprint">default</code> label is present.</li>
</ul>

<h2 id="iteration-statements">Iteration statements</h2>

<p>Iteration statements repeatedly execute an embedded statement.</p>
<pre class="highlight plaintext"><code>iteration_statement
    : while_statement
    | do_statement
    | for_statement
    | foreach_statement
    ;
</code></pre>
<h3 id="the-while-statement">The while statement</h3>

<p>The <code class="prettyprint">while</code> statement conditionally executes an embedded statement zero or more times.</p>
<pre class="highlight plaintext"><code>while_statement
    : 'while' '(' boolean_expression ')' embedded_statement
    ;
</code></pre>
<p>A <code class="prettyprint">while</code> statement is executed as follows:</p>

<ul>
<li> The <em>boolean_expression</em> (<a href="expressions.md#boolean-expressions">Boolean expressions</a>) is evaluated.</li>
<li> If the boolean expression yields <code class="prettyprint">true</code>, control is transferred to the embedded statement. When and if control reaches the end point of the embedded statement (possibly from execution of a <code class="prettyprint">continue</code> statement), control is transferred to the beginning of the <code class="prettyprint">while</code> statement.</li>
<li> If the boolean expression yields <code class="prettyprint">false</code>, control is transferred to the end point of the <code class="prettyprint">while</code> statement.</li>
</ul>

<p>Within the embedded statement of a <code class="prettyprint">while</code> statement, a <code class="prettyprint">break</code> statement (<a href="statements.md#the-break-statement">The break statement</a>) may be used to transfer control to the end point of the <code class="prettyprint">while</code> statement (thus ending iteration of the embedded statement), and a <code class="prettyprint">continue</code> statement (<a href="statements.md#the-continue-statement">The continue statement</a>) may be used to transfer control to the end point of the embedded statement (thus performing another iteration of the <code class="prettyprint">while</code> statement).</p>

<p>The embedded statement of a <code class="prettyprint">while</code> statement is reachable if the <code class="prettyprint">while</code> statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">false</code>.</p>

<p>The end point of a <code class="prettyprint">while</code> statement is reachable if at least one of the following is true:</p>

<ul>
<li> The <code class="prettyprint">while</code> statement contains a reachable <code class="prettyprint">break</code> statement that exits the <code class="prettyprint">while</code> statement.</li>
<li> The <code class="prettyprint">while</code> statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">true</code>.</li>
</ul>

<h3 id="the-do-statement">The do statement</h3>

<p>The <code class="prettyprint">do</code> statement conditionally executes an embedded statement one or more times.</p>
<pre class="highlight plaintext"><code>do_statement
    : 'do' embedded_statement 'while' '(' boolean_expression ')' ';'
    ;
</code></pre>
<p>A <code class="prettyprint">do</code> statement is executed as follows:</p>

<ul>
<li> Control is transferred to the embedded statement.</li>
<li> When and if control reaches the end point of the embedded statement (possibly from execution of a <code class="prettyprint">continue</code> statement), the <em>boolean_expression</em> (<a href="expressions.md#boolean-expressions">Boolean expressions</a>) is evaluated. If the boolean expression yields <code class="prettyprint">true</code>, control is transferred to the beginning of the <code class="prettyprint">do</code> statement. Otherwise, control is transferred to the end point of the <code class="prettyprint">do</code> statement.</li>
</ul>

<p>Within the embedded statement of a <code class="prettyprint">do</code> statement, a <code class="prettyprint">break</code> statement (<a href="statements.md#the-break-statement">The break statement</a>) may be used to transfer control to the end point of the <code class="prettyprint">do</code> statement (thus ending iteration of the embedded statement), and a <code class="prettyprint">continue</code> statement (<a href="statements.md#the-continue-statement">The continue statement</a>) may be used to transfer control to the end point of the embedded statement.</p>

<p>The embedded statement of a <code class="prettyprint">do</code> statement is reachable if the <code class="prettyprint">do</code> statement is reachable.</p>

<p>The end point of a <code class="prettyprint">do</code> statement is reachable if at least one of the following is true:</p>

<ul>
<li> The <code class="prettyprint">do</code> statement contains a reachable <code class="prettyprint">break</code> statement that exits the <code class="prettyprint">do</code> statement.</li>
<li> The end point of the embedded statement is reachable and the boolean expression does not have the constant value <code class="prettyprint">true</code>.</li>
</ul>

<h3 id="the-for-statement">The for statement</h3>

<p>The <code class="prettyprint">for</code> statement evaluates a sequence of initialization expressions and then, while a condition is true, repeatedly executes an embedded statement and evaluates a sequence of iteration expressions.</p>
<pre class="highlight plaintext"><code>for_statement
    : 'for' '(' for_initializer? ';' for_condition? ';' for_iterator? ')' embedded_statement
    ;

for_initializer
    : local_variable_declaration
    | statement_expression_list
    ;

for_condition
    : boolean_expression
    ;

for_iterator
    : statement_expression_list
    ;

statement_expression_list
    : statement_expression (',' statement_expression)*
    ;
</code></pre>
<p>The <em>for_initializer</em>, if present, consists of either a <em>local_variable_declaration</em> (<a href="statements.md#local-variable-declarations">Local variable declarations</a>) or a list of <em>statement_expression*s (<a href="statements.md#expression-statements">Expression statements</a>) separated by commas. The scope of a local variable declared by a *for_initializer</em> starts at the <em>local_variable_declarator</em> for the variable and extends to the end of the embedded statement. The scope includes the <em>for_condition</em> and the <em>for_iterator</em>.</p>

<p>The <em>for_condition</em>, if present, must be a <em>boolean_expression</em> (<a href="expressions.md#boolean-expressions">Boolean expressions</a>).</p>

<p>The <em>for_iterator</em>, if present, consists of a list of *statement_expression*s (<a href="statements.md#expression-statements">Expression statements</a>) separated by commas.</p>

<p>A for statement is executed as follows:</p>

<ul>
<li> If a <em>for_initializer</em> is present, the variable initializers or statement expressions are executed in the order they are written. This step is only performed once.</li>
<li> If a <em>for_condition</em> is present, it is evaluated.</li>
<li> If the <em>for_condition</em> is not present or if the evaluation yields <code class="prettyprint">true</code>, control is transferred to the embedded statement. When and if control reaches the end point of the embedded statement (possibly from execution of a <code class="prettyprint">continue</code> statement), the expressions of the <em>for_iterator</em>, if any, are evaluated in sequence, and then another iteration is performed, starting with evaluation of the <em>for_condition</em> in the step above.</li>
<li> If the <em>for_condition</em> is present and the evaluation yields <code class="prettyprint">false</code>, control is transferred to the end point of the <code class="prettyprint">for</code> statement.</li>
</ul>

<p>Within the embedded statement of a <code class="prettyprint">for</code> statement, a <code class="prettyprint">break</code> statement (<a href="statements.md#the-break-statement">The break statement</a>) may be used to transfer control to the end point of the <code class="prettyprint">for</code> statement (thus ending iteration of the embedded statement), and a <code class="prettyprint">continue</code> statement (<a href="statements.md#the-continue-statement">The continue statement</a>) may be used to transfer control to the end point of the embedded statement (thus executing the <em>for_iterator</em> and performing another iteration of the <code class="prettyprint">for</code> statement, starting with the <em>for_condition</em>).</p>

<p>The embedded statement of a <code class="prettyprint">for</code> statement is reachable if one of the following is true:</p>

<ul>
<li> The <code class="prettyprint">for</code> statement is reachable and no <em>for_condition</em> is present.</li>
<li> The <code class="prettyprint">for</code> statement is reachable and a <em>for_condition</em> is present and does not have the constant value <code class="prettyprint">false</code>.</li>
</ul>

<p>The end point of a <code class="prettyprint">for</code> statement is reachable if at least one of the following is true:</p>

<ul>
<li> The <code class="prettyprint">for</code> statement contains a reachable <code class="prettyprint">break</code> statement that exits the <code class="prettyprint">for</code> statement.</li>
<li> The <code class="prettyprint">for</code> statement is reachable and a <em>for_condition</em> is present and does not have the constant value <code class="prettyprint">true</code>.</li>
</ul>

<h3 id="the-foreach-statement">The foreach statement</h3>

<p>The <code class="prettyprint">foreach</code> statement enumerates the elements of a collection, executing an embedded statement for each element of the collection.</p>
<pre class="highlight plaintext"><code>foreach_statement
    : 'foreach' '(' local_variable_type identifier 'in' expression ')' embedded_statement
    ;
</code></pre>
<p>The <em>type</em> and <em>identifier</em> of a <code class="prettyprint">foreach</code> statement declare the <strong><em>iteration variable</em></strong> of the statement. If the <code class="prettyprint">var</code> identifier is given as the <em>local_variable_type</em>, and no type named <code class="prettyprint">var</code> is in scope, the iteration variable is said to be an <strong><em>implicitly typed iteration variable</em></strong>, and its type is taken to be the element type of the <code class="prettyprint">foreach</code> statement, as specified below. The iteration variable corresponds to a read-only local variable with a scope that extends over the embedded statement. During execution of a <code class="prettyprint">foreach</code> statement, the iteration variable represents the collection element for which an iteration is currently being performed. A compile-time error occurs if the embedded statement attempts to modify the iteration variable (via assignment or the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators) or pass the iteration variable as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</p>

<p>In the following, for brevity, <code class="prettyprint">IEnumerable</code>, <code class="prettyprint">IEnumerator</code>, <code class="prettyprint">IEnumerable&lt;T&gt;</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code> refer to the corresponding types in the namespaces <code class="prettyprint">System.Collections</code> and <code class="prettyprint">System.Collections.Generic</code>.</p>

<p>The compile-time processing of a foreach statement first determines the <strong><em>collection type</em></strong>, <strong><em>enumerator type</em></strong> and <strong><em>element type</em></strong> of the expression. This determination proceeds as follows:</p>

<ul>
<li> If the type <code class="prettyprint">X</code> of <em>expression</em> is an array type then there is an implicit reference conversion from <code class="prettyprint">X</code> to the <code class="prettyprint">IEnumerable</code> interface (since <code class="prettyprint">System.Array</code> implements this interface). The <strong><em>collection type</em></strong> is the <code class="prettyprint">IEnumerable</code> interface, the <strong><em>enumerator type</em></strong> is the <code class="prettyprint">IEnumerator</code> interface and the <strong><em>element type</em></strong> is the element type of the array type <code class="prettyprint">X</code>.</li>
<li> If the type <code class="prettyprint">X</code> of <em>expression</em> is <code class="prettyprint">dynamic</code> then there is an implicit conversion from <em>expression</em> to the <code class="prettyprint">IEnumerable</code> interface (<a href="conversions.md#implicit-dynamic-conversions">Implicit dynamic conversions</a>). The <strong><em>collection type</em></strong> is the <code class="prettyprint">IEnumerable</code> interface and the <strong><em>enumerator type</em></strong> is the <code class="prettyprint">IEnumerator</code> interface. If the <code class="prettyprint">var</code> identifier is given as the <em>local_variable_type</em> then the <strong><em>element type</em></strong> is <code class="prettyprint">dynamic</code>, otherwise it is <code class="prettyprint">object</code>.</li>
<li><p>Otherwise, determine whether the type <code class="prettyprint">X</code> has an appropriate <code class="prettyprint">GetEnumerator</code> method:</p>

<ul>
<li>Perform member lookup on the type <code class="prettyprint">X</code> with identifier <code class="prettyprint">GetEnumerator</code> and no type arguments. If the member lookup does not produce a match, or it produces an ambiguity, or produces a match that is not a method group, check for an enumerable interface as described below. It is recommended that a warning be issued if member lookup produces anything except a method group or no match.</li>
<li>Perform overload resolution using the resulting method group and an empty argument list. If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, check for an enumerable interface as described below. It is recommended that a warning be issued if overload resolution produces anything except an unambiguous public instance method or no applicable methods.</li>
<li>If the return type <code class="prettyprint">E</code> of the <code class="prettyprint">GetEnumerator</code> method is not a class, struct or interface type, an error is produced and no further steps are taken.</li>
<li>Member lookup is performed on <code class="prettyprint">E</code> with the identifier <code class="prettyprint">Current</code> and no type arguments. If the member lookup produces no match, the result is an error, or the result is anything except a public instance property that permits reading, an error is produced and no further steps are taken.</li>
<li>Member lookup is performed on <code class="prettyprint">E</code> with the identifier <code class="prettyprint">MoveNext</code> and no type arguments. If the member lookup produces no match, the result is an error, or the result is anything except a method group, an error is produced and no further steps are taken.</li>
<li>Overload resolution is performed on the method group with an empty argument list. If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, or its return type is not <code class="prettyprint">bool</code>, an error is produced and no further steps are taken.</li>
<li>The <strong><em>collection type</em></strong> is <code class="prettyprint">X</code>, the <strong><em>enumerator type</em></strong> is <code class="prettyprint">E</code>, and the <strong><em>element type</em></strong> is the type of the <code class="prettyprint">Current</code> property.</li>
</ul></li>
<li><p>Otherwise, check for an enumerable interface:</p>

<ul>
<li>If among all the types <code class="prettyprint">Ti</code> for which there is an implicit conversion from <code class="prettyprint">X</code> to <code class="prettyprint">IEnumerable&lt;Ti&gt;</code>, there is a unique type <code class="prettyprint">T</code> such that <code class="prettyprint">T</code> is not <code class="prettyprint">dynamic</code> and for all the other <code class="prettyprint">Ti</code> there is an implicit conversion from <code class="prettyprint">IEnumerable&lt;T&gt;</code> to <code class="prettyprint">IEnumerable&lt;Ti&gt;</code>, then the <strong><em>collection type</em></strong> is the interface <code class="prettyprint">IEnumerable&lt;T&gt;</code>, the <strong><em>enumerator type</em></strong> is the interface <code class="prettyprint">IEnumerator&lt;T&gt;</code>, and the <strong><em>element type</em></strong> is <code class="prettyprint">T</code>.</li>
<li>Otherwise, if there is more than one such type <code class="prettyprint">T</code>, then an error is produced and no further steps are taken.</li>
<li>Otherwise, if there is an implicit conversion from <code class="prettyprint">X</code> to the <code class="prettyprint">System.Collections.IEnumerable</code> interface, then the <strong><em>collection type</em></strong> is this interface, the <strong><em>enumerator type</em></strong> is the interface <code class="prettyprint">System.Collections.IEnumerator</code>, and the <strong><em>element type</em></strong> is <code class="prettyprint">object</code>.</li>
<li>Otherwise, an error is produced and no further steps are taken.</li>
</ul></li>
</ul>

<p>The above steps, if successful, unambiguously produce a collection type <code class="prettyprint">C</code>, enumerator type <code class="prettyprint">E</code> and element type <code class="prettyprint">T</code>. A foreach statement of the form
<code class="prettyprint">csharp
foreach (V v in x) embedded_statement
</code>
is then expanded to:
<code class="prettyprint">csharp
{
    E e = ((C)(x)).GetEnumerator();
    try {
        while (e.MoveNext()) {
            V v = (V)(T)e.Current;
            embedded_statement
        }
    }
    finally {
        ... // Dispose e
    }
}
</code></p>

<p>The variable <code class="prettyprint">e</code> is not visible to or accessible to the expression <code class="prettyprint">x</code> or the embedded statement or any other source code of the program. The variable <code class="prettyprint">v</code> is read-only in the embedded statement. If there is not an explicit conversion (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) from <code class="prettyprint">T</code> (the element type) to <code class="prettyprint">V</code> (the <em>local_variable_type</em> in the foreach statement), an error is produced and no further steps are taken. If <code class="prettyprint">x</code> has the value <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown at run-time.</p>

<p>An implementation is permitted to implement a given foreach-statement differently, e.g. for performance reasons, as long as the behavior is consistent with the above expansion.</p>

<p>The placement of <code class="prettyprint">v</code> inside the while loop is important for how it is captured by any anonymous function occurring in the <em>embedded_statement</em>.</p>

<p>For example:
&ldquo;`csharp
int[] values = { 7, 9, 13 };
Action f = null;</p>

<p>foreach (var value in values)
{
    if (f == null) f = () =&gt; Console.WriteLine(&quot;First value: &rdquo; + value);
}</p>

<p>f();
&ldquo;<code class="prettyprint">
If</code>v<code class="prettyprint">was declared outside of the while loop, it would be shared among all iterations, and its value after the for loop would be the final value,</code>13<code class="prettyprint">, which is what the invocation of</code>f<code class="prettyprint">would print. Instead, because each iteration has its own variable</code>v<code class="prettyprint">, the one captured by</code>f<code class="prettyprint">in the first iteration will continue to hold the value</code>7<code class="prettyprint">, which is what will be printed. (Note: earlier versions of C# declared</code>v` outside of the while loop.)</p>

<p>The body of the finally block is constructed according to the following steps:</p>

<ul>
<li><p>If there is an implicit conversion from <code class="prettyprint">E</code> to the <code class="prettyprint">System.IDisposable</code> interface, then</p>

<ul>
<li> If <code class="prettyprint">E</code> is a non-nullable value type then the finally clause is expanded to the semantic equivalent  of:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>  <span class="k">finally</span> <span class="p">{</span>
      <span class="p">((</span><span class="n">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="p">)</span><span class="n">e</span><span class="p">).</span><span class="nf">Dispose</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre>
<ul>
<li> Otherwise the finally clause is expanded to the semantic equivalent of:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>  <span class="k">finally</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">((</span><span class="n">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="p">)</span><span class="n">e</span><span class="p">).</span><span class="nf">Dispose</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></li>
</ul>

<p>except that if <code class="prettyprint">E</code> is a value type, or a type parameter instantiated to a value type, then the cast of <code class="prettyprint">e</code> to <code class="prettyprint">System.IDisposable</code> will not cause boxing to occur.</p>

<ul>
<li> Otherwise, if <code class="prettyprint">E</code> is a sealed type, the finally clause is expanded to an empty block:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">finally</span> <span class="p">{</span>
   <span class="p">}</span>
</code></pre>
<ul>
<li> Otherwise, the finally clause is expanded to:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">finally</span> <span class="p">{</span>
       <span class="n">System</span><span class="p">.</span><span class="n">IDisposable</span> <span class="n">d</span> <span class="p">=</span> <span class="n">e</span> <span class="k">as</span> <span class="n">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="p">;</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">d</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
   <span class="p">}</span>
</code></pre>
<p>The local variable <code class="prettyprint">d</code> is not visible to or accessible to any user code. In particular, it does not conflict with any other variable whose scope includes the finally block.</p>

<p>The order in which <code class="prettyprint">foreach</code> traverses the elements of an array, is as follows: For single-dimensional arrays elements are traversed in increasing index order, starting with indexÂ <code class="prettyprint">0</code> and ending with index <code class="prettyprint">LengthÂ -Â 1</code>. For multi-dimensional arrays, elements are traversed such that the indices of the rightmost dimension are increased first, then the next left dimension, and so on to the left.</p>

<p>The following example prints out each value in a two-dimensional array, in element order:
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        double[,] values = {
            {1.2, 2.3, 3.4, 4.5},
            {5.6, 6.7, 7.8, 8.9}
        };</p>

<p>foreach (double elementValue in values)
            Console.Write(&ldquo;{0} &rdquo;, elementValue);</p>

<p>Console.WriteLine();
    }
}
<code class="prettyprint">
The output produced is as follows:
</code>csharp
1.2 2.3 3.4 4.5 5.6 6.7 7.8 8.9
&ldquo;`</p>

<p>In the example
<code class="prettyprint">csharp
int[] numbers = { 1, 3, 5, 7, 9 };
foreach (var n in numbers) Console.WriteLine(n);
</code>
the type of <code class="prettyprint">n</code> is inferred to be <code class="prettyprint">int</code>, the element type of <code class="prettyprint">numbers</code>.</p>

<h2 id="jump-statements">Jump statements</h2>

<p>Jump statements unconditionally transfer control.</p>
<pre class="highlight plaintext"><code>jump_statement
    : break_statement
    | continue_statement
    | goto_statement
    | return_statement
    | throw_statement
    ;
</code></pre>
<p>The location to which a jump statement transfers control is called the <strong><em>target</em></strong> of the jump statement.</p>

<p>When a jump statement occurs within a block, and the target of that jump statement is outside that block, the jump statement is said to <strong><em>exit</em></strong> the block. While a jump statement may transfer control out of a block, it can never transfer control into a block.</p>

<p>Execution of jump statements is complicated by the presence of intervening <code class="prettyprint">try</code> statements. In the absence of such <code class="prettyprint">try</code> statements, a jump statement unconditionally transfers control from the jump statement to its target. In the presence of such intervening <code class="prettyprint">try</code> statements, execution is more complex. If the jump statement exits one or more <code class="prettyprint">try</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all intervening <code class="prettyprint">try</code> statements have been executed.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        while (true) {
            try {
                try {
                    Console.WriteLine(&ldquo;Before break&rdquo;);
                    break;
                }
                finally {
                    Console.WriteLine(&ldquo;Innermost finally block&rdquo;);
                }
            }
            finally {
                Console.WriteLine(&ldquo;Outermost finally block&rdquo;);
            }
        }
        Console.WriteLine(&ldquo;After break&rdquo;);
    }
}
&ldquo;<code class="prettyprint">
the</code>finally<code class="prettyprint">blocks associated with two</code>try` statements are executed before control is transferred to the target of the jump statement.</p>

<p>The output produced is as follows:
<code class="prettyprint">
Before break
Innermost finally block
Outermost finally block
After break
</code></p>

<h3 id="the-break-statement">The break statement</h3>

<p>The <code class="prettyprint">break</code> statement exits the nearest enclosing <code class="prettyprint">switch</code>, <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement.</p>
<pre class="highlight plaintext"><code>break_statement
    : 'break' ';'
    ;
</code></pre>
<p>The target of a <code class="prettyprint">break</code> statement is the end point of the nearest enclosing <code class="prettyprint">switch</code>, <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement. If a <code class="prettyprint">break</code> statement is not enclosed by a <code class="prettyprint">switch</code>, <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement, a compile-time error occurs.</p>

<p>When multiple <code class="prettyprint">switch</code>, <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statements are nested within each other, a <code class="prettyprint">break</code> statement applies only to the innermost statement. To transfer control across multiple nesting levels, a <code class="prettyprint">goto</code> statement (<a href="statements.md#the-goto-statement">The goto statement</a>) must be used.</p>

<p>A <code class="prettyprint">break</code> statement cannot exit a <code class="prettyprint">finally</code> block (<a href="statements.md#the-try-statement">The try statement</a>). When a <code class="prettyprint">break</code> statement occurs within a <code class="prettyprint">finally</code> block, the target of the <code class="prettyprint">break</code> statement must be within the same <code class="prettyprint">finally</code> block; otherwise, a compile-time error occurs.</p>

<p>A <code class="prettyprint">break</code> statement is executed as follows:</p>

<ul>
<li> If the <code class="prettyprint">break</code> statement exits one or more <code class="prettyprint">try</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all intervening <code class="prettyprint">try</code> statements have been executed.</li>
<li> Control is transferred to the target of the <code class="prettyprint">break</code> statement.</li>
</ul>

<p>Because a <code class="prettyprint">break</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">break</code> statement is never reachable.</p>

<h3 id="the-continue-statement">The continue statement</h3>

<p>The <code class="prettyprint">continue</code> statement starts a new iteration of the nearest enclosing <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement.</p>
<pre class="highlight plaintext"><code>continue_statement
    : 'continue' ';'
    ;
</code></pre>
<p>The target of a <code class="prettyprint">continue</code> statement is the end point of the embedded statement of the nearest enclosing <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement. If a <code class="prettyprint">continue</code> statement is not enclosed by a <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statement, a compile-time error occurs.</p>

<p>When multiple <code class="prettyprint">while</code>, <code class="prettyprint">do</code>, <code class="prettyprint">for</code>, or <code class="prettyprint">foreach</code> statements are nested within each other, a <code class="prettyprint">continue</code> statement applies only to the innermost statement. To transfer control across multiple nesting levels, a <code class="prettyprint">goto</code> statement (<a href="statements.md#the-goto-statement">The goto statement</a>) must be used.</p>

<p>A <code class="prettyprint">continue</code> statement cannot exit a <code class="prettyprint">finally</code> block (<a href="statements.md#the-try-statement">The try statement</a>). When a <code class="prettyprint">continue</code> statement occurs within a <code class="prettyprint">finally</code> block, the target of the <code class="prettyprint">continue</code> statement must be within the same <code class="prettyprint">finally</code> block; otherwise a compile-time error occurs.</p>

<p>A <code class="prettyprint">continue</code> statement is executed as follows:</p>

<ul>
<li> If the <code class="prettyprint">continue</code> statement exits one or more <code class="prettyprint">try</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all intervening <code class="prettyprint">try</code> statements have been executed.</li>
<li> Control is transferred to the target of the <code class="prettyprint">continue</code> statement.</li>
</ul>

<p>Because a <code class="prettyprint">continue</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">continue</code> statement is never reachable.</p>

<h3 id="the-goto-statement">The goto statement</h3>

<p>The <code class="prettyprint">goto</code> statement transfers control to a statement that is marked by a label.</p>
<pre class="highlight plaintext"><code>goto_statement
    : 'goto' identifier ';'
    | 'goto' 'case' constant_expression ';'
    | 'goto' 'default' ';'
    ;
</code></pre>
<p>The target of a <code class="prettyprint">goto</code> <em>identifier</em> statement is the labeled statement with the given label. If a label with the given name does not exist in the current function member, or if the <code class="prettyprint">goto</code> statement is not within the scope of the label, a compile-time error occurs. This rule permits the use of a <code class="prettyprint">goto</code> statement to transfer control out of a nested scope, but not into a nested scope. In the example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Main(string[] args) {
        string[,] table = {
            {&ldquo;Red&rdquo;, &ldquo;Blue&rdquo;, &ldquo;Green&rdquo;},
            {&ldquo;Monday&rdquo;, &ldquo;Wednesday&rdquo;, &ldquo;Friday&rdquo;}
        };</p>

<p>foreach (string str in args) {
            int row, colm;
            for (row = 0; row &lt;= 1; ++row)
                for (colm = 0; colm &lt;= 2; ++colm)
                    if (str == table[row,colm])
                         goto done;</p>

<p>Console.WriteLine(&ldquo;{0} not found&rdquo;, str);
            continue;
    done:
            Console.WriteLine(&ldquo;Found {0} at [{1}][{2}]&rdquo;, str, row, colm);
        }
    }
}
&ldquo;<code class="prettyprint">
a</code>goto` statement is used to transfer control out of a nested scope.</p>

<p>The target of a <code class="prettyprint">goto case</code> statement is the statement list in the immediately enclosing <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>), which contains a <code class="prettyprint">case</code> label with the given constant value. If the <code class="prettyprint">goto case</code> statement is not enclosed by a <code class="prettyprint">switch</code> statement, if the <em>constant_expression</em> is not implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the governing type of the nearest enclosing <code class="prettyprint">switch</code> statement, or if the nearest enclosing <code class="prettyprint">switch</code> statement does not contain a <code class="prettyprint">case</code> label with the given constant value, a compile-time error occurs.</p>

<p>The target of a <code class="prettyprint">goto default</code> statement is the statement list in the immediately enclosing <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>), which contains a <code class="prettyprint">default</code> label. If the <code class="prettyprint">goto default</code> statement is not enclosed by a <code class="prettyprint">switch</code> statement, or if the nearest enclosing <code class="prettyprint">switch</code> statement does not contain a <code class="prettyprint">default</code> label, a compile-time error occurs.</p>

<p>A <code class="prettyprint">goto</code> statement cannot exit a <code class="prettyprint">finally</code> block (<a href="statements.md#the-try-statement">The try statement</a>). When a <code class="prettyprint">goto</code> statement occurs within a <code class="prettyprint">finally</code> block, the target of the <code class="prettyprint">goto</code> statement must be within the same <code class="prettyprint">finally</code> block, or otherwise a compile-time error occurs.</p>

<p>A <code class="prettyprint">goto</code> statement is executed as follows:</p>

<ul>
<li> If the <code class="prettyprint">goto</code> statement exits one or more <code class="prettyprint">try</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all intervening <code class="prettyprint">try</code> statements have been executed.</li>
<li> Control is transferred to the target of the <code class="prettyprint">goto</code> statement.</li>
</ul>

<p>Because a <code class="prettyprint">goto</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">goto</code> statement is never reachable.</p>

<h3 id="the-return-statement">The return statement</h3>

<p>The <code class="prettyprint">return</code> statement returns control to the current caller of the function in which the <code class="prettyprint">return</code> statement appears.</p>
<pre class="highlight plaintext"><code>return_statement
    : 'return' expression? ';'
    ;
</code></pre>
<p>A <code class="prettyprint">return</code> statement with no expression can be used only in a function member that does not compute a value, that is, a method with the result type (<a href="classes.md#method-body">Method body</a>) <code class="prettyprint">void</code>, the <code class="prettyprint">set</code> accessor of a property or indexer, the <code class="prettyprint">add</code> and <code class="prettyprint">remove</code> accessors of an event, an instance constructor, a static constructor, or a destructor.</p>

<p>A <code class="prettyprint">return</code> statement with an expression can only be used in a function member that computes a value, that is, a method with a non-void result type, the <code class="prettyprint">get</code> accessor of a property or indexer, or a user-defined operator. An implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) must exist from the type of the expression to the return type of the containing function member.</p>

<p>Return statements can also be used in the body of anonymous function expressions (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>), and participate in determining which conversions exist for those functions.</p>

<p>It is a compile-time error for a <code class="prettyprint">return</code> statement to appear in a <code class="prettyprint">finally</code> block (<a href="statements.md#the-try-statement">The try statement</a>).</p>

<p>A <code class="prettyprint">return</code> statement is executed as follows:</p>

<ul>
<li> If the <code class="prettyprint">return</code> statement specifies an expression, the expression is evaluated and the resulting value is converted to the return type of the containing function by an implicit conversion. The result of the conversion becomes the result value produced by the function.</li>
<li> If the <code class="prettyprint">return</code> statement is enclosed by one or more <code class="prettyprint">try</code> or <code class="prettyprint">catch</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all enclosing <code class="prettyprint">try</code> statements have been executed.</li>
<li> If the containing function is not an async function, control is returned to the caller of the containing function along with the result value, if any.</li>
<li> If the containing function is an async function, control is returned to the current caller, and the result value, if any, is recorded in the return task as described in (<a href="classes.md#enumerator-interfaces">Enumerator interfaces</a>).</li>
</ul>

<p>Because a <code class="prettyprint">return</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">return</code> statement is never reachable.</p>

<h3 id="the-throw-statement">The throw statement</h3>

<p>The <code class="prettyprint">throw</code> statement throws an exception.</p>
<pre class="highlight plaintext"><code>throw_statement
    : 'throw' expression? ';'
    ;
</code></pre>
<p>A <code class="prettyprint">throw</code> statement with an expression throws the value produced by evaluating the expression. The expression must denote a value of the class type <code class="prettyprint">System.Exception</code>, of a class type that derives from <code class="prettyprint">System.Exception</code> or of a type parameter type that has <code class="prettyprint">System.Exception</code> (or a subclass thereof) as its effective base class. If evaluation of the expression produces <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown instead.</p>

<p>A <code class="prettyprint">throw</code> statement with no expression can be used only in a <code class="prettyprint">catch</code> block, in which case that statement re-throws the exception that is currently being handled by that <code class="prettyprint">catch</code> block.</p>

<p>Because a <code class="prettyprint">throw</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">throw</code> statement is never reachable.</p>

<p>When an exception is thrown, control is transferred to the first <code class="prettyprint">catch</code> clause in an enclosing <code class="prettyprint">try</code> statement that can handle the exception. The process that takes place from the point of the exception being thrown to the point of transferring control to a suitable exception handler is known as <strong><em>exception propagation</em></strong>. Propagation of an exception consists of repeatedly evaluating the following steps until a <code class="prettyprint">catch</code> clause that matches the exception is found. In this description, the <strong><em>throw point</em></strong> is initially the location at which the exception is thrown.</p>

<ul>
<li><p>In the current function member, each <code class="prettyprint">try</code> statement that encloses the throw point is examined. For each statement <code class="prettyprint">S</code>, starting with the innermost <code class="prettyprint">try</code> statement and ending with the outermost <code class="prettyprint">try</code> statement, the following steps are evaluated:</p>

<ul>
<li>If the <code class="prettyprint">try</code> block of <code class="prettyprint">S</code> encloses the throw point and if S has one or more <code class="prettyprint">catch</code> clauses, the <code class="prettyprint">catch</code> clauses are examined in order of appearance to locate a suitable handler for the exception, according to the rules specified in Section <a href="statements.md#the-try-statement">The try statement</a>. If a matching <code class="prettyprint">catch</code> clause is located, the exception propagation is completed by transferring control to the block of that <code class="prettyprint">catch</code> clause.</li>
<li>Otherwise, if the <code class="prettyprint">try</code> block or a <code class="prettyprint">catch</code> block of <code class="prettyprint">S</code> encloses the throw point and if <code class="prettyprint">S</code> has a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block. If the <code class="prettyprint">finally</code> block throws another exception, processing of the current exception is terminated. Otherwise, when control reaches the end point of the <code class="prettyprint">finally</code> block, processing of the current exception is continued.</li>
</ul></li>
<li><p>If an exception handler was not located in the current function invocation, the function invocation is terminated, and one of the following occurs:</p>

<ul>
<li>If the current function is non-async, the steps above are repeated for the caller of the function with a throw point corresponding to the statement from which the function member was invoked.</li>
<li>If the current function is async and task-returning, the exception is recorded in the return task, which is put into a faulted or cancelled state as described in <a href="classes.md#enumerator-interfaces">Enumerator interfaces</a>.</li>
<li>If the current function is async and void-returning, the synchronization context of the current thread is notified as described in <a href="classes.md#enumerable-interfaces">Enumerable interfaces</a>.</li>
</ul></li>
<li><p>If the exception processing terminates all function member invocations in the current thread, indicating that the thread has no handler for the exception, then the thread is itself terminated. The impact of such termination is implementation-defined.</p></li>
</ul>

<h2 id="the-try-statement">The try statement</h2>

<p>The <code class="prettyprint">try</code> statement provides a mechanism for catching exceptions that occur during execution of a block. Furthermore, the <code class="prettyprint">try</code> statement provides the ability to specify a block of code that is always executed when control leaves the <code class="prettyprint">try</code> statement.</p>
<pre class="highlight plaintext"><code>try_statement
    : 'try' block catch_clause+
    | 'try' block finally_clause
    | 'try' block catch_clause+ finally_clause
    ;

catch_clause
    : 'catch' exception_specifier? exception_filter?  block
    ;

exception_specifier
    : '(' type identifier? ')'
    ;

exception_filter
    : 'when' '(' expression ')'
    ;

finally_clause
    : 'finally' block
    ;
</code></pre>
<p>There are three possible forms of <code class="prettyprint">try</code> statements:</p>

<ul>
<li> A <code class="prettyprint">try</code> block followed by one or more <code class="prettyprint">catch</code> blocks.</li>
<li> A <code class="prettyprint">try</code> block followed by a <code class="prettyprint">finally</code> block.</li>
<li> A <code class="prettyprint">try</code> block followed by one or more <code class="prettyprint">catch</code> blocks followed by a <code class="prettyprint">finally</code> block.</li>
</ul>

<p>When a <code class="prettyprint">catch</code> clause specifies an <em>exception_specifier</em>, the type must be <code class="prettyprint">System.Exception</code>, a type that derives from <code class="prettyprint">System.Exception</code> or a type parameter type that has <code class="prettyprint">System.Exception</code> (or a subclass thereof) as its effective base class.</p>

<p>When a <code class="prettyprint">catch</code> clause specifies both an <em>exception_specifier</em> with an <em>identifier</em>, an <strong><em>exception variable</em></strong> of the given name and type is declared. The exception variable corresponds to a local variable with a scope that extends over the <code class="prettyprint">catch</code> clause. During execution of the <em>exception_filter</em> and <em>block</em>, the exception variable represents the exception currently being handled. For purposes of definite assignment checking, the exception variable is considered definitely assigned in its entire scope.</p>

<p>Unless a <code class="prettyprint">catch</code> clause includes an exception variable name, it is impossible to access the exception object in the filter and <code class="prettyprint">catch</code> block.</p>

<p>A <code class="prettyprint">catch</code> clause that does not specify an <em>exception_specifier</em> is called a general <code class="prettyprint">catch</code> clause.</p>

<p>Some programming languages may support exceptions that are not representable as an object derived from <code class="prettyprint">System.Exception</code>, although such exceptions could never be generated by C# code. A general <code class="prettyprint">catch</code> clause may be used to catch such exceptions. Thus, a general <code class="prettyprint">catch</code> clause is semantically different from one that specifies the type <code class="prettyprint">System.Exception</code>, in that the former may also catch exceptions from other languages.</p>

<p>In order to locate a handler for an exception, <code class="prettyprint">catch</code> clauses are examined in lexical order. If a <code class="prettyprint">catch</code> clause specifies a type but no exception filter, it is a compile-time error for a later <code class="prettyprint">catch</code> clause in the same <code class="prettyprint">try</code> statement to specify a type that is the same as, or is derived from, that type. If a <code class="prettyprint">catch</code> clause specifies no type and no filter, it must be the last <code class="prettyprint">catch</code> clause for that <code class="prettyprint">try</code> statement.</p>

<p>Within a <code class="prettyprint">catch</code> block, a <code class="prettyprint">throw</code> statement (<a href="statements.md#the-throw-statement">The throw statement</a>) with no expression can be used to re-throw the exception that was caught by the <code class="prettyprint">catch</code> block. Assignments to an exception variable do not alter the exception that is re-thrown.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F() {
        try {
            G();
        }
        catch (Exception e) {
            Console.WriteLine(&ldquo;Exception in F: &rdquo; + e.Message);
            e = new Exception(&ldquo;F&rdquo;);
            throw;                // re-throw
        }
    }</p>

<p>static void G() {
        throw new Exception(&ldquo;G&rdquo;);
    }</p>

<p>static void Main() {
        try {
            F();
        }
        catch (Exception e) {
            Console.WriteLine(&ldquo;Exception in Main: &rdquo; + e.Message);
        }
    }
}
<code class="prettyprint">
the method `F` catches an exception, writes some diagnostic information to the console, alters the exception variable, and re-throws the exception. The exception that is re-thrown is the original exception, so the output produced is:
</code>
Exception in F: G
Exception in Main: G
&ldquo;`</p>

<p>If the first catch block had thrown <code class="prettyprint">e</code> instead of rethrowing the current exception, the output produced would be as follows:
<code class="prettyprint">csharp
Exception in F: G
Exception in Main: F
</code></p>

<p>It is a compile-time error for a <code class="prettyprint">break</code>, <code class="prettyprint">continue</code>, or <code class="prettyprint">goto</code> statement to transfer control out of a <code class="prettyprint">finally</code> block. When a <code class="prettyprint">break</code>, <code class="prettyprint">continue</code>, or <code class="prettyprint">goto</code> statement occurs in a <code class="prettyprint">finally</code> block, the target of the statement must be within the same <code class="prettyprint">finally</code> block, or otherwise a compile-time error occurs.</p>

<p>It is a compile-time error for a <code class="prettyprint">return</code> statement to occur in a <code class="prettyprint">finally</code> block.</p>

<p>A <code class="prettyprint">try</code> statement is executed as follows:</p>

<ul>
<li> Control is transferred to the <code class="prettyprint">try</code> block.</li>
<li><p>When and if control reaches the end point of the <code class="prettyprint">try</code> block:</p>

<ul>
<li> If the <code class="prettyprint">try</code> statement has a <code class="prettyprint">finally</code> block, the <code class="prettyprint">finally</code> block is executed.</li>
<li> Control is transferred to the end point of the <code class="prettyprint">try</code> statement.</li>
</ul></li>
<li><p>If an exception is propagated to the <code class="prettyprint">try</code> statement during execution of the <code class="prettyprint">try</code> block:</p>

<ul>
<li> The <code class="prettyprint">catch</code> clauses, if any, are examined in order of appearance to locate a suitable handler for the exception. If a <code class="prettyprint">catch</code> clause does not specify a type, or specifies the exception type or a base type of the exception type:

<ul>
<li> If the <code class="prettyprint">catch</code> clause declares an exception variable, the exception object is assigned to the exception variable.</li>
<li> If the <code class="prettyprint">catch</code> clause declares an exception filter, the filter is evaluated. If it evaluates to <code class="prettyprint">false</code>, the catch clause is not a match, and the search continues through any subsequent <code class="prettyprint">catch</code> clauses for a suitable handler.</li>
<li> Otherwise, the <code class="prettyprint">catch</code> clause is considered a match, and control is transferred to the matching <code class="prettyprint">catch</code> block.</li>
<li> When and if control reaches the end point of the <code class="prettyprint">catch</code> block:

<ul>
<li>If the <code class="prettyprint">try</code> statement has a <code class="prettyprint">finally</code> block, the <code class="prettyprint">finally</code> block is executed.</li>
<li>Control is transferred to the end point of the <code class="prettyprint">try</code> statement.</li>
</ul></li>
<li> If an exception is propagated to the <code class="prettyprint">try</code> statement during execution of the <code class="prettyprint">catch</code> block:

<ul>
<li> If the <code class="prettyprint">try</code> statement has a <code class="prettyprint">finally</code> block, the <code class="prettyprint">finally</code> block is executed.</li>
<li> The exception is propagated to the next enclosing <code class="prettyprint">try</code> statement.</li>
</ul></li>
</ul></li>
<li> If the <code class="prettyprint">try</code> statement has no <code class="prettyprint">catch</code> clauses or if no <code class="prettyprint">catch</code> clause matches the exception:

<ul>
<li> If the <code class="prettyprint">try</code> statement has a <code class="prettyprint">finally</code> block, the <code class="prettyprint">finally</code> block is executed.</li>
<li> The exception is propagated to the next enclosing <code class="prettyprint">try</code> statement.</li>
</ul></li>
</ul></li>
</ul>

<p>The statements of a <code class="prettyprint">finally</code> block are always executed when control leaves a <code class="prettyprint">try</code> statement. This is true whether the control transfer occurs as a result of normal execution, as a result of executing a <code class="prettyprint">break</code>, <code class="prettyprint">continue</code>, <code class="prettyprint">goto</code>, or <code class="prettyprint">return</code> statement, or as a result of propagating an exception out of the <code class="prettyprint">try</code> statement.</p>

<p>If an exception is thrown during execution of a <code class="prettyprint">finally</code> block, and is not caught within the same finally block, the exception is propagated to the next enclosing <code class="prettyprint">try</code> statement. If another exception was in the process of being propagated, that exception is lost. The process of propagating an exception is discussed further in the description of the <code class="prettyprint">throw</code> statement (<a href="statements.md#the-throw-statement">The throw statement</a>).</p>

<p>The <code class="prettyprint">try</code> block of a <code class="prettyprint">try</code> statement is reachable if the <code class="prettyprint">try</code> statement is reachable.</p>

<p>A <code class="prettyprint">catch</code> block of a <code class="prettyprint">try</code> statement is reachable if the <code class="prettyprint">try</code> statement is reachable.</p>

<p>The <code class="prettyprint">finally</code> block of a <code class="prettyprint">try</code> statement is reachable if the <code class="prettyprint">try</code> statement is reachable.</p>

<p>The end point of a <code class="prettyprint">try</code> statement is reachable if both of the following are true:</p>

<ul>
<li> The end point of the <code class="prettyprint">try</code> block is reachable or the end point of at least one <code class="prettyprint">catch</code> block is reachable.</li>
<li> If a <code class="prettyprint">finally</code> block is present, the end point of the <code class="prettyprint">finally</code> block is reachable.</li>
</ul>

<h2 id="the-checked-and-unchecked-statements">The checked and unchecked statements</h2>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements are used to control the <strong><em>overflow checking context</em></strong> for integral-type arithmetic operations and conversions.</p>
<pre class="highlight plaintext"><code>checked_statement
    : 'checked' block
    ;

unchecked_statement
    : 'unchecked' block
    ;
</code></pre>
<p>The <code class="prettyprint">checked</code> statement causes all expressions in the <em>block</em> to be evaluated in a checked context, and the <code class="prettyprint">unchecked</code> statement causes all expressions in the <em>block</em> to be evaluated in an unchecked context.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements are precisely equivalent to the <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>), except that they operate on blocks instead of expressions.</p>

<h2 id="the-lock-statement">The lock statement</h2>

<p>The <code class="prettyprint">lock</code> statement obtains the mutual-exclusion lock for a given object, executes a statement, and then releases the lock.</p>
<pre class="highlight plaintext"><code>lock_statement
    : 'lock' '(' expression ')' embedded_statement
    ;
</code></pre>
<p>The expression of a <code class="prettyprint">lock</code> statement must denote a value of a type known to be a <em>reference_type</em>. No implicit boxing conversion (<a href="conversions.md#boxing-conversions">Boxing conversions</a>) is ever performed for the expression of a <code class="prettyprint">lock</code> statement, and thus it is a compile-time error for the expression to denote a value of a <em>value_type</em>.</p>

<p>A <code class="prettyprint">lock</code> statement of the form
<code class="prettyprint">csharp
lock (x) ...
</code>
where <code class="prettyprint">x</code> is an expression of a <em>reference_type</em>, is precisely equivalent to
<code class="prettyprint">csharp
bool __lockWasTaken = false;
try {
    System.Threading.Monitor.Enter(x, ref __lockWasTaken);
    ...
}
finally {
    if (__lockWasTaken) System.Threading.Monitor.Exit(x);
}
</code>
except that <code class="prettyprint">x</code> is only evaluated once.</p>

<p>While a mutual-exclusion lock is held, code executing in the same execution thread can also obtain and release the lock. However, code executing in other threads is blocked from obtaining the lock until the lock is released.</p>

<p>Locking <code class="prettyprint">System.Type</code> objects in order to synchronize access to static data is not recommended. Other code might lock on the same type, which can result in deadlock. A better approach is to synchronize access to static data by locking a private static object. For example:
&rdquo;`csharp
class Cache
{
    private static readonly object synchronizationObject = new object();</p>

<p>public static void Add(object x) {
        lock (Cache.synchronizationObject) {
            &hellip;
        }
    }</p>

<p>public static void Remove(object x) {
        lock (Cache.synchronizationObject) {
            &hellip;
        }
    }
}
&ldquo;`</p>

<h2 id="the-using-statement">The using statement</h2>

<p>The <code class="prettyprint">using</code> statement obtains one or more resources, executes a statement, and then disposes of the resource.</p>
<pre class="highlight plaintext"><code>using_statement
    : 'using' '(' resource_acquisition ')' embedded_statement
    ;

resource_acquisition
    : local_variable_declaration
    | expression
    ;
</code></pre>
<p>A <strong><em>resource</em></strong> is a class or struct that implements <code class="prettyprint">System.IDisposable</code>, which includes a single parameterless method named <code class="prettyprint">Dispose</code>. Code that is using a resource can call <code class="prettyprint">Dispose</code> to indicate that the resource is no longer needed. If <code class="prettyprint">Dispose</code> is not called, then automatic disposal eventually occurs as a consequence of garbage collection.</p>

<p>If the form of <em>resource_acquisition</em> is <em>local_variable_declaration</em> then the type of the <em>local_variable_declaration</em> must be either <code class="prettyprint">dynamic</code> or a type that can be implicitly converted to <code class="prettyprint">System.IDisposable</code>. If the form of <em>resource_acquisition</em> is <em>expression</em> then this expression must be implicitly convertible to <code class="prettyprint">System.IDisposable</code>.</p>

<p>Local variables declared in a <em>resource_acquisition</em> are read-only, and must include an initializer. A compile-time error occurs if the embedded statement attempts to modify these local variables (via assignment or the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators) , take the address of them, or pass them as <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</p>

<p>A <code class="prettyprint">using</code> statement is translated into three parts: acquisition, usage, and disposal. Usage of the resource is implicitly enclosed in a <code class="prettyprint">try</code> statement that includes a <code class="prettyprint">finally</code> clause. This <code class="prettyprint">finally</code> clause disposes of the resource. If a <code class="prettyprint">null</code> resource is acquired, then no call to <code class="prettyprint">Dispose</code> is made, and no exception is thrown. If the resource is of type <code class="prettyprint">dynamic</code> it is dynamically converted through an implicit dynamic conversion (<a href="conversions.md#implicit-dynamic-conversions">Implicit dynamic conversions</a>) to <code class="prettyprint">IDisposable</code> during acquisition in order to ensure that the conversion is successful before the usage and disposal.</p>

<p>A <code class="prettyprint">using</code> statement of the form
<code class="prettyprint">csharp
using (ResourceType resource = expression) statement
</code>
corresponds to one of three possible expansions. When <code class="prettyprint">ResourceType</code> is a non-nullable value type, the expansion is
<code class="prettyprint">csharp
{
    ResourceType resource = expression;
    try {
        statement;
    }
    finally {
        ((IDisposable)resource).Dispose();
    }
}
</code></p>

<p>Otherwise, when <code class="prettyprint">ResourceType</code> is a nullable value type or a reference type other than <code class="prettyprint">dynamic</code>, the expansion is
<code class="prettyprint">csharp
{
    ResourceType resource = expression;
    try {
        statement;
    }
    finally {
        if (resource != null) ((IDisposable)resource).Dispose();
    }
}
</code></p>

<p>Otherwise, when <code class="prettyprint">ResourceType</code> is <code class="prettyprint">dynamic</code>, the expansion is
<code class="prettyprint">csharp
{
    ResourceType resource = expression;
    IDisposable d = (IDisposable)resource;
    try {
        statement;
    }
    finally {
        if (d != null) d.Dispose();
    }
}
</code></p>

<p>In either expansion, the <code class="prettyprint">resource</code> variable is read-only in the embedded statement, and the <code class="prettyprint">d</code> variable is inaccessible in, and invisible to, the embedded statement.</p>

<p>An implementation is permitted to implement a given using-statement differently, e.g. for performance reasons, as long as the behavior is consistent with the above expansion.</p>

<p>A <code class="prettyprint">using</code> statement of the form
<code class="prettyprint">csharp
using (expression) statement
</code>
has the same three possible expansions. In this case <code class="prettyprint">ResourceType</code> is implicitly the compile-time type of the <code class="prettyprint">expression</code>, if it has one. Otherwise the interface <code class="prettyprint">IDisposable</code> itself is used as the <code class="prettyprint">ResourceType</code>. The <code class="prettyprint">resource</code> variable is inaccessible in, and invisible to, the embedded statement.</p>

<p>When a <em>resource_acquisition</em> takes the form of a <em>local_variable_declaration</em>, it is possible to acquire multiple resources of a given type. A <code class="prettyprint">using</code> statement of the form
<code class="prettyprint">csharp
using (ResourceType r1 = e1, r2 = e2, ..., rN = eN) statement
</code>
is precisely equivalent to a sequence of nested <code class="prettyprint">using</code> statements:
<code class="prettyprint">csharp
using (ResourceType r1 = e1)
    using (ResourceType r2 = e2)
        ...
            using (ResourceType rN = eN)
                statement
</code></p>

<p>The example below creates a file named <code class="prettyprint">log.txt</code> and writes two lines of text to the file. The example then opens that same file for reading and copies the contained lines of text to the console.
&rdquo;`csharp
using System;
using System.IO;</p>

<p>class Test
{
    static void Main() {
        using (TextWriter w = File.CreateText(&ldquo;log.txt&rdquo;)) {
            w.WriteLine(&ldquo;This is line one&rdquo;);
            w.WriteLine(&ldquo;This is line two&rdquo;);
        }</p>

<p>using (TextReader r = File.OpenText(&ldquo;log.txt&rdquo;)) {
            string s;
            while ((s = r.ReadLine()) != null) {
                Console.WriteLine(s);
            }</p>

<p>}
    }
}
&ldquo;`</p>

<p>Since the <code class="prettyprint">TextWriter</code> and <code class="prettyprint">TextReader</code> classes implement the <code class="prettyprint">IDisposable</code> interface, the example can use <code class="prettyprint">using</code> statements to ensure that the underlying file is properly closed following the write or read operations.</p>

<h2 id="the-yield-statement">The yield statement</h2>

<p>The <code class="prettyprint">yield</code> statement is used in an iterator block (<a href="statements.md#blocks">Blocks</a>) to yield a value to the enumerator object (<a href="classes.md#enumerator-objects">Enumerator objects</a>) or enumerable object (<a href="classes.md#enumerable-objects">Enumerable objects</a>) of an iterator or to signal the end of the iteration.</p>
<pre class="highlight plaintext"><code>yield_statement
    : 'yield' 'return' expression ';'
    | 'yield' 'break' ';'
    ;
</code></pre>
<p><code class="prettyprint">yield</code> is not a reserved word; it has special meaning only when used immediately before a <code class="prettyprint">return</code> or <code class="prettyprint">break</code> keyword. In other contexts, <code class="prettyprint">yield</code> can be used as an identifier.</p>

<p>There are several restrictions on where a <code class="prettyprint">yield</code> statement can appear, as described in the following.</p>

<ul>
<li> It is a compile-time error for a <code class="prettyprint">yield</code> statement (of either form) to appear outside a <em>method_body</em>, <em>operator_body</em> or <em>accessor_body</em></li>
<li> It is a compile-time error for a <code class="prettyprint">yield</code> statement (of either form) to appear inside an anonymous function.</li>
<li> It is a compile-time error for a <code class="prettyprint">yield</code> statement (of either form) to appear in the <code class="prettyprint">finally</code> clause of a <code class="prettyprint">try</code> statement.</li>
<li> It is a compile-time error for a <code class="prettyprint">yield return</code> statement to appear anywhere in a <code class="prettyprint">try</code> statement that contains any <code class="prettyprint">catch</code> clauses.</li>
</ul>

<p>The following example shows some valid and invalid uses of <code class="prettyprint">yield</code> statements.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">D</span><span class="p">();</span>

<span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="m">1</span><span class="p">;</span>        <span class="c1">// Ok</span>
        <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>           <span class="c1">// Ok</span>
    <span class="p">}</span>
    <span class="k">finally</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="m">2</span><span class="p">;</span>        <span class="c1">// Error, yield in finally</span>
        <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>           <span class="c1">// Error, yield in finally</span>
    <span class="p">}</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="m">3</span><span class="p">;</span>        <span class="c1">// Error, yield return in try...catch</span>
        <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>           <span class="c1">// Ok</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="m">4</span><span class="p">;</span>        <span class="c1">// Error, yield return in try...catch</span>
        <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>           <span class="c1">// Ok</span>
    <span class="p">}</span>

    <span class="n">D</span> <span class="n">d</span> <span class="p">=</span> <span class="k">delegate</span> <span class="p">{</span> 
        <span class="k">yield</span> <span class="k">return</span> <span class="m">5</span><span class="p">;</span>        <span class="c1">// Error, yield in an anonymous function</span>
    <span class="p">};</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">MyMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="m">1</span><span class="p">;</span>            <span class="c1">// Error, wrong return type for an iterator block</span>
<span class="p">}</span>
</code></pre>
<p>An implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) must exist from the type of the expression in the <code class="prettyprint">yield return</code> statement to the yield type (<a href="classes.md#yield-type">Yield type</a>) of the iterator.</p>

<p>A <code class="prettyprint">yield return</code> statement is executed as follows:</p>

<ul>
<li> The expression given in the statement is evaluated, implicitly converted to the yield type, and assigned to the <code class="prettyprint">Current</code> property of the enumerator object.</li>
<li> Execution of the iterator block is suspended. If the <code class="prettyprint">yield return</code> statement is within one or more <code class="prettyprint">try</code> blocks, the associated <code class="prettyprint">finally</code> blocks are not executed at this time.</li>
<li> The <code class="prettyprint">MoveNext</code> method of the enumerator object returns <code class="prettyprint">true</code> to its caller, indicating that the enumerator object successfully advanced to the next item.</li>
</ul>

<p>The next call to the enumerator object&rsquo;s <code class="prettyprint">MoveNext</code> method resumes execution of the iterator block from where it was last suspended.</p>

<p>A <code class="prettyprint">yield break</code> statement is executed as follows:</p>

<ul>
<li> If the <code class="prettyprint">yield break</code> statement is enclosed by one or more <code class="prettyprint">try</code> blocks with associated <code class="prettyprint">finally</code> blocks, control is initially transferred to the <code class="prettyprint">finally</code> block of the innermost <code class="prettyprint">try</code> statement. When and if control reaches the end point of a <code class="prettyprint">finally</code> block, control is transferred to the <code class="prettyprint">finally</code> block of the next enclosing <code class="prettyprint">try</code> statement. This process is repeated until the <code class="prettyprint">finally</code> blocks of all enclosing <code class="prettyprint">try</code> statements have been executed.</li>
<li> Control is returned to the caller of the iterator block. This is either the <code class="prettyprint">MoveNext</code> method or <code class="prettyprint">Dispose</code> method of the enumerator object.</li>
</ul>

<p>Because a <code class="prettyprint">yield break</code> statement unconditionally transfers control elsewhere, the end point of a <code class="prettyprint">yield break</code> statement is never reachable.</p>

          <h1 id="namespaces">Namespaces</h1>

<p>C# programs are organized using namespaces. Namespaces are used both as an &ldquo;internal&rdquo; organization system for a program, and as an &ldquo;external&rdquo; organization systemâ€”a way of presenting program elements that are exposed to other programs.</p>

<p>Using directives (<a href="namespaces.md#using-directives">Using directives</a>) are provided to facilitate the use of namespaces.</p>

<h2 id="compilation-units">Compilation units</h2>

<p>A <em>compilation_unit</em> defines the overall structure of a source file. A compilation unit consists of zero or more <em>using_directive*s followed by zero or more *global_attributes</em> followed by zero or more *namespace_member_declaration*s.</p>
<pre class="highlight plaintext"><code>compilation_unit
    : extern_alias_directive* using_directive* global_attributes? namespace_member_declaration*
    ;
</code></pre>
<p>A C# program consists of one or more compilation units, each contained in a separate source file. When a C# program is compiled, all of the compilation units are processed together. Thus, compilation units can depend on each other, possibly in a circular fashion.</p>

<p>The <em>using_directive*s of a compilation unit affect the *global_attributes</em> and *namespace_member_declaration*s of that compilation unit, but have no effect on other compilation units.</p>

<p>The <em>global_attributes</em> (<a href="attributes.md#attributes">Attributes</a>) of a compilation unit permit the specification of attributes for the target assembly and module. Assemblies and modules act as physical containers for types. An assembly may consist of several physically separate modules.</p>

<p>The *namespace_member_declaration*s of each compilation unit of a program contribute members to a single declaration space called the global namespace. For example:</p>

<p>File <code class="prettyprint">A.cs</code>:
<code class="prettyprint">csharp
class A {}
</code></p>

<p>File <code class="prettyprint">B.cs</code>:
<code class="prettyprint">csharp
class B {}
</code></p>

<p>The two compilation units contribute to the single global namespace, in this case declaring two classes with the fully qualified names <code class="prettyprint">A</code> and <code class="prettyprint">B</code>. Because the two compilation units contribute to the same declaration space, it would have been an error if each contained a declaration of a member with the same name.</p>

<h2 id="namespace-declarations">Namespace declarations</h2>

<p>A <em>namespace_declaration</em> consists of the keyword <code class="prettyprint">namespace</code>, followed by a namespace name and body, optionally followed by a semicolon.</p>
<pre class="highlight plaintext"><code>namespace_declaration
    : 'namespace' qualified_identifier namespace_body ';'?
    ;

qualified_identifier
    : identifier ('.' identifier)*
    ;

namespace_body
    : '{' extern_alias_directive* using_directive* namespace_member_declaration* '}'
    ;
</code></pre>
<p>A <em>namespace_declaration</em> may occur as a top-level declaration in a <em>compilation_unit</em> or as a member declaration within another <em>namespace_declaration</em>. When a <em>namespace_declaration</em> occurs as a top-level declaration in a <em>compilation_unit</em>, the namespace becomes a member of the global namespace. When a <em>namespace_declaration</em> occurs within another <em>namespace_declaration</em>, the inner namespace becomes a member of the outer namespace. In either case, the name of a namespace must be unique within the containing namespace.</p>

<p>Namespaces are implicitly <code class="prettyprint">public</code> and the declaration of a namespace cannot include any access modifiers.</p>

<p>Within a <em>namespace_body</em>, the optional *using_directive*s import the names of other namespaces, types and members, allowing them to be referenced directly instead of through qualified names. The optional *namespace_member_declaration*s contribute members to the declaration space of the namespace. Note that all *using_directive*s must appear before any member declarations.</p>

<p>The <em>qualified_identifier</em> of a <em>namespace_declaration</em> may be a single identifier or a sequence of identifiers separated by &ldquo;<code class="prettyprint">.</code>&rdquo; tokens. The latter form permits a program to define a nested namespace without lexically nesting several namespace declarations. For example,</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">N1.N2</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>

    <span class="k">class</span> <span class="nc">B</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>is semantically equivalent to
&ldquo;`csharp
namespace N1
{
    namespace N2
    {
        class A {}</p>

<p>class B {}
    }
}
&rdquo;`</p>

<p>Namespaces are open-ended, and two namespace declarations with the same fully qualified name contribute to the same declaration space (<a href="basic-concepts.md#declarations">Declarations</a>). In the example
&ldquo;`csharp
namespace N1.N2
{
    class A {}
}</p>

<p>namespace N1.N2
{
    class B {}
}
&rdquo;<code class="prettyprint">
the two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names</code>N1.N2.A<code class="prettyprint">and</code>N1.N2.B`. Because the two declarations contribute to the same declaration space, it would have been an error if each contained a declaration of a member with the same name.</p>

<h2 id="extern-aliases">Extern aliases</h2>

<p>An <em>extern_alias_directive</em> introduces an identifier that serves as an alias for a namespace. The specification of the aliased namespace is external to the source code of the program and applies also to nested namespaces of the aliased namespace.</p>
<pre class="highlight plaintext"><code>extern_alias_directive
    : 'extern' 'alias' identifier ';'
    ;
</code></pre>
<p>The scope of an <em>extern_alias_directive</em> extends over the <em>using_directive*s, *global_attributes</em> and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</p>

<p>Within a compilation unit or namespace body that contains an <em>extern_alias_directive</em>, the identifier introduced by the <em>extern_alias_directive</em> can be used to reference the aliased namespace. It is a compile-time error for the <em>identifier</em> to be the word <code class="prettyprint">global</code>.</p>

<p>An <em>extern_alias_directive</em> makes an alias available within a particular compilation unit or namespace body, but it does not contribute any new members to the underlying declaration space. In other words, an <em>extern_alias_directive</em> is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</p>

<p>The following program declares and uses two extern aliases, <code class="prettyprint">X</code> and <code class="prettyprint">Y</code>, each of which represent the root of a distinct namespace hierarchy:
&ldquo;`csharp
extern alias X;
extern alias Y;</p>

<p>class Test
{
    X::N.A a;
    X::N.B b1;
    Y::N.B b2;
    Y::N.C c;
}
&rdquo;`</p>

<p>The program declares the existence of the extern aliases <code class="prettyprint">X</code> and <code class="prettyprint">Y</code>, but the actual definitions of the aliases are external to the program. The identically named <code class="prettyprint">N.B</code> classes can now be referenced as <code class="prettyprint">X.N.B</code> and <code class="prettyprint">Y.N.B</code>, or, using the namespace alias qualifier, <code class="prettyprint">X::N.B</code> and <code class="prettyprint">Y::N.B</code>. An error occurs if a program declares an extern alias for which no external definition is provided.</p>

<h2 id="using-directives">Using directives</h2>

<p><strong><em>Using directives</em></strong> facilitate the use of namespaces and types defined in other namespaces. Using directives impact the name resolution process of *namespace_or_type_name*s (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) and *simple_name*s (<a href="expressions.md#simple-names">Simple names</a>), but unlike declarations, using directives do not contribute new members to the underlying declaration spaces of the compilation units or namespaces within which they are used.</p>
<pre class="highlight plaintext"><code>using_directive
    : using_alias_directive
    | using_namespace_directive
    | using_static_directive
    ;
</code></pre>
<p>A <em>using_alias_directive</em> (<a href="namespaces.md#using-alias-directives">Using alias directives</a>) introduces an alias for a namespace or type.</p>

<p>A <em>using_namespace_directive</em> (<a href="namespaces.md#using-namespace-directives">Using namespace directives</a>) imports the type members of a namespace.</p>

<p>A <em>using_static_directive</em> (<a href="namespaces.md#using-static-directives">Using static directives</a>) imports the nested types and static members of a type.</p>

<p>The scope of a <em>using_directive</em> extends over the <em>namespace_member_declaration*s of its immediately containing compilation unit or namespace body. The scope of a *using_directive</em> specifically does not include its peer *using_directive*s. Thus, peer *using_directive*s do not affect each other, and the order in which they are written is insignificant.</p>

<h3 id="using-alias-directives">Using alias directives</h3>

<p>A <em>using_alias_directive</em> introduces an identifier that serves as an alias for a namespace or type within the immediately enclosing compilation unit or namespace body.</p>
<pre class="highlight plaintext"><code>using_alias_directive
    : 'using' identifier '=' namespace_or_type_name ';'
    ;
</code></pre>
<p>Within member declarations in a compilation unit or namespace body that contains a <em>using_alias_directive</em>, the identifier introduced by the <em>using_alias_directive</em> can be used to reference the given namespace or type. For example:
&ldquo;`csharp
namespace N1.N2
{
    class A {}
}</p>

<p>namespace N3
{
    using A = N1.N2.A;</p>

<p>class B: A {}
}
&rdquo;`</p>

<p>Above, within member declarations in the <code class="prettyprint">N3</code> namespace, <code class="prettyprint">A</code> is an alias for <code class="prettyprint">N1.N2.A</code>, and thus class <code class="prettyprint">N3.B</code> derives from class <code class="prettyprint">N1.N2.A</code>. The same effect can be obtained by creating an alias <code class="prettyprint">R</code> for <code class="prettyprint">N1.N2</code> and then referencing <code class="prettyprint">R.A</code>:
&ldquo;`csharp
namespace N3
{
    using R = N1.N2;</p>

<p>class B: R.A {}
}
&rdquo;`</p>

<p>The <em>identifier</em> of a <em>using_alias_directive</em> must be unique within the declaration space of the compilation unit or namespace that immediately contains the <em>using_alias_directive</em>. For example:
&ldquo;`csharp
namespace N3
{
    class A {}
}</p>

<p>namespace N3
{
    using A = N1.N2.A;        // Error, A already exists
}
&rdquo;`</p>

<p>Above, <code class="prettyprint">N3</code> already contains a member <code class="prettyprint">A</code>, so it is a compile-time error for a <em>using_alias_directive</em> to use that identifier. Likewise, it is a compile-time error for two or more *using_alias_directive*s in the same compilation unit or namespace body to declare aliases by the same name.</p>

<p>A <em>using_alias_directive</em> makes an alias available within a particular compilation unit or namespace body, but it does not contribute any new members to the underlying declaration space. In other words, a <em>using_alias_directive</em> is not transitive but rather affects only the compilation unit or namespace body in which it occurs. In the example
&ldquo;`csharp
namespace N3
{
    using R = N1.N2;
}</p>

<p>namespace N3
{
    class B: R.A {}            // Error, R unknown
}
<code class="prettyprint">
the scope of the *using_alias_directive* that introduces `R` only extends to member declarations in the namespace body in which it is contained, so `R` is unknown in the second namespace declaration. However, placing the *using_alias_directive* in the containing compilation unit causes the alias to become available within both namespace declarations:
</code>csharp
using R = N1.N2;</p>

<p>namespace N3
{
    class B: R.A {}
}</p>

<p>namespace N3
{
    class C: R.A {}
}
&rdquo;`</p>

<p>Just like regular members, names introduced by *using_alias_directive*s are hidden by similarly named members in nested scopes. In the example
&ldquo;`csharp
using R = N1.N2;</p>

<p>namespace N3
{
    class R {}</p>

<p>class B: R.A {}        // Error, R has no member A
}
&rdquo;<code class="prettyprint">
the reference to</code>R.A<code class="prettyprint">in the declaration of</code>B<code class="prettyprint">causes a compile-time error because</code>R<code class="prettyprint">refers to</code>N3.R<code class="prettyprint">, not</code>N1.N2`.</p>

<p>The order in which <em>using_alias_directive*s are written has no significance, and resolution of the *namespace_or_type_name</em> referenced by a <em>using_alias_directive</em> is not affected by the <em>using_alias_directive</em> itself or by other <em>using_directive*s in the immediately containing compilation unit or namespace body. In other words, the *namespace_or_type_name</em> of a <em>using_alias_directive</em> is resolved as if the immediately containing compilation unit or namespace body had no <em>using_directive*s. A *using_alias_directive</em> may however be affected by *extern_alias_directive*s in the immediately containing compilation unit or namespace body. In the example
&ldquo;`csharp
namespace N1.N2 {}</p>

<p>namespace N3
{
    extern alias E;</p>

<p>using R1 = E.N;        // OK</p>

<p>using R2 = N1;         // OK</p>

<p>using R3 = N1.N2;      // OK</p>

<p>using R4 = R2.N2;      // Error, R2 unknown
}
&rdquo;<code class="prettyprint">
the last *using_alias_directive* results in a compile-time error because it is not affected by the first *using_alias_directive*. The first *using_alias_directive* does not result in an error since the scope of the extern alias</code>E` includes the <em>using_alias_directive</em>.</p>

<p>A <em>using_alias_directive</em> can create an alias for any namespace or type, including the namespace within which it appears and any namespace or type nested within that namespace.</p>

<p>Accessing a namespace or type through an alias yields exactly the same result as accessing that namespace or type through its declared name. For example, given
&ldquo;`csharp
namespace N1.N2
{
    class A {}
}</p>

<p>namespace N3
{
    using R1 = N1;
    using R2 = N1.N2;</p>

<p>class B
    {
        N1.N2.A a;            // refers to N1.N2.A
        R1.N2.A b;            // refers to N1.N2.A
        R2.A c;               // refers to N1.N2.A
    }
}
&rdquo;<code class="prettyprint">
the names</code>N1.N2.A<code class="prettyprint">,</code>R1.N2.A<code class="prettyprint">, and</code>R2.A<code class="prettyprint">are equivalent and all refer to the class whose fully qualified name is</code>N1.N2.A`.</p>

<p>Using aliases can name a closed constructed type, but cannot name an unbound generic type declaration without supplying type arguments. For example:
&ldquo;`csharp
namespace N1
{
    class A<T>
    {
        class B {}
    }
}</p>

<p>namespace N2
{
    using W = N1.A;          // Error, cannot name unbound generic type</p>

<p>using X = N1.A.B;        // Error, cannot name unbound generic type</p>

<p>using Y = N1.A<int>;     // Ok, can name closed constructed type</p>

<p>using Z<T> = N1.A<T>;    // Error, using alias cannot have type parameters
}
&rdquo;`</p>

<h3 id="using-namespace-directives">Using namespace directives</h3>

<p>A <em>using_namespace_directive</em> imports the types contained in a namespace into the immediately enclosing compilation unit or namespace body, enabling the identifier of each type to be used without qualification.</p>
<pre class="highlight plaintext"><code>using_namespace_directive
    : 'using' namespace_name ';'
    ;
</code></pre>
<p>Within member declarations in a compilation unit or namespace body that contains a <em>using_namespace_directive</em>, the types contained in the given namespace can be referenced directly. For example:
&ldquo;`csharp
namespace N1.N2
{
    class A {}
}</p>

<p>namespace N3
{
    using N1.N2;</p>

<p>class B: A {}
}
&rdquo;`</p>

<p>Above, within member declarations in the <code class="prettyprint">N3</code> namespace, the type members of <code class="prettyprint">N1.N2</code> are directly available, and thus class <code class="prettyprint">N3.B</code> derives from class <code class="prettyprint">N1.N2.A</code>.</p>

<p>A <em>using_namespace_directive</em> imports the types contained in the given namespace, but specifically does not import nested namespaces. In the example
&ldquo;`csharp
namespace N1.N2
{
    class A {}
}</p>

<p>namespace N3
{
    using N1;</p>

<p>class B: N2.A {}        // Error, N2 unknown
}
&rdquo;<code class="prettyprint">
the *using_namespace_directive* imports the types contained in</code>N1<code class="prettyprint">, but not the namespaces nested in</code>N1<code class="prettyprint">. Thus, the reference to</code>N2.A<code class="prettyprint">in the declaration of</code>B<code class="prettyprint">results in a compile-time error because no members named</code>N2` are in scope.</p>

<p>Unlike a <em>using_alias_directive</em>, a <em>using_namespace_directive</em> may import types whose identifiers are already defined within the enclosing compilation unit or namespace body. In effect, names imported by a <em>using_namespace_directive</em> are hidden by similarly named members in the enclosing compilation unit or namespace body. For example:
&ldquo;`csharp
namespace N1.N2
{
    class A {}</p>

<p>class B {}
}</p>

<p>namespace N3
{
    using N1.N2;</p>

<p>class A {}
}
&rdquo;`</p>

<p>Here, within member declarations in the <code class="prettyprint">N3</code> namespace, <code class="prettyprint">A</code> refers to <code class="prettyprint">N3.A</code> rather than <code class="prettyprint">N1.N2.A</code>.</p>

<p>When more than one namespace or type imported by <em>using_namespace_directive*s or *using_static_directive*s in the same compilation unit or namespace body contain types by the same name, references to that name as a *type_name</em> are considered ambiguous. In the example
&ldquo;`csharp
namespace N1
{
    class A {}
}</p>

<p>namespace N2
{
    class A {}
}</p>

<p>namespace N3
{
    using N1;</p>

<p>using N2;</p>

<p>class B: A {}                // Error, A is ambiguous
}
<code class="prettyprint">
both `N1` and `N2` contain a member `A`, and because `N3` imports both, referencing `A` in `N3` is a compile-time error. In this situation, the conflict can be resolved either through qualification of references to `A`, or by introducing a *using_alias_directive* that picks a particular `A`. For example:
</code>csharp
namespace N3
{
    using N1;</p>

<p>using N2;</p>

<p>using A = N1.A;</p>

<p>class B: A {}                // A means N1.A
}
&rdquo;`</p>

<p>Furthermore, when more than one namespace or type imported by <em>using_namespace_directive*s or *using_static_directive*s in the same compilation unit or namespace body contain types or members by the same name, references to that name as a *simple_name</em> are considered ambiguous. In the example
&ldquo;`csharp
namespace N1
{
    class A {}
}</p>

<p>class C
{
    public static int A
}</p>

<p>namespace N2
{
    using N1;
    using static C;</p>

<p>class B
    {
        void M() 
        { 
            A a = new A();   // Ok, A is unambiguous as a type-name
            A.Equals(2);     // Error, A is ambiguous as a simple-name
    }
}
&rdquo;<code class="prettyprint">
</code>N1<code class="prettyprint">contains a type member</code>A<code class="prettyprint">, and</code>C<code class="prettyprint">contains a static method</code>A<code class="prettyprint">, and because</code>N2<code class="prettyprint">imports both, referencing</code>A` as a <em>simple_name</em> is ambiguous and a compile-time error. </p>

<p>Like a <em>using_alias_directive</em>, a <em>using_namespace_directive</em> does not contribute any new members to the underlying declaration space of the compilation unit or namespace, but rather affects only the compilation unit or namespace body in which it appears.</p>

<p>The <em>namespace_name</em> referenced by a <em>using_namespace_directive</em> is resolved in the same way as the <em>namespace_or_type_name</em> referenced by a <em>using_alias_directive</em>. Thus, *using_namespace_directive*s in the same compilation unit or namespace body do not affect each other and can be written in any order.</p>

<h3 id="using-static-directives">Using static directives</h3>

<p>A <em>using_static_directive</em> imports the nested types and static members contained directly in a type declaration into the immediately enclosing compilation unit or namespace body, enabling the identifier of each member and type to be used without qualification.</p>
<pre class="highlight plaintext"><code>using_static_directive
    : 'using' 'static' type_name ';'
    ;
</code></pre>
<p>Within member declarations in a compilation unit or namespace body that contains a <em>using_static_directive</em>, the accessible nested types and static members (except extension methods) contained directly in the declaration of the given type can be referenced directly. For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">N1</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">A</span> 
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">class</span> <span class="nc">B</span><span class="p">{}</span>
        <span class="k">public</span> <span class="k">static</span> <span class="n">B</span> <span class="nf">M</span><span class="p">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N2</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">static</span> <span class="n">N1</span><span class="p">.</span><span class="n">A</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">C</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">N</span><span class="p">()</span> <span class="p">{</span> <span class="n">B</span> <span class="n">b</span> <span class="p">=</span> <span class="nf">M</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Above, within member declarations in the <code class="prettyprint">N2</code> namespace, the static members and nested types of <code class="prettyprint">N1.A</code> are directly available, and thus the method <code class="prettyprint">N</code> is able to reference both the <code class="prettyprint">B</code> and <code class="prettyprint">M</code> members of <code class="prettyprint">N1.A</code>.</p>

<p>A <em>using_static_directive</em> specifically does not import extension methods directly as static methods, but makes them available for extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">N1</span> 
<span class="p">{</span>
    <span class="k">static</span> <span class="k">class</span> <span class="nc">A</span> 
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M</span><span class="p">(</span><span class="k">this</span> <span class="kt">string</span> <span class="n">s</span><span class="p">){}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N2</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">static</span> <span class="n">N1</span><span class="p">.</span><span class="n">A</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">B</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">N</span><span class="p">()</span> 
        <span class="p">{</span>
            <span class="nf">M</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>      <span class="c1">// Error, M unknown</span>
            <span class="s">"B"</span><span class="p">.</span><span class="nf">M</span><span class="p">();</span>     <span class="c1">// Ok, M known as extension method</span>
            <span class="n">N1</span><span class="p">.</span><span class="n">A</span><span class="p">.</span><span class="nf">M</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span> <span class="c1">// Ok, fully qualified</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>the <em>using_static_directive</em> imports the extension method <code class="prettyprint">M</code> contained in <code class="prettyprint">N1.A</code>, but only as an extension method. Thus, the first reference to <code class="prettyprint">M</code> in the body of <code class="prettyprint">B.N</code> results in a compile-time error because no members named <code class="prettyprint">M</code> are in scope.</p>

<p>A <em>using_static_directive</em> only imports members and types declared directly in the given type, not members and types declared in base classes.</p>

<p>TODO: Example</p>

<p>Ambiguities between multiple <em>using_namespace_directives</em> and <em>using_static_directives</em> are discussed in <a href="namespaces.md#using-namespace-directives">Using namespace directives</a>.</p>

<h2 id="namespace-members">Namespace members</h2>

<p>A <em>namespace_member_declaration</em> is either a <em>namespace_declaration</em> (<a href="namespaces.md#namespace-declarations">Namespace declarations</a>) or a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>).</p>
<pre class="highlight plaintext"><code>namespace_member_declaration
    : namespace_declaration
    | type_declaration
    ;
</code></pre>
<p>A compilation unit or a namespace body can contain *namespace_member_declaration*s, and such declarations contribute new members to the underlying declaration space of the containing compilation unit or namespace body.</p>

<h2 id="type-declarations">Type declarations</h2>

<p>A <em>type_declaration</em> is a <em>class_declaration</em> (<a href="classes.md#class-declarations">Class declarations</a>), a <em>struct_declaration</em> (<a href="structs.md#struct-declarations">Struct declarations</a>), an <em>interface_declaration</em> (<a href="interfaces.md#interface-declarations">Interface declarations</a>), an <em>enum_declaration</em> (<a href="enums.md#enum-declarations">Enum declarations</a>), or a <em>delegate_declaration</em> (<a href="delegates.md#delegate-declarations">Delegate declarations</a>).</p>
<pre class="highlight plaintext"><code>type_declaration
    : class_declaration
    | struct_declaration
    | interface_declaration
    | enum_declaration
    | delegate_declaration
    ;
</code></pre>
<p>A <em>type_declaration</em> can occur as a top-level declaration in a compilation unit or as a member declaration within a namespace, class, or struct.</p>

<p>When a type declaration for a type <code class="prettyprint">T</code> occurs as a top-level declaration in a compilation unit, the fully qualified name of the newly declared type is simply <code class="prettyprint">T</code>. When a type declaration for a type <code class="prettyprint">T</code> occurs within a namespace, class, or struct, the fully qualified name of the newly declared type is <code class="prettyprint">N.T</code>, where <code class="prettyprint">N</code> is the fully qualified name of the containing namespace, class, or struct.</p>

<p>A type declared within a class or struct is called a nested type (<a href="classes.md#nested-types">Nested types</a>).</p>

<p>The permitted access modifiers and the default access for a type declaration depend on the context in which the declaration takes place (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>):</p>

<ul>
<li> Types declared in compilation units or namespaces can have <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> access. The default is <code class="prettyprint">internal</code> access.</li>
<li> Types declared in classes can have <code class="prettyprint">public</code>, <code class="prettyprint">protected internal</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> access. The default is <code class="prettyprint">private</code> access.</li>
<li> Types declared in structs can have <code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> access. The default is <code class="prettyprint">private</code> access.</li>
</ul>

<h2 id="namespace-alias-qualifiers">Namespace alias qualifiers</h2>

<p>The <strong><em>namespace alias qualifier</em></strong> <code class="prettyprint">::</code> makes it possible to guarantee that type name lookups are unaffected by the introduction of new types and members. The namespace alias qualifier always appears between two identifiers referred to as the left-hand and right-hand identifiers. Unlike the regular <code class="prettyprint">.</code> qualifier, the left-hand identifier of the <code class="prettyprint">::</code> qualifier is looked up only as an extern or using alias.</p>

<p>A <em>qualified_alias_member</em> is defined as follows:</p>
<pre class="highlight plaintext"><code>qualified_alias_member
    : identifier '::' identifier type_argument_list?
    ;
</code></pre>
<p>A <em>qualified_alias_member</em> can be used as a <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) or as the left operand in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>).</p>

<p>A <em>qualified_alias_member</em> has one of two forms:</p>

<ul>
<li> <code class="prettyprint">N::I&lt;A1, ..., Ak&gt;</code>, where <code class="prettyprint">N</code> and <code class="prettyprint">I</code> represent identifiers, and <code class="prettyprint">&lt;A1, ..., Ak&gt;</code> is a type argument list. (<code class="prettyprint">K</code> is always at least one.)</li>
<li> <code class="prettyprint">N::I</code>, where <code class="prettyprint">N</code> and <code class="prettyprint">I</code> represent identifiers. (In this case, <code class="prettyprint">K</code> is considered to be zero.)</li>
</ul>

<p>Using this notation, the meaning of a <em>qualified_alias_member</em> is determined as follows:</p>

<ul>
<li><p>If <code class="prettyprint">N</code> is the identifier <code class="prettyprint">global</code>, then the global namespace is searched for <code class="prettyprint">I</code>:</p>

<ul>
<li>If the global namespace contains a namespace namedÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code> is zero, then the <em>qualified_alias_member</em> refers to that namespace.</li>
<li>Otherwise, if the global namespace contains a non-generic type namedÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code> is zero, then the <em>qualified_alias_member</em> refers to that type.</li>
<li>Otherwise, if the global namespace contains a type namedÂ <code class="prettyprint">I</code> that has <code class="prettyprint">K</code>Â type parameters, then the <em>qualified_alias_member</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, the <em>qualified_alias_member</em> is undefined and a compile-time error occurs.</li>
</ul></li>
<li><p>Otherwise, starting with the namespace declaration (<a href="namespaces.md#namespace-declarations">Namespace declarations</a>) immediately containing the <em>qualified_alias_member</em> (if any), continuing with each enclosing namespace declaration (if any), and ending with the compilation unit containing the <em>qualified_alias_member</em>, the following steps are evaluated until an entity is located:</p>

<ul>
<li>If the namespace declaration or compilation unit contains a <em>using_alias_directive</em> that associates <code class="prettyprint">N</code> with a type, then the <em>qualified_alias_member</em> is undefined and a compile-time error occurs.</li>
<li>Otherwise, if the namespace declaration or compilation unit contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates <code class="prettyprint">N</code> with a namespace, then:

<ul>
<li>If the namespace associated with <code class="prettyprint">N</code> contains a namespace namedÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code> is zero, then the <em>qualified_alias_member</em> refers to that namespace.</li>
<li>Otherwise, if the namespace associated with <code class="prettyprint">N</code> contains a non-generic type namedÂ <code class="prettyprint">I</code> and <code class="prettyprint">K</code> is zero, then the <em>qualified_alias_member</em> refers to that type.</li>
<li>Otherwise, if the namespace associated with <code class="prettyprint">N</code> contains a type namedÂ <code class="prettyprint">I</code> that has <code class="prettyprint">K</code>Â type parameters, then the <em>qualified_alias_member</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, the <em>qualified_alias_member</em> is undefined and a compile-time error occurs.</li>
</ul></li>
</ul></li>
<li><p>Otherwise, the <em>qualified_alias_member</em> is undefined and a compile-time error occurs.</p></li>
</ul>

<p>Note that using the namespace alias qualifier with an alias that references a type causes a compile-time error. Also note that if the identifierÂ <code class="prettyprint">N</code> is <code class="prettyprint">global</code>, then lookup is performed in the global namespace, even if there is a using alias associating <code class="prettyprint">global</code> with a type or namespace.</p>

<h3 id="uniqueness-of-aliases">Uniqueness of aliases</h3>

<p>Each compilation unit and namespace body has a separate declaration space for extern aliases and using aliases. Thus, while the name of an extern alias or using alias must be unique within the set of extern aliases and using aliases declared in the immediately containing compilation unit or namespace body, an alias is permitted to have the same name as a type or namespace as long as it is used only with the <code class="prettyprint">::</code> qualifier.</p>

<p>In the example
&ldquo;`csharp
namespace N
{
    public class A {}</p>

<p>public class B {}
}</p>

<p>namespace N
{
    using A = System.IO;</p>

<p>class X
    {
        A.Stream s1;            // Error, A is ambiguous</p>

<p>A::Stream s2;           // Ok
    }
}
&rdquo;<code class="prettyprint">
the name</code>A<code class="prettyprint">has two possible meanings in the second namespace body because both the class</code>A<code class="prettyprint">and the using alias</code>A<code class="prettyprint">are in scope. For this reason, use of</code>A<code class="prettyprint">in the qualified name</code>A.Stream<code class="prettyprint">is ambiguous and causes a compile-time error to occur. However, use of</code>A<code class="prettyprint">with the</code>::<code class="prettyprint">qualifier is not an error because</code>A` is looked up only as a namespace alias.</p>

          <h1 id="classes">Classes</h1>

<p>A class is a data structure that may contain data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types. Class types support inheritance, a mechanism whereby a derived class can extend and specialize a base class.</p>

<h2 id="class-declarations">Class declarations</h2>

<p>A <em>class_declaration</em> is a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>) that declares a new class.</p>
<pre class="highlight plaintext"><code>class_declaration
    : attributes? class_modifier* 'partial'? 'class' identifier type_parameter_list?
      class_base? type_parameter_constraints_clause* class_body ';'?
    ;
</code></pre>
<p>A <em>class_declaration</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), followed by an optional set of <em>class_modifier*s (<a href="classes.md#class-modifiers">Class modifiers</a>), followed by an optional <code class="prettyprint">partial</code> modifier, followed by the keyword <code class="prettyprint">class</code> and an *identifier</em> that names the class, followed by an optional <em>type_parameter_list</em> (<a href="classes.md#type-parameters">Type parameters</a>), followed by an optional <em>class_base</em> specification (<a href="classes.md#class-base-specification">Class base specification</a>) , followed by an optional set of <em>type_parameter_constraints_clause*s (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), followed by a *class_body</em> (<a href="classes.md#class-body">Class body</a>), optionally followed by a semicolon.</p>

<p>A class declaration cannot supply <em>type_parameter_constraints_clause*s unless it also supplies a *type_parameter_list</em>.</p>

<p>A class declaration that supplies a <em>type_parameter_list</em> is a <strong><em>generic class declaration</em></strong>. Additionally, any class nested inside a generic class declaration or a generic struct declaration is itself a generic class declaration, since type parameters for the containing type must be supplied to create a constructed type.</p>

<h3 id="class-modifiers">Class modifiers</h3>

<p>A <em>class_declaration</em> may optionally include a sequence of class modifiers:</p>
<pre class="highlight plaintext"><code>class_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'abstract'
    | 'sealed'
    | 'static'
    | class_modifier_unsafe
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in a class declaration.</p>

<p>The <code class="prettyprint">new</code> modifier is permitted on nested classes. It specifies that the class hides an inherited member by the same name, as described in <a href="classes.md#the-new-modifier">The new modifier</a>. It is a compile-time error for the <code class="prettyprint">new</code> modifier to appear on a class declaration that is not a nested class declaration.</p>

<p>The <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers control the accessibility of the class. Depending on the context in which the class declaration occurs, some of these modifiers may not be permitted (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<p>The <code class="prettyprint">abstract</code>, <code class="prettyprint">sealed</code> and <code class="prettyprint">static</code> modifiers are discussed in the following sections.</p>

<h4 id="abstract-classes">Abstract classes</h4>

<p>The <code class="prettyprint">abstract</code> modifier is used to indicate that a class is incomplete and that it is intended to be used only as a base class. An abstract class differs from a non-abstract class in the following ways:</p>

<ul>
<li> An abstract class cannot be instantiated directly, and it is a compile-time error to use the <code class="prettyprint">new</code> operator on an abstract class. While it is possible to have variables and values whose compile-time types are abstract, such variables and values will necessarily either be <code class="prettyprint">null</code> or contain references to instances of non-abstract classes derived from the abstract types.</li>
<li> An abstract class is permitted (but not required) to contain abstract members.</li>
<li> An abstract class cannot be sealed.</li>
</ul>

<p>When a non-abstract class is derived from an abstract class, the non-abstract class must include actual implementations of all inherited abstract members, thereby overriding those abstract members. In the example
&ldquo;`csharp
abstract class A
{
    public abstract void F();
}</p>

<p>abstract class B: A
{
    public void G() {}
}</p>

<p>class C: B
{
    public override void F() {
        // actual implementation of F
    }
}
&rdquo;<code class="prettyprint">
the abstract class</code>A<code class="prettyprint">introduces an abstract method</code>F<code class="prettyprint">. Class</code>B<code class="prettyprint">introduces an additional method</code>G<code class="prettyprint">, but since it doesn&#39;t provide an implementation of</code>F<code class="prettyprint">,</code>B<code class="prettyprint">must also be declared abstract. Class</code>C<code class="prettyprint">overrides</code>F<code class="prettyprint">and provides an actual implementation. Since there are no abstract members in</code>C<code class="prettyprint">,</code>C` is permitted (but not required) to be non-abstract.</p>

<h4 id="sealed-classes">Sealed classes</h4>

<p>The <code class="prettyprint">sealed</code> modifier is used to prevent derivation from a class. A compile-time error occurs if a sealed class is specified as the base class of another class.</p>

<p>A sealed class cannot also be an abstract class.</p>

<p>The <code class="prettyprint">sealed</code> modifier is primarily used to prevent unintended derivation, but it also enables certain run-time optimizations. In particular, because a sealed class is known to never have any derived classes, it is possible to transform virtual function member invocations on sealed class instances into non-virtual invocations.</p>

<h4 id="static-classes">Static classes</h4>

<p>The <code class="prettyprint">static</code> modifier is used to mark the class being declared as a <strong><em>static class</em></strong>. A static class cannot be instantiated, cannot be used as a type and can contain only static members. Only a static class can contain declarations of extension methods (<a href="classes.md#extension-methods">Extension methods</a>).</p>

<p>A static class declaration is subject to the following restrictions:</p>

<ul>
<li> A static class may not include a <code class="prettyprint">sealed</code> or <code class="prettyprint">abstract</code> modifier. Note, however, that since a static class cannot be instantiated or derived from, it behaves as if it was both sealed and abstract.</li>
<li> A static class may not include a <em>class_base</em> specification (<a href="classes.md#class-base-specification">Class base specification</a>) and cannot explicitly specify a base class or a list of implemented interfaces. A static class implicitly inherits from type <code class="prettyprint">object</code>.</li>
<li> A static class can only contain static members (<a href="classes.md#static-and-instance-members">Static and instance members</a>). Note that constants and nested types are classified as static members.</li>
<li> A static class cannot have members with <code class="prettyprint">protected</code> or <code class="prettyprint">protected internal</code> declared accessibility.</li>
</ul>

<p>It is a compile-time error to violate any of these restrictions.</p>

<p>A static class has no instance constructors. It is not possible to declare an instance constructor in a static class, and no default instance constructor (<a href="classes.md#default-constructors">Default constructors</a>) is provided for a static class.</p>

<p>The members of a static class are not automatically static, and the member declarations must explicitly include a <code class="prettyprint">static</code> modifier (except for constants and nested types). When a class is nested within a static outer class, the nested class is not a static class unless it explicitly includes a <code class="prettyprint">static</code> modifier.</p>

<p><strong>Referencing static class types</strong></p>

<p>A <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) is permitted to reference a static class if</p>

<ul>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>namespace_or_type_name</em> of the form <code class="prettyprint">T.I</code>, or</li>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>typeof_expression</em> (<a href="expressions.md#argument-lists">Argument lists</a>1) of the form <code class="prettyprint">typeof(T)</code>.</li>
</ul>

<p>A <em>primary_expression</em> (<a href="expressions.md#function-members">Function members</a>) is permitted to reference a static class if</p>

<ul>
<li> The <em>primary_expression</em> is the <code class="prettyprint">E</code> in a <em>member_access</em> (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) of the form <code class="prettyprint">E.I</code>.</li>
</ul>

<p>In any other context it is a compile-time error to reference a static class. For example, it is an error for a static class to be used as a base class, a constituent type (<a href="classes.md#nested-types">Nested types</a>) of a member, a generic type argument, or a type parameter constraint. Likewise, a static class cannot be used in an array type, a pointer type, a <code class="prettyprint">new</code> expression, a cast expression, an <code class="prettyprint">is</code> expression, an <code class="prettyprint">as</code> expression, a <code class="prettyprint">sizeof</code> expression, or a default value expression.</p>

<h3 id="partial-modifier">Partial modifier</h3>

<p>The <code class="prettyprint">partial</code> modifier is used to indicate that this <em>class_declaration</em> is a partial type declaration. Multiple partial type declarations with the same name within an enclosing namespace or type declaration combine to form one type declaration, following the rules specified in <a href="classes.md#partial-types">Partial types</a>.</p>

<p>Having the declaration of a class distributed over separate segments of program text can be useful if these segments are produced or maintained in different contexts. For instance, one part of a class declaration may be machine generated, whereas the other is manually authored. Textual separation of the two prevents updates by one from conflicting with updates by the other.</p>

<h3 id="type-parameters">Type parameters</h3>

<p>A type parameter is a simple identifier that denotes a placeholder for a type argument supplied to create a constructed type. A type parameter is a formal placeholder for a type that will be supplied later. By constrast, a type argument (<a href="types.md#type-arguments">Type arguments</a>) is the actual type that is substituted for the type parameter when a constructed type is created.</p>
<pre class="highlight plaintext"><code>type_parameter_list
    : '&lt;' type_parameters '&gt;'
    ;

type_parameters
    : attributes? type_parameter
    | type_parameters ',' attributes? type_parameter
    ;

type_parameter
    : identifier
    ;
</code></pre>
<p>Each type parameter in a class declaration defines a name in the declaration space (<a href="basic-concepts.md#declarations">Declarations</a>) of that class. Thus, it cannot have the same name as another type parameter or a member declared in that class. A type parameter cannot have the same name as the type itself.</p>

<h3 id="class-base-specification">Class base specification</h3>

<p>A class declaration may include a <em>class_base</em> specification, which defines the direct base class of the class and the interfaces (<a href="interfaces.md#interfaces">Interfaces</a>) directly implemented by the class.</p>
<pre class="highlight plaintext"><code>class_base
    : ':' class_type
    | ':' interface_type_list
    | ':' class_type ',' interface_type_list
    ;

interface_type_list
    : interface_type (',' interface_type)*
    ;
</code></pre>
<p>The base class specified in a class declaration can be a constructed class type (<a href="types.md#constructed-types">Constructed types</a>). A base class cannot be a type parameter on its own, though it can involve the type parameters that are in scope.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Extend</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;:</span> <span class="n">V</span> <span class="p">{}</span>            <span class="c1">// Error, type parameter used as base class</span>
</code></pre>
<h4 id="base-classes">Base classes</h4>

<p>When a <em>class_type</em> is included in the <em>class_base</em>, it specifies the direct base class of the class being declared. If a class declaration has no <em>class_base</em>, or if the <em>class_base</em> lists only interface types, the direct base class is assumed to be <code class="prettyprint">object</code>. A class inherits members from its direct base class, as described in <a href="classes.md#inheritance">Inheritance</a>.</p>

<p>In the example
&ldquo;`csharp
class A {}</p>

<p>class B: A {}
&rdquo;<code class="prettyprint">
class</code>A<code class="prettyprint">is said to be the direct base class of</code>B<code class="prettyprint">, and</code>B<code class="prettyprint">is said to be derived from</code>A<code class="prettyprint">. Since</code>A<code class="prettyprint">does not explicitly specify a direct base class, its direct base class is implicitly</code>object`.</p>

<p>For a constructed class type, if a base class is specified in the generic class declaration, the base class of the constructed type is obtained by substituting, for each <em>type_parameter</em> in the base class declaration, the corresponding <em>type_argument</em> of the constructed type. Given the generic class declarations
&ldquo;`csharp
class B<U,V> {&hellip;}</p>

<p>class G<T>: B<string,T[]> {&hellip;}
&rdquo;<code class="prettyprint">
the base class of the constructed type</code>G<int><code class="prettyprint">would be</code>B<string,int[]>`.</p>

<p>The direct base class of a class type must be at least as accessible as the class type itself (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>). For example, it is a compile-time error for a <code class="prettyprint">public</code> class to derive from a <code class="prettyprint">private</code> or <code class="prettyprint">internal</code> class.</p>

<p>The direct base class of a class type must not be any of the following types: <code class="prettyprint">System.Array</code>, <code class="prettyprint">System.Delegate</code>, <code class="prettyprint">System.MulticastDelegate</code>, <code class="prettyprint">System.Enum</code>, or <code class="prettyprint">System.ValueType</code>. Furthermore, a generic class declaration cannot use <code class="prettyprint">System.Attribute</code> as a direct or indirect base class.</p>

<p>While determining the meaning of the direct base class specification <code class="prettyprint">A</code> of a class <code class="prettyprint">B</code>, the direct base class of <code class="prettyprint">B</code> is temporarily assumed to be <code class="prettyprint">object</code>. Intuitively this ensures that the meaning of a base class specification cannot recursively depend on itself. The example:
&ldquo;`csharp
class A<T> {
   public class B {}
}</p>

<p>class C : A<C.B> {}
&rdquo;<code class="prettyprint">
is in error since in the base class specification</code>A<C.B><code class="prettyprint">the direct base class of</code>C<code class="prettyprint">is considered to be</code>object<code class="prettyprint">, and hence (by the rules of [Namespace and type names](basic-concepts.md#namespace-and-type-names))</code>C<code class="prettyprint">is not considered to have a member</code>B`.</p>

<p>The base classes of a class type are the direct base class and its base classes. In other words, the set of base classes is the transitive closure of the direct base class relationship. Referring to the example above, the base classes of <code class="prettyprint">B</code> are <code class="prettyprint">A</code> and <code class="prettyprint">object</code>. In the example
&ldquo;`csharp
class A {&hellip;}</p>

<p>class B<T>: A {&hellip;}</p>

<p>class C<T>: B<IComparable<T>&gt; {&hellip;}</p>

<p>class D<T>: C<T[]> {&hellip;}
&rdquo;<code class="prettyprint">
the base classes of</code>D<int><code class="prettyprint">are</code>C<int[]><code class="prettyprint">,</code>B<IComparable<int[]>&gt;<code class="prettyprint">,</code>A<code class="prettyprint">, and</code>object`.</p>

<p>Except for class <code class="prettyprint">object</code>, every class type has exactly one direct base class. The <code class="prettyprint">object</code> class has no direct base class and is the ultimate base class of all other classes.</p>

<p>When a class <code class="prettyprint">B</code> derives from a class <code class="prettyprint">A</code>, it is a compile-time error for <code class="prettyprint">A</code> to depend on <code class="prettyprint">B</code>. A class <strong><em>directly depends on</em></strong> its direct base class (if any) and <strong><em>directly depends on</em></strong> the class within which it is immediately nested (if any). Given this definition, the complete set of classes upon which a class depends is the reflexive and transitive closure of the <strong><em>directly depends on</em></strong> relationship.</p>

<p>The example
<code class="prettyprint">csharp
class A: A {}
</code>
is erroneous because the class depends on itself. Likewise, the example
<code class="prettyprint">csharp
class A: B {}
class B: C {}
class C: A {}
</code>
is in error because the classes circularly depend on themselves. Finally, the example
&ldquo;`csharp
class A: B.C {}</p>

<p>class B: A
{
    public class C {}
}
&rdquo;<code class="prettyprint">
results in a compile-time error because</code>A<code class="prettyprint">depends on</code>B.C<code class="prettyprint">(its direct base class), which depends on</code>B<code class="prettyprint">(its immediately enclosing class), which circularly depends on</code>A`.</p>

<p>Note that a class does not depend on the classes that are nested within it. In the example
<code class="prettyprint">csharp
class A
{
    class B: A {}
}
</code>
<code class="prettyprint">B</code> depends on <code class="prettyprint">A</code> (because <code class="prettyprint">A</code> is both its direct base class and its immediately enclosing class), but <code class="prettyprint">A</code> does not depend on <code class="prettyprint">B</code> (since <code class="prettyprint">B</code> is neither a base class nor an enclosing class of <code class="prettyprint">A</code>). Thus, the example is valid.</p>

<p>It is not possible to derive from a <code class="prettyprint">sealed</code> class. In the example
&ldquo;`csharp
sealed class A {}</p>

<p>class B: A {}            // Error, cannot derive from a sealed class
&rdquo;<code class="prettyprint">
class</code>B<code class="prettyprint">is in error because it attempts to derive from the</code>sealed<code class="prettyprint">class</code>A`.</p>

<h4 id="interface-implementations">Interface implementations</h4>

<p>A <em>class_base</em> specification may include a list of interface types, in which case the class is said to directly implement the given interface types. Interface implementations are discussed further in <a href="interfaces.md#interface-implementations">Interface implementations</a>.</p>

<h3 id="type-parameter-constraints">Type parameter constraints</h3>

<p>Generic type and method declarations can optionally specify type parameter constraints by including *type_parameter_constraints_clause*s.</p>
<pre class="highlight plaintext"><code>type_parameter_constraints_clause
    : 'where' type_parameter ':' type_parameter_constraints
    ;

type_parameter_constraints
    : primary_constraint
    | secondary_constraints
    | constructor_constraint
    | primary_constraint ',' secondary_constraints
    | primary_constraint ',' constructor_constraint
    | secondary_constraints ',' constructor_constraint
    | primary_constraint ',' secondary_constraints ',' constructor_constraint
    ;

primary_constraint
    : class_type
    | 'class'
    | 'struct'
    ;

secondary_constraints
    : interface_type
    | type_parameter
    | secondary_constraints ',' interface_type
    | secondary_constraints ',' type_parameter
    ;

constructor_constraint
    : 'new' '(' ')'
    ;
</code></pre>
<p>Each <em>type_parameter_constraints_clause</em> consists of the token <code class="prettyprint">where</code>, followed by the name of a type parameter, followed by a colon and the list of constraints for that type parameter. There can be at most one <code class="prettyprint">where</code> clause for each type parameter, and the <code class="prettyprint">where</code> clauses can be listed in any order. Like the <code class="prettyprint">get</code> and <code class="prettyprint">set</code> tokens in a property accessor, the <code class="prettyprint">where</code> token is not a keyword.</p>

<p>The list of constraints given in a <code class="prettyprint">where</code> clause can include any of the following components, in this order: a single primary constraint, one or more secondary constraints, and the constructor constraint, <code class="prettyprint">new()</code>.</p>

<p>A primary constraint can be a class type or the <strong><em>reference type constraint</em></strong> <code class="prettyprint">class</code> or the <strong><em>value type constraint</em></strong> <code class="prettyprint">struct</code>. A secondary constraint can be a <em>type_parameter</em> or <em>interface_type</em>.</p>

<p>The reference type constraint specifies that a type argument used for the type parameter must be a reference type. All class types, interface types, delegate types, array types, and type parameters known to be a reference type (as defined below) satisfy this constraint.</p>

<p>The value type constraint specifies that a type argument used for the type parameter must be a non-nullable value type. All non-nullable struct types, enum types, and type parameters having the value type constraint satisfy this constraint. Note that although classified as a value type, a nullable type (<a href="types.md#nullable-types">Nullable types</a>) does not satisfy the value type constraint. A type parameter having the value type constraint cannot also have the <em>constructor_constraint</em>.</p>

<p>Pointer types are never allowed to be type arguments and are not considered to satisfy either the reference type or value type constraints.</p>

<p>If a constraint is a class type, an interface type, or a type parameter, that type specifies a minimal &ldquo;base type&rdquo; that every type argument used for that type parameter must support. Whenever a constructed type or generic method is used, the type argument is checked against the constraints on the type parameter at compile-time. The type argument supplied must satisfy the conditions described in <a href="types.md#satisfying-constraints">Satisfying constraints</a>.</p>

<p>A <em>class_type</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be a class type.</li>
<li> The type must not be <code class="prettyprint">sealed</code>.</li>
<li> The type must not be one of the following types: <code class="prettyprint">System.Array</code>, <code class="prettyprint">System.Delegate</code>, <code class="prettyprint">System.Enum</code>, or <code class="prettyprint">System.ValueType</code>.</li>
<li> The type must not be <code class="prettyprint">object</code>. Because all types derive from <code class="prettyprint">object</code>, such a constraint would have no effect if it were permitted.</li>
<li> At most one constraint for a given type parameter can be a class type.</li>
</ul>

<p>A type specified as an <em>interface_type</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be an interface type.</li>
<li> A type must not be specified more than once in a given <code class="prettyprint">where</code> clause.</li>
</ul>

<p>In either case, the constraint can involve any of the type parameters of the associated type or method declaration as part of a constructed type, and can involve the type being declared.</p>

<p>Any class or interface type specified as a type parameter constraint must be at least as accessible (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>) as the generic type or method being declared.</p>

<p>A type specified as a <em>type_parameter</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be a type parameter.</li>
<li> A type must not be specified more than once in a given <code class="prettyprint">where</code> clause.</li>
</ul>

<p>In addition there must be no cycles in the dependency graph of type parameters, where dependency is a transitive relation defined by:</p>

<ul>
<li> If a type parameter <code class="prettyprint">T</code> is used as a constraint for type parameter <code class="prettyprint">S</code> then <code class="prettyprint">S</code> <strong><em>depends on</em></strong> <code class="prettyprint">T</code>.</li>
<li> If a type parameter <code class="prettyprint">S</code> depends on a type parameter <code class="prettyprint">T</code> and <code class="prettyprint">T</code> depends on a type parameter <code class="prettyprint">U</code> then <code class="prettyprint">S</code> <strong><em>depends on</em></strong> <code class="prettyprint">U</code>.</li>
</ul>

<p>Given this relation, it is a compile-time error for a type parameter to depend on itself (directly or indirectly).</p>

<p>Any constraints must be consistent among dependent type parameters. If type parameter <code class="prettyprint">S</code> depends on type parameter <code class="prettyprint">T</code> then:</p>

<ul>
<li> <code class="prettyprint">T</code> must not have the value type constraint. Otherwise, <code class="prettyprint">T</code> is effectively sealed so <code class="prettyprint">S</code> would be forced to be the same type as <code class="prettyprint">T</code>, eliminating the need for two type parameters.</li>
<li> If <code class="prettyprint">S</code> has the value type constraint then <code class="prettyprint">T</code> must not have a <em>class_type</em> constraint.</li>
<li> If <code class="prettyprint">S</code> has a <em>class_type</em> constraint <code class="prettyprint">A</code> and <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">B</code> then there must be an identity conversion or implicit reference conversion from <code class="prettyprint">A</code> to <code class="prettyprint">B</code> or an implicit reference conversion from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</li>
<li> If <code class="prettyprint">S</code> also depends on type parameter <code class="prettyprint">U</code> and <code class="prettyprint">U</code> has a <em>class_type</em> constraint <code class="prettyprint">A</code> and <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">B</code> then there must be an identity conversion or implicit reference conversion from <code class="prettyprint">A</code> to <code class="prettyprint">B</code> or an implicit reference conversion from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</li>
</ul>

<p>It is valid for <code class="prettyprint">S</code> to have the value type constraint and <code class="prettyprint">T</code> to have the reference type constraint. Effectively this limits <code class="prettyprint">T</code> to the types <code class="prettyprint">System.Object</code>, <code class="prettyprint">System.ValueType</code>, <code class="prettyprint">System.Enum</code>, and any interface type.</p>

<p>If the <code class="prettyprint">where</code> clause for a type parameter includes a constructor constraint (which has the form <code class="prettyprint">new()</code>), it is possible to use the <code class="prettyprint">new</code> operator to create instances of the type (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>). Any type argument used for a type parameter with a constructor constraint must have a public parameterless constructor (this constructor implicitly exists for any value type) or be a type parameter having the value type constraint or constructor constraint (see <a href="classes.md#type-parameter-constraints">Type parameter constraints</a> for details).</p>

<p>The following are examples of constraints:
&ldquo;`csharp
interface IPrintable
{
    void Print();
}</p>

<p>interface IComparable<T>
{
    int CompareTo(T value);
}</p>

<p>interface IKeyProvider<T>
{
    T GetKey();
}</p>

<p>class Printer<T> where T: IPrintable {&hellip;}</p>

<p>class SortedList<T> where T: IComparable<T> {&hellip;}</p>

<p>class Dictionary<K,V>
    where K: IComparable<K>
    where V: IPrintable, IKeyProvider<K>, new()
{
    &hellip;
}
&rdquo;`</p>

<p>The following example is in error because it causes a circularity in the dependency graph of the type parameters:
<code class="prettyprint">csharp
class Circular&lt;S,T&gt;
    where S: T
    where T: S                // Error, circularity in dependency graph
{
    ...
}
</code></p>

<p>The following examples illustrate additional invalid situations:
&ldquo;`csharp
class Sealed<S,T>
    where S: T
    where T: struct        // Error, T is sealed
{
    &hellip;
}</p>

<p>class A {&hellip;}</p>

<p>class B {&hellip;}</p>

<p>class Incompat<S,T>
    where S: A, T
    where T: B                // Error, incompatible class-type constraints
{
    &hellip;
}</p>

<p>class StructWithClass<S,T,U>
    where S: struct, T
    where T: U
    where U: A                // Error, A incompatible with struct
{
    &hellip;
}
&rdquo;`</p>

<p>The <strong><em>effective base class</em></strong> of a type parameter <code class="prettyprint">T</code> is defined as follows:</p>

<ul>
<li> If <code class="prettyprint">T</code> has no primary constraints or type parameter constraints, its effective base class is <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> has the value type constraint, its effective base class is <code class="prettyprint">System.ValueType</code>.</li>
<li> If <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">C</code> but no <em>type_parameter</em> constraints, its effective base class is <code class="prettyprint">C</code>.</li>
<li> If <code class="prettyprint">T</code> has no <em>class_type</em> constraint but has one or more <em>type_parameter</em> constraints, its effective base class is the most encompassed type (<a href="conversions.md#lifted-conversion-operators">Lifted conversion operators</a>) in the set of effective base classes of its <em>type_parameter</em> constraints. The consistency rules ensure that such a most encompassed type exists.</li>
<li> If <code class="prettyprint">T</code> has both a <em>class_type</em> constraint and one or more <em>type_parameter</em> constraints, its effective base class is the most encompassed type (<a href="conversions.md#lifted-conversion-operators">Lifted conversion operators</a>) in the set consisting of the <em>class_type</em> constraint of <code class="prettyprint">T</code> and the effective base classes of its <em>type_parameter</em> constraints. The consistency rules ensure that such a most encompassed type exists.</li>
<li> If <code class="prettyprint">T</code> has the reference type constraint but no <em>class_type</em> constraints, its effective base class is <code class="prettyprint">object</code>.</li>
</ul>

<p>For the purpose of these rules, if T has a constraint <code class="prettyprint">V</code> that is a <em>value_type</em>, use instead the most specific base type of <code class="prettyprint">V</code> that is a <em>class_type</em>. This can never happen in an explicitly given constraint, but may occur when the constraints of a generic method are implicitly inherited by an overriding method declaration or an explicit implementation of an interface method.</p>

<p>These rules ensure that the effective base class is always a <em>class_type</em>.</p>

<p>The <strong><em>effective interface set</em></strong> of a type parameter <code class="prettyprint">T</code> is defined as follows:</p>

<ul>
<li> If <code class="prettyprint">T</code> has no <em>secondary_constraints</em>, its effective interface set is empty.</li>
<li> If <code class="prettyprint">T</code> has <em>interface_type</em> constraints but no <em>type_parameter</em> constraints, its effective interface set is its set of <em>interface_type</em> constraints.</li>
<li> If <code class="prettyprint">T</code> has no <em>interface_type</em> constraints but has <em>type_parameter</em> constraints, its effective interface set is the union of the effective interface sets of its <em>type_parameter</em> constraints.</li>
<li> If <code class="prettyprint">T</code> has both <em>interface_type</em> constraints and <em>type_parameter</em> constraints, its effective interface set is the union of its set of <em>interface_type</em> constraints and the effective interface sets of its <em>type_parameter</em> constraints.</li>
</ul>

<p>A type parameter is <strong><em>known to be a reference type</em></strong> if it has the reference type constraint or its effective base class is not <code class="prettyprint">object</code> or <code class="prettyprint">System.ValueType</code>.</p>

<p>Values of a constrained type parameter type can be used to access the instance members implied by the constraints. In the example
&ldquo;`csharp
interface IPrintable
{
    void Print();
}</p>

<p>class Printer<T> where T: IPrintable
{
    void PrintOne(T x) {
        x.Print();
    }
}
&rdquo;<code class="prettyprint">
the methods of</code>IPrintable<code class="prettyprint">can be invoked directly on</code>x<code class="prettyprint">because</code>T<code class="prettyprint">is constrained to always implement</code>IPrintable`.</p>

<h3 id="class-body">Class body</h3>

<p>The <em>class_body</em> of a class defines the members of that class.</p>
<pre class="highlight plaintext"><code>class_body
    : '{' class_member_declaration* '}'
    ;
</code></pre>
<h2 id="partial-types">Partial types</h2>

<p>A type declaration can be split across multiple <strong><em>partial type declarations</em></strong>. The type declaration is constructed from its parts by following the rules in this section, whereupon it is treated as a single declaration during the remainder of the compile-time and run-time processing of the program.</p>

<p>A <em>class_declaration</em>, <em>struct_declaration</em> or <em>interface_declaration</em> represents a partial type declaration if it includes a <code class="prettyprint">partial</code> modifier. <code class="prettyprint">partial</code> is not a keyword, and only acts as a modifier if it appears immediately before one of the keywords <code class="prettyprint">class</code>, <code class="prettyprint">struct</code> or <code class="prettyprint">interface</code> in a type declaration, or before the type <code class="prettyprint">void</code> in a method declaration. In other contexts it can be used as a normal identifier.</p>

<p>Each part of a partial type declaration must include a <code class="prettyprint">partial</code> modifier. It must have the same name  and be declared in the same namespace or type declaration as the other parts. The <code class="prettyprint">partial</code> modifier indicates that additional parts of the type declaration may exist elsewhere, but the existence of such additional parts is not a requirement; it is valid for a type with a single declaration to include the <code class="prettyprint">partial</code> modifier.</p>

<p>All parts of a partial type must be compiled together such that the parts can be merged at compile-time into a single type declaration. Partial types specifically do not allow already compiled types to be extended.</p>

<p>Nested types may be declared in multiple parts by using the <code class="prettyprint">partial</code> modifier. Typically, the containing type is declared using <code class="prettyprint">partial</code> as well, and each part of the nested type is declared in a different part of the containing type.</p>

<p>The <code class="prettyprint">partial</code> modifier is not permitted on delegate or enum declarations.</p>

<h3 id="attributes">Attributes</h3>

<p>The attributes of a partial type are determined by combining, in an unspecified order, the attributes of each of the parts. If an attribute is placed on multiple parts, it is equivalent to specifying the attribute multiple times on the type. For example, the two parts:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Attr1, Attr2("hello")]</span>
<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>

<span class="na">[Attr3, Attr2("goodbye")]</span>
<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>
</code></pre>
<p>are equivalent to a declaration such as:
<code class="prettyprint">csharp
[Attr1, Attr2(&quot;hello&quot;), Attr3, Attr2(&quot;goodbye&quot;)]
class A {}
</code></p>

<p>Attributes on type parameters combine in a similar fashion.</p>

<h3 id="modifiers">Modifiers</h3>

<p>When a partial type declaration includes an accessibility specification (the <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers) it must agree with all other parts that include an accessibility specification. If no part of a partial type includes an accessibility specification, the type is given the appropriate default accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<p>If one or more partial declarations of a nested type include a <code class="prettyprint">new</code> modifier, no warning is reported if the nested type hides an inherited member (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>).</p>

<p>If one or more partial declarations of a class include an <code class="prettyprint">abstract</code> modifier, the class is considered abstract (<a href="classes.md#abstract-classes">Abstract classes</a>). Otherwise, the class is considered non-abstract.</p>

<p>If one or more partial declarations of a class include a <code class="prettyprint">sealed</code> modifier, the class is considered sealed (<a href="classes.md#sealed-classes">Sealed classes</a>). Otherwise, the class is considered unsealed.</p>

<p>Note that a class cannot be both abstract and sealed.</p>

<p>When the <code class="prettyprint">unsafe</code> modifier is used on a partial type declaration, only that particular part is considered an unsafe context (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>).</p>

<h3 id="type-parameters-and-constraints">Type parameters and constraints</h3>

<p>If a generic type is declared in multiple parts, each part must state the type parameters. Each part must have the same number of type parameters, and the same name for each type parameter, in order.</p>

<p>When a partial generic type declaration includes constraints (<code class="prettyprint">where</code> clauses), the constraints must agree with all other parts that include constraints. Specifically, each part that includes constraints must have constraints for the same set of type parameters, and for each type parameter the sets of primary, secondary, and constructor constraints must be equivalent. Two sets of constraints are equivalent if they contain the same members. If no part of a partial generic type specifies type parameter constraints, the type parameters are considered unconstrained.</p>

<p>The example
&ldquo;`csharp
partial class Dictionary<K,V>
    where K: IComparable<K>
    where V: IKeyProvider<K>, IPersistable
{
    &hellip;
}</p>

<p>partial class Dictionary<K,V>
    where V: IPersistable, IKeyProvider<K>
    where K: IComparable<K>
{
    &hellip;
}</p>

<p>partial class Dictionary<K,V>
{
    &hellip;
}
&rdquo;`
is correct because those parts that include constraints (the first two) effectively specify the same set of primary, secondary, and constructor constraints for the same set of type parameters, respectively.</p>

<h3 id="base-class">Base class</h3>

<p>When a partial class declaration includes a base class specification it must agree with all other parts that include a base class specification. If no part of a partial class includes a base class specification, the base class becomes <code class="prettyprint">System.Object</code> (<a href="classes.md#base-classes">Base classes</a>).</p>

<h3 id="base-interfaces">Base interfaces</h3>

<p>The set of base interfaces for a type declared in multiple parts is the union of the base interfaces specified on each part. A particular base interface may only be named once on each part, but it is permitted for multiple parts to name the same base interface(s). There must only be one implementation of the members of any given base interface.</p>

<p>In the example
&ldquo;`csharp
partial class C: IA, IB {&hellip;}</p>

<p>partial class C: IC {&hellip;}</p>

<p>partial class C: IA, IB {&hellip;}
&rdquo;<code class="prettyprint">
the set of base interfaces for class</code>C<code class="prettyprint">is</code>IA<code class="prettyprint">,</code>IB<code class="prettyprint">, and</code>IC`.</p>

<p>Typically, each part provides an implementation of the interface(s) declared on that part; however, this is not a requirement. A part may provide the implementation for an interface declared on a different part:
&ldquo;`csharp
partial class X
{
    int IComparable.CompareTo(object o) {&hellip;}
}</p>

<p>partial class X: IComparable
{
    &hellip;
}
&rdquo;`</p>

<h3 id="members">Members</h3>

<p>With the exception of partial methods (<a href="classes.md#partial-methods">Partial methods</a>), the set of members of a type declared in multiple parts is simply the union of the set of members declared in each part. The bodies of all parts of the type declaration share the same declaration space (<a href="basic-concepts.md#declarations">Declarations</a>), and the scope of each member (<a href="basic-concepts.md#scopes">Scopes</a>) extends to the bodies of all the parts. The accessibility domain of any member always includes all the parts of the enclosing type; a <code class="prettyprint">private</code> member declared in one part is freely accessible from another part. It is a compile-time error to declare the same member in more than one part of the type, unless that member is a type with the <code class="prettyprint">partial</code> modifier.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                     <span class="c1">// Error, cannot declare x more than once</span>

    <span class="k">partial</span> <span class="k">class</span> <span class="nc">Inner</span>        <span class="c1">// Ok, Inner is a partial type</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                     <span class="c1">// Error, cannot declare x more than once</span>

    <span class="k">partial</span> <span class="k">class</span> <span class="nc">Inner</span>        <span class="c1">// Ok, Inner is a partial type</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The ordering of members within a type is rarely significant to C# code, but may be significant when interfacing with other languages and environments. In these cases, the ordering of members within a type declared in multiple parts is undefined.</p>

<h3 id="partial-methods">Partial methods</h3>

<p>Partial methods can be defined in one part of a type declaration and implemented in another. The implementation is optional; if no part implements the partial method, the partial method declaration and all calls to it are removed from the type declaration resulting from the combination of the parts.</p>

<p>Partial methods cannot define access modifiers, but are implicitly <code class="prettyprint">private</code>. Their return type must be <code class="prettyprint">void</code>, and their parameters cannot have the <code class="prettyprint">out</code> modifier. The identifier <code class="prettyprint">partial</code> is recognized as a special keyword in a method declaration only if it appears right before the <code class="prettyprint">void</code> type; otherwise it can be used as a normal identifier. A partial method cannot explicitly implement interface methods.</p>

<p>There are two kinds of partial method declarations: If the body of the method declaration is a semicolon, the declaration is said to be a <strong><em>defining partial method declaration</em></strong>. If the body is given as a <em>block</em>, the declaration is said to be an <strong><em>implementing partial method declaration</em></strong>. Across the parts of a type declaration there can be only one defining partial method declaration with a given signature, and there can be only one implementing partial method declaration with a given signature. If an implementing partial method declaration is given, a corresponding defining partial method declaration must exist, and the declarations must match as specified in the following:</p>

<ul>
<li>The declarations must have the same modifiers (although not necessarily in the same order), method name, number of type parameters and number of parameters.</li>
<li>Corresponding parameters in the declarations must have the same modifiers (although not necessarily in the same order) and the same types (modulo differences in type parameter names).</li>
<li>Corresponding type parameters in the declarations must have the same constraints (modulo differences in type parameter names).</li>
</ul>

<p>An implementing partial method declaration can appear in the same part as the corresponding defining partial method declaration.</p>

<p>Only a defining partial method participates in overload resolution. Thus, whether or not an implementing declaration is given, invocation expressions may resolve to invocations of the partial method. Because a partial method always returns <code class="prettyprint">void</code>, such invocation expressions will always be expression statements. Furthermore, because a partial method is implicitly <code class="prettyprint">private</code>, such statements will always occur within one of the parts of the type declaration within which the partial method is declared.</p>

<p>If no part of a partial type declaration contains an implementing declaration for a given partial method, any expression statement invoking it is simply removed from the combined type declaration. Thus the invocation expression, including any constituent expressions, has no effect at run-time. The partial method itself is also removed and will not be a member of the combined type declaration.</p>

<p>If an implementing declaration exist for a given partial method, the invocations of the partial methods are retained. The partial method gives rise to a method declaration similar to the implementing partial method declaration except for the following:</p>

<ul>
<li>The <code class="prettyprint">partial</code> modifier is not included</li>
<li>The attributes in the resulting method declaration are the combined attributes of the defining and the implementing partial method declaration in unspecified order. Duplicates are not removed.</li>
<li>The attributes on the parameters of the resulting method declaration are the combined attributes of the corresponding parameters of the defining and the implementing partial method declaration in unspecified order. Duplicates are not removed.</li>
</ul>

<p>If a defining declaration but not an implementing declaration is given for a partial method M, the following restrictions apply:</p>

<ul>
<li>It is a compile-time error to create a delegate to method (<a href="expressions.md#delegate-creation-expressions">Delegate creation expressions</a>).</li>
<li>It is a compile-time error to refer to <code class="prettyprint">M</code> inside an anonymous function that is converted to an expression tree type (<a href="conversions.md#evaluation-of-anonymous-function-conversions-to-expression-tree-types">Evaluation of anonymous function conversions to expression tree types</a>).</li>
<li>Expressions occurring as part of an invocation of <code class="prettyprint">M</code> do not affect the definite assignment state (<a href="variables.md#definite-assignment">Definite assignment</a>), which can potentially lead to compile-time errors.</li>
<li><code class="prettyprint">M</code> cannot be the entry point for an application (<a href="basic-concepts.md#application-startup">Application Startup</a>).</li>
</ul>

<p>Partial methods are useful for allowing one part of a type declaration to customize the behavior of another part, e.g., one that is generated by a tool. Consider the following partial class declaration:
&ldquo;`csharp
partial class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }</p>

<p>}</p>

<p>partial void OnNameChanging(string newName);</p>

<p>partial void OnNameChanged();
}
&rdquo;`</p>

<p>If this class is compiled without any other parts, the defining partial method declarations and their invocations will be removed, and the resulting combined class declaration will be equivalent to the following:
&ldquo;`csharp
class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set { name = value; }
    }
}
&rdquo;`</p>

<p>Assume that another part is given, however, which provides implementing declarations of the partial methods:
&ldquo;`csharp
partial class Customer
{
    partial void OnNameChanging(string newName)
    {
        Console.WriteLine(&quot;Changing &rdquo; + name + &ldquo; to &rdquo; + newName);
    }</p>

<p>partial void OnNameChanged()
    {
        Console.WriteLine(&ldquo;Changed to &rdquo; + name);
    }
}
&ldquo;`</p>

<p>Then the resulting combined class declaration will be equivalent to the following:
&rdquo;`csharp
class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }</p>

<p>}</p>

<p>void OnNameChanging(string newName)
    {
        Console.WriteLine(&ldquo;Changing &rdquo; + name + &ldquo; to &rdquo; + newName);
    }</p>

<p>void OnNameChanged()
    {
        Console.WriteLine(&ldquo;Changed to &rdquo; + name);
    }
}
&ldquo;`</p>

<h3 id="name-binding">Name binding</h3>

<p>Although each part of an extensible type must be declared within the same namespace, the parts are typically written within different namespace declarations. Thus, different <code class="prettyprint">using</code> directives (<a href="namespaces.md#using-directives">Using directives</a>) may be present for each part. When interpreting simple names (<a href="expressions.md#type-inference">Type inference</a>) within one part, only the <code class="prettyprint">using</code> directives of the namespace declaration(s) enclosing that part are considered. This may result in the same identifier having different meanings in different parts:
&rdquo;`csharp
namespace N
{
    using List = System.Collections.ArrayList;</p>

<p>partial class A
    {
        List x;                // x has type System.Collections.ArrayList
    }
}</p>

<p>namespace N
{
    using List = Widgets.LinkedList;</p>

<p>partial class A
    {
        List y;                // y has type Widgets.LinkedList
    }
}
&ldquo;`</p>

<h2 id="class-members">Class members</h2>

<p>The members of a class consist of the members introduced by its *class_member_declaration*s and the members inherited from the direct base class.</p>
<pre class="highlight plaintext"><code>class_member_declaration
    : constant_declaration
    | field_declaration
    | method_declaration
    | property_declaration
    | event_declaration
    | indexer_declaration
    | operator_declaration
    | constructor_declaration
    | destructor_declaration
    | static_constructor_declaration
    | type_declaration
    ;
</code></pre>
<p>The members of a class type are divided into the following categories:</p>

<ul>
<li> Constants, which represent constant values associated with the class (<a href="classes.md#constants">Constants</a>).</li>
<li> Fields, which are the variables of the class (<a href="classes.md#fields">Fields</a>).</li>
<li> Methods, which implement the computations and actions that can be performed by the class (<a href="classes.md#methods">Methods</a>).</li>
<li> Properties, which define named characteristics and the actions associated with reading and writing those characteristics (<a href="classes.md#properties">Properties</a>).</li>
<li> Events, which define notifications that can be generated by the class (<a href="classes.md#events">Events</a>).</li>
<li> Indexers, which permit instances of the class to be indexed in the same way (syntactically) as arrays (<a href="classes.md#indexers">Indexers</a>).</li>
<li> Operators, which define the expression operators that can be applied to instances of the class (<a href="classes.md#operators">Operators</a>).</li>
<li> Instance constructors, which implement the actions required to initialize instances of the class (<a href="classes.md#instance-constructors">Instance constructors</a>)</li>
<li> Destructors, which implement the actions to be performed before instances of the class are permanently discarded (<a href="classes.md#destructors">Destructors</a>).</li>
<li> Static constructors, which implement the actions required to initialize the class itself (<a href="classes.md#static-constructors">Static constructors</a>).</li>
<li> Types, which represent the types that are local to the class (<a href="classes.md#nested-types">Nested types</a>).</li>
</ul>

<p>Members that can contain executable code are collectively known as the <em>function members</em> of the class type. The function members of a class type are the methods, properties, events, indexers, operators, instance constructors,  destructors, and static constructors of that class type.</p>

<p>A <em>class_declaration</em> creates a new declaration space (<a href="basic-concepts.md#declarations">Declarations</a>), and the <em>class_member_declaration*s immediately contained by the *class_declaration</em> introduce new members into this declaration space. The following rules apply to *class_member_declaration*s:</p>

<ul>
<li> Instance constructors, destructors and static constructors must have the same name as the immediately enclosing class. All other members must have names that differ from the name of the immediately enclosing class.</li>
<li> The name of a constant, field, property, event, or type must differ from the names of all other members declared in the same class.</li>
<li> The name of a method must differ from the names of all other non-methods declared in the same class. In addition, the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of a method must differ from the signatures of all other methods declared in the same class, and two methods declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</li>
<li> The signature of an instance constructor must differ from the signatures of all other instance constructors declared in the same class, and two constructors declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</li>
<li> The signature of an indexer must differ from the signatures of all other indexers declared in the same class.</li>
<li> The signature of an operator must differ from the signatures of all other operators declared in the same class.</li>
</ul>

<p>The inherited members of a class type (<a href="classes.md#inheritance">Inheritance</a>) are not part of the declaration space of a class. Thus, a derived class is allowed to declare a member with the same name or signature as an inherited member (which in effect hides the inherited member).</p>

<h3 id="the-instance-type">The instance type</h3>

<p>Each class declaration has an associated bound type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>), the <strong><em>instance type</em></strong>. For a generic class declaration, the instance type is formed by creating a constructed type (<a href="types.md#constructed-types">Constructed types</a>) from the type declaration, with each of the supplied type arguments being the corresponding type parameter. Since the instance type uses the type parameters, it can only be used where the type parameters are in scope; that is, inside the class declaration. The instance type is the type of <code class="prettyprint">this</code> for code written inside the class declaration. For non-generic classes, the instance type is simply the declared class. The following shows several class declarations along with their instance types: 
&rdquo;`csharp
class A<T>                           // instance type: A<T>
{
    class B {}                       // instance type: A<T>.B
    class C<U> {}                    // instance type: A<T>.C<U>
}</p>

<p>class D {}                           // instance type: D
&ldquo;`</p>

<h3 id="members-of-constructed-types">Members of constructed types</h3>

<p>The non-inherited members of a constructed type are obtained by substituting, for each <em>type_parameter</em> in the member declaration, the corresponding <em>type_argument</em> of the constructed type. The substitution process is based on the semantic meaning of type declarations, and is not simply textual substitution.</p>

<p>For example, given the generic class declaration
<code class="prettyprint">csharp
class Gen&lt;T,U&gt;
{
    public T[,] a;
    public void G(int i, T t, Gen&lt;U,T&gt; gt) {...}
    public U Prop { get {...} set {...} }
    public int H(double d) {...}
}
</code>
the constructed type <code class="prettyprint">Gen&lt;int[],IComparable&lt;string&gt;&gt;</code> has the following members:
<code class="prettyprint">csharp
public int[,][] a;
public void G(int i, int[] t, Gen&lt;IComparable&lt;string&gt;,int[]&gt; gt) {...}
public IComparable&lt;string&gt; Prop { get {...} set {...} }
public int H(double d) {...}
</code></p>

<p>The type of the member <code class="prettyprint">a</code> in the generic class declaration <code class="prettyprint">Gen</code> is &quot;two-dimensional array of <code class="prettyprint">T</code>&rdquo;, so the type of the member <code class="prettyprint">a</code> in the constructed type above is &ldquo;two-dimensional array of one-dimensional array of <code class="prettyprint">int</code>&rdquo;, or <code class="prettyprint">int[,][]</code>.</p>

<p>Within instance function members, the type of <code class="prettyprint">this</code> is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the containing declaration.</p>

<p>All members of a generic class can use type parameters from any enclosing class, either directly or as part of a constructed type. When a particular closed constructed type (<a href="types.md#open-and-closed-types">Open and closed types</a>) is used at run-time, each use of a type parameter is replaced with the actual type argument supplied to the constructed type. For example:
&ldquo;`csharp
class C<V>
{
    public V f1;
    public C<V> f2 = null;</p>

<p>public C(V x) {
        this.f1 = x;
        this.f2 = this;
    }
}</p>

<p>class Application
{
    static void Main() {
        C<int> x1 = new C<int>(1);
        Console.WriteLine(x1.f1);        // Prints 1</p>

<p>C<double> x2 = new C<double>(3.1415);
        Console.WriteLine(x2.f1);        // Prints 3.1415
    }
}
&rdquo;`</p>

<h3 id="inheritance">Inheritance</h3>

<p>A class <strong><em>inherits</em></strong> the members of its direct base class type. Inheritance means that a class implicitly contains all members of its direct base class type, except for the instance constructors, destructors and static constructors of the base class. Some important aspects of inheritance are:</p>

<ul>
<li> Inheritance is transitive. If <code class="prettyprint">C</code> is derived from <code class="prettyprint">B</code>, and <code class="prettyprint">B</code> is derived from <code class="prettyprint">A</code>, then <code class="prettyprint">C</code> inherits the members declared in <code class="prettyprint">B</code> as well as the members declared in <code class="prettyprint">A</code>.</li>
<li> A derived class extends its direct base class. A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</li>
<li> Instance constructors, destructors, and static constructors are not inherited, but all other members are, regardless of their declared accessibility (<a href="basic-concepts.md#member-access">Member access</a>). However, depending on their declared accessibility, inherited members might not be accessible in a derived class.</li>
<li> A derived class can <strong><em>hide</em></strong> (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>) inherited members by declaring new members with the same name or signature. Note however that hiding an inherited member does not remove that memberâ€”it merely makes that member inaccessible directly through the derived class.</li>
<li> An instance of a class contains a set of all instance fields declared in the class and its base classes, and an implicit conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from a derived class type to any of its base class types. Thus, a reference to an instance of some derived class can be treated as a reference to an instance of any of its base classes.</li>
<li> A class can declare virtual methods, properties, and indexers, and derived classes can override the implementation of these function members. This enables classes to exhibit polymorphic behavior wherein the actions performed by a function member invocation varies depending on the run-time type of the instance through which that function member is invoked.</li>
</ul>

<p>The inherited member of a constructed class type are the members of the immediate base class type (<a href="classes.md#base-classes">Base classes</a>), which is found by substituting the type arguments of the constructed type for each occurrence of the corresponding type parameters in the <em>class_base</em> specification. These members, in turn, are transformed by substituting, for each <em>type_parameter</em> in the member declaration, the corresponding <em>type_argument</em> of the <em>class_base</em> specification.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">B</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">U</span> <span class="nf">F</span><span class="p">(</span><span class="kt">long</span> <span class="n">index</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">[</span><span class="k">]&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="nf">G</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>In the above example, the constructed type <code class="prettyprint">D&lt;int&gt;</code> has a non-inherited member <code class="prettyprint">public int G(string s)</code> obtained by substituting the type argument <code class="prettyprint">int</code> for the type parameter <code class="prettyprint">T</code>. <code class="prettyprint">D&lt;int&gt;</code> also has an inherited member from the class declaration <code class="prettyprint">B</code>. This inherited member is determined by first determining the base class type <code class="prettyprint">B&lt;int[]&gt;</code> of <code class="prettyprint">D&lt;int&gt;</code> by substituting <code class="prettyprint">int</code> for <code class="prettyprint">T</code> in the base class specification <code class="prettyprint">B&lt;T[]&gt;</code>. Then, as a type argument to <code class="prettyprint">B</code>, <code class="prettyprint">int[]</code> is substituted for <code class="prettyprint">U</code> in <code class="prettyprint">public U F(long index)</code>, yielding the inherited member <code class="prettyprint">public int[] F(long index)</code>.</p>

<h3 id="the-new-modifier">The new modifier</h3>

<p>A <em>class_member_declaration</em> is permitted to declare a member with the same name or signature as an inherited member. When this occurs, the derived class member is said to <strong><em>hide</em></strong> the base class member. Hiding an inherited member is not considered an error, but it does cause the compiler to issue a warning. To suppress the warning, the declaration of the derived class member can include a <code class="prettyprint">new</code> modifier to indicate that the derived member is intended to hide the base member. This topic is discussed further in <a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>.</p>

<p>If a <code class="prettyprint">new</code> modifier is included in a declaration that doesn&rsquo;t hide an inherited member, a warning to that effect is issued. This warning is suppressed by removing the <code class="prettyprint">new</code> modifier.</p>

<h3 id="access-modifiers">Access modifiers</h3>

<p>A <em>class_member_declaration</em> can have any one of the five possible kinds of declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>): <code class="prettyprint">public</code>, <code class="prettyprint">protected internal</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>. Except for the <code class="prettyprint">protected internal</code> combination, it is a compile-time error to specify more than one access modifier. When a <em>class_member_declaration</em> does not include any access modifiers, <code class="prettyprint">private</code> is assumed.</p>

<h3 id="constituent-types">Constituent types</h3>

<p>Types that are used in the declaration of a member are called the constituent types of that member. Possible constituent types are the type of a constant, field, property, event, or indexer, the return type of a method or operator, and the parameter types of a method, indexer, operator, or instance constructor. The constituent types of a member must be at least as accessible as that member itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<h3 id="static-and-instance-members">Static and instance members</h3>

<p>Members of a class are either <strong><em>static members</em></strong> or <strong><em>instance members</em></strong>. Generally speaking, it is useful to think of static members as belonging to class types and instance members as belonging to objects (instances of class types).</p>

<p>When a field, method, property, event, operator, or constructor declaration includes a <code class="prettyprint">static</code> modifier, it declares a static member. In addition, a constant or type declaration implicitly declares a static member. Static members have the following characteristics:</p>

<ul>
<li> When a static member <code class="prettyprint">M</code> is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>. It is a compile-time error for <code class="prettyprint">E</code> to denote an instance.</li>
<li> A static field identifies exactly one storage location to be shared by all instances of a given closed class type. No matter how many instances of a given closed class type are created, there is only ever one copy of a static field.</li>
<li> A static function member (method, property, event, operator, or constructor) does not operate on a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in such a function member.</li>
</ul>

<p>When a field, method, property, event, indexer, constructor, or destructor declaration does not include a <code class="prettyprint">static</code> modifier, it declares an instance member. (An instance member is sometimes called a non-static member.) Instance members have the following characteristics:</p>

<ul>
<li> When an instance member <code class="prettyprint">M</code> is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, <code class="prettyprint">E</code> must denote an instance of a type containing <code class="prettyprint">M</code>. It is a binding-time error for <code class="prettyprint">E</code> to denote a type.</li>
<li> Every instance of a class contains a separate set of all instance fields of the class.</li>
<li> An instance function member (method, property, indexer, instance constructor, or destructor) operates on a given instance of the class, and this instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
</ul>

<p>The following example illustrates the rules for accessing static and instance members:
&ldquo;`csharp
class Test
{
    int x;
    static int y;</p>

<p>void F() {
        x = 1;            // Ok, same as this.x = 1
        y = 1;            // Ok, same as Test.y = 1
    }</p>

<p>static void G() {
        x = 1;            // Error, cannot access this.x
        y = 1;            // Ok, same as Test.y = 1
    }</p>

<p>static void Main() {
        Test t = new Test();
        t.x = 1;          // Ok
        t.y = 1;          // Error, cannot access static member through instance
        Test.x = 1;       // Error, cannot access instance member through type
        Test.y = 1;       // Ok
    }
}
&rdquo;`</p>

<p>The <code class="prettyprint">F</code> method shows that in an instance function member, a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) can be used to access both instance members and static members. The <code class="prettyprint">G</code> method shows that in a static function member, it is a compile-time error to access an instance member through a <em>simple_name</em>. The <code class="prettyprint">Main</code> method shows that in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), instance members must be accessed through instances, and static members must be accessed through types.</p>

<h3 id="nested-types">Nested types</h3>

<p>A type declared within a class or struct declaration is called a <strong><em>nested type</em></strong>. A type that is declared within a compilation unit or namespace is called a <strong><em>non-nested type</em></strong>.</p>

<p>In the example
&ldquo;`csharp
using System;</p>

<p>class A
{
    class B
    {
        static void F() {
            Console.WriteLine(&quot;A.B.F&rdquo;);
        }
    }
}
&ldquo;<code class="prettyprint">
class</code>B<code class="prettyprint">is a nested type because it is declared within class</code>A<code class="prettyprint">, and class</code>A` is a non-nested type because it is declared within a compilation unit.</p>

<h4 id="fully-qualified-name">Fully qualified name</h4>

<p>The fully qualified name (<a href="basic-concepts.md#fully-qualified-names">Fully qualified names</a>) for a nested type is <code class="prettyprint">S.N</code> where <code class="prettyprint">S</code> is the fully qualified name of the type in which type <code class="prettyprint">N</code> is declared.</p>

<h4 id="declared-accessibility">Declared accessibility</h4>

<p>Non-nested types can have <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility and have <code class="prettyprint">internal</code> declared accessibility by default. Nested types can have these forms of declared accessibility too, plus one or more additional forms of declared accessibility, depending on whether the containing type is a class or struct:</p>

<ul>
<li> A nested type that is declared in a class can have any of five forms of declared accessibility (<code class="prettyprint">public</code>, <code class="prettyprint">protected internal</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>) and, like other class members, defaults to <code class="prettyprint">private</code> declared accessibility.</li>
<li> A nested type that is declared in a struct can have any of three forms of declared accessibility (<code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>) and, like other struct members, defaults to <code class="prettyprint">private</code> declared accessibility.</li>
</ul>

<p>The example
&rdquo;`csharp
public class List
{
    // Private data structure
    private class Node
    { 
        public object Data;
        public Node Next;</p>

<p>public Node(object data, Node next) {
            this.Data = data;
            this.Next = next;
        }
    }</p>

<p>private Node first = null;
    private Node last = null;</p>

<p>// Public interface
    public void AddToFront(object o) {&hellip;}
    public void AddToBack(object o) {&hellip;}
    public object RemoveFromFront() {&hellip;}
    public object RemoveFromBack() {&hellip;}
    public int Count { get {&hellip;} }
}
&ldquo;<code class="prettyprint">
declares a private nested class</code>Node`.</p>

<h4 id="hiding">Hiding</h4>

<p>A nested type may hide (<a href="basic-concepts.md#name-hiding">Name hiding</a>) a base member. The <code class="prettyprint">new</code> modifier is permitted on nested type declarations so that hiding can be expressed explicitly. The example
&rdquo;`csharp
using System;</p>

<p>class Base
{
    public static void M() {
        Console.WriteLine(&ldquo;Base.M&rdquo;);
    }
}</p>

<p>class Derived: Base 
{
    new public class M 
    {
        public static void F() {
            Console.WriteLine(&ldquo;Derived.M.F&rdquo;);
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        Derived.M.F();
    }
}
&ldquo;<code class="prettyprint">
shows a nested class</code>M<code class="prettyprint">that hides the method</code>M<code class="prettyprint">defined in</code>Base`.</p>

<h4 id="this-access">this access</h4>

<p>A nested type and its containing type do not have a special relationship with regard to <em>this_access</em> (<a href="expressions.md#this-access">This access</a>). Specifically, <code class="prettyprint">this</code> within a nested type cannot be used to refer to instance members of the containing type. In cases where a nested type needs access to the instance members of its containing type, access can be provided by providing the <code class="prettyprint">this</code> for the instance of the containing type as a constructor argument for the nested type. The following example
&rdquo;`csharp
using System;</p>

<p>class C
{
    int i = 123;</p>

<p>public void F() {
        Nested n = new Nested(this);
        n.G();
    }</p>

<p>public class Nested
    {
        C this_c;</p>

<p>public Nested(C c) {
            this_c = c;
        }</p>

<p>public void G() {
            Console.WriteLine(this_c.i);
        }
    }
}</p>

<p>class Test
{
    static void Main() {
        C c = new C();
        c.F();
    }
}
&ldquo;<code class="prettyprint">
shows this technique. An instance of</code>C<code class="prettyprint">creates an instance of</code>Nested<code class="prettyprint">and passes its own</code>this<code class="prettyprint">to</code>Nested<code class="prettyprint">&#39;s constructor in order to provide subsequent access to</code>C`&lsquo;s instance members.</p>

<h4 id="access-to-private-and-protected-members-of-the-containing-type">Access to private and protected members of the containing type</h4>

<p>A nested type has access to all of the members that are accessible to its containing type, including members of the containing type that have <code class="prettyprint">private</code> and <code class="prettyprint">protected</code> declared accessibility. The example
&rdquo;`csharp
using System;</p>

<p>class C 
{
    private static void F() {
        Console.WriteLine(&ldquo;C.F&rdquo;);
    }</p>

<p>public class Nested 
    {
        public static void G() {
            F();
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        C.Nested.G();
    }
}
&ldquo;<code class="prettyprint">
shows a class</code>C<code class="prettyprint">that contains a nested class</code>Nested<code class="prettyprint">. Within</code>Nested<code class="prettyprint">, the method</code>G<code class="prettyprint">calls the static method</code>F<code class="prettyprint">defined in</code>C<code class="prettyprint">, and</code>F` has private declared accessibility.</p>

<p>A nested type also may access protected members defined in a base type of its containing type. In the example
&rdquo;`csharp
using System;</p>

<p>class Base 
{
    protected void F() {
        Console.WriteLine(&ldquo;Base.F&rdquo;);
    }
}</p>

<p>class Derived: Base 
{
    public class Nested 
    {
        public void G() {
            Derived d = new Derived();
            d.F();        // ok
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        Derived.Nested n = new Derived.Nested();
        n.G();
    }
}
&ldquo;<code class="prettyprint">
the nested class</code>Derived.Nested<code class="prettyprint">accesses the protected method</code>F<code class="prettyprint">defined in</code>Derived<code class="prettyprint">&#39;s base class,</code>Base<code class="prettyprint">, by calling through an instance of</code>Derived`.</p>

<h4 id="nested-types-in-generic-classes">Nested types in generic classes</h4>

<p>A generic class declaration can contain nested type declarations. The type parameters of the enclosing class can be used within the nested types. A nested type declaration can contain additional type parameters that apply only to the nested type.</p>

<p>Every type declaration contained within a generic class declaration is implicitly a generic type declaration. When writing a reference to a type nested within a generic type, the containing constructed type, including its type arguments, must be named. However, from within the outer class, the nested type can be used without qualification; the instance type of the outer class can be implicitly used when constructing the nested type. The following example shows three different correct ways to refer to a constructed type created from <code class="prettyprint">Inner</code>; the first two are equivalent:
&rdquo;`csharp
class Outer<T>
{
    class Inner<U>
    {
        public static void F(T t, U u) {&hellip;}
    }</p>

<p>static void F(T t) {
        Outer<T>.Inner<string>.F(t, &ldquo;abc&rdquo;);      // These two statements have
        Inner<string>.F(t, &ldquo;abc&rdquo;);               // the same effect</p>

<p>Outer<int>.Inner<string>.F(3, &ldquo;abc&rdquo;);    // This type is different</p>

<p>Outer.Inner<string>.F(t, &ldquo;abc&rdquo;);         // Error, Outer needs type arg
    }
}
&ldquo;`</p>

<p>Although it is bad programming style, a type parameter in a nested type can hide a member or type parameter declared in the outer type:
<code class="prettyprint">csharp
class Outer&lt;T&gt;
{
    class Inner&lt;T&gt;        // Valid, hides Outer&#39;s T
    {
        public T t;       // Refers to Inner&#39;s T
    }
}
</code></p>

<h3 id="reserved-member-names">Reserved member names</h3>

<p>To facilitate the underlying C# run-time implementation, for each source member declaration that is a property, event, or indexer, the implementation must reserve two method signatures based on the kind of the member declaration, its name, and its type. It is a compile-time error for a program to declare a member whose signature matches one of these reserved signatures, even if the underlying run-time implementation does not make use of these reservations.</p>

<p>The reserved names do not introduce declarations, thus they do not participate in member lookup. However, a declaration&rsquo;s associated reserved method signatures do participate in inheritance (<a href="classes.md#inheritance">Inheritance</a>), and can be hidden with the <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>).</p>

<p>The reservation of these names serves three purposes:</p>

<ul>
<li> To allow the underlying implementation to use an ordinary identifier as a method name for get or set access to the C# language feature.</li>
<li> To allow other languages to interoperate using an ordinary identifier as a method name for get or set access to the C# language feature.</li>
<li> To help ensure that the source accepted by one conforming compiler is accepted by another, by making the specifics of reserved member names consistent across all C# implementations.</li>
</ul>

<p>The declaration of a destructor (<a href="classes.md#destructors">Destructors</a>) also causes a signature to be reserved (<a href="classes.md#member-names-reserved-for-destructors">Member names reserved for destructors</a>).</p>

<h4 id="member-names-reserved-for-properties">Member names reserved for properties</h4>

<p>For a property <code class="prettyprint">P</code> (<a href="classes.md#properties">Properties</a>) of type <code class="prettyprint">T</code>, the following signatures are reserved:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">T</span> <span class="nf">get_P</span><span class="p">();</span>
<span class="k">void</span> <span class="nf">set_P</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">);</span>
</code></pre>
<p>Both signatures are reserved, even if the property is read-only or write-only.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public int P {
        get { return 123; }
    }
}</p>

<p>class B: A
{
    new public int get_P() {
        return 456;
    }</p>

<p>new public void set_P(int value) {
    }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        Console.WriteLine(a.P);
        Console.WriteLine(b.P);
        Console.WriteLine(b.get_P());
    }
}
<code class="prettyprint">
a class `A` defines a read-only property `P`, thus reserving signatures for `get_P` and `set_P` methods. A class `B` derives from `A` and hides both of these reserved signatures. The example produces the output:
</code>
123
123
456
&ldquo;`</p>

<h4 id="member-names-reserved-for-events">Member names reserved for events</h4>

<p>For an event <code class="prettyprint">E</code> (<a href="classes.md#events">Events</a>) of delegate type <code class="prettyprint">T</code>, the following signatures are reserved:
<code class="prettyprint">csharp
void add_E(T handler);
void remove_E(T handler);
</code></p>

<h4 id="member-names-reserved-for-indexers">Member names reserved for indexers</h4>

<p>For an indexer (<a href="classes.md#indexers">Indexers</a>) of type <code class="prettyprint">T</code> with parameter-list <code class="prettyprint">L</code>, the following signatures are reserved:
<code class="prettyprint">csharp
T get_Item(L);
void set_Item(L, T value);
</code></p>

<p>Both signatures are reserved, even if the indexer is read-only or write-only.</p>

<p>Furthermore the member name <code class="prettyprint">Item</code> is reserved.</p>

<h4 id="member-names-reserved-for-destructors">Member names reserved for destructors</h4>

<p>For a class containing a destructor (<a href="classes.md#destructors">Destructors</a>), the following signature is reserved:
<code class="prettyprint">csharp
void Finalize();
</code></p>

<h2 id="constants">Constants</h2>

<p>A <strong><em>constant</em></strong> is a class member that represents a constant value: a value that can be computed at compile-time. A <em>constant_declaration</em> introduces one or more constants of a given type.</p>
<pre class="highlight plaintext"><code>constant_declaration
    : attributes? constant_modifier* 'const' type constant_declarators ';'
    ;

constant_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    ;

constant_declarators
    : constant_declarator (',' constant_declarator)*
    ;

constant_declarator
    : identifier '=' constant_expression
    ;
</code></pre>
<p>A <em>constant_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>), and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>). The attributes and modifiers apply to all of the members declared by the <em>constant_declaration</em>. Even though constants are considered static members, a <em>constant_declaration</em> neither requires nor allows a <code class="prettyprint">static</code> modifier. It is an error for the same modifier to appear multiple times in a constant declaration.</p>

<p>The <em>type</em> of a <em>constant_declaration</em> specifies the type of the members introduced by the declaration. The type is followed by a list of <em>constant_declarator*s, each of which introduces a new member. A *constant_declarator</em> consists of an <em>identifier</em> that names the member, followed by an &rdquo;<code class="prettyprint">=</code>&ldquo; token, followed by a <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>) that gives the value of the member.</p>

<p>The <em>type</em> specified in a constant declaration must be <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">string</code>, an <em>enum_type</em>, or a <em>reference_type</em>. Each <em>constant_expression</em> must yield a value of the target type or of a type that can be converted to the target type by an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</p>

<p>The <em>type</em> of a constant must be at least as accessible as the constant itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The value of a constant is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>).</p>

<p>A constant can itself participate in a <em>constant_expression</em>. Thus, a constant may be used in any construct that requires a <em>constant_expression</em>. Examples of such constructs include <code class="prettyprint">case</code> labels, <code class="prettyprint">goto case</code> statements, <code class="prettyprint">enum</code> member declarations, attributes, and other constant declarations.</p>

<p>As described in <a href="expressions.md#constant-expressions">Constant expressions</a>, a <em>constant_expression</em> is an expression that can be fully evaluated at compile-time. Since the only way to create a non-null value of a <em>reference_type</em> other than <code class="prettyprint">string</code> is to apply the <code class="prettyprint">new</code> operator, and since the <code class="prettyprint">new</code> operator is not permitted in a <em>constant_expression</em>, the only possible value for constants of *reference_type*s other than <code class="prettyprint">string</code> is <code class="prettyprint">null</code>.</p>

<p>When a symbolic name for a constant value is desired, but when the type of that value is not permitted in a constant declaration, or when the value cannot be computed at compile-time by a <em>constant_expression</em>, a <code class="prettyprint">readonly</code> field (<a href="classes.md#readonly-fields">Readonly fields</a>) may be used instead.</p>

<p>A constant declaration that declares multiple constants is equivalent to multiple declarations of single constants with the same attributes, modifiers, and type. For example
<code class="prettyprint">csharp
class A
{
    public const double X = 1.0, Y = 2.0, Z = 3.0;
}
</code>
is equivalent to
<code class="prettyprint">csharp
class A
{
    public const double X = 1.0;
    public const double Y = 2.0;
    public const double Z = 3.0;
}
</code></p>

<p>Constants are permitted to depend on other constants within the same program as long as the dependencies are not of a circular nature. The compiler automatically arranges to evaluate the constant declarations in the appropriate order. In the example
&rdquo;`csharp
class A
{
    public const int X = B.Z + 1;
    public const int Y = 10;
}</p>

<p>class B
{
    public const int Z = A.Y + 1;
}
&ldquo;<code class="prettyprint">
the compiler first evaluates</code>A.Y<code class="prettyprint">, then evaluates</code>B.Z<code class="prettyprint">, and finally evaluates</code>A.X<code class="prettyprint">, producing the values</code>10<code class="prettyprint">,</code>11<code class="prettyprint">, and</code>12<code class="prettyprint">. Constant declarations may depend on constants from other programs, but such dependencies are only possible in one direction. Referring to the example above, if</code>A<code class="prettyprint">and</code>B<code class="prettyprint">were declared in separate programs, it would be possible for</code>A.X<code class="prettyprint">to depend on</code>B.Z<code class="prettyprint">, but</code>B.Z<code class="prettyprint">could then not simultaneously depend on</code>A.Y`.</p>

<h2 id="fields">Fields</h2>

<p>A <strong><em>field</em></strong> is a member that represents a variable associated with an object or class. A <em>field_declaration</em> introduces one or more fields of a given type.</p>
<pre class="highlight plaintext"><code>field_declaration
    : attributes? field_modifier* type variable_declarators ';'
    ;

field_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'readonly'
    | 'volatile'
    | field_modifier_unsafe
    ;

variable_declarators
    : variable_declarator (',' variable_declarator)*
    ;

variable_declarator
    : identifier ('=' variable_initializer)?
    ;

variable_initializer
    : expression
    | array_initializer
    ;
</code></pre>
<p>A <em>field_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>), a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), and a <code class="prettyprint">static</code> modifier (<a href="classes.md#static-and-instance-fields">Static and instance fields</a>). In addition, a <em>field_declaration</em> may include a <code class="prettyprint">readonly</code> modifier (<a href="classes.md#readonly-fields">Readonly fields</a>) or a <code class="prettyprint">volatile</code> modifier (<a href="classes.md#volatile-fields">Volatile fields</a>) but not both. The attributes and modifiers apply to all of the members declared by the <em>field_declaration</em>. It is an error for the same modifier to appear multiple times in a field declaration.</p>

<p>The <em>type</em> of a <em>field_declaration</em> specifies the type of the members introduced by the declaration. The type is followed by a list of <em>variable_declarator*s, each of which introduces a new member. A *variable_declarator</em> consists of an <em>identifier</em> that names that member, optionally followed by an &rdquo;<code class="prettyprint">=</code>&ldquo; token and a <em>variable_initializer</em> (<a href="classes.md#variable-initializers">Variable initializers</a>) that gives the initial value of that member.</p>

<p>The <em>type</em> of a field must be at least as accessible as the field itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The value of a field is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>). The value of a non-readonly field is modified using an <em>assignment</em> (<a href="expressions.md#assignment-operators">Assignment operators</a>). The value of a non-readonly field can be both obtained and modified using postfix increment and decrement operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>) and prefix increment and decrement operators (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>).</p>

<p>A field declaration that declares multiple fields is equivalent to multiple declarations of single fields with the same attributes, modifiers, and type. For example
<code class="prettyprint">csharp
class A
{
    public static int X = 1, Y, Z = 100;
}
</code>
is equivalent to
<code class="prettyprint">csharp
class A
{
    public static int X = 1;
    public static int Y;
    public static int Z = 100;
}
</code></p>

<h3 id="static-and-instance-fields">Static and instance fields</h3>

<p>When a field declaration includes a <code class="prettyprint">static</code> modifier, the fields introduced by the declaration are <strong><em>static fields</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the fields introduced by the declaration are <strong><em>instance fields</em></strong>. Static fields and instance fields are two of the several kinds of variables (<a href="variables.md#variables">Variables</a>) supported by C#, and at times they are referred to as <strong><em>static variables</em></strong> and <strong><em>instance variables</em></strong>, respectively.</p>

<p>A static field is not part of a specific instance; instead, it is shared amongst all instances of a closed type (<a href="types.md#open-and-closed-types">Open and closed types</a>). No matter how many instances of a closed class type are created, there is only ever one copy of a static field for the associated application domain.</p>

<p>For example:
&rdquo;`csharp
class C<V>
{
    static int count = 0;</p>

<p>public C() {
        count++;
    }</p>

<p>public static int Count {
        get { return count; }
    }
}</p>

<p>class Application
{
    static void Main() {
        C<int> x1 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 1</p>

<p>C<double> x2 = new C<double>();
        Console.WriteLine(C<int>.Count);        // Prints 1</p>

<p>C<int> x3 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 2
    }
}
&ldquo;`</p>

<p>An instance field belongs to an instance. Specifically, every instance of a class contains a separate set of all the instance fields of that class.</p>

<p>When a field is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static field, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance field, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="readonly-fields">Readonly fields</h3>

<p>When a <em>field_declaration</em> includes a <code class="prettyprint">readonly</code> modifier, the fields introduced by the declaration are <strong><em>readonly fields</em></strong>. Direct assignments to readonly fields can only occur as part of that declaration or in an instance constructor or static constructor in the same class. (A readonly field can be assigned to multiple times in these contexts.) Specifically, direct assignments to a <code class="prettyprint">readonly</code> field are permitted only in the following contexts:</p>

<ul>
<li> In the <em>variable_declarator</em> that introduces the field (by including a <em>variable_initializer</em> in the declaration).</li>
<li> For an instance field, in the instance constructors of the class that contains the field declaration; for a static field, in the static constructor of the class that contains the field declaration. These are also the only contexts in which it is valid to pass a <code class="prettyprint">readonly</code> field as an <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> parameter.</li>
</ul>

<p>Attempting to assign to a <code class="prettyprint">readonly</code> field or pass it as an <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> parameter in any other context is a compile-time error.</p>

<h4 id="using-static-readonly-fields-for-constants">Using static readonly fields for constants</h4>

<p>A <code class="prettyprint">static readonly</code> field is useful when a symbolic name for a constant value is desired, but when the type of the value is not permitted in a <code class="prettyprint">const</code> declaration, or when the value cannot be computed at compile-time. In the example
&rdquo;`csharp
public class Color
{
    public static readonly Color Black = new Color(0, 0, 0);
    public static readonly Color White = new Color(255, 255, 255);
    public static readonly Color Red = new Color(255, 0, 0);
    public static readonly Color Green = new Color(0, 255, 0);
    public static readonly Color Blue = new Color(0, 0, 255);</p>

<p>private byte red, green, blue;</p>

<p>public Color(byte r, byte g, byte b) {
        red = r;
        green = g;
        blue = b;
    }
}
&ldquo;<code class="prettyprint">
the</code>Black<code class="prettyprint">,</code>White<code class="prettyprint">,</code>Red<code class="prettyprint">,</code>Green<code class="prettyprint">, and</code>Blue<code class="prettyprint">members cannot be declared as</code>const<code class="prettyprint">members because their values cannot be computed at compile-time. However, declaring them</code>static readonly` instead has much the same effect.</p>

<h4 id="versioning-of-constants-and-static-readonly-fields">Versioning of constants and static readonly fields</h4>

<p>Constants and readonly fields have different binary versioning semantics. When an expression references a constant, the value of the constant is obtained at compile-time, but when an expression references a readonly field, the value of the field is not obtained until run-time. Consider an application that consists of two separate programs:
&rdquo;`csharp
using System;</p>

<p>namespace Program1
{
    public class Utils
    {
        public static readonly int X = 1;
    }
}</p>

<p>namespace Program2
{
    class Test
    {
        static void Main() {
            Console.WriteLine(Program1.Utils.X);
        }
    }
}
&ldquo;`</p>

<p>The <code class="prettyprint">Program1</code> and <code class="prettyprint">Program2</code> namespaces denote two programs that are compiled separately. Because <code class="prettyprint">Program1.Utils.X</code> is declared as a static readonly field, the value output by the <code class="prettyprint">Console.WriteLine</code> statement is not known at compile-time, but rather is obtained at run-time. Thus, if the value of <code class="prettyprint">X</code> is changed and <code class="prettyprint">Program1</code> is recompiled, the <code class="prettyprint">Console.WriteLine</code> statement will output the new value even if <code class="prettyprint">Program2</code> isn&rsquo;t recompiled. However, had <code class="prettyprint">X</code> been a constant, the value of <code class="prettyprint">X</code> would have been obtained at the time <code class="prettyprint">Program2</code> was compiled, and would remain unaffected by changes in <code class="prettyprint">Program1</code> until <code class="prettyprint">Program2</code> is recompiled.</p>

<h3 id="volatile-fields">Volatile fields</h3>

<p>When a <em>field_declaration</em> includes a <code class="prettyprint">volatile</code> modifier, the fields introduced by that declaration are <strong><em>volatile fields</em></strong>.</p>

<p>For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the <em>lock_statement</em> (<a href="statements.md#the-lock-statement">The lock statement</a>). These optimizations can be performed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted:</p>

<ul>
<li> A read of a volatile field is called a <strong><em>volatile read</em></strong>. A volatile read has &quot;acquire semantics&rdquo;; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence.</li>
<li> A write of a volatile field is called a <strong><em>volatile write</em></strong>. A volatile write has &ldquo;release semantics&rdquo;; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence.</li>
</ul>

<p>These restrictions ensure that all threads will observe volatile writes performed by any other thread in the order in which they were performed. A conforming implementation is not required to provide a single total ordering of volatile writes as seen from all threads of execution. The type of a volatile field must be one of the following:</p>

<ul>
<li> A <em>reference_type</em>.</li>
<li> The type <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">System.IntPtr</code>, or<code class="prettyprint">System.UIntPtr</code>.</li>
<li> An <em>enum_type</em> having an enum base type of <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">uint</code>.</li>
</ul>

<p>The example
&ldquo;`csharp
using System;
using System.Threading;</p>

<p>class Test
{
    public static int result;<br>
    public static volatile bool finished;</p>

<p>static void Thread2() {
        result = 143;<br>
        finished = true; 
    }</p>

<p>static void Main() {
        finished = false;</p>

<p>// Run Thread2() in a new thread
        new Thread(new ThreadStart(Thread2)).Start();</p>

<p>// Wait for Thread2 to signal that it has a result by setting
        // finished to true.
        for (;;) {
            if (finished) {
                Console.WriteLine(&quot;result = {0}&rdquo;, result);
                return;
            }
        }
    }
}
<code class="prettyprint">
produces the output:
</code>
result = 143
&ldquo;`</p>

<p>In this example, the method <code class="prettyprint">Main</code> starts a new thread that runs the method <code class="prettyprint">Thread2</code>. This method stores a value into a non-volatile field called <code class="prettyprint">result</code>, then stores <code class="prettyprint">true</code> in the volatile field <code class="prettyprint">finished</code>. The main thread waits for the field <code class="prettyprint">finished</code> to be set to <code class="prettyprint">true</code>, then reads the field <code class="prettyprint">result</code>. Since <code class="prettyprint">finished</code> has been declared <code class="prettyprint">volatile</code>, the main thread must read the value <code class="prettyprint">143</code> from the field <code class="prettyprint">result</code>. If the field <code class="prettyprint">finished</code> had not been declared <code class="prettyprint">volatile</code>, then it would be permissible for the store to <code class="prettyprint">result</code> to be visible to the main thread after the store to <code class="prettyprint">finished</code>, and hence for the main thread to read the value <code class="prettyprint">0</code> from the field <code class="prettyprint">result</code>. Declaring <code class="prettyprint">finished</code> as a <code class="prettyprint">volatile</code> field prevents any such inconsistency.</p>

<h3 id="field-initialization">Field initialization</h3>

<p>The initial value of a field, whether it be a static field or an instance field, is the default value (<a href="variables.md#default-values">Default values</a>) of the field&rsquo;s type. It is not possible to observe the value of a field before this default initialization has occurred, and a field is thus never &quot;uninitialized&rdquo;. The example
&ldquo;`csharp
using System;</p>

<p>class Test
{
    static bool b;
    int i;</p>

<p>static void Main() {
        Test t = new Test();
        Console.WriteLine(&quot;b = {0}, i = {1}&rdquo;, b, t.i);
    }
}
<code class="prettyprint">
produces the output
</code>
b = False, i = 0
&ldquo;<code class="prettyprint">
because</code>b<code class="prettyprint">and</code>i` are both automatically initialized to default values.</p>

<h3 id="variable-initializers">Variable initializers</h3>

<p>Field declarations may include *variable_initializer*s. For static fields, variable initializers correspond to assignment statements that are executed during class initialization. For instance fields, variable initializers correspond to assignment statements that are executed when an instance of the class is created.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static double x = Math.Sqrt(2.0);
    int i = 100;
    string s = &ldquo;Hello&rdquo;;</p>

<p>static void Main() {
        Test a = new Test();
        Console.WriteLine(&ldquo;x = {0}, i = {1}, s = {2}&rdquo;, x, a.i, a.s);
    }
}
<code class="prettyprint">
produces the output
</code>
x = 1.4142135623731, i = 100, s = Hello
&ldquo;<code class="prettyprint">
because an assignment to</code>x<code class="prettyprint">occurs when static field initializers execute and assignments to</code>i<code class="prettyprint">and</code>s` occur when the instance field initializers execute.</p>

<p>The default value initialization described in <a href="classes.md#field-initialization">Field initialization</a> occurs for all fields, including fields that have variable initializers. Thus, when a class is initialized, all static fields in that class are first initialized to their default values, and then the static field initializers are executed in textual order. Likewise, when an instance of a class is created, all instance fields in that instance are first initialized to their default values, and then the instance field initializers are executed in textual order.</p>

<p>It is possible for static fields with variable initializers to be observed in their default value state. However, this is strongly discouraged as a matter of style. The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static int a = b + 1;
    static int b = a + 1;</p>

<p>static void Main() {
        Console.WriteLine(&ldquo;a = {0}, b = {1}&rdquo;, a, b);
    }
}
<code class="prettyprint">
exhibits this behavior. Despite the circular definitions of a and b, the program is valid. It results in the output
</code>
a = 1, b = 2
&ldquo;<code class="prettyprint">
because the static fields</code>a<code class="prettyprint">and</code>b<code class="prettyprint">are initialized to</code>0<code class="prettyprint">(the default value for</code>int<code class="prettyprint">) before their initializers are executed. When the initializer for</code>a<code class="prettyprint">runs, the value of</code>b<code class="prettyprint">is zero, and so</code>a<code class="prettyprint">is initialized to</code>1<code class="prettyprint">. When the initializer for</code>b<code class="prettyprint">runs, the value of</code>a<code class="prettyprint">is already</code>1<code class="prettyprint">, and so</code>b<code class="prettyprint">is initialized to</code>2`.</p>

<h4 id="static-field-initialization">Static field initialization</h4>

<p>The static field variable initializers of a class correspond to a sequence of assignments that are executed in the textual order in which they appear in the class declaration. If a static constructor (<a href="classes.md#static-constructors">Static constructors</a>) exists in the class, execution of the static field initializers occurs immediately prior to executing that static constructor. Otherwise, the static field initializers are executed at an implementation-dependent time prior to the first use of a static field of that class. The example
&rdquo;`csharp
using System;</p>

<p>class Test 
{ 
    static void Main() {
        Console.WriteLine(&ldquo;{0} {1}&rdquo;, B.Y, A.X);
    }</p>

<p>public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}</p>

<p>class A
{
    public static int X = Test.F(&ldquo;Init A&rdquo;);
}</p>

<p>class B
{
    public static int Y = Test.F(&ldquo;Init B&rdquo;);
}
<code class="prettyprint">
might produce either the output:
</code>
Init A
Init B
1 1
<code class="prettyprint">
or the output:
</code>
Init B
Init A
1 1
<code class="prettyprint">
because the execution of `X`&#39;s initializer and `Y`&#39;s initializer could occur in either order; they are only constrained to occur before the references to those fields. However, in the example:
</code>csharp
using System;</p>

<p>class Test
{
    static void Main() {
        Console.WriteLine(&ldquo;{0} {1}&rdquo;, B.Y, A.X);
    }</p>

<p>public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}</p>

<p>class A
{
    static A() {}</p>

<p>public static int X = Test.F(&ldquo;Init A&rdquo;);
}</p>

<p>class B
{
    static B() {}</p>

<p>public static int Y = Test.F(&ldquo;Init B&rdquo;);
}
<code class="prettyprint">
the output must be:
</code>
Init B
Init A
1 1
&ldquo;<code class="prettyprint">
because the rules for when static constructors execute (as defined in [Static constructors](classes.md#static-constructors)) provide that</code>B<code class="prettyprint">&#39;s static constructor (and hence</code>B<code class="prettyprint">&#39;s static field initializers) must run before</code>A`&rsquo;s static constructor and field initializers.</p>

<h4 id="instance-field-initialization">Instance field initialization</h4>

<p>The instance field variable initializers of a class correspond to a sequence of assignments that are executed immediately upon entry to any one of the instance constructors (<a href="classes.md#constructor-initializers">Constructor initializers</a>) of that class. The variable initializers are executed in the textual order in which they appear in the class declaration. The class instance creation and initialization process is described further in <a href="classes.md#instance-constructors">Instance constructors</a>.</p>

<p>A variable initializer for an instance field cannot reference the instance being created. Thus, it is a compile-time error to reference <code class="prettyprint">this</code> in a variable initializer, as it is a compile-time error for a variable initializer to reference any instance member through a <em>simple_name</em>. In the example
<code class="prettyprint">csharp
class A
{
    int x = 1;
    int y = x + 1;        // Error, reference to instance member of this
}
</code>
the variable initializer for <code class="prettyprint">y</code> results in a compile-time error because it references a member of the instance being created.</p>

<h2 id="methods">Methods</h2>

<p>A <strong><em>method</em></strong> is a member that implements a computation or action that can be performed by an object or class. Methods are declared using *method_declaration*s:</p>
<pre class="highlight plaintext"><code>method_declaration
    : method_header method_body
    ;

method_header
    : attributes? method_modifier* 'partial'? return_type member_name type_parameter_list?
      '(' formal_parameter_list? ')' type_parameter_constraints_clause*
    ;

method_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | method_modifier_unsafe
    ;

return_type
    : type
    | 'void'
    ;

member_name
    : identifier
    | interface_type '.' identifier
    ;

method_body
    : block
    | '=&gt;' expression ';'
    | ';'
    ;
</code></pre>
<p>A <em>method_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>A declaration has a valid combination of modifiers if all of the following are true:</p>

<ul>
<li> The declaration includes a valid combination of access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>).</li>
<li> The declaration does not include the same modifier multiple times.</li>
<li> The declaration includes at most one of the following modifiers: <code class="prettyprint">static</code>, <code class="prettyprint">virtual</code>, and <code class="prettyprint">override</code>.</li>
<li> The declaration includes at most one of the following modifiers: <code class="prettyprint">new</code> and <code class="prettyprint">override</code>.</li>
<li> If the declaration includes the <code class="prettyprint">abstract</code> modifier, then the declaration does not include any of the following modifiers: <code class="prettyprint">static</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">sealed</code> or <code class="prettyprint">extern</code>.</li>
<li> If the declaration includes the <code class="prettyprint">private</code> modifier, then the declaration does not include any of the following modifiers: <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, or <code class="prettyprint">abstract</code>.</li>
<li> If the declaration includes the <code class="prettyprint">sealed</code> modifier, then the declaration also includes the <code class="prettyprint">override</code> modifier.</li>
<li> If the declaration includes the <code class="prettyprint">partial</code> modifier, then it does not include any of the following modifiers: <code class="prettyprint">new</code>, <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, <code class="prettyprint">private</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">sealed</code>, <code class="prettyprint">override</code>, <code class="prettyprint">abstract</code>, or <code class="prettyprint">extern</code>.</li>
</ul>

<p>A method that has the async modifier is an async function and follows the rules described in <a href="classes.md#iterators">Iterators</a>.</p>

<p>The <em>return_type</em> of a method declaration specifies the type of the value computed and returned by the method. The <em>return_type</em> is <code class="prettyprint">void</code> if the method does not return a value. If the declaration includes the <code class="prettyprint">partial</code> modifier, then the return type must be <code class="prettyprint">void</code>.</p>

<p>The <em>member_name</em> specifies the name of the method. Unless the method is an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>), the <em>member_name</em> is simply an <em>identifier</em>. For an explicit interface member implementation, the <em>member_name</em> consists of an <em>interface_type</em> followed by a &rdquo;<code class="prettyprint">.</code>&ldquo; and an <em>identifier</em>.</p>

<p>The optional <em>type_parameter_list</em> specifies the type parameters of the method (<a href="classes.md#type-parameters">Type parameters</a>). If a <em>type_parameter_list</em> is specified the method is a <strong><em>generic method</em></strong>. If the method has an <code class="prettyprint">extern</code> modifier, a <em>type_parameter_list</em> cannot be specified.</p>

<p>The optional <em>formal_parameter_list</em> specifies the parameters of the method (<a href="classes.md#method-parameters">Method parameters</a>).</p>

<p>The optional <em>type_parameter_constraints_clause*s specify constraints on individual type parameters (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) and may only be specified if a *type_parameter_list</em> is also supplied, and the method does not have an <code class="prettyprint">override</code> modifier.</p>

<p>The <em>return_type</em> and each of the types referenced in the <em>formal_parameter_list</em> of a method must be at least as accessible as the method itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The <em>method_body</em> is either a semicolon, a <strong><em>statement body</em></strong> or an <strong><em>expression body</em></strong>. A statement body consists of a <em>block</em>, which specifies the statements to execute when the method is invoked. An expression body consists of <code class="prettyprint">=&gt;</code> followed by an <em>expression</em> and a semicolon, and denotes a single expression to perform when the method is invoked. </p>

<p>For <code class="prettyprint">abstract</code> and <code class="prettyprint">extern</code> methods, the <em>method_body</em> consists simply of a semicolon. For <code class="prettyprint">partial</code> methods the <em>method_body</em> may consist of either a semicolon, a block body or an expression body. For all other methods, the <em>method_body</em> is either a block body or an expression body.</p>

<p>If the <em>method_body</em> consists of a semicolon, then the declaration may not include the <code class="prettyprint">async</code> modifier.</p>

<p>The name, the type parameter list and the formal parameter list of a method define the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of the method. Specifically, the signature of a method consists of its name, the number of type parameters and the number, modifiers, and types of its formal parameters. For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.The return type is not part of a method&rsquo;s signature, nor are the names of the type parameters or the formal parameters.</p>

<p>The name of a method must differ from the names of all other non-methods declared in the same class. In addition, the signature of a method must differ from the signatures of all other methods declared in the same class, and two methods declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</p>

<p>The method&rsquo;s <em>type_parameter*s are in scope throughout the *method_declaration</em>, and can be used to form types throughout that scope in <em>return_type</em>, <em>method_body</em>, and <em>type_parameter_constraints_clause*s but not in *attributes</em>.</p>

<p>All formal parameters and type parameters must have different names.</p>

<h3 id="method-parameters">Method parameters</h3>

<p>The parameters of a method, if any, are declared by the method&rsquo;s <em>formal_parameter_list</em>.</p>
<pre class="highlight plaintext"><code>formal_parameter_list
    : fixed_parameters
    | fixed_parameters ',' parameter_array
    | parameter_array
    ;

fixed_parameters
    : fixed_parameter (',' fixed_parameter)*
    ;

fixed_parameter
    : attributes? parameter_modifier? type identifier default_argument?
    ;

default_argument
    : '=' expression
    ;

parameter_modifier
    : 'ref'
    | 'out'
    | 'this'
    ;

parameter_array
    : attributes? 'params' array_type identifier
    ;
</code></pre>
<p>The formal parameter list consists of one or more comma-separated parameters of which only the last may be a <em>parameter_array</em>.</p>

<p>A <em>fixed_parameter</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), an optional <code class="prettyprint">ref</code>, <code class="prettyprint">out</code> or <code class="prettyprint">this</code> modifier, a <em>type</em>, an <em>identifier</em> and an optional <em>default_argument</em>. Each <em>fixed_parameter</em> declares a parameter of the given type with the given name. The <code class="prettyprint">this</code> modifier designates the method as an extension method and is only allowed on the first parameter of a static method. Extension methods are further described in <a href="classes.md#extension-methods">Extension methods</a>.</p>

<p>A <em>fixed_parameter</em> with a <em>default_argument</em> is known as an <strong><em>optional parameter</em></strong>, whereas a <em>fixed_parameter</em> without a <em>default_argument</em> is a <strong><em>required parameter</em></strong>. A required parameter may not appear after an optional parameter in a <em>formal_parameter_list</em>.</p>

<p>A <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter cannot have a <em>default_argument</em>. The <em>expression</em> in a <em>default_argument</em> must be one of the following:</p>

<ul>
<li> a <em>constant_expression</em></li>
<li> an expression of the form <code class="prettyprint">new S()</code> where <code class="prettyprint">S</code> is a value type</li>
<li> an expression of the form <code class="prettyprint">default(S)</code> where <code class="prettyprint">S</code> is a value type</li>
</ul>

<p>The <em>expression</em> must be implicitly convertible by an identity or nullable conversion to the type of the parameter.</p>

<p>If optional parameters occur in an implementing partial method declaration (<a href="classes.md#partial-methods">Partial methods</a>) , an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>) or in a single-parameter indexer declaration (<a href="classes.md#indexers">Indexers</a>) the compiler should give a warning, since these members can never be invoked in a way that permits arguments to be omitted.</p>

<p>A <em>parameter_array</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">params</code> modifier, an <em>array_type</em>, and an <em>identifier</em>. A parameter array declares a single parameter of the given array type with the given name. The <em>array_type</em> of a parameter array must be a single-dimensional array type (<a href="arrays.md#array-types">Array types</a>). In a method invocation, a parameter array permits either a single argument of the given array type to be specified, or it permits zero or more arguments of the array element type to be specified. Parameter arrays are described further in <a href="classes.md#parameter-arrays">Parameter arrays</a>.</p>

<p>A <em>parameter_array</em> may occur after an optional parameter, but cannot have a default value &ndash; the omission of arguments for a <em>parameter_array</em> would instead result in the creation of an empty array.</p>

<p>The following example illustrates different kinds of parameters:
<code class="prettyprint">csharp
public void M(
    ref int      i,
    decimal      d,
    bool         b = false,
    bool?        n = false,
    string       s = &quot;Hello&quot;,
    object       o = null,
    T            t = default(T),
    params int[] a
) { }
</code></p>

<p>In the <em>formal_parameter_list</em> for <code class="prettyprint">M</code>, <code class="prettyprint">i</code> is a required ref parameter, <code class="prettyprint">d</code> is a required value parameter, <code class="prettyprint">b</code>, <code class="prettyprint">s</code>, <code class="prettyprint">o</code> and <code class="prettyprint">t</code> are optional value parameters and <code class="prettyprint">a</code> is a parameter array.</p>

<p>A method declaration creates a separate declaration space for parameters, type parameters and local variables. Names are introduced into this declaration space by the type parameter list and the formal parameter list of the method and by local variable declarations in the <em>block</em> of the method. It is an error for two members of a method declaration space to have the same name. It is an error for the method declaration space and the local variable declaration space of a nested declaration space to contain elements with the same name.</p>

<p>A method invocation (<a href="expressions.md#method-invocations">Method invocations</a>) creates a copy, specific to that invocation, of the formal parameters and local variables of the method, and the argument list of the invocation assigns values or variable references to the newly created formal parameters. Within the <em>block</em> of a method, formal parameters can be referenced by their identifiers in <em>simple_name</em> expressions (<a href="expressions.md#simple-names">Simple names</a>).</p>

<p>There are four kinds of formal parameters:</p>

<ul>
<li> Value parameters, which are declared without any modifiers.</li>
<li> Reference parameters, which are declared with the <code class="prettyprint">ref</code> modifier.</li>
<li> Output parameters, which are declared with the <code class="prettyprint">out</code> modifier.</li>
<li> Parameter arrays, which are declared with the <code class="prettyprint">params</code> modifier.</li>
</ul>

<p>As described in <a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>, the <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> modifiers are part of a method&rsquo;s signature, but the <code class="prettyprint">params</code> modifier is not.</p>

<h4 id="value-parameters">Value parameters</h4>

<p>A parameter declared with no modifiers is a value parameter. A value parameter corresponds to a local variable that gets its initial value from the corresponding argument supplied in the method invocation.</p>

<p>When a formal parameter is a value parameter, the corresponding argument in a method invocation must be an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the formal parameter type.</p>

<p>A method is permitted to assign new values to a value parameter. Such assignments only affect the local storage location represented by the value parameterâ€”they have no effect on the actual argument given in the method invocation.</p>

<h4 id="reference-parameters">Reference parameters</h4>

<p>A parameter declared with a <code class="prettyprint">ref</code> modifier is a reference parameter. Unlike a value parameter, a reference parameter does not create a new storage location. Instead, a reference parameter represents the same storage location as the variable given as the argument in the method invocation.</p>

<p>When a formal parameter is a reference parameter, the corresponding argument in a method invocation must consist of the keyword <code class="prettyprint">ref</code> followed by a <em>variable_reference</em> (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>) of the same type as the formal parameter. A variable must be definitely assigned before it can be passed as a reference parameter.</p>

<p>Within a method, a reference parameter is always considered definitely assigned.</p>

<p>A method declared as an iterator (<a href="classes.md#iterators">Iterators</a>) cannot have reference parameters.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Swap(ref int x, ref int y) {
        int temp = x;
        x = y;
        y = temp;
    }</p>

<p>static void Main() {
        int i = 1, j = 2;
        Swap(ref i, ref j);
        Console.WriteLine(&ldquo;i = {0}, j = {1}&rdquo;, i, j);
    }
}
<code class="prettyprint">
produces the output
</code>
i = 2, j = 1
&ldquo;`</p>

<p>For the invocation of <code class="prettyprint">Swap</code> in <code class="prettyprint">Main</code>, <code class="prettyprint">x</code> represents <code class="prettyprint">i</code> and <code class="prettyprint">y</code> represents <code class="prettyprint">j</code>. Thus, the invocation has the effect of swapping the values of <code class="prettyprint">i</code> and <code class="prettyprint">j</code>.</p>

<p>In a method that takes reference parameters it is possible for multiple names to represent the same storage location. In the example
&rdquo;`csharp
class A
{
    string s;</p>

<p>void F(ref string a, ref string b) {
        s = &ldquo;One&rdquo;;
        a = &ldquo;Two&rdquo;;
        b = &ldquo;Three&rdquo;;
    }</p>

<p>void G() {
        F(ref s, ref s);
    }
}
&ldquo;<code class="prettyprint">
the invocation of</code>F<code class="prettyprint">in</code>G<code class="prettyprint">passes a reference to</code>s<code class="prettyprint">for both</code>a<code class="prettyprint">and</code>b<code class="prettyprint">. Thus, for that invocation, the names</code>s<code class="prettyprint">,</code>a<code class="prettyprint">, and</code>b<code class="prettyprint">all refer to the same storage location, and the three assignments all modify the instance field</code>s`.</p>

<h4 id="output-parameters">Output parameters</h4>

<p>A parameter declared with an <code class="prettyprint">out</code> modifier is an output parameter. Similar to a reference parameter, an output parameter does not create a new storage location. Instead, an output parameter represents the same storage location as the variable given as the argument in the method invocation.</p>

<p>When a formal parameter is an output parameter, the corresponding argument in a method invocation must consist of the keyword <code class="prettyprint">out</code> followed by a <em>variable_reference</em> (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>) of the same type as the formal parameter. A variable need not be definitely assigned before it can be passed as an output parameter, but following an invocation where a variable was passed as an output parameter, the variable is considered definitely assigned.</p>

<p>Within a method, just like a local variable, an output parameter is initially considered unassigned and must be definitely assigned before its value is used.</p>

<p>Every output parameter of a method must be definitely assigned before the method returns.</p>

<p>A method declared as a partial method (<a href="classes.md#partial-methods">Partial methods</a>) or an iterator (<a href="classes.md#iterators">Iterators</a>) cannot have output parameters.</p>

<p>Output parameters are typically used in methods that produce multiple return values. For example:
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void SplitPath(string path, out string dir, out string name) {
        int i = path.Length;
        while (i &gt; 0) {
            char ch = path[i - 1];
            if (ch == &rsquo;\&lsquo; || ch == &rsquo;/&lsquo; || ch == &rsquo;:&lsquo;) break;
            i&ndash;;
        }
        dir = path.Substring(0, i);
        name = path.Substring(i);
    }</p>

<p>static void Main() {
        string dir, name;
        SplitPath(&ldquo;c:\Windows\System\hello.txt&rdquo;, out dir, out name);
        Console.WriteLine(dir);
        Console.WriteLine(name);
    }
}
&ldquo;`</p>

<p>The example produces the output:
<code class="prettyprint">
c:\Windows\System\
hello.txt
</code></p>

<p>Note that the <code class="prettyprint">dir</code> and <code class="prettyprint">name</code> variables can be unassigned before they are passed to <code class="prettyprint">SplitPath</code>, and that they are considered definitely assigned following the call.</p>

<h4 id="parameter-arrays">Parameter arrays</h4>

<p>A parameter declared with a <code class="prettyprint">params</code> modifier is a parameter array. If a formal parameter list includes a parameter array, it must be the last parameter in the list and it must be of a single-dimensional array type. For example, the types <code class="prettyprint">string[]</code> and <code class="prettyprint">string[][]</code> can be used as the type of a parameter array, but the type <code class="prettyprint">string[,]</code> can not. It is not possible to combine the <code class="prettyprint">params</code> modifier with the modifiers <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</p>

<p>A parameter array permits arguments to be specified in one of two ways in a method invocation:</p>

<ul>
<li> The argument given for a parameter array can be a single expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the parameter array type. In this case, the parameter array acts precisely like a value parameter.</li>
<li> Alternatively, the invocation can specify zero or more arguments for the parameter array, where each argument is an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the element type of the parameter array. In this case, the invocation creates an instance of the parameter array type with a length corresponding to the number of arguments, initializes the elements of the array instance with the given argument values, and uses the newly created array instance as the actual argument.</li>
</ul>

<p>Except for allowing a variable number of arguments in an invocation, a parameter array is precisely equivalent to a value parameter (<a href="classes.md#value-parameters">Value parameters</a>) of the same type.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params int[] args) {
        Console.Write(&ldquo;Array contains {0} elements:&rdquo;, args.Length);
        foreach (int i in args) 
            Console.Write(&ldquo; {0}&rdquo;, i);
        Console.WriteLine();
    }</p>

<p>static void Main() {
        int[] arr = {1, 2, 3};
        F(arr);
        F(10, 20, 30, 40);
        F();
    }
}
<code class="prettyprint">
produces the output
</code>
Array contains 3 elements: 1 2 3
Array contains 4 elements: 10 20 30 40
Array contains 0 elements:
&ldquo;`</p>

<p>The first invocation of <code class="prettyprint">F</code> simply passes the array <code class="prettyprint">a</code> as a value parameter. The second invocation of <code class="prettyprint">F</code> automatically creates a four-element <code class="prettyprint">int[]</code> with the given element values and passes that array instance as a value parameter. Likewise, the third invocation of <code class="prettyprint">F</code> creates a zero-element <code class="prettyprint">int[]</code> and passes that instance as a value parameter. The second and third invocations are precisely equivalent to writing:
<code class="prettyprint">csharp
F(new int[] {10, 20, 30, 40});
F(new int[] {});
</code></p>

<p>When performing overload resolution, a method with a parameter array may be applicable either in its normal form or in its expanded form (<a href="expressions.md#applicable-function-member">Applicable function member</a>). The expanded form of a method is available only if the normal form of the method is not applicable and only if an applicable method with the same signature as the expanded form is not already declared in the same type.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params object[] a) {
        Console.WriteLine(&ldquo;F(object[])&rdquo;);
    }</p>

<p>static void F() {
        Console.WriteLine(&ldquo;F()&rdquo;);
    }</p>

<p>static void F(object a0, object a1) {
        Console.WriteLine(&ldquo;F(object,object)&rdquo;);
    }</p>

<p>static void Main() {
        F();
        F(1);
        F(1, 2);
        F(1, 2, 3);
        F(1, 2, 3, 4);
    }
}
<code class="prettyprint">
produces the output
</code>
F();
F(object[]);
F(object,object);
F(object[]);
F(object[]);
&ldquo;`</p>

<p>In the example, two of the possible expanded forms of the method with a parameter array are already included in the class as regular methods. These expanded forms are therefore not considered when performing overload resolution, and the first and third method invocations thus select the regular methods. When a class declares a method with a parameter array, it is not uncommon to also include some of the expanded forms as regular methods. By doing so it is possible to avoid the allocation of an array instance that occurs when an expanded form of a method with a parameter array is invoked.</p>

<p>When the type of a parameter array is <code class="prettyprint">object[]</code>, a potential ambiguity arises between the normal form of the method and the expended form for a single <code class="prettyprint">object</code> parameter. The reason for the ambiguity is that an <code class="prettyprint">object[]</code> is itself implicitly convertible to type <code class="prettyprint">object</code>. The ambiguity presents no problem, however, since it can be resolved by inserting a cast if needed.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params object[] args) {
        foreach (object o in args) {
            Console.Write(o.GetType().FullName);
            Console.Write(&ldquo; &rdquo;);
        }
        Console.WriteLine();
    }</p>

<p>static void Main() {
        object[] a = {1, &ldquo;Hello&rdquo;, 123.456};
        object o = a;
        F(a);
        F((object)a);
        F(o);
        F((object[])o);
    }
}
<code class="prettyprint">
produces the output
</code>
System.Int32 System.String System.Double
System.Object[]
System.Object[]
System.Int32 System.String System.Double
&ldquo;`</p>

<p>In the first and last invocations of <code class="prettyprint">F</code>, the normal form of <code class="prettyprint">F</code> is applicable because an implicit conversion exists from the argument type to the parameter type (both are of type <code class="prettyprint">object[]</code>). Thus, overload resolution selects the normal form of <code class="prettyprint">F</code>, and the argument is passed as a regular value parameter. In the second and third invocations, the normal form of <code class="prettyprint">F</code> is not applicable because no implicit conversion exists from the argument type to the parameter type (type <code class="prettyprint">object</code> cannot be implicitly converted to type <code class="prettyprint">object[]</code>). However, the expanded form of <code class="prettyprint">F</code> is applicable, so it is selected by overload resolution. As a result, a one-element <code class="prettyprint">object[]</code> is created by the invocation, and the single element of the array is initialized with the given argument value (which itself is a reference to an <code class="prettyprint">object[]</code>).</p>

<h3 id="static-and-instance-methods">Static and instance methods</h3>

<p>When a method declaration includes a <code class="prettyprint">static</code> modifier, that method is said to be a static method. When no <code class="prettyprint">static</code> modifier is present, the method is said to be an instance method.</p>

<p>A static method does not operate on a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in a static method.</p>

<p>An instance method operates on a given instance of a class, and that instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</p>

<p>When a method is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static method, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance method, <code class="prettyprint">E</code> must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="virtual-methods">Virtual methods</h3>

<p>When an instance method declaration includes a <code class="prettyprint">virtual</code> modifier, that method is said to be a virtual method. When no <code class="prettyprint">virtual</code> modifier is present, the method is said to be a non-virtual method.</p>

<p>The implementation of a non-virtual method is invariant: The implementation is the same whether the method is invoked on an instance of the class in which it is declared or an instance of a derived class. In contrast, the implementation of a virtual method can be superseded by derived classes. The process of superseding the implementation of an inherited virtual method is known as <strong><em>overriding</em></strong> that method (<a href="classes.md#override-methods">Override methods</a>).</p>

<p>In a virtual method invocation, the <strong><em>run-time type</em></strong> of the instance for which that invocation takes place determines the actual method implementation to invoke. In a non-virtual method invocation, the <strong><em>compile-time type</em></strong> of the instance is the determining factor. In precise terms, when a method named <code class="prettyprint">N</code> is invoked with an argument list <code class="prettyprint">A</code> on an instance with a compile-time type <code class="prettyprint">C</code> and a run-time type <code class="prettyprint">R</code> (where <code class="prettyprint">R</code> is either <code class="prettyprint">C</code> or a class derived from <code class="prettyprint">C</code>), the invocation is processed as follows:</p>

<ul>
<li> First, overload resolution is applied to <code class="prettyprint">C</code>, <code class="prettyprint">N</code>, and <code class="prettyprint">A</code>, to select a specific method <code class="prettyprint">M</code> from the set of methods declared in and inherited by <code class="prettyprint">C</code>. This is described in <a href="expressions.md#method-invocations">Method invocations</a>.</li>
<li> Then, if <code class="prettyprint">M</code> is a non-virtual method, <code class="prettyprint">M</code> is invoked.</li>
<li> Otherwise, <code class="prettyprint">M</code> is a virtual method, and the most derived implementation of <code class="prettyprint">M</code> with respect to <code class="prettyprint">R</code> is invoked.</li>
</ul>

<p>For every virtual method declared in or inherited by a class, there exists a <strong><em>most derived implementation</em></strong> of the method with respect to that class. The most derived implementation of a virtual method <code class="prettyprint">M</code> with respect to a class <code class="prettyprint">R</code> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">R</code> contains the introducing <code class="prettyprint">virtual</code> declaration of <code class="prettyprint">M</code>, then this is the most derived implementation of <code class="prettyprint">M</code>.</li>
<li> Otherwise, if <code class="prettyprint">R</code> contains an <code class="prettyprint">override</code> of <code class="prettyprint">M</code>, then this is the most derived implementation of <code class="prettyprint">M</code>.</li>
<li> Otherwise, the most derived implementation of <code class="prettyprint">M</code> with respect to <code class="prettyprint">R</code> is the same as the most derived implementation of <code class="prettyprint">M</code> with respect to the direct base class of <code class="prettyprint">R</code>.</li>
</ul>

<p>The following example illustrates the differences between virtual and non-virtual methods:
&rdquo;`csharp
using System;</p>

<p>class A
{
    public void F() { Console.WriteLine(&ldquo;A.F&rdquo;); }</p>

<p>public virtual void G() { Console.WriteLine(&ldquo;A.G&rdquo;); }
}</p>

<p>class B: A
{
    new public void F() { Console.WriteLine(&ldquo;B.F&rdquo;); }</p>

<p>public override void G() { Console.WriteLine(&ldquo;B.G&rdquo;); }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        a.F();
        b.F();
        a.G();
        b.G();
    }
}
&ldquo;`</p>

<p>In the example, <code class="prettyprint">A</code> introduces a non-virtual method <code class="prettyprint">F</code> and a virtual method <code class="prettyprint">G</code>. The class <code class="prettyprint">B</code> introduces a new non-virtual method <code class="prettyprint">F</code>, thus hiding the inherited <code class="prettyprint">F</code>, and also overrides the inherited method <code class="prettyprint">G</code>. The example produces the output:
<code class="prettyprint">
A.F
B.F
B.G
B.G
</code></p>

<p>Notice that the statement <code class="prettyprint">a.G()</code> invokes <code class="prettyprint">B.G</code>, not <code class="prettyprint">A.G</code>. This is because the run-time type of the instance (which is <code class="prettyprint">B</code>), not the compile-time type of the instance (which is <code class="prettyprint">A</code>), determines the actual method implementation to invoke.</p>

<p>Because methods are allowed to hide inherited methods, it is possible for a class to contain several virtual methods with the same signature. This does not present an ambiguity problem, since all but the most derived method are hidden. In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() { Console.WriteLine(&ldquo;A.F&rdquo;); }
}</p>

<p>class B: A
{
    public override void F() { Console.WriteLine(&ldquo;B.F&rdquo;); }
}</p>

<p>class C: B
{
    new public virtual void F() { Console.WriteLine(&ldquo;C.F&rdquo;); }
}</p>

<p>class D: C
{
    public override void F() { Console.WriteLine(&ldquo;D.F&rdquo;); }
}</p>

<p>class Test
{
    static void Main() {
        D d = new D();
        A a = d;
        B b = d;
        C c = d;
        a.F();
        b.F();
        c.F();
        d.F();
    }
}
<code class="prettyprint">
the `C` and `D` classes contain two virtual methods with the same signature: The one introduced by `A` and the one introduced by `C`. The method introduced by `C` hides the method inherited from `A`. Thus, the override declaration in `D` overrides the method introduced by `C`, and it is not possible for `D` to override the method introduced by `A`. The example produces the output:
</code>
B.F
B.F
D.F
D.F
&ldquo;`</p>

<p>Note that it is possible to invoke the hidden virtual method by accessing an instance of <code class="prettyprint">D</code> through a less derived type in which the method is not hidden.</p>

<h3 id="override-methods">Override methods</h3>

<p>When an instance method declaration includes an <code class="prettyprint">override</code> modifier, the method is said to be an <strong><em>override method</em></strong>. An override method overrides an inherited virtual method with the same signature. Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</p>

<p>The method overridden by an <code class="prettyprint">override</code> declaration is known as the <strong><em>overridden base method</em></strong>. For an override method <code class="prettyprint">M</code> declared in a class <code class="prettyprint">C</code>, the overridden base method is determined by examining each base class type of <code class="prettyprint">C</code>, starting with the direct base class type of <code class="prettyprint">C</code> and continuing with each successive direct base class type, until in a given base class type at least one accessible method is located which has the same signature as <code class="prettyprint">M</code> after substitution of type arguments. For the purposes of locating the overridden base method, a method is considered accessible if it is <code class="prettyprint">public</code>, if it is <code class="prettyprint">protected</code>, if it is <code class="prettyprint">protected internal</code>, or if it is <code class="prettyprint">internal</code> and declared in the same program as <code class="prettyprint">C</code>.</p>

<p>A compile-time error occurs unless all of the following are true for an override declaration:</p>

<ul>
<li> An overridden base method can be located as described above.</li>
<li> There is exactly one such overridden base method. This restriction has effect only if the base class type is a constructed type where the substitution of type arguments makes the signature of two methods the same.</li>
<li> The overridden base method is a virtual, abstract, or override method. In other words, the overridden base method cannot be static or non-virtual.</li>
<li> The overridden base method is not a sealed method.</li>
<li> The override method and the overridden base method have the same return type.</li>
<li> The override declaration and the overridden base method have the same declared accessibility. In other words, an override declaration cannot change the accessibility of the virtual method. However, if the overridden base method is protected internal and it is declared in a different assembly than the assembly containing the override method then the override method&rsquo;s declared accessibility must be protected.</li>
<li> The override declaration does not specify type-parameter-constraints-clauses. Instead the constraints are inherited from the overridden base method. Note that constraints that are type parameters in the overridden method may be replaced by type arguments in the inherited constraint. This can lead to constraints that are not legal when explicitly specified, such as value types or sealed types.</li>
</ul>

<p>The following example demonstrates how the overriding rules work for generic classes:
&rdquo;`csharp
abstract class C<T>
{
    public virtual T F() {&hellip;}
    public virtual C<T> G() {&hellip;}
    public virtual void H(C<T> x) {&hellip;}
}</p>

<p>class D: C<string>
{
    public override string F() {&hellip;}            // Ok
    public override C<string> G() {&hellip;}         // Ok
    public override void H(C<T> x) {&hellip;}        // Error, should be C<string>
}</p>

<p>class E<T,U>: C<U>
{
    public override U F() {&hellip;}                 // Ok
    public override C<U> G() {&hellip;}              // Ok
    public override void H(C<T> x) {&hellip;}        // Error, should be C<U>
}
&ldquo;`</p>

<p>An override declaration can access the overridden base method using a <em>base_access</em> (<a href="expressions.md#base-access">Base access</a>). In the example
&rdquo;`csharp
class A
{
    int x;</p>

<p>public virtual void PrintFields() {
        Console.WriteLine(&ldquo;x = {0}&rdquo;, x);
    }
}</p>

<p>class B: A
{
    int y;</p>

<p>public override void PrintFields() {
        base.PrintFields();
        Console.WriteLine(&ldquo;y = {0}&rdquo;, y);
    }
}
&ldquo;<code class="prettyprint">
the</code>base.PrintFields()<code class="prettyprint">invocation in</code>B<code class="prettyprint">invokes the</code>PrintFields<code class="prettyprint">method declared in</code>A<code class="prettyprint">. A *base_access* disables the virtual invocation mechanism and simply treats the base method as a non-virtual method. Had the invocation in</code>B<code class="prettyprint">been written</code>((A)this).PrintFields()<code class="prettyprint">, it would recursively invoke the</code>PrintFields<code class="prettyprint">method declared in</code>B<code class="prettyprint">, not the one declared in</code>A<code class="prettyprint">, since</code>PrintFields<code class="prettyprint">is virtual and the run-time type of</code>((A)this)<code class="prettyprint">is</code>B`.</p>

<p>Only by including an <code class="prettyprint">override</code> modifier can a method override another method. In all other cases, a method with the same signature as an inherited method simply hides the inherited method. In the example
&rdquo;`csharp
class A
{
    public virtual void F() {}
}</p>

<p>class B: A
{
    public virtual void F() {}        // Warning, hiding inherited F()
}
&ldquo;<code class="prettyprint">
the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">does not include an</code>override<code class="prettyprint">modifier and therefore does not override the</code>F<code class="prettyprint">method in</code>A<code class="prettyprint">. Rather, the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">hides the method in</code>A<code class="prettyprint">, and a warning is reported because the declaration does not include a</code>new` modifier.</p>

<p>In the example
&rdquo;`csharp
class A
{
    public virtual void F() {}
}</p>

<p>class B: A
{
    new private void F() {}        // Hides A.F within body of B
}</p>

<p>class C: B
{
    public override void F() {}    // Ok, overrides A.F
}
&ldquo;<code class="prettyprint">
the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">hides the virtual</code>F<code class="prettyprint">method inherited from</code>A<code class="prettyprint">. Since the new</code>F<code class="prettyprint">in</code>B<code class="prettyprint">has private access, its scope only includes the class body of</code>B<code class="prettyprint">and does not extend to</code>C<code class="prettyprint">. Therefore, the declaration of</code>F<code class="prettyprint">in</code>C<code class="prettyprint">is permitted to override the</code>F<code class="prettyprint">inherited from</code>A`.</p>

<h3 id="sealed-methods">Sealed methods</h3>

<p>When an instance method declaration includes a <code class="prettyprint">sealed</code> modifier, that method is said to be a <strong><em>sealed method</em></strong>. If an instance method declaration includes the  <code class="prettyprint">sealed</code> modifier, it must also include the <code class="prettyprint">override</code> modifier. Use of the <code class="prettyprint">sealed</code> modifier prevents a derived class from further overriding the method.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }</p>

<p>public virtual void G() {
        Console.WriteLine(&ldquo;A.G&rdquo;);
    }
}</p>

<p>class B: A
{
    sealed override public void F() {
        Console.WriteLine(&ldquo;B.F&rdquo;);
    } </p>

<p>override public void G() {
        Console.WriteLine(&ldquo;B.G&rdquo;);
    } 
}</p>

<p>class C: B
{
    override public void G() {
        Console.WriteLine(&ldquo;C.G&rdquo;);
    } 
}
&ldquo;<code class="prettyprint">
the class</code>B<code class="prettyprint">provides two override methods: an</code>F<code class="prettyprint">method that has the</code>sealed<code class="prettyprint">modifier and a</code>G<code class="prettyprint">method that does not.</code>B<code class="prettyprint">&#39;s use of the sealed</code>modifier<code class="prettyprint">prevents</code>C<code class="prettyprint">from further overriding</code>F`.</p>

<h3 id="abstract-methods">Abstract methods</h3>

<p>When an instance method declaration includes an <code class="prettyprint">abstract</code> modifier, that method is said to be an <strong><em>abstract method</em></strong>. Although an abstract method is implicitly also a virtual method, it cannot have the modifier <code class="prettyprint">virtual</code>.</p>

<p>An abstract method declaration introduces a new virtual method but does not provide an implementation of that method. Instead, non-abstract derived classes are required to provide their own implementation by overriding that method. Because an abstract method provides no actual implementation, the <em>method_body</em> of an abstract method simply consists of a semicolon.</p>

<p>Abstract method declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).</p>

<p>In the example
&rdquo;`csharp
public abstract class Shape
{
    public abstract void Paint(Graphics g, Rectangle r);
}</p>

<p>public class Ellipse: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawEllipse&reg;;
    }
}</p>

<p>public class Box: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawRect&reg;;
    }
}
&ldquo;<code class="prettyprint">
the</code>Shape<code class="prettyprint">class defines the abstract notion of a geometrical shape object that can paint itself. The</code>Paint<code class="prettyprint">method is abstract because there is no meaningful default implementation. The</code>Ellipse<code class="prettyprint">and</code>Box<code class="prettyprint">classes are concrete</code>Shape<code class="prettyprint">implementations. Because these classes are non-abstract, they are required to override the</code>Paint` method and provide an actual implementation.</p>

<p>It is a compile-time error for a <em>base_access</em> (<a href="expressions.md#base-access">Base access</a>) to reference an abstract method. In the example
&rdquo;`csharp
abstract class A
{
    public abstract void F();
}</p>

<p>class B: A
{
    public override void F() {
        base.F();                        // Error, base.F is abstract
    }
}
&ldquo;<code class="prettyprint">
a compile-time error is reported for the</code>base.F()` invocation because it references an abstract method.</p>

<p>An abstract method declaration is permitted to override a virtual method. This allows an abstract class to force re-implementation of the method in derived classes, and makes the original implementation of the method unavailable. In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }
}</p>

<p>abstract class B: A
{
    public abstract override void F();
}</p>

<p>class C: B
{
    public override void F() {
        Console.WriteLine(&ldquo;C.F&rdquo;);
    }
}
&ldquo;<code class="prettyprint">
class</code>A<code class="prettyprint">declares a virtual method, class</code>B<code class="prettyprint">overrides this method with an abstract method, and class</code>C` overrides the abstract method to provide its own implementation.</p>

<h3 id="external-methods">External methods</h3>

<p>When a method declaration includes an <code class="prettyprint">extern</code> modifier, that method is said to be an <strong><em>external method</em></strong>. External methods are implemented externally, typically using a language other than C#. Because an external method declaration provides no actual implementation, the <em>method_body</em> of an external method simply consists of a semicolon. An external method may not be generic.</p>

<p>The <code class="prettyprint">extern</code> modifier is typically used in conjunction with a <code class="prettyprint">DllImport</code> attribute (<a href="attributes.md#interoperation-with-com-and-win32-components">Interoperation with COM and Win32 components</a>), allowing external methods to be implemented by DLLs (Dynamic Link Libraries). The execution environment may support other mechanisms whereby implementations of external methods can be provided.</p>

<p>When an external method includes a <code class="prettyprint">DllImport</code> attribute, the method declaration must also include a <code class="prettyprint">static</code> modifier. This example demonstrates the use of the <code class="prettyprint">extern</code> modifier and the <code class="prettyprint">DllImport</code> attribute:
&rdquo;`csharp
using System.Text;
using System.Security.Permissions;
using System.Runtime.InteropServices;</p>

<p>class Path
{
    [DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool CreateDirectory(string name, SecurityAttribute sa);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool RemoveDirectory(string name);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern int GetCurrentDirectory(int bufSize, StringBuilder buf);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool SetCurrentDirectory(string name);
}
&ldquo;`</p>

<h3 id="partial-methods-recap">Partial methods (recap)</h3>

<p>When a method declaration includes a <code class="prettyprint">partial</code> modifier, that method is said to be a <strong><em>partial method</em></strong>. Partial methods can only be declared as members of partial types (<a href="classes.md#partial-types">Partial types</a>), and are subject to a number of restrictions. Partial methods are further described in <a href="classes.md#partial-methods">Partial methods</a>.</p>

<h3 id="extension-methods">Extension methods</h3>

<p>When the first parameter of a method includes the <code class="prettyprint">this</code> modifier, that method is said to be an <strong><em>extension method</em></strong>. Extension methods can only be declared in non-generic, non-nested static classes. The first parameter of an extension method can have no modifiers other than <code class="prettyprint">this</code>, and the parameter type cannot be a pointer type.</p>

<p>The following is an example of a static class that declares two extension methods:
&rdquo;`csharp
public static class Extensions
{
    public static int ToInt32(this string s) {
        return Int32.Parse(s);
    }</p>

<p>public static T[] Slice<T>(this T[] source, int index, int count) {
        if (index &lt; 0 || count &lt; 0 || source.Length - index &lt; count)
            throw new ArgumentException();
        T[] result = new T[count];
        Array.Copy(source, index, result, 0, count);
        return result;
    }
}
&ldquo;`</p>

<p>An extension method is a regular static method. In addition, where its enclosing static class is in scope, an extension method can be invoked using instance method invocation syntax (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>), using the receiver expression as the first argument.</p>

<p>The following program uses the extension methods declared above:
<code class="prettyprint">csharp
static class Program
{
    static void Main() {
        string[] strings = { &quot;1&quot;, &quot;22&quot;, &quot;333&quot;, &quot;4444&quot; };
        foreach (string s in strings.Slice(1, 2)) {
            Console.WriteLine(s.ToInt32());
        }
    }
}
</code></p>

<p>The <code class="prettyprint">Slice</code> method is available on the <code class="prettyprint">string[]</code>, and the <code class="prettyprint">ToInt32</code> method is available on <code class="prettyprint">string</code>, because they have been declared as extension methods. The meaning of the program is the same as the following, using ordinary static method calls:
<code class="prettyprint">csharp
static class Program
{
    static void Main() {
        string[] strings = { &quot;1&quot;, &quot;22&quot;, &quot;333&quot;, &quot;4444&quot; };
        foreach (string s in Extensions.Slice(strings, 1, 2)) {
            Console.WriteLine(Extensions.ToInt32(s));
        }
    }
}
</code></p>

<h3 id="method-body">Method body</h3>

<p>The <em>method_body</em> of a method declaration consists of either a block body, an expression body or a semicolon.</p>

<p>The <strong><em>result type</em></strong> of a method is <code class="prettyprint">void</code> if the return type is <code class="prettyprint">void</code>, or if the method is async and the return type is <code class="prettyprint">System.Threading.Tasks.Task</code>. Otherwise, the result type of a non-async method is its return type, and the result type of an async method with return type <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code> is <code class="prettyprint">T</code>.</p>

<p>When a method has a <code class="prettyprint">void</code> result type and a block body, <code class="prettyprint">return</code> statements (<a href="statements.md#the-return-statement">The return statement</a>) in the block are not permitted to specify an expression. If execution of the block of a void method completes normally (that is, control flows off the end of the method body), that method simply returns to its current caller.</p>

<p>When a method has a <code class="prettyprint">void</code> result and an expression body, the expression <code class="prettyprint">E</code> must be a <em>statement_expression</em>, and the body is exactly equivalent to a block body of the form <code class="prettyprint">{ E; }</code>.</p>

<p>When a method has a non-void result type and a block body, each <code class="prettyprint">return</code> statement in the block must specify an expression that is implicitly convertible to the result type. The endpoint of a block body of a value-returning method must not be reachable. In other words, in a value-returning method with a block body, control is not permitted to flow off the end of the method body.</p>

<p>When a method has a non-void result type and an expression body, the expression must be implicitly convertible to the result type, and the body is exactly equivalent to a block body of the form <code class="prettyprint">{ return E; }</code>.</p>

<p>In the example
&rdquo;`csharp
class A
{
    public int F() {}            // Error, return value required</p>

<p>public int G() {
        return 1;
    }</p>

<p>public int H(bool b) {
        if (b) {
            return 1;
        }
        else {
            return 0;
        }
    }</p>

<p>public int I(bool b) =&gt; b ? 1 : 0;
}
&ldquo;<code class="prettyprint">
the value-returning</code>F<code class="prettyprint">method results in a compile-time error because control can flow off the end of the method body. The</code>G<code class="prettyprint">and</code>H<code class="prettyprint">methods are correct because all possible execution paths end in a return statement that specifies a return value. The</code>I` method is correct, because its body is equivalent to a statement block with just a single return statement in it.</p>

<h3 id="method-overloading">Method overloading</h3>

<p>The method overload resolution rules are described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<h2 id="properties">Properties</h2>

<p>A <strong><em>property</em></strong> is a member that provides access to a characteristic of an object or a class. Examples of properties include the length of a string, the size of a font, the caption of a window, the name of a customer, and so on. Properties are a natural extension of fieldsâ€”both are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties do not denote storage locations. Instead, properties have <strong><em>accessors</em></strong> that specify the statements to be executed when their values are read or written. Properties thus provide a mechanism for associating actions with the reading and writing of an object&rsquo;s attributes; furthermore, they permit such attributes to be computed.</p>

<p>Properties are declared using *property_declaration*s:</p>
<pre class="highlight plaintext"><code>property_declaration
    : attributes? property_modifier* type member_name property_body
    ;

property_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | property_modifier_unsafe
    ;

property_body
    : '{' accessor_declarations '}' property_initializer?
    | '=&gt;' expression ';'
    ;

property_initializer
    : '=' variable_initializer
    ;
</code></pre>
<p>A <em>property_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Property declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers.</p>

<p>The <em>type</em> of a property declaration specifies the type of the property introduced by the declaration, and the <em>member_name</em> specifies the name of the property. Unless the property is an explicit interface member implementation, the <em>member_name</em> is simply an <em>identifier</em>. For an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>), the <em>member_name</em> consists of an <em>interface_type</em> followed by a &rdquo;<code class="prettyprint">.</code>&ldquo; and an <em>identifier</em>.</p>

<p>The <em>type</em> of a property must be at least as accessible as the property itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>A <em>property_body</em> may either consist of an <strong><em>accessor body</em></strong> or an <strong><em>expression body</em></strong>. In an accessor body,  <em>accessor_declarations</em>, which must be enclosed in &rdquo;<code class="prettyprint">{</code>&ldquo; and &rdquo;<code class="prettyprint">}</code>&ldquo; tokens, declare the accessors (<a href="classes.md#accessors">Accessors</a>) of the property. The accessors specify the executable statements associated with reading and writing the property.</p>

<p>An expression body consisting of <code class="prettyprint">=&gt;</code> followed by an <em>expression</em> <code class="prettyprint">E</code> and a semicolon is exactly equivalent to the statement body <code class="prettyprint">{ get { return E; } }</code>, and can therefore only be used to specify getter-only properties where the result of the getter is given by a single expression.</p>

<p>A <em>property_initializer</em> may only be given for an automatically implemented property (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>), and causes the initialization of the underlying field of such properties with the value given by the <em>expression</em>.</p>

<p>Even though the syntax for accessing a property is the same as that for a field, a property is not classified as a variable. Thus, it is not possible to pass a property as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> argument.</p>

<p>When a property declaration includes an <code class="prettyprint">extern</code> modifier, the property is said to be an <strong><em>external property</em></strong>. Because an external property declaration provides no actual implementation, each of its <em>accessor_declarations</em> consists of a semicolon.</p>

<h3 id="static-and-instance-properties">Static and instance properties</h3>

<p>When a property declaration includes a <code class="prettyprint">static</code> modifier, the property is said to be a <strong><em>static property</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the property is said to be an <strong><em>instance property</em></strong>.</p>

<p>A static property is not associated with a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in the accessors of a static property.</p>

<p>An instance property is associated with a given instance of a class, and that instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>) in the accessors of that property.</p>

<p>When a property is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static property, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance property, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="accessors">Accessors</h3>

<p>The <em>accessor_declarations</em> of a property specify the executable statements associated with reading and writing that property.</p>
<pre class="highlight plaintext"><code>accessor_declarations
    : get_accessor_declaration set_accessor_declaration?
    | set_accessor_declaration get_accessor_declaration?
    ;

get_accessor_declaration
    : attributes? accessor_modifier? 'get' accessor_body
    ;

set_accessor_declaration
    : attributes? accessor_modifier? 'set' accessor_body
    ;

accessor_modifier
    : 'protected'
    | 'internal'
    | 'private'
    | 'protected' 'internal'
    | 'internal' 'protected'
    ;

accessor_body
    : block
    | ';'
    ;
</code></pre>
<p>The accessor declarations consist of a <em>get_accessor_declaration</em>, a <em>set_accessor_declaration</em>, or both. Each accessor declaration consists of the token <code class="prettyprint">get</code> or <code class="prettyprint">set</code> followed by an optional <em>accessor_modifier</em> and an <em>accessor_body</em>.</p>

<p>The use of *accessor_modifier*s is governed by the following restrictions:</p>

<ul>
<li> An <em>accessor_modifier</em> may not be used in an interface or in an explicit interface member implementation.</li>
<li> For a property or indexer that has no <code class="prettyprint">override</code> modifer, an <em>accessor_modifier</em> is permitted only if the property or indexer has both a <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor, and then is permitted only on one of those accessors.</li>
<li> For a property or indexer that includes an <code class="prettyprint">override</code> modifer, an accessor must match the <em>accessor_modifier</em>, if any, of the accessor being overridden.</li>
<li> The <em>accessor_modifier</em> must declare an accessibility that is strictly more restrictive than the declared accessibility of the property or indexer itself. To be precise:

<ul>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">public</code>, the <em>accessor_modifier</em> may be either <code class="prettyprint">protected internal</code>, <code class="prettyprint">internal</code>, <code class="prettyprint">protected</code>, or <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">protected internal</code>, the <em>accessor_modifier</em> may be either <code class="prettyprint">internal</code>, <code class="prettyprint">protected</code>, or <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">internal</code> or <code class="prettyprint">protected</code>, the <em>accessor_modifier</em> must be <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">private</code>, no <em>accessor_modifier</em> may be used.</li>
</ul></li>
</ul>

<p>For <code class="prettyprint">abstract</code> and <code class="prettyprint">extern</code> properties, the <em>accessor_body</em> for each accessor specified is simply a semicolon. A non-abstract, non-extern property may have each <em>accessor_body</em> be a semicolon, in which case it is an <strong><em>automatically implemented property</em></strong> (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>). An automatically implemented property must have at least a get accessor. For the accessors of any other non-abstract, non-extern property, the <em>accessor_body</em> is a <em>block</em> which specifies the statements to be executed when the corresponding accessor is invoked.</p>

<p>A <code class="prettyprint">get</code> accessor corresponds to a parameterless method with a return value of the property type. Except as the target of an assignment, when a property is referenced in an expression, the <code class="prettyprint">get</code> accessor of the property is invoked to compute the value of the property (<a href="expressions.md#values-of-expressions">Values of expressions</a>). The body of a <code class="prettyprint">get</code> accessor must conform to the rules for value-returning methods described in <a href="classes.md#method-body">Method body</a>. In particular, all <code class="prettyprint">return</code> statements in the body of a <code class="prettyprint">get</code> accessor must specify an expression that is implicitly convertible to the property type. Furthermore, the endpoint of a <code class="prettyprint">get</code> accessor must not be reachable.</p>

<p>A <code class="prettyprint">set</code> accessor corresponds to a method with a single value parameter of the property type and a <code class="prettyprint">void</code> return type. The implicit parameter of a <code class="prettyprint">set</code> accessor is always named <code class="prettyprint">value</code>. When a property is referenced as the target of an assignment (<a href="expressions.md#assignment-operators">Assignment operators</a>), or as the operand of <code class="prettyprint">++</code> or <code class="prettyprint">--</code> (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>, <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>), the <code class="prettyprint">set</code> accessor is invoked with an argument (whose value is that of the right-hand side of the assignment or the operand of the <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operator) that provides the new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). The body of a <code class="prettyprint">set</code> accessor must conform to the rules for <code class="prettyprint">void</code> methods described in <a href="classes.md#method-body">Method body</a>. In particular, <code class="prettyprint">return</code> statements in the <code class="prettyprint">set</code> accessor body are not permitted to specify an expression. Since a <code class="prettyprint">set</code> accessor implicitly has a parameter named <code class="prettyprint">value</code>, it is a compile-time error for a local variable or constant declaration in a <code class="prettyprint">set</code> accessor to have that name.</p>

<p>Based on the presence or absence of the <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessors, a property is classified as follows:</p>

<ul>
<li> A property that includes both a <code class="prettyprint">get</code> accessor and a <code class="prettyprint">set</code> accessor is said to be a <strong><em>read-write</em></strong> property.</li>
<li> A property that has only a <code class="prettyprint">get</code> accessor is said to be a <strong><em>read-only</em></strong> property. It is a compile-time error for a read-only property to be the target of an assignment.</li>
<li> A property that has only a <code class="prettyprint">set</code> accessor is said to be a <strong><em>write-only</em></strong> property. Except as the target of an assignment, it is a compile-time error to reference a write-only property in an expression.</li>
</ul>

<p>In the example
&rdquo;`csharp
public class Button: Control
{
    private string caption;</p>

<p>public string Caption {
        get {
            return caption;
        }
        set {
            if (caption != value) {
                caption = value;
                Repaint();
            }
        }
    }</p>

<p>public override void Paint(Graphics g, Rectangle r) {
        // Painting code goes here
    }
}
&ldquo;<code class="prettyprint">
the</code>Button<code class="prettyprint">control declares a public</code>Caption<code class="prettyprint">property. The</code>get<code class="prettyprint">accessor of the</code>Caption<code class="prettyprint">property returns the string stored in the private</code>caption<code class="prettyprint">field. The</code>set<code class="prettyprint">accessor checks if the new value is different from the current value, and if so, it stores the new value and repaints the control. Properties often follow the pattern shown above: The</code>get<code class="prettyprint">accessor simply returns a value stored in a private field, and the</code>set` accessor modifies that private field and then performs any additional actions required to fully update the state of the object.</p>

<p>Given the <code class="prettyprint">Button</code> class above, the following is an example of use of the <code class="prettyprint">Caption</code> property:
<code class="prettyprint">csharp
Button okButton = new Button();
okButton.Caption = &quot;OK&quot;;            // Invokes set accessor
string s = okButton.Caption;        // Invokes get accessor
</code></p>

<p>Here, the <code class="prettyprint">set</code> accessor is invoked by assigning a value to the property, and the <code class="prettyprint">get</code> accessor is invoked by referencing the property in an expression.</p>

<p>The <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessors of a property are not distinct members, and it is not possible to declare the accessors of a property separately. As such, it is not possible for the two accessors of a read-write property to have different accessibility. The example
&rdquo;`csharp
class A
{
    private string name;</p>

<p>public string Name {                // Error, duplicate member name
        get { return name; }
    }</p>

<p>public string Name {                // Error, duplicate member name
        set { name = value; }
    }
}
&ldquo;`
does not declare a single read-write property. Rather, it declares two properties with the same name, one read-only and one write-only. Since two members declared in the same class cannot have the same name, the example causes a compile-time error to occur.</p>

<p>When a derived class declares a property by the same name as an inherited property, the derived property hides the inherited property with respect to both reading and writing. In the example
&rdquo;`csharp
class A
{
    public int P {
        set {&hellip;}
    }
}</p>

<p>class B: A
{
    new public int P {
        get {&hellip;}
    }
}
<code class="prettyprint">
the `P` property in `B` hides the `P` property in `A` with respect to both reading and writing. Thus, in the statements
</code>csharp
B b = new B();
b.P = 1;          // Error, B.P is read-only
((A)b).P = 1;     // Ok, reference to A.P
&ldquo;<code class="prettyprint">
the assignment to</code>b.P<code class="prettyprint">causes a compile-time error to be reported, since the read-only</code>P<code class="prettyprint">property in</code>B<code class="prettyprint">hides the write-only</code>P<code class="prettyprint">property in</code>A<code class="prettyprint">. Note, however, that a cast can be used to access the hidden</code>P` property.</p>

<p>Unlike public fields, properties provide a separation between an object&rsquo;s internal state and its public interface. Consider the example:
&rdquo;`csharp
class Label
{
    private int x, y;
    private string caption;</p>

<p>public Label(int x, int y, string caption) {
        this.x = x;
        this.y = y;
        this.caption = caption;
    }</p>

<p>public int X {
        get { return x; }
    }</p>

<p>public int Y {
        get { return y; }
    }</p>

<p>public Point Location {
        get { return new Point(x, y); }
    }</p>

<p>public string Caption {
        get { return caption; }
    }
}
&ldquo;`</p>

<p>Here, the <code class="prettyprint">Label</code> class uses two <code class="prettyprint">int</code> fields, <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, to store its location. The location is publicly exposed both as an <code class="prettyprint">X</code> and a <code class="prettyprint">Y</code> property and as a <code class="prettyprint">Location</code> property of type <code class="prettyprint">Point</code>. If, in a future version of <code class="prettyprint">Label</code>, it becomes more convenient to store the location as a <code class="prettyprint">Point</code> internally, the change can be made without affecting the public interface of the class:
&rdquo;`csharp
class Label
{
    private Point location;
    private string caption;</p>

<p>public Label(int x, int y, string caption) {
        this.location = new Point(x, y);
        this.caption = caption;
    }</p>

<p>public int X {
        get { return location.x; }
    }</p>

<p>public int Y {
        get { return location.y; }
    }</p>

<p>public Point Location {
        get { return location; }
    }</p>

<p>public string Caption {
        get { return caption; }
    }
}
&ldquo;`</p>

<p>Had <code class="prettyprint">x</code> and <code class="prettyprint">y</code> instead been <code class="prettyprint">public readonly</code> fields, it would have been impossible to make such a change to the <code class="prettyprint">Label</code> class.</p>

<p>Exposing state through properties is not necessarily any less efficient than exposing fields directly. In particular, when a property is non-virtual and contains only a small amount of code, the execution environment may replace calls to accessors with the actual code of the accessors. This process is known as <strong><em>inlining</em></strong>, and it makes property access as efficient as field access, yet preserves the increased flexibility of properties.</p>

<p>Since invoking a <code class="prettyprint">get</code> accessor is conceptually equivalent to reading the value of a field, it is considered bad programming style for <code class="prettyprint">get</code> accessors to have observable side-effects. In the example
&rdquo;`csharp
class Counter
{
    private int next;</p>

<p>public int Next {
        get { return next++; }
    }
}
&ldquo;<code class="prettyprint">
the value of the</code>Next` property depends on the number of times the property has previously been accessed. Thus, accessing the property produces an observable side-effect, and the property should be implemented as a method instead.</p>

<p>The &quot;no side-effects&rdquo; convention for <code class="prettyprint">get</code> accessors doesn&rsquo;t mean that <code class="prettyprint">get</code> accessors should always be written to simply return values stored in fields. Indeed, <code class="prettyprint">get</code> accessors often compute the value of a property by accessing multiple fields or invoking methods. However, a properly designed <code class="prettyprint">get</code> accessor performs no actions that cause observable changes in the state of the object.</p>

<p>Properties can be used to delay initialization of a resource until the moment it is first referenced. For example:
&ldquo;`csharp
using System.IO;</p>

<p>public class Console
{
    private static TextReader reader;
    private static TextWriter writer;
    private static TextWriter error;</p>

<p>public static TextReader In {
        get {
            if (reader == null) {
                reader = new StreamReader(Console.OpenStandardInput());
            }
            return reader;
        }
    }</p>

<p>public static TextWriter Out {
        get {
            if (writer == null) {
                writer = new StreamWriter(Console.OpenStandardOutput());
            }
            return writer;
        }
    }</p>

<p>public static TextWriter Error {
        get {
            if (error == null) {
                error = new StreamWriter(Console.OpenStandardError());
            }
            return error;
        }
    }
}
&rdquo;`</p>

<p>The <code class="prettyprint">Console</code> class contains three properties, <code class="prettyprint">In</code>, <code class="prettyprint">Out</code>, and <code class="prettyprint">Error</code>, that represent the standard input, output, and error devices, respectively. By exposing these members as properties, the <code class="prettyprint">Console</code> class can delay their initialization until they are actually used. For example, upon first referencing the <code class="prettyprint">Out</code> property, as in
<code class="prettyprint">csharp
Console.Out.WriteLine(&quot;hello, world&quot;);
</code>
the underlying <code class="prettyprint">TextWriter</code> for the output device is created. But if the application makes no reference to the <code class="prettyprint">In</code> and <code class="prettyprint">Error</code> properties, then no objects are created for those devices.</p>

<h3 id="automatically-implemented-properties">Automatically implemented properties</h3>

<p>An automatically implemented property (or <strong><em>auto-property</em></strong> for short), is a non-abstract non-extern property with semicolon-only accessor bodies. Auto-properties must have a get accessor and can optionally have a set accessor.</p>

<p>When a property is specified as an automatically implemented property, a hidden backing field is automatically available for the property, and the accessors are implemented to read from and write to that backing field. If the auto-property has no set accessor, the backing field is considered <code class="prettyprint">readonly</code> (<a href="classes.md#readonly-fields">Readonly fields</a>). Just like a <code class="prettyprint">readonly</code> field, a getter-only auto-property can also be assigned to in the body of a constructor of the enclosing class. Such an assignment assigns directly to the readonly backing field of the property.</p>

<p>An auto-property may optionally have a <em>property_initializer</em>, which is applied directly to the backing field as a <em>variable_initializer</em> (<a href="classes.md#variable-initializers">Variable initializers</a>).</p>

<p>The following example:
<code class="prettyprint">csharp
public class Point {
    public int X { get; set; } = 0;
    public int Y { get; set; } = 0;
}
</code>
is equivalent to the following declaration:
<code class="prettyprint">csharp
public class Point {
    private int __x = 0;
    private int __y = 0;
    public int X { get { return __x; } set { __x = value; } }
    public int Y { get { return __y; } set { __y = value; } }
}
</code></p>

<p>The following example:
<code class="prettyprint">csharp
public class ReadOnlyPoint
{
    public int X { get; }
    public int Y { get; }
    public ReadOnlyPoint(int x, int y) { X = x; Y = y; }
}
</code>
is equivalent to the following declaration:
<code class="prettyprint">csharp
public class ReadOnlyPoint
{
    private readonly int __x;
    private readonly int __y;
    public int X { get { return __x; } }
    public int Y { get { return __y; } }
    public ReadOnlyPoint(int x, int y) { __x = x; __y = y; }
}
</code></p>

<p>Notice that the assignments to the readonly field are legal, because they occur within the constructor.</p>

<h3 id="accessibility">Accessibility</h3>

<p>If an accessor has an <em>accessor_modifier</em>, the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the accessor is determined using the declared accessibility of the <em>accessor_modifier</em>. If an accessor does not have an <em>accessor_modifier</em>, the accessibility domain of the accessor is determined from the declared accessibility of the property or indexer.</p>

<p>The presence of an <em>accessor_modifier</em> never affects member lookup (<a href="expressions.md#operators">Operators</a>) or overload resolution (<a href="expressions.md#overload-resolution">Overload resolution</a>). The modifiers on the property or indexer always determine which property or indexer is bound to, regardless of the context of the access.</p>

<p>Once a particular property or indexer has been selected, the accessibility domains of the specific accessors involved are used to determine if that usage is valid:</p>

<ul>
<li> If the usage is as a value (<a href="expressions.md#values-of-expressions">Values of expressions</a>), the <code class="prettyprint">get</code> accessor must exist and be accessible.</li>
<li> If the usage is as the target of a simple assignment (<a href="expressions.md#simple-assignment">Simple assignment</a>), the <code class="prettyprint">set</code> accessor must exist and be accessible.</li>
<li> If the usage is as the target of compound assignment (<a href="expressions.md#compound-assignment">Compound assignment</a>), or as the target of the <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operators (<a href="expressions.md#function-members">Function members</a>.9, <a href="expressions.md#invocation-expressions">Invocation expressions</a>), both the <code class="prettyprint">get</code> accessors and the <code class="prettyprint">set</code> accessor must exist and be accessible.</li>
</ul>

<p>In the following example, the property <code class="prettyprint">A.Text</code> is hidden by the property <code class="prettyprint">B.Text</code>, even in contexts where only the <code class="prettyprint">set</code> accessor is called. In contrast, the property <code class="prettyprint">B.Count</code> is not accessible to class <code class="prettyprint">M</code>, so the accessible property <code class="prettyprint">A.Count</code> is used instead.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Text</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"hello"</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="m">5</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">text</span> <span class="p">=</span> <span class="s">"goodbye"</span><span class="p">;</span> 
    <span class="k">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">new</span> <span class="k">public</span> <span class="kt">string</span> <span class="n">Text</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">protected</span> <span class="k">set</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">new</span> <span class="k">protected</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> 
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">count</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">M</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">B</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">B</span><span class="p">();</span>
        <span class="n">b</span><span class="p">.</span><span class="n">Count</span> <span class="p">=</span> <span class="m">12</span><span class="p">;</span>             <span class="c1">// Calls A.Count set accessor</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>          <span class="c1">// Calls A.Count get accessor</span>
        <span class="n">b</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">"howdy"</span><span class="p">;</span>         <span class="c1">// Error, B.Text set accessor not accessible</span>
        <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>        <span class="c1">// Calls B.Text get accessor</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An accessor that is used to implement an interface may not have an <em>accessor_modifier</em>. If only one accessor is used to implement an interface, the other accessor may be declared with an <em>accessor_modifier</em>:
&ldquo;`csharp
public interface I
{
    string Prop { get; }
}</p>

<p>public class C: I
{
    public Prop {
        get { return &quot;April&rdquo;; }       // Must not have a modifier here
        internal set {&hellip;}            // Ok, because I.Prop has no set accessor
    }
}
&ldquo;`</p>

<h3 id="virtual-sealed-override-and-abstract-property-accessors">Virtual, sealed, override, and abstract property accessors</h3>

<p>A <code class="prettyprint">virtual</code> property declaration specifies that the accessors of the property are virtual. The <code class="prettyprint">virtual</code> modifier applies to both accessors of a read-write propertyâ€”it is not possible for only one accessor of a read-write property to be virtual.</p>

<p>An <code class="prettyprint">abstract</code> property declaration specifies that the accessors of the property are virtual, but does not provide an actual implementation of the accessors. Instead, non-abstract derived classes are required to provide their own implementation for the accessors by overriding the property. Because an accessor for an abstract property declaration provides no actual implementation, its <em>accessor_body</em> simply consists of a semicolon.</p>

<p>A property declaration that includes both the <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers specifies that the property is abstract and overrides a base property. The accessors of such a property are also abstract.</p>

<p>Abstract property declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).The accessors of an inherited virtual property can be overridden in a derived class by including a property declaration that specifies an <code class="prettyprint">override</code> directive. This is known as an <strong><em>overriding property declaration</em></strong>. An overriding property declaration does not declare a new property. Instead, it simply specializes the implementations of the accessors of an existing virtual property.</p>

<p>An overriding property declaration must specify the exact same accessibility modifiers, type, and name as the inherited property. If the inherited property has only a single accessor (i.e., if the inherited property is read-only or write-only), the overriding property must include only that accessor. If the inherited property includes both accessors (i.e., if the inherited property is read-write), the overriding property can include either a single accessor or both accessors.</p>

<p>An overriding property declaration may include the <code class="prettyprint">sealed</code> modifier. Use of this modifier prevents a derived class from further overriding the property. The accessors of a sealed property are also sealed.</p>

<p>Except for differences in declaration and invocation syntax, virtual, sealed, override, and abstract accessors behave exactly like virtual, sealed, override and abstract methods. Specifically, the rules described in <a href="classes.md#virtual-methods">Virtual methods</a>, <a href="classes.md#override-methods">Override methods</a>, <a href="classes.md#sealed-methods">Sealed methods</a>, and <a href="classes.md#abstract-methods">Abstract methods</a> apply as if accessors were methods of a corresponding form:</p>

<ul>
<li> A <code class="prettyprint">get</code> accessor corresponds to a parameterless method with a return value of the property type and the same modifiers as the containing property.</li>
<li> A <code class="prettyprint">set</code> accessor corresponds to a method with a single value parameter of the property type, a <code class="prettyprint">void</code> return type, and the same modifiers as the containing property.</li>
</ul>

<p>In the example
&rdquo;`csharp
abstract class A
{
    int y;</p>

<p>public virtual int X {
        get { return 0; }
    }</p>

<p>public virtual int Y {
        get { return y; }
        set { y = value; }
    }</p>

<p>public abstract int Z { get; set; }
}
&ldquo;<code class="prettyprint">
</code>X<code class="prettyprint">is a virtual read-only property,</code>Y<code class="prettyprint">is a virtual read-write property, and</code>Z<code class="prettyprint">is an abstract read-write property. Because</code>Z<code class="prettyprint">is abstract, the containing class</code>A` must also be declared abstract.</p>

<p>A class that derives from <code class="prettyprint">A</code> is show below:
&rdquo;`csharp
class B: A
{
    int z;</p>

<p>public override int X {
        get { return base.X + 1; }
    }</p>

<p>public override int Y {
        set { base.Y = value &lt; 0? 0: value; }
    }</p>

<p>public override int Z {
        get { return z; }
        set { z = value; }
    }
}
&ldquo;`</p>

<p>Here, the declarations of <code class="prettyprint">X</code>, <code class="prettyprint">Y</code>, and <code class="prettyprint">Z</code> are overriding property declarations. Each property declaration exactly matches the accessibility modifiers, type, and name of the corresponding inherited property. The <code class="prettyprint">get</code> accessor of <code class="prettyprint">X</code> and the <code class="prettyprint">set</code> accessor of <code class="prettyprint">Y</code> use the <code class="prettyprint">base</code> keyword to access the inherited accessors. The declaration of <code class="prettyprint">Z</code> overrides both abstract accessorsâ€”thus, there are no outstanding abstract function members in <code class="prettyprint">B</code>, and <code class="prettyprint">B</code> is permitted to be a non-abstract class.</p>

<p>When a property is declared as an <code class="prettyprint">override</code>, any overridden accessors must be accessible to the overriding code. In addition, the declared accessibility of both the property or indexer itself, and of the accessors, must match that of the overridden member and accessors. For example:
&rdquo;`csharp
public class B
{
    public virtual int P {
        protected set {&hellip;}
        get {&hellip;}
    }
}</p>

<p>public class D: B
{
    public override int P {
        protected set {&hellip;}            // Must specify protected here
        get {&hellip;}                      // Must not have a modifier here
    }
}
&ldquo;`</p>

<h2 id="events">Events</h2>

<p>An <strong><em>event</em></strong> is a member that enables an object or class to provide notifications. Clients can attach executable code for events by supplying <strong><em>event handlers</em></strong>.</p>

<p>Events are declared using *event_declaration*s:</p>
<pre class="highlight plaintext"><code>event_declaration
    : attributes? event_modifier* 'event' type variable_declarators ';'
    | attributes? event_modifier* 'event' type member_name '{' event_accessor_declarations '}'
    ;

event_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | event_modifier_unsafe
    ;

event_accessor_declarations
    : add_accessor_declaration remove_accessor_declaration
    | remove_accessor_declaration add_accessor_declaration
    ;

add_accessor_declaration
    : attributes? 'add' block
    ;

remove_accessor_declaration
    : attributes? 'remove' block
    ;
</code></pre>
<p>An <em>event_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Event declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers.</p>

<p>The <em>type</em> of an event declaration must be a <em>delegate_type</em> (<a href="types.md#reference-types">Reference types</a>), and that <em>delegate_type</em> must be at least as accessible as the event itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>An event declaration may include <em>event_accessor_declarations</em>. However, if it does not, for non-extern, non-abstract events, the compiler supplies them automatically (<a href="classes.md#field-like-events">Field-like events</a>); for extern events, the accessors are provided externally.</p>

<p>An event declaration that omits <em>event_accessor_declarations</em> defines one or more eventsâ€”one for each of the <em>variable_declarator*s. The attributes and modifiers apply to all of the members declared by such an *event_declaration</em>.</p>

<p>It is a compile-time error for an <em>event_declaration</em> to include both the <code class="prettyprint">abstract</code> modifier and brace-delimited <em>event_accessor_declarations</em>.</p>

<p>When an event declaration includes an <code class="prettyprint">extern</code> modifier, the event is said to be an <strong><em>external event</em></strong>. Because an external event declaration provides no actual implementation, it is an error for it to include both the <code class="prettyprint">extern</code> modifier and <em>event_accessor_declarations</em>.</p>

<p>It is a compile-time error for a <em>variable_declarator</em> of an event declaration with an <code class="prettyprint">abstract</code> or <code class="prettyprint">external</code> modifier to include a <em>variable_initializer</em>.</p>

<p>An event can be used as the left-hand operand of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators (<a href="expressions.md#event-assignment">Event assignment</a>). These operators are used, respectively, to attach event handlers to or to remove event handlers from an event, and the access modifiers of the event control the contexts in which such operations are permitted.</p>

<p>Since <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> are the only operations that are permitted on an event outside the type that declares the event, external code can add and remove handlers for an event, but cannot in any other way obtain or modify the underlying list of event handlers.</p>

<p>In an operation of the form <code class="prettyprint">x += y</code> or <code class="prettyprint">x -= y</code>, when <code class="prettyprint">x</code> is an event and the reference takes place outside the type that contains the declaration of <code class="prettyprint">x</code>, the result of the operation has type <code class="prettyprint">void</code> (as opposed to having the type of <code class="prettyprint">x</code>, with the value of <code class="prettyprint">x</code> after the assignment). This rule prohibits external code from indirectly examining the underlying delegate of an event.</p>

<p>The following example shows how event handlers are attached to instances of the <code class="prettyprint">Button</code> class:
&rdquo;`csharp
public delegate void EventHandler(object sender, EventArgs e);</p>

<p>public class Button: Control
{
    public event EventHandler Click;
}</p>

<p>public class LoginDialog: Form
{
    Button OkButton;
    Button CancelButton;</p>

<p>public LoginDialog() {
        OkButton = new Button(&hellip;);
        OkButton.Click += new EventHandler(OkButtonClick);
        CancelButton = new Button(&hellip;);
        CancelButton.Click += new EventHandler(CancelButtonClick);
    }</p>

<p>void OkButtonClick(object sender, EventArgs e) {
        // Handle OkButton.Click event
    }</p>

<p>void CancelButtonClick(object sender, EventArgs e) {
        // Handle CancelButton.Click event
    }
}
&ldquo;`</p>

<p>Here, the <code class="prettyprint">LoginDialog</code> instance constructor creates two <code class="prettyprint">Button</code> instances and attaches event handlers to the <code class="prettyprint">Click</code> events.</p>

<h3 id="field-like-events">Field-like events</h3>

<p>Within the program text of the class or struct that contains the declaration of an event, certain events can be used like fields. To be used in this way, an event must not be <code class="prettyprint">abstract</code> or <code class="prettyprint">extern</code>, and must not explicitly include <em>event_accessor_declarations</em>. Such an event can be used in any context that permits a field. The field contains a delegate (<a href="delegates.md#delegates">Delegates</a>) which refers to the list of event handlers that have been added to the event. If no event handlers have been added, the field contains <code class="prettyprint">null</code>.</p>

<p>In the example
&rdquo;`csharp
public delegate void EventHandler(object sender, EventArgs e);</p>

<p>public class Button: Control
{
    public event EventHandler Click;</p>

<p>protected void OnClick(EventArgs e) {
        if (Click != null) Click(this, e);
    }</p>

<p>public void Reset() {
        Click = null;
    }
}
&ldquo;<code class="prettyprint">
</code>Click<code class="prettyprint">is used as a field within the</code>Button<code class="prettyprint">class. As the example demonstrates, the field can be examined, modified, and used in delegate invocation expressions. The</code>OnClick<code class="prettyprint">method in the</code>Button<code class="prettyprint">class &quot;raises&quot; the</code>Click` event. The notion of raising an event is precisely equivalent to invoking the delegate represented by the eventâ€”thus, there are no special language constructs for raising events. Note that the delegate invocation is preceded by a check that ensures the delegate is non-null.</p>

<p>Outside the declaration of the <code class="prettyprint">Button</code> class, the <code class="prettyprint">Click</code> member can only be used on the left-hand side of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators, as in
<code class="prettyprint">csharp
b.Click += new EventHandler(...);
</code>
which appends a delegate to the invocation list of the <code class="prettyprint">Click</code> event, and
<code class="prettyprint">csharp
b.Click -= new EventHandler(...);
</code>
which removes a delegate from the invocation list of the <code class="prettyprint">Click</code> event.</p>

<p>When compiling a field-like event, the compiler automatically creates storage to hold the delegate, and creates accessors for the event that add or remove event handlers to the delegate field. The addition and removal operations are thread safe, and may (but are not required to) be done while holding the lock (<a href="statements.md#the-lock-statement">The lock statement</a>) on the containing object for an instance event, or the type object (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) for a static event.</p>

<p>Thus, an instance event declaration of the form:
<code class="prettyprint">csharp
class X
{
    public event D Ev;
}
</code>
will be compiled to something equivalent to:
&rdquo;`csharp
class X
{
    private D __Ev;  // field to hold the delegate</p>

<p>public event D Ev {
        add {
            /* add the delegate in a thread safe way */
        }</p>

<p>remove {
            /* remove the delegate in a thread safe way */
        }
    }
}
&ldquo;<code class="prettyprint">
Within the class</code>X<code class="prettyprint">, references to</code>Ev<code class="prettyprint">on the left-hand side of the</code>+=<code class="prettyprint">and</code>-=<code class="prettyprint">operators cause the add and remove accessors to be invoked. All other references to</code>Ev<code class="prettyprint">are compiled to reference the hidden field</code><strong>Ev<code class="prettyprint">instead ([Member access](expressions.md#member-access)). The name &quot;</code></strong>Ev`&rdquo; is arbitrary; the hidden field could have any name or no name at all.</p>

<h3 id="event-accessors">Event accessors</h3>

<p>Event declarations typically omit <em>event_accessor_declarations</em>, as in the <code class="prettyprint">Button</code> example above. One situation for doing so involves the case in which the storage cost of one field per event is not acceptable. In such cases, a class can include <em>event_accessor_declarations</em> and use a private mechanism for storing the list of event handlers.</p>

<p>The <em>event_accessor_declarations</em> of an event specify the executable statements associated with adding and removing event handlers.</p>

<p>The accessor declarations consist of an <em>add_accessor_declaration</em> and a <em>remove_accessor_declaration</em>. Each accessor declaration consists of the token <code class="prettyprint">add</code> or <code class="prettyprint">remove</code> followed by a <em>block</em>. The <em>block</em> associated with an <em>add_accessor_declaration</em> specifies the statements to execute when an event handler is added, and the <em>block</em> associated with a <em>remove_accessor_declaration</em> specifies the statements to execute when an event handler is removed.</p>

<p>Each <em>add_accessor_declaration</em> and <em>remove_accessor_declaration</em> corresponds to a method with a single value parameter of the event type and a <code class="prettyprint">void</code> return type. The implicit parameter of an event accessor is named <code class="prettyprint">value</code>. When an event is used in an event assignment, the appropriate event accessor is used. Specifically, if the assignment operator is <code class="prettyprint">+=</code> then the add accessor is used, and if the assignment operator is <code class="prettyprint">-=</code> then the remove accessor is used. In either case, the right-hand operand of the assignment operator is used as the argument to the event accessor. The block of an <em>add_accessor_declaration</em> or a <em>remove_accessor_declaration</em> must conform to the rules for <code class="prettyprint">void</code> methods described in <a href="classes.md#method-body">Method body</a>. In particular, <code class="prettyprint">return</code> statements in such a block are not permitted to specify an expression.</p>

<p>Since an event accessor implicitly has a parameter named <code class="prettyprint">value</code>, it is a compile-time error for a local variable or constant declared in an event accessor to have that name.</p>

<p>In the example
&ldquo;`csharp
class Control: Component
{
    // Unique keys for events
    static readonly object mouseDownEventKey = new object();
    static readonly object mouseUpEventKey = new object();</p>

<p>// Return event handler associated with key
    protected Delegate GetEventHandler(object key) {&hellip;}</p>

<p>// Add event handler associated with key
    protected void AddEventHandler(object key, Delegate handler) {&hellip;}</p>

<p>// Remove event handler associated with key
    protected void RemoveEventHandler(object key, Delegate handler) {&hellip;}</p>

<p>// MouseDown event
    public event MouseEventHandler MouseDown {
        add { AddEventHandler(mouseDownEventKey, value); }
        remove { RemoveEventHandler(mouseDownEventKey, value); }
    }</p>

<p>// MouseUp event
    public event MouseEventHandler MouseUp {
        add { AddEventHandler(mouseUpEventKey, value); }
        remove { RemoveEventHandler(mouseUpEventKey, value); }
    }</p>

<p>// Invoke the MouseUp event
    protected void OnMouseUp(MouseEventArgs args) {
        MouseEventHandler handler; 
        handler = (MouseEventHandler)GetEventHandler(mouseUpEventKey);
        if (handler != null)
            handler(this, args);
    }
}
&rdquo;<code class="prettyprint">
the</code>Control<code class="prettyprint">class implements an internal storage mechanism for events. The</code>AddEventHandler<code class="prettyprint">method associates a delegate value with a key, the</code>GetEventHandler<code class="prettyprint">method returns the delegate currently associated with a key, and the</code>RemoveEventHandler<code class="prettyprint">method removes a delegate as an event handler for the specified event. Presumably, the underlying storage mechanism is designed such that there is no cost for associating a</code>null` delegate value with a key, and thus unhandled events consume no storage.</p>

<h3 id="static-and-instance-events">Static and instance events</h3>

<p>When an event declaration includes a <code class="prettyprint">static</code> modifier, the event is said to be a <strong><em>static event</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the event is said to be an <strong><em>instance event</em></strong>.</p>

<p>A static event is not associated with a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in the accessors of a static event.</p>

<p>An instance event is associated with a given instance of a class, and this instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>) in the accessors of that event.</p>

<p>When an event is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static event, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance event, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="virtual-sealed-override-and-abstract-event-accessors">Virtual, sealed, override, and abstract event accessors</h3>

<p>A <code class="prettyprint">virtual</code> event declaration specifies that the accessors of that event are virtual. The <code class="prettyprint">virtual</code> modifier applies to both accessors of an event.</p>

<p>An <code class="prettyprint">abstract</code> event declaration specifies that the accessors of the event are virtual, but does not provide an actual implementation of the accessors. Instead, non-abstract derived classes are required to provide their own implementation for the accessors by overriding the event. Because an abstract event declaration provides no actual implementation, it cannot provide brace-delimited <em>event_accessor_declarations</em>.</p>

<p>An event declaration that includes both the <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers specifies that the event is abstract and overrides a base event. The accessors of such an event are also abstract.</p>

<p>Abstract event declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).</p>

<p>The accessors of an inherited virtual event can be overridden in a derived class by including an event declaration that specifies an <code class="prettyprint">override</code> modifier. This is known as an <strong><em>overriding event declaration</em></strong>. An overriding event declaration does not declare a new event. Instead, it simply specializes the implementations of the accessors of an existing virtual event.</p>

<p>An overriding event declaration must specify the exact same accessibility modifiers, type, and name as the overridden event.</p>

<p>An overriding event declaration may include the <code class="prettyprint">sealed</code> modifier. Use of this modifier prevents a derived class from further overriding the event. The accessors of a sealed event are also sealed.</p>

<p>It is a compile-time error for an overriding event declaration to include a <code class="prettyprint">new</code> modifier.</p>

<p>Except for differences in declaration and invocation syntax, virtual, sealed, override, and abstract accessors behave exactly like virtual, sealed, override and abstract methods. Specifically, the rules described in <a href="classes.md#virtual-methods">Virtual methods</a>, <a href="classes.md#override-methods">Override methods</a>, <a href="classes.md#sealed-methods">Sealed methods</a>, and <a href="classes.md#abstract-methods">Abstract methods</a> apply as if accessors were methods of a corresponding form. Each accessor corresponds to a method with a single value parameter of the event type, a <code class="prettyprint">void</code> return type, and the same modifiers as the containing event.</p>

<h2 id="indexers">Indexers</h2>

<p>An <strong><em>indexer</em></strong> is a member that enables an object to be indexed in the same way as an array. Indexers are declared using *indexer_declaration*s:</p>
<pre class="highlight plaintext"><code>indexer_declaration
    : attributes? indexer_modifier* indexer_declarator indexer_body
    ;

indexer_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | indexer_modifier_unsafe
    ;

indexer_declarator
    : type 'this' '[' formal_parameter_list ']'
    | type interface_type '.' 'this' '[' formal_parameter_list ']'
    ;

indexer_body
    : '{' accessor_declarations '}' 
    | '=&gt;' expression ';'
    ;
</code></pre>
<p>An <em>indexer_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Indexer declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers, with the one exception being that the static modifier is not permitted on an indexer declaration.</p>

<p>The modifiers <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, and <code class="prettyprint">abstract</code> are mutually exclusive except in one case. The <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers may be used together so that an abstract indexer can override a virtual one.</p>

<p>The <em>type</em> of an indexer declaration specifies the element type of the indexer introduced by the declaration. Unless the indexer is an explicit interface member implementation, the <em>type</em> is followed by the keyword <code class="prettyprint">this</code>. For an explicit interface member implementation, the <em>type</em> is followed by an <em>interface_type</em>, a &ldquo;<code class="prettyprint">.</code>&rdquo;, and the keyword <code class="prettyprint">this</code>. Unlike other members, indexers do not have user-defined names.</p>

<p>The <em>formal_parameter_list</em> specifies the parameters of the indexer. The formal parameter list of an indexer corresponds to that of a method (<a href="classes.md#method-parameters">Method parameters</a>), except that at least one parameter must be specified, and that the <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter modifiers are not permitted.</p>

<p>The <em>type</em> of an indexer and each of the types referenced in the <em>formal_parameter_list</em> must be at least as accessible as the indexer itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>An <em>indexer_body</em> may either consist of an <strong><em>accessor body</em></strong> or an <strong><em>expression body</em></strong>. In an accessor body, <em>accessor_declarations</em>, which must be enclosed in &ldquo;<code class="prettyprint">{</code>&rdquo; and &ldquo;<code class="prettyprint">}</code>&rdquo; tokens, declare the accessors (<a href="classes.md#accessors">Accessors</a>) of the property. The accessors specify the executable statements associated with reading and writing the property.</p>

<p>An expression body consisting of &ldquo;<code class="prettyprint">=&gt;</code>&rdquo; followed by an expression <code class="prettyprint">E</code> and a semicolon is exactly equivalent to the statement body <code class="prettyprint">{ get { return E; } }</code>, and can therefore only be used to specify getter-only indexers where the result of the getter is given by a single expression.</p>

<p>Even though the syntax for accessing an indexer element is the same as that for an array element, an indexer element is not classified as a variable. Thus, it is not possible to pass an indexer element as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> argument.</p>

<p>The formal parameter list of an indexer defines the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of the indexer. Specifically, the signature of an indexer consists of the number and types of its formal parameters. The element type and names of the formal parameters are not part of an indexer&rsquo;s signature.</p>

<p>The signature of an indexer must differ from the signatures of all other indexers declared in the same class.</p>

<p>Indexers and properties are very similar in concept, but differ in the following ways:</p>

<ul>
<li> A property is identified by its name, whereas an indexer is identified by its signature.</li>
<li> A property is accessed through a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), whereas an indexer element is accessed through an <em>element_access</em> (<a href="expressions.md#indexer-access">Indexer access</a>).</li>
<li> A property can be a <code class="prettyprint">static</code> member, whereas an indexer is always an instance member.</li>
<li> A <code class="prettyprint">get</code> accessor of a property corresponds to a method with no parameters, whereas a <code class="prettyprint">get</code> accessor of an indexer corresponds to a method with the same formal parameter list as the indexer.</li>
<li> A <code class="prettyprint">set</code> accessor of a property corresponds to a method with a single parameter named <code class="prettyprint">value</code>, whereas a <code class="prettyprint">set</code> accessor of an indexer corresponds to a method with the same formal parameter list as the indexer, plus an additional parameter named <code class="prettyprint">value</code>.</li>
<li> It is a compile-time error for an indexer accessor to declare a local variable with the same name as an indexer parameter.</li>
<li> In an overriding property declaration, the inherited property is accessed using the syntax <code class="prettyprint">base.P</code>, where <code class="prettyprint">P</code> is the property name. In an overriding indexer declaration, the inherited indexer is accessed using the syntax <code class="prettyprint">base[E]</code>, where <code class="prettyprint">E</code> is a comma separated list of expressions.</li>
<li> There is no concept of an &ldquo;automatically implemented indexer&rdquo;. It is an error to have a non-abstract, non-external indexer with semicolon accessors.</li>
</ul>

<p>Aside from these differences, all rules defined in <a href="classes.md#accessors">Accessors</a> and <a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a> apply to indexer accessors as well as to property accessors.</p>

<p>When an indexer declaration includes an <code class="prettyprint">extern</code> modifier, the indexer is said to be an <strong><em>external indexer</em></strong>. Because an external indexer declaration provides no actual implementation, each of its <em>accessor_declarations</em> consists of a semicolon.</p>

<p>The example below declares a <code class="prettyprint">BitArray</code> class that implements an indexer for accessing the individual bits in the bit array.
&ldquo;`csharp
using System;</p>

<p>class BitArray
{
    int[] bits;
    int length;</p>

<p>public BitArray(int length) {
        if (length &lt; 0) throw new ArgumentException();
        bits = new int[((length - 1) &gt;&gt; 5) + 1];
        this.length = length;
    }</p>

<p>public int Length {
        get { return length; }
    }</p>

<p>public bool this[int index] {
        get {
            if (index &lt; 0 || index &gt;= length) {
                throw new IndexOutOfRangeException();
            }
            return (bits[index &gt;&gt; 5] &amp; 1 &lt;&lt; index) != 0;
        }
        set {
            if (index &lt; 0 || index &gt;= length) {
                throw new IndexOutOfRangeException();
            }
            if (value) {
                bits[index &gt;&gt; 5] |= 1 &lt;&lt; index;
            }
            else {
                bits[index &gt;&gt; 5] &amp;= ~(1 &lt;&lt; index);
            }
        }
    }
}
&rdquo;`</p>

<p>An instance of the <code class="prettyprint">BitArray</code> class consumes substantially less memory than a corresponding <code class="prettyprint">bool[]</code> (since each value of the former occupies only one bit instead of the latter&rsquo;s one byte), but it permits the same operations as a <code class="prettyprint">bool[]</code>.</p>

<p>The following <code class="prettyprint">CountPrimes</code> class uses a <code class="prettyprint">BitArray</code> and the classical &ldquo;sieve&rdquo; algorithm to compute the number of primes between 1 and a given maximum:
&ldquo;`csharp
class CountPrimes
{
    static int Count(int max) {
        BitArray flags = new BitArray(max + 1);
        int count = 1;
        for (int i = 2; i &lt;= max; i++) {
            if (!flags[i]) {
                for (int j = i * 2; j &lt;= max; j += i) flags[j] = true;
                count++;
            }
        }
        return count;
    }</p>

<p>static void Main(string[] args) {
        int max = int.Parse(args[0]);
        int count = Count(max);
        Console.WriteLine(&quot;Found {0} primes between 1 and {1}&rdquo;, count, max);
    }
}
&ldquo;`</p>

<p>Note that the syntax for accessing elements of the <code class="prettyprint">BitArray</code> is precisely the same as for a <code class="prettyprint">bool[]</code>.</p>

<p>The following example shows a 26 * 10 grid class that has an indexer with two parameters. The first parameter is required to be an upper- or lowercase letter in the range A-Z, and the second is required to be an integer in the range 0-9.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Grid</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NumRows</span> <span class="p">=</span> <span class="m">26</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NumCols</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>

    <span class="kt">int</span><span class="p">[,]</span> <span class="n">cells</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">NumRows</span><span class="p">,</span> <span class="n">NumCols</span><span class="p">];</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="k">this</span><span class="p">[</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="n">c</span> <span class="p">=</span> <span class="n">Char</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">&lt;</span> <span class="sc">'A'</span> <span class="p">||</span> <span class="n">c</span> <span class="p">&gt;</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">col</span> <span class="p">&gt;=</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">cells</span><span class="p">[</span><span class="n">c</span> <span class="p">-</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">col</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">set</span> <span class="p">{</span>
            <span class="n">c</span> <span class="p">=</span> <span class="n">Char</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">&lt;</span> <span class="sc">'A'</span> <span class="p">||</span> <span class="n">c</span> <span class="p">&gt;</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">col</span> <span class="p">&gt;=</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">cells</span><span class="p">[</span><span class="n">c</span> <span class="p">-</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="indexer-overloading">Indexer overloading</h3>

<p>The indexer overload resolution rules are described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<h2 id="operators">Operators</h2>

<p>An <strong><em>operator</em></strong> is a member that defines the meaning of an expression operator that can be applied to instances of the class. Operators are declared using *operator_declaration*s:</p>
<pre class="highlight plaintext"><code>operator_declaration
    : attributes? operator_modifier+ operator_declarator operator_body
    ;

operator_modifier
    : 'public'
    | 'static'
    | 'extern'
    | operator_modifier_unsafe
    ;

operator_declarator
    : unary_operator_declarator
    | binary_operator_declarator
    | conversion_operator_declarator
    ;

unary_operator_declarator
    : type 'operator' overloadable_unary_operator '(' type identifier ')'
    ;

overloadable_unary_operator
    : '+' | '-' | '!' | '~' | '++' | '--' | 'true' | 'false'
    ;

binary_operator_declarator
    : type 'operator' overloadable_binary_operator '(' type identifier ',' type identifier ')'
    ;

overloadable_binary_operator
    : '+'   | '-'   | '*'   | '/'   | '%'   | '&amp;'   | '|'   | '^'   | '&lt;&lt;'
    | 'right_shift' | '=='  | '!='  | '&gt;'   | '&lt;'   | '&gt;='  | '&lt;='
    ;

conversion_operator_declarator
    : 'implicit' 'operator' type '(' type identifier ')'
    | 'explicit' 'operator' type '(' type identifier ')'
    ;

operator_body
    : block
    | '=&gt;' expression ';'
    | ';'
    ;
</code></pre>
<p>There are three categories of overloadable operators: Unary operators (<a href="classes.md#unary-operators">Unary operators</a>), binary operators (<a href="classes.md#binary-operators">Binary operators</a>), and conversion operators (<a href="classes.md#conversion-operators">Conversion operators</a>).</p>

<p>The <em>operator_body</em> is either a semicolon, a <strong><em>statement body</em></strong> or an <strong><em>expression body</em></strong>. A statement body consists of a <em>block</em>, which specifies the statements to execute when the operator is invoked. The <em>block</em> must conform to the rules for value-returning methods described in <a href="classes.md#method-body">Method body</a>. An expression body consists of <code class="prettyprint">=&gt;</code> followed by an expression and a semicolon, and denotes a single expression to perform when the operator is invoked.</p>

<p>For <code class="prettyprint">extern</code> operators, the <em>operator_body</em> consists simply of a semicolon. For all other operators, the <em>operator_body</em> is either a block body or an expression body.</p>

<p>The following rules apply to all operator declarations:</p>

<ul>
<li> An operator declaration must include both a <code class="prettyprint">public</code> and a <code class="prettyprint">static</code> modifier.</li>
<li> The parameter(s) of an operator must be value parameters (<a href="variables.md#value-parameters">Value parameters</a>). It is a compile-time error for an operator declaration to specify <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</li>
<li> The signature of an operator (<a href="classes.md#unary-operators">Unary operators</a>, <a href="classes.md#binary-operators">Binary operators</a>, <a href="classes.md#conversion-operators">Conversion operators</a>) must differ from the signatures of all other operators declared in the same class.</li>
<li> All types referenced in an operator declaration must be at least as accessible as the operator itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</li>
<li> It is an error for the same modifier to appear multiple times in an operator declaration.</li>
</ul>

<p>Each operator category imposes additional restrictions, as described in the following sections.</p>

<p>Like other members, operators declared in a base class are inherited by derived classes. Because operator declarations always require the class or struct in which the operator is declared to participate in the signature of the operator, it is not possible for an operator declared in a derived class to hide an operator declared in a base class. Thus, the <code class="prettyprint">new</code> modifier is never required, and therefore never permitted, in an operator declaration.</p>

<p>Additional information on unary and binary operators can be found in <a href="expressions.md#operators">Operators</a>.</p>

<p>Additional information on conversion operators can be found in <a href="conversions.md#user-defined-conversions">User-defined conversions</a>.</p>

<h3 id="unary-operators">Unary operators</h3>

<p>The following rules apply to unary operator declarations, where <code class="prettyprint">T</code> denotes the instance type of the class or struct that contains the operator declaration:</p>

<ul>
<li> A unary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, or <code class="prettyprint">~</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and can return any type.</li>
<li> A unary <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and must return that same type or a type derived from it.</li>
<li> A unary <code class="prettyprint">true</code> or <code class="prettyprint">false</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and must return type <code class="prettyprint">bool</code>.</li>
</ul>

<p>The signature of a unary operator consists of the operator token (<code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, <code class="prettyprint">true</code>, or <code class="prettyprint">false</code>) and the type of the single formal parameter. The return type is not part of a unary operator&rsquo;s signature, nor is the name of the formal parameter.</p>

<p>The <code class="prettyprint">true</code> and <code class="prettyprint">false</code> unary operators require pair-wise declaration. A compile-time error occurs if a class declares one of these operators without also declaring the other. The <code class="prettyprint">true</code> and <code class="prettyprint">false</code> operators are described further in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a> and <a href="expressions.md#boolean-expressions">Boolean expressions</a>.</p>

<p>The following example shows an implementation and subsequent usage of <code class="prettyprint">operator ++</code> for an integer vector class:
&rdquo;`csharp
public class IntVector
{
    public IntVector(int length) {&hellip;}</p>

<p>public int Length {&hellip;}                 // read-only property</p>

<p>public int this[int index] {&hellip;}        // read-write indexer</p>

<p>public static IntVector operator ++(IntVector iv) {
        IntVector temp = new IntVector(iv.Length);
        for (int i = 0; i &lt; iv.Length; i++)
            temp[i] = iv[i] + 1;
        return temp;
    }
}</p>

<p>class Test
{
    static void Main() {
        IntVector iv1 = new IntVector(4);    // vector of 4 x 0
        IntVector iv2;</p>

<p>iv2 = iv1++;    // iv2 contains 4 x 0, iv1 contains 4 x 1
        iv2 = ++iv1;    // iv2 contains 4 x 2, iv1 contains 4 x 2
    }
}
&ldquo;`</p>

<p>Note how the operator method returns the value produced by adding 1 to the operand, just like the  postfix increment and decrement operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>), and the prefix increment and decrement operators (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>). Unlike in C++, this method need not modify the value of its operand directly. In fact, modifying the operand value would violate the standard semantics of the postfix increment operator.</p>

<h3 id="binary-operators">Binary operators</h3>

<p>The following rules apply to binary operator declarations, where <code class="prettyprint">T</code> denotes the instance type of the class or struct that contains the operator declaration:</p>

<ul>
<li> A binary non-shift operator must take two parameters, at least one of which must have type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code>, and can return any type.</li>
<li> A binary <code class="prettyprint">&lt;&lt;</code> or <code class="prettyprint">&gt;&gt;</code> operator must take two parameters, the first of which must have type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and the second of which must have type <code class="prettyprint">int</code> or <code class="prettyprint">int?</code>, and can return any type.</li>
</ul>

<p>The signature of a binary operator consists of the operator token (<code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, or <code class="prettyprint">&lt;=</code>) and the types of the two formal parameters. The return type and the names of the formal parameters are not part of a binary operator&rsquo;s signature.</p>

<p>Certain binary operators require pair-wise declaration. For every declaration of either operator of a pair, there must be a matching declaration of the other operator of the pair. Two operator declarations match when they have the same return type and the same type for each parameter. The following operators require pair-wise declaration:</p>

<ul>
<li> <code class="prettyprint">operator ==</code> and <code class="prettyprint">operator !=</code></li>
<li> <code class="prettyprint">operator &gt;</code> and <code class="prettyprint">operator &lt;</code></li>
<li> <code class="prettyprint">operator &gt;=</code> and <code class="prettyprint">operator &lt;=</code></li>
</ul>

<h3 id="conversion-operators">Conversion operators</h3>

<p>A conversion operator declaration introduces a <strong><em>user-defined conversion</em></strong> (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>) which augments the pre-defined implicit and explicit conversions.</p>

<p>A conversion operator declaration that includes the <code class="prettyprint">implicit</code> keyword introduces a user-defined implicit conversion. Implicit conversions can occur in a variety of situations, including function member invocations, cast expressions, and assignments. This is described further in <a href="conversions.md#implicit-conversions">Implicit conversions</a>.</p>

<p>A conversion operator declaration that includes the <code class="prettyprint">explicit</code> keyword introduces a user-defined explicit conversion. Explicit conversions can occur in cast expressions, and are described further in <a href="conversions.md#explicit-conversions">Explicit conversions</a>.</p>

<p>A conversion operator converts from a source type, indicated by the parameter type of the conversion operator, to a target type, indicated by the return type of the conversion operator.</p>

<p>For a given source type <code class="prettyprint">S</code> and target type <code class="prettyprint">T</code>, if <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are nullable types, let <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> refer to their underlying types, otherwise <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are equal to <code class="prettyprint">S</code> and <code class="prettyprint">T</code> respectively. A class or struct is permitted to declare a conversion from a source type <code class="prettyprint">S</code> to a target type <code class="prettyprint">T</code> only if all of the following are true:</p>

<ul>
<li> <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are different types.</li>
<li> Either <code class="prettyprint">S0</code> or <code class="prettyprint">T0</code> is the class or struct type in which the operator declaration takes place.</li>
<li> Neither <code class="prettyprint">S0</code> nor <code class="prettyprint">T0</code> is an <em>interface_type</em>.</li>
<li> Excluding user-defined conversions, a conversion does not exist from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> or from <code class="prettyprint">T</code> to <code class="prettyprint">S</code>.</li>
</ul>

<p>For the purposes of these rules, any type parameters associated with <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are considered to be unique types that have no inheritance relationship with other types, and any constraints on those type parameters are ignored.</p>

<p>In the example
&rdquo;`csharp
class C<T> {&hellip;}</p>

<p>class D<T>: C<T>
{
    public static implicit operator C<int>(D<T> value) {&hellip;}      // Ok
    public static implicit operator C<string>(D<T> value) {&hellip;}   // Ok
    public static implicit operator C<T>(D<T> value) {&hellip;}        // Error
}
&ldquo;<code class="prettyprint">
the first two operator declarations are permitted because, for the purposes of [Indexers](classes.md#indexers).3,</code>T<code class="prettyprint">and</code>int<code class="prettyprint">and</code>string<code class="prettyprint">respectively are considered unique types with no relationship. However, the third operator is an error because</code>C<T><code class="prettyprint">is the base class of</code>D<T>`.</p>

<p>From the second rule it follows that a conversion operator must convert either to or from the class or struct type in which the operator is declared. For example, it is possible for a class or struct type <code class="prettyprint">C</code> to define a conversion from <code class="prettyprint">C</code> to <code class="prettyprint">int</code> and from <code class="prettyprint">int</code> to <code class="prettyprint">C</code>, but not from <code class="prettyprint">int</code> to <code class="prettyprint">bool</code>.</p>

<p>It is not possible to directly redefine a pre-defined conversion. Thus, conversion operators are not allowed to convert from or to <code class="prettyprint">object</code> because implicit and explicit conversions already exist between <code class="prettyprint">object</code> and all other types. Likewise, neither the source nor the target types of a conversion can be a base type of the other, since a conversion would then already exist.</p>

<p>However, it is possible to declare operators on generic types that, for particular type arguments, specify conversions that already exist as pre-defined conversions. In the example
<code class="prettyprint">csharp
struct Convertible&lt;T&gt;
{
    public static implicit operator Convertible&lt;T&gt;(T value) {...}
    public static explicit operator T(Convertible&lt;T&gt; value) {...}
}
</code>
when type <code class="prettyprint">object</code> is specified as a type argument for <code class="prettyprint">T</code>, the second operator declares a conversion that already exists (an implicit, and therefore also an explicit, conversion exists from any type to type <code class="prettyprint">object</code>).</p>

<p>In cases where a pre-defined conversion exists between two types, any user-defined conversions between those types are ignored. Specifically:</p>

<ul>
<li> If a pre-defined implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code>, all user-defined conversions (implicit or explicit) from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored.</li>
<li> If a pre-defined explicit conversion (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) exists from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code>, any user-defined explicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored. Furthermore:</li>
</ul>

<p>If <code class="prettyprint">T</code> is an interface type, user-defined implicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored.</p>

<p>Otherwise, user-defined implicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are still considered.</p>

<p>For all types but <code class="prettyprint">object</code>, the operators declared by the <code class="prettyprint">Convertible&lt;T&gt;</code> type above do not conflict with pre-defined conversions. For example:
<code class="prettyprint">csharp
void F(int i, Convertible&lt;int&gt; n) {
    i = n;                          // Error
    i = (int)n;                     // User-defined explicit conversion
    n = i;                          // User-defined implicit conversion
    n = (Convertible&lt;int&gt;)i;        // User-defined implicit conversion
}
</code></p>

<p>However, for type <code class="prettyprint">object</code>, pre-defined conversions hide the user-defined conversions in all cases but one:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">object</span> <span class="n">o</span><span class="p">,</span> <span class="n">Convertible</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">o</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>                         <span class="c1">// Pre-defined boxing conversion</span>
    <span class="n">o</span> <span class="p">=</span> <span class="p">(</span><span class="kt">object</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>                 <span class="c1">// Pre-defined boxing conversion</span>
    <span class="n">n</span> <span class="p">=</span> <span class="n">o</span><span class="p">;</span>                         <span class="c1">// User-defined implicit conversion</span>
    <span class="n">n</span> <span class="p">=</span> <span class="p">(</span><span class="n">Convertible</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">o</span><span class="p">;</span>    <span class="c1">// Pre-defined unboxing conversion</span>
<span class="p">}</span>
</code></pre>
<p>User-defined conversions are not allowed to convert from or to <em>interface_type*s. In particular, this restriction ensures that no user-defined transformations occur when converting to an *interface_type</em>, and that a conversion to an <em>interface_type</em> succeeds only if the object being converted actually implements the specified <em>interface_type</em>.</p>

<p>The signature of a conversion operator consists of the source type and the target type. (Note that this is the only form of member for which the return type participates in the signature.) The <code class="prettyprint">implicit</code> or <code class="prettyprint">explicit</code> classification of a conversion operator is not part of the operator&rsquo;s signature. Thus, a class or struct cannot declare both an <code class="prettyprint">implicit</code> and an <code class="prettyprint">explicit</code> conversion operator with the same source and target types.</p>

<p>In general, user-defined implicit conversions should be designed to never throw exceptions and never lose information. If a user-defined conversion can give rise to exceptions (for example, because the source argument is out of range) or loss of information (such as discarding high-order bits), then that conversion should be defined as an explicit conversion.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>public struct Digit
{
    byte value;</p>

<p>public Digit(byte value) {
        if (value &lt; 0 || value &gt; 9) throw new ArgumentException();
        this.value = value;
    }</p>

<p>public static implicit operator byte(Digit d) {
        return d.value;
    }</p>

<p>public static explicit operator Digit(byte b) {
        return new Digit(b);
    }
}
&ldquo;<code class="prettyprint">
the conversion from</code>Digit<code class="prettyprint">to</code>byte<code class="prettyprint">is implicit because it never throws exceptions or loses information, but the conversion from</code>byte<code class="prettyprint">to</code>Digit<code class="prettyprint">is explicit since</code>Digit<code class="prettyprint">can only represent a subset of the possible values of a</code>byte`.</p>

<h2 id="instance-constructors">Instance constructors</h2>

<p>An <strong><em>instance constructor</em></strong> is a member that implements the actions required to initialize an instance of a class. Instance constructors are declared using *constructor_declaration*s:</p>
<pre class="highlight plaintext"><code>constructor_declaration
    : attributes? constructor_modifier* constructor_declarator constructor_body
    ;

constructor_modifier
    : 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'extern'
    | constructor_modifier_unsafe
    ;

constructor_declarator
    : identifier '(' formal_parameter_list? ')' constructor_initializer?
    ;

constructor_initializer
    : ':' 'base' '(' argument_list? ')'
    | ':' 'this' '(' argument_list? ')'
    ;

constructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>constructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), and an <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifier. A constructor declaration is not permitted to include the same modifier multiple times.</p>

<p>The <em>identifier</em> of a <em>constructor_declarator</em> must name the class in which the instance constructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>The optional <em>formal_parameter_list</em> of an instance constructor is subject to the same rules as the <em>formal_parameter_list</em> of a method (<a href="classes.md#methods">Methods</a>). The formal parameter list defines the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of an instance constructor and governs the process whereby overload resolution (<a href="expressions.md#type-inference">Type inference</a>) selects a particular instance constructor in an invocation.</p>

<p>Each of the types referenced in the <em>formal_parameter_list</em> of an instance constructor must be at least as accessible as the constructor itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The optional <em>constructor_initializer</em> specifies another instance constructor to invoke before executing the statements given in the <em>constructor_body</em> of this instance constructor. This is described further in <a href="classes.md#constructor-initializers">Constructor initializers</a>.</p>

<p>When a constructor declaration includes an <code class="prettyprint">extern</code> modifier, the constructor is said to be an <strong><em>external constructor</em></strong>. Because an external constructor declaration provides no actual implementation, its <em>constructor_body</em> consists of a semicolon. For all other constructors, the <em>constructor_body</em> consists of a <em>block</em> which specifies the statements to initialize a new instance of the class. This corresponds exactly to the <em>block</em> of an instance method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Instance constructors are not inherited. Thus, a class has no instance constructors other than those actually declared in the class. If a class contains no instance constructor declarations, a default instance constructor is automatically provided (<a href="classes.md#default-constructors">Default constructors</a>).</p>

<p>Instance constructors are invoked by *object_creation_expression*s (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>) and through *constructor_initializer*s.</p>

<h3 id="constructor-initializers">Constructor initializers</h3>

<p>All instance constructors (except those for class <code class="prettyprint">object</code>) implicitly include an invocation of another instance constructor immediately before the <em>constructor_body</em>. The constructor to implicitly invoke is determined by the <em>constructor_initializer</em>:</p>

<ul>
<li> An instance constructor initializer of the form <code class="prettyprint">base(argument_list)</code> or <code class="prettyprint">base()</code> causes an instance constructor from the direct base class to be invoked. That constructor is selected using <em>argument_list</em> if present and the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors contained in the direct base class, or the default constructor (<a href="classes.md#default-constructors">Default constructors</a>), if no instance constructors are declared in the direct base class. If this set is empty, or if a single best instance constructor cannot be identified, a compile-time error occurs.</li>
<li> An instance constructor initializer of the form <code class="prettyprint">this(argument-list)</code> or <code class="prettyprint">this()</code> causes an instance constructor from the class itself to be invoked. The constructor is selected using <em>argument_list</em> if present and the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors declared in the class itself. If this set is empty, or if a single best instance constructor cannot be identified, a compile-time error occurs. If an instance constructor declaration includes a constructor initializer that invokes the constructor itself, a compile-time error occurs.</li>
</ul>

<p>If an instance constructor has no constructor initializer, a constructor initializer of the form <code class="prettyprint">base()</code> is implicitly provided. Thus, an instance constructor declaration of the form
<code class="prettyprint">csharp
C(...) {...}
</code>
is exactly equivalent to
<code class="prettyprint">csharp
C(...): base() {...}
</code></p>

<p>The scope of the parameters given by the <em>formal_parameter_list</em> of an instance constructor declaration includes the constructor initializer of that declaration. Thus, a constructor initializer is permitted to access the parameters of the constructor. For example:
&rdquo;`csharp
class A
{
    public A(int x, int y) {}
}</p>

<p>class B: A
{
    public B(int x, int y): base(x + y, x - y) {}
}
&ldquo;`</p>

<p>An instance constructor initializer cannot access the instance being created. Therefore it is a compile-time error to reference <code class="prettyprint">this</code> in an argument expression of the constructor initializer, as is it a compile-time error for an argument expression to reference any instance member through a <em>simple_name</em>.</p>

<h3 id="instance-variable-initializers">Instance variable initializers</h3>

<p>When an instance constructor has no constructor initializer, or it has a constructor initializer of the form <code class="prettyprint">base(...)</code>, that constructor implicitly performs the initializations specified by the *variable_initializer*s of the instance fields declared in its class. This corresponds to a sequence of assignments that are executed immediately upon entry to the constructor and before the implicit invocation of the direct base class constructor. The variable initializers are executed in the textual order in which they appear in the class declaration.</p>

<h3 id="constructor-execution">Constructor execution</h3>

<p>Variable initializers are transformed into assignment statements, and these assignment statements are executed before the invocation of the base class instance constructor. This ordering ensures that all instance fields are initialized by their variable initializers before any statements that have access to that instance are executed.</p>

<p>Given the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public A() {
        PrintFields();
    }</p>

<p>public virtual void PrintFields() {}
}</p>

<p>class B: A
{
    int x = 1;
    int y;</p>

<p>public B() {
        y = -1;
    }</p>

<p>public override void PrintFields() {
        Console.WriteLine(&ldquo;x = {0}, y = {1}&rdquo;, x, y);
    }
}
<code class="prettyprint">
when `new B()` is used to create an instance of `B`, the following output is produced:
</code>
x = 1, y = 0
&ldquo;`</p>

<p>The value of <code class="prettyprint">x</code> is 1 because the variable initializer is executed before the base class instance constructor is invoked. However, the value of <code class="prettyprint">y</code> is 0 (the default value of an <code class="prettyprint">int</code>) because the assignment to <code class="prettyprint">y</code> is not executed until after the base class constructor returns.</p>

<p>It is useful to think of instance variable initializers and constructor initializers as statements that are automatically inserted before the <em>constructor_body</em>. The example
&rdquo;`csharp
using System;
using System.Collections;</p>

<p>class A
{
    int x = 1, y = -1, count;</p>

<p>public A() {
        count = 0;
    }</p>

<p>public A(int n) {
        count = n;
    }
}</p>

<p>class B: A
{
    double sqrt2 = Math.Sqrt(2.0);
    ArrayList items = new ArrayList(100);
    int max;</p>

<p>public B(): this(100) {
        items.Add(&ldquo;default&rdquo;);
    }</p>

<p>public B(int n): base(n - 1) {
        max = n;
    }
}
&ldquo;<code class="prettyprint">
contains several variable initializers; it also contains constructor initializers of both forms (</code>base<code class="prettyprint">and</code>this`). The example corresponds to the code shown below, where each comment indicates an automatically inserted statement (the syntax used for the automatically inserted constructor invocations isn&rsquo;t valid, but merely serves to illustrate the mechanism).</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                       <span class="c1">// Variable initializer</span>
        <span class="n">y</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>                      <span class="c1">// Variable initializer</span>
        <span class="kt">object</span><span class="p">();</span>                    <span class="c1">// Invoke object() constructor</span>
        <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                       <span class="c1">// Variable initializer</span>
        <span class="n">y</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>                      <span class="c1">// Variable initializer</span>
        <span class="kt">object</span><span class="p">();</span>                    <span class="c1">// Invoke object() constructor</span>
        <span class="n">count</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">sqrt2</span><span class="p">;</span>
    <span class="n">ArrayList</span> <span class="n">items</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">B</span><span class="p">():</span> <span class="k">this</span><span class="p">(</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">B</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>                      <span class="c1">// Invoke B(int) constructor</span>
        <span class="n">items</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"default"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">):</span> <span class="k">base</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sqrt2</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="m">2.0</span><span class="p">);</span>      <span class="c1">// Variable initializer</span>
        <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>  <span class="c1">// Variable initializer</span>
        <span class="nf">A</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>                    <span class="c1">// Invoke A(int) constructor</span>
        <span class="n">max</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="default-constructors">Default constructors</h3>

<p>If a class contains no instance constructor declarations, a default instance constructor is automatically provided. That default constructor simply invokes the parameterless constructor of the direct base class. If the class is abstract then the declared accessibility for the default constructor is protected. Otherwise, the declared accessibility for the default constructor is public. Thus, the default constructor is always of the form</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">protected</span> <span class="nf">C</span><span class="p">():</span> <span class="k">base</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
<p>or
<code class="prettyprint">csharp
public C(): base() {}
</code>
where <code class="prettyprint">C</code> is the name of the class. If overload resolution is unable to determine a unique best candidate for the base class constructor initializer then a compile-time error occurs.</p>

<p>In the example
<code class="prettyprint">csharp
class Message
{
    object sender;
    string text;
}
</code>
a default constructor is provided because the class contains no instance constructor declarations. Thus, the example is precisely equivalent to
&rdquo;`csharp
class Message
{
    object sender;
    string text;</p>

<p>public Message(): base() {}
}
&ldquo;`</p>

<h3 id="private-constructors">Private constructors</h3>

<p>When a class <code class="prettyprint">T</code> declares only private instance constructors, it is not possible for classes outside the program text of <code class="prettyprint">T</code> to derive from <code class="prettyprint">T</code> or to directly create instances of <code class="prettyprint">T</code>. Thus, if a class contains only static members and isn&rsquo;t intended to be instantiated, adding an empty private instance constructor will prevent instantiation. For example:
&rdquo;`csharp
public class Trig
{
    private Trig() {}        // Prevent instantiation</p>

<p>public const double PI = 3.14159265358979323846;</p>

<p>public static double Sin(double x) {&hellip;}
    public static double Cos(double x) {&hellip;}
    public static double Tan(double x) {&hellip;}
}
&ldquo;`</p>

<p>The <code class="prettyprint">Trig</code> class groups related methods and constants, but is not intended to be instantiated. Therefore it declares a single empty private instance constructor. At least one instance constructor must be declared to suppress the automatic generation of a default constructor.</p>

<h3 id="optional-instance-constructor-parameters">Optional instance constructor parameters</h3>

<p>The <code class="prettyprint">this(...)</code> form of constructor initializer is commonly used in conjunction with overloading to implement optional instance constructor parameters. In the example
&rdquo;`csharp
class Text
{
    public Text(): this(0, 0, null) {}</p>

<p>public Text(int x, int y): this(x, y, null) {}</p>

<p>public Text(int x, int y, string s) {
        // Actual constructor implementation
    }
}
<code class="prettyprint">
the first two instance constructors merely provide the default values for the missing arguments. Both use a `this(...)` constructor initializer to invoke the third instance constructor, which actually does the work of initializing the new instance. The effect is that of optional constructor parameters:
</code>csharp
Text t1 = new Text();                    // Same as Text(0, 0, null)
Text t2 = new Text(5, 10);               // Same as Text(5, 10, null)
Text t3 = new Text(5, 20, &ldquo;Hello&rdquo;);
&ldquo;`</p>

<h2 id="static-constructors">Static constructors</h2>

<p>A <strong><em>static constructor</em></strong> is a member that implements the actions required to initialize a closed class type. Static constructors are declared using *static_constructor_declaration*s:</p>
<pre class="highlight plaintext"><code>static_constructor_declaration
    : attributes? static_constructor_modifiers identifier '(' ')' static_constructor_body
    ;

static_constructor_modifiers
    : 'extern'? 'static'
    | 'static' 'extern'?
    | static_constructor_modifiers_unsafe
    ;

static_constructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>static_constructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and an <code class="prettyprint">extern</code> modifier (<a href="classes.md#external-methods">External methods</a>).</p>

<p>The <em>identifier</em> of a <em>static_constructor_declaration</em> must name the class in which the static constructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>When a static constructor declaration includes an <code class="prettyprint">extern</code> modifier, the static constructor is said to be an <strong><em>external static constructor</em></strong>. Because an external static constructor declaration provides no actual implementation, its <em>static_constructor_body</em> consists of a semicolon. For all other static constructor declarations, the <em>static_constructor_body</em> consists of a <em>block</em> which specifies the statements to execute in order to initialize the class. This corresponds exactly to the <em>method_body</em> of a static method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Static constructors are not inherited, and cannot be called directly.</p>

<p>The static constructor for a closed class type executes at most once in a given application domain. The execution of a static constructor is triggered by the first of the following events to occur within an application domain:</p>

<ul>
<li> An instance of the class type is created.</li>
<li> Any of the static members of the class type are referenced.</li>
</ul>

<p>If a class contains the <code class="prettyprint">Main</code> method (<a href="basic-concepts.md#application-startup">Application Startup</a>) in which execution begins, the static constructor for that class executes before the <code class="prettyprint">Main</code> method is called.</p>

<p>To initialize a new closed class type, first a new set of static fields (<a href="classes.md#static-and-instance-fields">Static and instance fields</a>) for that particular closed type is created. Each of the static fields is initialized to its default value (<a href="variables.md#default-values">Default values</a>). Next, the static field initializers (<a href="classes.md#static-field-initialization">Static field initialization</a>) are executed for those static fields. Finally, the static constructor is executed.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        A.F();
        B.F();
    }
}</p>

<p>class A
{
    static A() {
        Console.WriteLine(&ldquo;Init A&rdquo;);
    }
    public static void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }
}</p>

<p>class B
{
    static B() {
        Console.WriteLine(&ldquo;Init B&rdquo;);
    }
    public static void F() {
        Console.WriteLine(&ldquo;B.F&rdquo;);
    }
}
<code class="prettyprint">
must produce the output:
</code>
Init A
A.F
Init B
B.F
&ldquo;<code class="prettyprint">
because the execution of</code>A<code class="prettyprint">&#39;s static constructor is triggered by the call to</code>A.F<code class="prettyprint">, and the execution of</code>B<code class="prettyprint">&#39;s static constructor is triggered by the call to</code>B.F`.</p>

<p>It is possible to construct circular dependencies that allow static fields with variable initializers to be observed in their default value state.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public static int X;</p>

<p>static A() {
        X = B.Y + 1;
    }
}</p>

<p>class B
{
    public static int Y = A.X + 1;</p>

<p>static B() {}</p>

<p>static void Main() {
        Console.WriteLine(&ldquo;X = {0}, Y = {1}&rdquo;, A.X, B.Y);
    }
}
<code class="prettyprint">
produces the output
</code>
X = 1, Y = 2
&ldquo;`</p>

<p>To execute the <code class="prettyprint">Main</code> method, the system first runs the initializer for <code class="prettyprint">B.Y</code>, prior to class <code class="prettyprint">B</code>&rsquo;s static constructor. <code class="prettyprint">Y</code>&rsquo;s initializer causes <code class="prettyprint">A</code>&rsquo;s static constructor to be run because the value of <code class="prettyprint">A.X</code> is referenced. The static constructor ofÂ <code class="prettyprint">A</code> in turn proceeds to compute the value ofÂ <code class="prettyprint">X</code>, and in doing so fetches the default value ofÂ <code class="prettyprint">Y</code>, which is zero. <code class="prettyprint">A.X</code> is thus initialized toÂ 1. The process of running <code class="prettyprint">A</code>&rsquo;s static field initializers and static constructor then completes, returning to the calculation of the initial value ofÂ <code class="prettyprint">Y</code>, the result of which becomesÂ 2.</p>

<p>Because the static constructor is executed exactly once for each closed constructed class type, it is a convenient place to enforce run-time checks on the type parameter that cannot be checked at compile-time via constraints (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For example, the following type uses a static constructor to enforce that the type argument is an enum:
<code class="prettyprint">csharp
class Gen&lt;T&gt; where T: struct
{
    static Gen() {
        if (!typeof(T).IsEnum) {
            throw new ArgumentException(&quot;T must be an enum&quot;);
        }
    }
}
</code></p>

<h2 id="destructors">Destructors</h2>

<p>A <strong><em>destructor</em></strong> is a member that implements the actions required to destruct an instance of a class. A destructor is declared using a <em>destructor_declaration</em>:</p>
<pre class="highlight plaintext"><code>destructor_declaration
    : attributes? 'extern'? '~' identifier '(' ')' destructor_body
    | destructor_declaration_unsafe
    ;

destructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>destructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>).</p>

<p>The <em>identifier</em> of a <em>destructor_declaration</em> must name the class in which the destructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>When a destructor declaration includes an <code class="prettyprint">extern</code> modifier, the destructor is said to be an <strong><em>external destructor</em></strong>. Because an external destructor declaration provides no actual implementation, its <em>destructor_body</em> consists of a semicolon. For all other destructors, the <em>destructor_body</em> consists of a <em>block</em> which specifies the statements to execute in order to destruct an instance of the class. A <em>destructor_body</em> corresponds exactly to the <em>method_body</em> of an instance method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Destructors are not inherited. Thus, a class has no destructors other than the one which may be declared in that class.</p>

<p>Since a destructor is required to have no parameters, it cannot be overloaded, so a class can have, at most, one destructor.</p>

<p>Destructors are invoked automatically, and cannot be invoked explicitly. An instance becomes eligible for destruction when it is no longer possible for any code to use that instance. Execution of the destructor for the instance may occur at any time after the instance becomes eligible for destruction. When an instance is destructed, the destructors in that instance&rsquo;s inheritance chain are called, in order, from most derived to least derived. A destructor may be executed on any thread. For further discussion of the rules that govern when and how a destructor is executed, see <a href="basic-concepts.md#automatic-memory-management">Automatic memory management</a>.</p>

<p>The output of the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&ldquo;A&rsquo;s destructor&rdquo;);
    }
}</p>

<p>class B: A
{
    ~B() {
        Console.WriteLine(&ldquo;B&rsquo;s destructor&rdquo;);
    }
}</p>

<p>class Test
{
   static void Main() {
        B b = new B();
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
   }
}
<code class="prettyprint">
is
</code>
B&rsquo;s destructor
A&rsquo;s destructor
&ldquo;`
since destructors in an inheritance chain are called in order, from most derived to least derived.</p>

<p>Destructors are implemented by overriding the virtual method <code class="prettyprint">Finalize</code> on <code class="prettyprint">System.Object</code>. C# programs are not permitted to override this method or call it (or overrides of it) directly. For instance, the program
&rdquo;`csharp
class A 
{
    override protected void Finalize() {}    // error</p>

<p>public void F() {
        this.Finalize();                     // error
    }
}
&ldquo;`
contains two errors.</p>

<p>The compiler behaves as if this method, and overrides of it, do not exist at all. Thus, this program:
<code class="prettyprint">csharp
class A 
{
    void Finalize() {}                            // permitted
}
</code>
is valid, and the method shown hides <code class="prettyprint">System.Object</code>&rsquo;s <code class="prettyprint">Finalize</code> method.</p>

<p>For a discussion of the behavior when an exception is thrown from a destructor, see <a href="exceptions.md#how-exceptions-are-handled">How exceptions are handled</a>.</p>

<h2 id="iterators">Iterators</h2>

<p>A function member (<a href="expressions.md#function-members">Function members</a>) implemented using an iterator block (<a href="statements.md#blocks">Blocks</a>) is called an <strong><em>iterator</em></strong>.</p>

<p>An iterator block may be used as the body of a function member as long as the return type of the corresponding function member is one of the enumerator interfaces (<a href="classes.md#enumerator-interfaces">Enumerator interfaces</a>) or one of the enumerable interfaces (<a href="classes.md#enumerable-interfaces">Enumerable interfaces</a>). It can occur as a <em>method_body</em>, <em>operator_body</em> or <em>accessor_body</em>, whereas events, instance constructors, static constructors and destructors cannot be implemented as iterators.</p>

<p>When a function member is implemented using an iterator block, it is a compile-time error for the formal parameter list of the function member to specify any <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</p>

<h3 id="enumerator-interfaces">Enumerator interfaces</h3>

<p>The <strong><em>enumerator interfaces</em></strong> are the non-generic interface <code class="prettyprint">System.Collections.IEnumerator</code> and all instantiations of the generic interface <code class="prettyprint">System.Collections.Generic.IEnumerator&lt;T&gt;</code>. For the sake of brevity, in this chapter these interfaces are referenced as <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, respectively.</p>

<h3 id="enumerable-interfaces">Enumerable interfaces</h3>

<p>The <strong><em>enumerable interfaces</em></strong> are the non-generic interface <code class="prettyprint">System.Collections.IEnumerable</code> and all instantiations of the generic interface <code class="prettyprint">System.Collections.Generic.IEnumerable&lt;T&gt;</code>. For the sake of brevity, in this chapter these interfaces are referenced as <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code>, respectively.</p>

<h3 id="yield-type">Yield type</h3>

<p>An iterator produces a sequence of values, all of the same type. This type is called the <strong><em>yield type</em></strong> of the iterator.</p>

<ul>
<li> The yield type of an iterator that returns <code class="prettyprint">IEnumerator</code> or <code class="prettyprint">IEnumerable</code> is <code class="prettyprint">object</code>.</li>
<li> The yield type of an iterator that returns <code class="prettyprint">IEnumerator&lt;T&gt;</code> or <code class="prettyprint">IEnumerable&lt;T&gt;</code> is <code class="prettyprint">T</code>.</li>
</ul>

<h3 id="enumerator-objects">Enumerator objects</h3>

<p>When a function member returning an enumerator interface type is implemented using an iterator block, invoking the function member does not immediately execute the code in the iterator block. Instead, an <strong><em>enumerator object</em></strong> is created and returned. This object encapsulates the code specified in the iterator block, and execution of the code in the iterator block occurs when the enumerator object&rsquo;s <code class="prettyprint">MoveNext</code> method is invoked. An enumerator object has the following characteristics:</p>

<ul>
<li> It implements <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, where <code class="prettyprint">T</code> is the yield type of the iterator.</li>
<li> It implements <code class="prettyprint">System.IDisposable</code>.</li>
<li> It is initialized with a copy of the argument values (if any) and instance value passed to the function member.</li>
<li> It has four potential states, <strong><em>before</em></strong>, <strong><em>running</em></strong>, <strong><em>suspended</em></strong>, and <strong><em>after</em></strong>, and is initially in the <strong><em>before</em></strong> state.</li>
</ul>

<p>An enumerator object is typically an instance of a compiler-generated enumerator class that encapsulates the code in the iterator block and implements the enumerator interfaces, but other methods of implementation are possible. If an enumerator class is generated by the compiler, that class will be nested, directly or indirectly, in the class containing the function member, it will have private accessibility, and it will have a name reserved for compiler use (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<p>An enumerator object may implement more interfaces than those specified above.</p>

<p>The following sections describe the exact behavior of the <code class="prettyprint">MoveNext</code>, <code class="prettyprint">Current</code>, and <code class="prettyprint">Dispose</code> members of the <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code> interface implementations provided by an enumerator object.</p>

<p>Note that enumerator objects do not support the <code class="prettyprint">IEnumerator.Reset</code> method. Invoking this method causes a <code class="prettyprint">System.NotSupportedException</code> to be thrown.</p>

<h4 id="the-movenext-method">The MoveNext method</h4>

<p>The <code class="prettyprint">MoveNext</code> method of an enumerator object encapsulates the code of an iterator block. Invoking the <code class="prettyprint">MoveNext</code> method executes code in the iterator block and sets the <code class="prettyprint">Current</code> property of the enumerator object as appropriate. The precise action performed by <code class="prettyprint">MoveNext</code> depends on the state of the enumerator object when <code class="prettyprint">MoveNext</code> is invoked:</p>

<ul>
<li> If the state of the enumerator object is <strong><em>before</em></strong>, invoking <code class="prettyprint">MoveNext</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Initializes the parameters (including <code class="prettyprint">this</code>) of the iterator block to the argument values and instance value saved when the enumerator object was initialized.</li>
<li>Executes the iterator block from the beginning until execution is interrupted (as described below).</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>running</em></strong>, the result of invoking <code class="prettyprint">MoveNext</code> is unspecified.</li>
<li> If the state of the enumerator object is <strong><em>suspended</em></strong>, invoking <code class="prettyprint">MoveNext</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Restores the values of all local variables and parameters (including this) to the values saved when execution of the iterator block was last suspended. Note that the contents of any objects referenced by these variables may have changed since the previous call to MoveNext.</li>
<li>Resumes execution of the iterator block immediately following the <code class="prettyprint">yield return</code> statement that caused the suspension of execution and continues until execution is interrupted (as described below).</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>after</em></strong>, invoking <code class="prettyprint">MoveNext</code> returns <code class="prettyprint">false</code>.</li>
</ul>

<p>When <code class="prettyprint">MoveNext</code> executes the iterator block, execution can be interrupted in four ways: By a <code class="prettyprint">yield return</code> statement, by a <code class="prettyprint">yield break</code> statement, by encountering the end of the iterator block, and by an exception being thrown and propagated out of the iterator block.</p>

<ul>
<li> When a <code class="prettyprint">yield return</code> statement is encountered (<a href="statements.md#the-yield-statement">The yield statement</a>):

<ul>
<li>The expression given in the statement is evaluated, implicitly converted to the yield type, and assigned to the <code class="prettyprint">Current</code> property of the enumerator object.</li>
<li>Execution of the iterator body is suspended. The values of all local variables and parameters (including <code class="prettyprint">this</code>) are saved, as is the location of this <code class="prettyprint">yield return</code> statement. If the <code class="prettyprint">yield return</code> statement is within one or more <code class="prettyprint">try</code> blocks, the associated <code class="prettyprint">finally</code> blocks are not executed at this time.</li>
<li>The state of the enumerator object is changed to <strong><em>suspended</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">true</code> to its caller, indicating that the iteration successfully advanced to the next value.</li>
</ul></li>
<li> When a <code class="prettyprint">yield break</code> statement is encountered (<a href="statements.md#the-yield-statement">The yield statement</a>):

<ul>
<li>If the <code class="prettyprint">yield break</code> statement is within one or more <code class="prettyprint">try</code> blocks, the associated <code class="prettyprint">finally</code> blocks are executed.</li>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">false</code> to its caller, indicating that the iteration is complete.</li>
</ul></li>
<li> When the end of the iterator body is encountered:

<ul>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">false</code> to its caller, indicating that the iteration is complete.</li>
</ul></li>
<li> When an exception is thrown and propagated out of the iterator block:

<ul>
<li>Appropriate <code class="prettyprint">finally</code> blocks in the iterator body will have been executed by the exception propagation.</li>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The exception propagation continues to the caller of the <code class="prettyprint">MoveNext</code> method.</li>
</ul></li>
</ul>

<h4 id="the-current-property">The Current property</h4>

<p>An enumerator object&rsquo;s <code class="prettyprint">Current</code> property is affected by <code class="prettyprint">yield return</code> statements in the iterator block.</p>

<p>When an enumerator object is in the <strong><em>suspended</em></strong> state, the value of <code class="prettyprint">Current</code> is the value set by the previous call to <code class="prettyprint">MoveNext</code>. When an enumerator object is in the <strong><em>before</em></strong>, <strong><em>running</em></strong>, or <strong><em>after</em></strong> states, the result of accessing <code class="prettyprint">Current</code> is unspecified.</p>

<p>For an iterator with a yield type other than <code class="prettyprint">object</code>, the result of accessing <code class="prettyprint">Current</code> through the enumerator object&rsquo;s <code class="prettyprint">IEnumerable</code> implementation corresponds to accessing <code class="prettyprint">Current</code> through the enumerator object&rsquo;s <code class="prettyprint">IEnumerator&lt;T&gt;</code> implementation and casting the result to <code class="prettyprint">object</code>.</p>

<h4 id="the-dispose-method">The Dispose method</h4>

<p>The <code class="prettyprint">Dispose</code> method is used to clean up the iteration by bringing the enumerator object to the <strong><em>after</em></strong> state.</p>

<ul>
<li> If the state of the enumerator object is <strong><em>before</em></strong>, invoking <code class="prettyprint">Dispose</code> changes the state to <strong><em>after</em></strong>.</li>
<li> If the state of the enumerator object is <strong><em>running</em></strong>, the result of invoking <code class="prettyprint">Dispose</code> is unspecified.</li>
<li> If the state of the enumerator object is <strong><em>suspended</em></strong>, invoking <code class="prettyprint">Dispose</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Executes any finally blocks as if the last executed <code class="prettyprint">yield return</code> statement were a <code class="prettyprint">yield break</code> statement. If this causes an exception to be thrown and propagated out of the iterator body, the state of the enumerator object is set to <strong><em>after</em></strong> and the exception is propagated to the caller of the <code class="prettyprint">Dispose</code> method.</li>
<li>Changes the state to <strong><em>after</em></strong>.</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>after</em></strong>, invoking <code class="prettyprint">Dispose</code> has no affect.</li>
</ul>

<h3 id="enumerable-objects">Enumerable objects</h3>

<p>When a function member returning an enumerable interface type is implemented using an iterator block, invoking the function member does not immediately execute the code in the iterator block. Instead, an <strong><em>enumerable object</em></strong> is created and returned. The enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code> method returns an enumerator object that encapsulates the code specified in the iterator block, and execution of the code in the iterator block occurs when the enumerator object&rsquo;s <code class="prettyprint">MoveNext</code> method is invoked. An enumerable object has the following characteristics:</p>

<ul>
<li> It implements <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code>, where <code class="prettyprint">T</code> is the yield type of the iterator.</li>
<li> It is initialized with a copy of the argument values (if any) and instance value passed to the function member.</li>
</ul>

<p>An enumerable object is typically an instance of a compiler-generated enumerable class that encapsulates the code in the iterator block and implements the enumerable interfaces, but other methods of implementation are possible. If an enumerable class is generated by the compiler, that class will be nested, directly or indirectly, in the class containing the function member, it will have private accessibility, and it will have a name reserved for compiler use (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<p>An enumerable object may implement more interfaces than those specified above. In particular, an enumerable object may also implement <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, enabling it to serve as both an enumerable and an enumerator. In that type of implementation, the first time an enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code> method is invoked, the enumerable object itself is returned. Subsequent invocations of the enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code>, if any, return a copy of the enumerable object. Thus, each returned enumerator has its own state and changes in one enumerator will not affect another.</p>

<h4 id="the-getenumerator-method">The GetEnumerator method</h4>

<p>An enumerable object provides an implementation of the <code class="prettyprint">GetEnumerator</code> methods of the <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code> interfaces. The two <code class="prettyprint">GetEnumerator</code> methods share a common implementation that acquires and returns an available enumerator object. The enumerator object is initialized with the argument values and instance value saved when the enumerable object was initialized, but otherwise the enumerator object functions as described in <a href="classes.md#enumerator-objects">Enumerator objects</a>.</p>

<h3 id="implementation-example">Implementation example</h3>

<p>This section describes a possible implementation of iterators in terms of standard C# constructs. The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation or the only one possible.</p>

<p>The following <code class="prettyprint">Stack&lt;T&gt;</code> class implements its <code class="prettyprint">GetEnumerator</code> method using an iterator. The iterator enumerates the elements of the stack in top to bottom order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="m">4</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">T</span><span class="p">[]</span> <span class="n">newItems</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">count</span> <span class="p">*</span> <span class="m">2</span><span class="p">];</span>
            <span class="n">Array</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">newItems</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
            <span class="n">items</span> <span class="p">=</span> <span class="n">newItems</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">items</span><span class="p">[</span><span class="n">count</span><span class="p">++]</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">T</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">result</span> <span class="p">=</span> <span class="n">items</span><span class="p">[--</span><span class="n">count</span><span class="p">];</span>
        <span class="n">items</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="p">--</span><span class="n">i</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">GetEnumerator</code> method can be translated into an instantiation of a compiler-generated enumerator class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerator1</span><span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">__current</span><span class="p">;</span>
        <span class="n">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="n">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__this</span> <span class="p">=</span> <span class="n">__this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="m">1</span><span class="p">:</span> <span class="k">goto</span> <span class="n">__state1</span><span class="p">;</span>
                <span class="k">case</span> <span class="m">2</span><span class="p">:</span> <span class="k">goto</span> <span class="n">__state2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">i</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
        <span class="n">__loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__state2</span><span class="p">;</span>
            <span class="n">__current</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">__state1</span><span class="p">:</span>
            <span class="p">--</span><span class="n">i</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">__loop</span><span class="p">;</span>
        <span class="n">__state2</span><span class="p">:</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In the preceding translation, the code in the iterator block is turned into a state machine and placed in the <code class="prettyprint">MoveNext</code> method of the enumerator class. Furthermore, the local variable <code class="prettyprint">i</code> is turned into a field in the enumerator object so it can continue to exist across invocations of <code class="prettyprint">MoveNext</code>.</p>

<p>The following example prints a simple multiplication table of the integers 1 through 10. The <code class="prettyprint">FromTo</code> method in the example returns an enumerable object and is implemented using an iterator.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">FromTo</span><span class="p">(</span><span class="kt">int</span> <span class="k">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">from</span> <span class="p">&lt;=</span> <span class="n">to</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="k">from</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">e</span> <span class="p">=</span> <span class="nf">FromTo</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="k">in</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0,3} "</span><span class="p">,</span> <span class="n">x</span> <span class="p">*</span> <span class="n">y</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">FromTo</code> method can be translated into an instantiation of a compiler-generated enumerable class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">FromTo</span><span class="p">(</span><span class="kt">int</span> <span class="k">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerable1</span><span class="p">:</span>
        <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> <span class="n">IEnumerable</span><span class="p">,</span>
        <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__current</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__from</span><span class="p">;</span>
        <span class="kt">int</span> <span class="k">from</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="kt">int</span> <span class="n">__from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__from</span> <span class="p">=</span> <span class="n">__from</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">to</span> <span class="p">=</span> <span class="n">to</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__Enumerable1</span> <span class="n">result</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">__state</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="n">__from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
                <span class="n">result</span><span class="p">.</span><span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="p">.</span><span class="k">from</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">__from</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">IEnumerator</span><span class="p">)</span><span class="nf">GetEnumerator</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">from</span> <span class="p">&gt;</span> <span class="n">to</span><span class="p">)</span> <span class="k">goto</span> <span class="k">case</span> <span class="m">2</span><span class="p">;</span>
                <span class="n">__current</span> <span class="p">=</span> <span class="k">from</span><span class="p">++;</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">case</span> <span class="m">2</span><span class="p">:</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The enumerable class implements both the enumerable interfaces and the enumerator interfaces, enabling it to serve as both an enumerable and an enumerator. The first time the <code class="prettyprint">GetEnumerator</code> method is invoked, the enumerable object itself is returned. Subsequent invocations of the enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code>, if any, return a copy of the enumerable object. Thus, each returned enumerator has its own state and changes in one enumerator will not affect another. The <code class="prettyprint">Interlocked.CompareExchange</code> method is used to ensure thread-safe operation.</p>

<p>The <code class="prettyprint">from</code> and <code class="prettyprint">to</code> parameters are turned into fields in the enumerable class. Because <code class="prettyprint">from</code> is modified in the iterator block, an additional <code class="prettyprint">__from</code> field is introduced to hold the initial value given to <code class="prettyprint">from</code> in each enumerator.</p>

<p>The <code class="prettyprint">MoveNext</code> method throws an <code class="prettyprint">InvalidOperationException</code> if it is called when <code class="prettyprint">__state</code> is <code class="prettyprint">0</code>. This protects against use of the enumerable object as an enumerator object without first calling <code class="prettyprint">GetEnumerator</code>.</p>

<p>The following example shows a simple tree class. The <code class="prettyprint">Tree&lt;T&gt;</code> class implements its <code class="prettyprint">GetEnumerator</code> method using an iterator. The iterator enumerates the elements of the tree in infix order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="k">value</span><span class="p">;</span>
    <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Tree</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">left</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">right</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span> <span class="k">in</span> <span class="n">left</span><span class="p">)</span> <span class="k">yield</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">yield</span> <span class="k">value</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span> <span class="k">in</span> <span class="n">right</span><span class="p">)</span> <span class="k">yield</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">MakeTree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="p">(</span><span class="n">left</span> <span class="p">+</span> <span class="n">right</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
            <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">),</span>
            <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">MakeTree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">params</span> <span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">items</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// The output of the program is:</span>
    <span class="c1">// 1 2 3 4 5 6 7 8 9</span>
    <span class="c1">// Mon Tue Wed Thu Fri Sat Sun</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Tree</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">ints</span> <span class="p">=</span> <span class="nf">MakeTree</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="k">in</span> <span class="n">ints</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0} "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>

        <span class="n">Tree</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">strings</span> <span class="p">=</span> <span class="nf">MakeTree</span><span class="p">(</span>
            <span class="s">"Mon"</span><span class="p">,</span> <span class="s">"Tue"</span><span class="p">,</span> <span class="s">"Wed"</span><span class="p">,</span> <span class="s">"Thu"</span><span class="p">,</span> <span class="s">"Fri"</span><span class="p">,</span> <span class="s">"Sat"</span><span class="p">,</span> <span class="s">"Sun"</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="k">in</span> <span class="n">strings</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0} "</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">GetEnumerator</code> method can be translated into an instantiation of a compiler-generated enumerator class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerator1</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">;</span>
        <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__left</span><span class="p">,</span> <span class="n">__right</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">__current</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="n">Node</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__this</span> <span class="p">=</span> <span class="n">__this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__this</span><span class="p">.</span><span class="n">left</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__yield_value</span><span class="p">;</span>
                    <span class="n">__left</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
                    <span class="k">goto</span> <span class="k">case</span> <span class="m">1</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">2</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">__left</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span> <span class="k">goto</span> <span class="n">__left_dispose</span><span class="p">;</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__left</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="n">__left_dispose</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="n">__left</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>

                <span class="n">__yield_value</span><span class="p">:</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="k">value</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">2</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__this</span><span class="p">.</span><span class="n">right</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__end</span><span class="p">;</span>
                    <span class="n">__right</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
                    <span class="k">goto</span> <span class="k">case</span> <span class="m">3</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">3</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">3</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">__right</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span> <span class="k">goto</span> <span class="n">__right_dispose</span><span class="p">;</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__right</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="n">__right_dispose</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="n">__right</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>

                <span class="n">__end</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">__state</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="nf">Dispose</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                <span class="k">case</span> <span class="p">-</span><span class="m">2</span><span class="p">:</span>
                    <span class="n">__left</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">3</span><span class="p">:</span>
                <span class="k">case</span> <span class="p">-</span><span class="m">3</span><span class="p">:</span>
                    <span class="n">__right</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The compiler generated temporaries used in the <code class="prettyprint">foreach</code> statements are lifted into the <code class="prettyprint">__left</code> and <code class="prettyprint">__right</code> fields of the enumerator object. The <code class="prettyprint">__state</code> field of the enumerator object is carefully updated so that the correct <code class="prettyprint">Dispose()</code> method will be called correctly if an exception is thrown. Note that it is not possible to write the translated code with simple <code class="prettyprint">foreach</code> statements.</p>

<h2 id="async-functions">Async functions</h2>

<p>A method (<a href="classes.md#methods">Methods</a>) or anonymous function (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) with the <code class="prettyprint">async</code> modifier is called an <strong><em>async function</em></strong>. In general, the term <strong><em>async</em></strong> is used to describe any kind of function that has the <code class="prettyprint">async</code> modifier.</p>

<p>It is a compile-time error for the formal parameter list of an async function to specify any <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</p>

<p>The <em>return_type</em> of an async method must be either <code class="prettyprint">void</code> or a <strong><em>task type</em></strong>. The task types are <code class="prettyprint">System.Threading.Tasks.Task</code> and types constructed from <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code>. For the sake of brevity, in this chapter these types are referenced as <code class="prettyprint">Task</code> and <code class="prettyprint">Task&lt;T&gt;</code>, respectively. An async method returning a task type is said to be task-returning.</p>

<p>The exact definition of the task types is implementation defined, but from the language&rsquo;s point of view a task type is in one of the states incomplete, succeeded or faulted. A faulted task records a pertinent exception. A succeeded <code class="prettyprint">Task&lt;T&gt;</code> records a result of type <code class="prettyprint">T</code>. Task types are awaitable, and can therefore be the operands of await expressions (<a href="expressions.md#await-expressions">Await expressions</a>).</p>

<p>An async function invocation has the ability to suspend evaluation by means of await expressions (<a href="expressions.md#await-expressions">Await expressions</a>) in its body. Evaluation may later be resumed at the point of the suspending await expression by means of a <strong><em>resumption delegate</em></strong>. The resumption delegate is of type <code class="prettyprint">System.Action</code>, and when it is invoked, evaluation of the async function invocation will resume from the await expression where it left off. The <strong><em>current caller</em></strong> of an async function invocation is the original caller if the function invocation has never been suspended, or the most recent caller of the resumption delegate otherwise.</p>

<h3 id="evaluation-of-a-task-returning-async-function">Evaluation of a task-returning async function</h3>

<p>Invocation of a task-returning async function causes an instance of the returned task type to be generated. This is called the <strong><em>return task</em></strong> of the async function. The task is initially in an incomplete state.</p>

<p>The async function body is then evaluated until it is either suspended (by reaching an await expression) or terminates, at which point control is returned to the caller, along with the return task.</p>

<p>When the body of the async function terminates, the return task is moved out of the incomplete state:</p>

<ul>
<li> If the function body terminates as the result of reaching a return statement or the end of the body, any result value is recorded in the return task, which is put into a succeeded state.</li>
<li> If the function body terminates as the result of an uncaught exception (<a href="statements.md#the-throw-statement">The throw statement</a>) the exception is recorded in the return task which is put into a faulted state.</li>
</ul>

<h3 id="evaluation-of-a-void-returning-async-function">Evaluation of a void-returning async function</h3>

<p>If the return type of the async function is <code class="prettyprint">void</code>, evaluation differs from the above in the following way: Because no task is returned, the function instead communicates completion and exceptions to the current thread&rsquo;s <strong><em>synchronization context</em></strong>. The exact definition of synchronization context is implementation-dependent, but is a representation of &quot;where&rdquo; the current thread is running. The synchronization context is notified when evaluation of a void-returning async function commences, completes successfully, or causes an uncaught exception to be thrown.</p>

<p>This allows the context to keep track of how many void-returning async functions are running under it, and to decide how to propagate exceptions coming out of them.</p>

          <h1 id="structs">Structs</h1>

<p>Structs are similar to classes in that they represent data structures that can contain data members and function members. However, unlike classes, structs are value types and do not require heap allocation. A variable of a struct type directly contains the data of the struct, whereas a variable of a class type contains a reference to the data, the latter known as an object.</p>

<p>Structs are particularly useful for small data structures that have value semantics. Complex numbers, points in a coordinate system, or key-value pairs in a dictionary are all good examples of structs. Key to these data structures is that they have few data members, that they do not require use of inheritance or referential identity, and that they can be conveniently implemented using value semantics where assignment copies the value instead of the reference.</p>

<p>As described in <a href="types.md#simple-types">Simple types</a>, the simple types provided by C#, such as <code class="prettyprint">int</code>, <code class="prettyprint">double</code>, and <code class="prettyprint">bool</code>, are in fact all struct types. Just as these predefined types are structs, it is also possible to use structs and operator overloading to implement new &ldquo;primitive&rdquo; types in the C# language. Two examples of such types are given at the end of this chapter (<a href="structs.md#struct-examples">Struct examples</a>).</p>

<h2 id="struct-declarations">Struct declarations</h2>

<p>A <em>struct_declaration</em> is a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>) that declares a new struct:</p>
<pre class="highlight plaintext"><code>struct_declaration
    : attributes? struct_modifier* 'partial'? 'struct' identifier type_parameter_list?
      struct_interfaces? type_parameter_constraints_clause* struct_body ';'?
    ;
</code></pre>
<p>A <em>struct_declaration</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), followed by an optional set of <em>struct_modifier*s (<a href="structs.md#struct-modifiers">Struct modifiers</a>), followed by an optional <code class="prettyprint">partial</code> modifier, followed by the keyword <code class="prettyprint">struct</code> and an *identifier</em> that names the struct, followed by an optional <em>type_parameter_list</em> specification (<a href="classes.md#type-parameters">Type parameters</a>), followed by an optional <em>struct_interfaces</em> specification (<a href="structs.md#partial-modifier">Partial modifier</a>) ), followed by an optional <em>type_parameter_constraints_clause*s specification (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), followed by a *struct_body</em> (<a href="structs.md#struct-body">Struct body</a>), optionally followed by a semicolon.</p>

<h3 id="struct-modifiers">Struct modifiers</h3>

<p>A <em>struct_declaration</em> may optionally include a sequence of struct modifiers:</p>
<pre class="highlight plaintext"><code>struct_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | struct_modifier_unsafe
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in a struct declaration.</p>

<p>The modifiers of a struct declaration have the same meaning as those of a class declaration (<a href="classes.md#class-declarations">Class declarations</a>).</p>

<h3 id="partial-modifier">Partial modifier</h3>

<p>The <code class="prettyprint">partial</code> modifier indicates that this <em>struct_declaration</em> is a partial type declaration. Multiple partial struct declarations with the same name within an enclosing namespace or type declaration combine to form one struct declaration, following the rules specified in <a href="classes.md#partial-types">Partial types</a>.</p>

<h3 id="struct-interfaces">Struct interfaces</h3>

<p>A struct declaration may include a <em>struct_interfaces</em> specification, in which case the struct is said to directly implement the given interface types.</p>
<pre class="highlight plaintext"><code>struct_interfaces
    : ':' interface_type_list
    ;
</code></pre>
<p>Interface implementations are discussed further in <a href="interfaces.md#interface-implementations">Interface implementations</a>.</p>

<h3 id="struct-body">Struct body</h3>

<p>The <em>struct_body</em> of a struct defines the members of the struct.</p>
<pre class="highlight plaintext"><code>struct_body
    : '{' struct_member_declaration* '}'
    ;
</code></pre>
<h2 id="struct-members">Struct members</h2>

<p>The members of a struct consist of the members introduced by its *struct_member_declaration*s and the members inherited from the type <code class="prettyprint">System.ValueType</code>.</p>
<pre class="highlight plaintext"><code>struct_member_declaration
    : constant_declaration
    | field_declaration
    | method_declaration
    | property_declaration
    | event_declaration
    | indexer_declaration
    | operator_declaration
    | constructor_declaration
    | static_constructor_declaration
    | type_declaration
    | struct_member_declaration_unsafe
    ;
</code></pre>
<p>Except for the differences noted in <a href="structs.md#class-and-struct-differences">Class and struct differences</a>, the descriptions of class members provided in <a href="classes.md#class-members">Class members</a> through <a href="classes.md#iterators">Iterators</a> apply to struct members as well.</p>

<h2 id="class-and-struct-differences">Class and struct differences</h2>

<p>Structs differ from classes in several important ways:</p>

<ul>
<li> Structs are value types (<a href="structs.md#value-semantics">Value semantics</a>).</li>
<li> All struct types implicitly inherit from the class <code class="prettyprint">System.ValueType</code> (<a href="structs.md#inheritance">Inheritance</a>).</li>
<li> Assignment to a variable of a struct type creates a copy of the value being assigned (<a href="structs.md#assignment">Assignment</a>).</li>
<li> The default value of a struct is the value produced by setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code> (<a href="structs.md#default-values">Default values</a>).</li>
<li> Boxing and unboxing operations are used to convert between a struct type and <code class="prettyprint">object</code> (<a href="structs.md#boxing-and-unboxing">Boxing and unboxing</a>).</li>
<li> The meaning of <code class="prettyprint">this</code> is different for structs (<a href="expressions.md#this-access">This access</a>).</li>
<li> Instance field declarations for a struct are not permitted to include variable initializers (<a href="structs.md#field-initializers">Field initializers</a>).</li>
<li> A struct is not permitted to declare a parameterless instance constructor (<a href="structs.md#constructors">Constructors</a>).</li>
<li> A struct is not permitted to declare a destructor (<a href="structs.md#destructors">Destructors</a>).</li>
</ul>

<h3 id="value-semantics">Value semantics</h3>

<p>Structs are value types (<a href="types.md#value-types">Value types</a>) and are said to have value semantics. Classes, on the other hand, are reference types (<a href="types.md#reference-types">Reference types</a>) and are said to have reference semantics.</p>

<p>A variable of a struct type directly contains the data of the struct, whereas a variable of a class type contains a reference to the data, the latter known as an object. When a struct <code class="prettyprint">B</code> contains an instance field of type <code class="prettyprint">A</code> and <code class="prettyprint">A</code> is a struct type, it is a compile-time error for <code class="prettyprint">A</code> to depend on <code class="prettyprint">B</code> or a type constructed from <code class="prettyprint">B</code>. A struct <code class="prettyprint">X</code> <strong><em>directly depends on</em></strong> a struct <code class="prettyprint">Y</code> if <code class="prettyprint">X</code> contains an instance field of type <code class="prettyprint">Y</code>. Given this definition, the complete set of structs upon which a struct depends is the transitive closure of the <strong><em>directly depends on</em></strong> relationship.  For example
<code class="prettyprint">csharp
struct Node
{
    int data;
    Node next; // error, Node directly depends on itself
}
</code>
is an error because <code class="prettyprint">Node</code> contains an instance field of its own type.  Another example
&ldquo;`csharp
struct A { B b; }</p>

<p>struct B { C c; }</p>

<p>struct C { A a; }
&rdquo;<code class="prettyprint">
is an error because each of the types</code>A<code class="prettyprint">,</code>B<code class="prettyprint">, and</code>C` depend on each other.</p>

<p>With classes, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With structs, the variables each have their own copy of the data (except in the case of <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter variables), and it is not possible for operations on one to affect the other. Furthermore, because structs are not reference types, it is not possible for values of a struct type to be <code class="prettyprint">null</code>.</p>

<p>Given the declaration
&ldquo;`csharp
struct Point
{
    public int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
<code class="prettyprint">
the code fragment
</code>csharp
Point a = new Point(10, 10);
Point b = a;
a.x = 100;
System.Console.WriteLine(b.x);
&rdquo;<code class="prettyprint">
outputs the value</code>10<code class="prettyprint">. The assignment of</code>a<code class="prettyprint">to</code>b<code class="prettyprint">creates a copy of the value, and</code>b<code class="prettyprint">is thus unaffected by the assignment to</code>a.x<code class="prettyprint">. Had</code>Point<code class="prettyprint">instead been declared as a class, the output would be</code>100<code class="prettyprint">because</code>a<code class="prettyprint">and</code>b` would reference the same object.</p>

<h3 id="inheritance">Inheritance</h3>

<p>All struct types implicitly inherit from the class <code class="prettyprint">System.ValueType</code>, which, in turn, inherits from class <code class="prettyprint">object</code>. A struct declaration may specify a list of implemented interfaces, but it is not possible for a struct declaration to specify a base class.</p>

<p>Struct types are never abstract and are always implicitly sealed. The <code class="prettyprint">abstract</code> and <code class="prettyprint">sealed</code> modifiers are therefore not permitted in a struct declaration.</p>

<p>Since inheritance isn&rsquo;t supported for structs, the declared accessibility of a struct member cannot be <code class="prettyprint">protected</code> or <code class="prettyprint">protected internal</code>.</p>

<p>Function members in a struct cannot be <code class="prettyprint">abstract</code> or <code class="prettyprint">virtual</code>, and the <code class="prettyprint">override</code> modifier is allowed only to override methods inherited from <code class="prettyprint">System.ValueType</code>.</p>

<h3 id="assignment">Assignment</h3>

<p>Assignment to a variable of a struct type creates a copy of the value being assigned. This differs from assignment to a variable of a class type, which copies the reference but not the object identified by the reference.</p>

<p>Similar to an assignment, when a struct is passed as a value parameter or returned as the result of a function member, a copy of the struct is created. A struct may be passed by reference to a function member using a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</p>

<p>When a property or indexer of a struct is the target of an assignment, the instance expression associated with the property or indexer access must be classified as a variable. If the instance expression is classified as a value, a compile-time error occurs. This is described in further detail in <a href="expressions.md#simple-assignment">Simple assignment</a>.</p>

<h3 id="default-values">Default values</h3>

<p>As described in <a href="variables.md#default-values">Default values</a>, several kinds of variables are automatically initialized to their default value when they are created. For variables of class types and other reference types, this default value is <code class="prettyprint">null</code>. However, since structs are value types that cannot be <code class="prettyprint">null</code>, the default value of a struct is the value produced by setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code>.</p>

<p>Referring to the <code class="prettyprint">Point</code> struct declared above, the example
<code class="prettyprint">csharp
Point[] a = new Point[100];
</code>
initializes each <code class="prettyprint">Point</code> in the array to the value produced by setting the <code class="prettyprint">x</code> and <code class="prettyprint">y</code> fields to zero.</p>

<p>The default value of a struct corresponds to the value returned by the default constructor of the struct (<a href="types.md#default-constructors">Default constructors</a>). Unlike a class, a struct is not permitted to declare a parameterless instance constructor. Instead, every struct implicitly has a parameterless instance constructor which always returns the value that results from setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code>.</p>

<p>Structs should be designed to consider the default initialization state a valid state. In the example
&ldquo;`csharp
using System;</p>

<p>struct KeyValuePair
{
    string key;
    string value;</p>

<p>public KeyValuePair(string key, string value) {
        if (key == null || value == null) throw new ArgumentException();
        this.key = key;
        this.value = value;
    }
}
&rdquo;<code class="prettyprint">
the user-defined instance constructor protects against null values only where it is explicitly called. In cases where a</code>KeyValuePair<code class="prettyprint">variable is subject to default value initialization, the</code>key<code class="prettyprint">and</code>value` fields will be null, and the struct must be prepared to handle this state.</p>

<h3 id="boxing-and-unboxing">Boxing and unboxing</h3>

<p>A value of a class type can be converted to type <code class="prettyprint">object</code> or to an interface type that is implemented by the class simply by treating the reference as another type at compile-time. Likewise, a value of type <code class="prettyprint">object</code> or a value of an interface type can be converted back to a class type without changing the reference (but of course a run-time type check is required in this case).</p>

<p>Since structs are not reference types, these operations are implemented differently for struct types. When a value of a struct type is converted to type <code class="prettyprint">object</code> or to an interface type that is implemented by the struct, a boxing operation takes place. Likewise, when a value of type <code class="prettyprint">object</code> or a value of an interface type is converted back to a struct type, an unboxing operation takes place. A key difference from the same operations on class types is that boxing and unboxing copies the struct value either into or out of the boxed instance. Thus, following a boxing or unboxing operation, changes made to the unboxed struct are not reflected in the boxed struct.</p>

<p>When a struct type overrides a virtual method inherited from <code class="prettyprint">System.Object</code> (such as <code class="prettyprint">Equals</code>, <code class="prettyprint">GetHashCode</code>, or <code class="prettyprint">ToString</code>), invocation of the virtual method through an instance of the struct type does not cause boxing to occur. This is true even when the struct is used as a type parameter and the invocation occurs through an instance of the type parameter type. For example:
&ldquo;`csharp
using System;</p>

<p>struct Counter
{
    int value;</p>

<p>public override string ToString() {
        value++;
        return value.ToString();
    }
}</p>

<p>class Program
{
    static void Test<T>() where T: new() {
        T x = new T();
        Console.WriteLine(x.ToString());
        Console.WriteLine(x.ToString());
        Console.WriteLine(x.ToString());
    }</p>

<p>static void Main() {
        Test<Counter>();
    }
}
&rdquo;`</p>

<p>The output of the program is:
<code class="prettyprint">
1
2
3
</code></p>

<p>Although it is bad style for <code class="prettyprint">ToString</code> to have side effects, the example demonstrates that no boxing occurred for the three invocations of <code class="prettyprint">x.ToString()</code>.</p>

<p>Similarly, boxing never implicitly occurs when accessing a member on a constrained type parameter. For example, suppose an interface <code class="prettyprint">ICounter</code> contains a method <code class="prettyprint">Increment</code> which can be used to modify a value. If <code class="prettyprint">ICounter</code> is used as a constraint, the implementation of the <code class="prettyprint">Increment</code> method is called with a reference to the variable that <code class="prettyprint">Increment</code> was called on, never a boxed copy.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">interface</span> <span class="n">ICounter</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Increment</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Counter</span><span class="p">:</span> <span class="n">ICounter</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">ICounter</span><span class="p">.</span><span class="nf">Increment</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">value</span><span class="p">++;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="n">Test</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">ICounter</span><span class="p">,</span> <span class="k">new</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">x</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">T</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span><span class="p">.</span><span class="nf">Increment</span><span class="p">();</span>                    <span class="c1">// Modify x</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">((</span><span class="n">ICounter</span><span class="p">)</span><span class="n">x</span><span class="p">).</span><span class="nf">Increment</span><span class="p">();</span>        <span class="c1">// Modify boxed copy of x</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Test</span><span class="p">&lt;</span><span class="n">Counter</span><span class="p">&gt;();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The first call to <code class="prettyprint">Increment</code> modifies the value in the variable <code class="prettyprint">x</code>. This is not equivalent to the second call to <code class="prettyprint">Increment</code>, which modifies the value in a boxed copy of <code class="prettyprint">x</code>. Thus, the output of the program is:
<code class="prettyprint">
0
1
1
</code></p>

<p>For further details on boxing and unboxing, see <a href="types.md#boxing-and-unboxing">Boxing and unboxing</a>.</p>

<h3 id="meaning-of-this">Meaning of this</h3>

<p>Within an instance constructor or instance function member of a class, <code class="prettyprint">this</code> is classified as a value. Thus, while <code class="prettyprint">this</code> can be used to refer to the instance for which the function member was invoked, it is not possible to assign to <code class="prettyprint">this</code> in a function member of a class.</p>

<p>Within an instance constructor of a struct, <code class="prettyprint">this</code> corresponds to an <code class="prettyprint">out</code> parameter of the struct type, and within an instance function member of a struct, <code class="prettyprint">this</code> corresponds to a <code class="prettyprint">ref</code> parameter of the struct type. In both cases, <code class="prettyprint">this</code> is classified as a variable, and it is possible to modify the entire struct for which the function member was invoked by assigning to <code class="prettyprint">this</code> or by passing this as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</p>

<h3 id="field-initializers">Field initializers</h3>

<p>As described in <a href="structs.md#default-values">Default values</a>, the default value of a struct consists of the value that results from setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code>. For this reason, a struct does not permit instance field declarations to include variable initializers. This restriction applies only to instance fields. Static fields of a struct are permitted to include variable initializers.</p>

<p>The example
<code class="prettyprint">csharp
struct Point
{
    public int x = 1;  // Error, initializer not permitted
    public int y = 1;  // Error, initializer not permitted
}
</code>
is in error because the instance field declarations include variable initializers.</p>

<h3 id="constructors">Constructors</h3>

<p>Unlike a class, a struct is not permitted to declare a parameterless instance constructor. Instead, every struct implicitly has a parameterless instance constructor which always returns the value that results from setting all value type fields to their default value and all reference type fields to null (<a href="types.md#default-constructors">Default constructors</a>). A struct can declare instance constructors having parameters. For example
&ldquo;`csharp
struct Point
{
    int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
&rdquo;`</p>

<p>Given the above declaration, the statements
<code class="prettyprint">csharp
Point p1 = new Point();
Point p2 = new Point(0, 0);
</code>
both create a <code class="prettyprint">Point</code> with <code class="prettyprint">x</code> and <code class="prettyprint">y</code> initialized to zero.</p>

<p>A struct instance constructor is not permitted to include a constructor initializer of the form <code class="prettyprint">base(...)</code>.</p>

<p>If the struct instance constructor doesn&rsquo;t specify a constructor initializer, the <code class="prettyprint">this</code> variable corresponds to an <code class="prettyprint">out</code> parameter of the struct type, and similar to an <code class="prettyprint">out</code> parameter, <code class="prettyprint">this</code> must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) at every location where the constructor returns. If the struct instance constructor specifies a constructor initializer, the <code class="prettyprint">this</code> variable corresponds to a <code class="prettyprint">ref</code> parameter of the struct type, and similar to a <code class="prettyprint">ref</code> parameter, <code class="prettyprint">this</code> is considered definitely assigned on entry to the constructor body. Consider the instance constructor implementation below:
&ldquo;`csharp
struct Point
{
    int x, y;</p>

<p>public int X {
        set { x = value; }
    }</p>

<p>public int Y {
        set { y = value; }
    }</p>

<p>public Point(int x, int y) {
        X = x;        // error, this is not yet definitely assigned
        Y = y;        // error, this is not yet definitely assigned
    }
}
&rdquo;`</p>

<p>No instance member function (including the set accessors for the properties <code class="prettyprint">X</code> and <code class="prettyprint">Y</code>) can be called until all fields of the struct being constructed have been definitely assigned. The only exception involves automatically implemented properties (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>). The definite assignment rules (<a href="variables.md#simple-assignment-expressions">Simple assignment expressions</a>) specifically exempt assignment to an auto-property of a struct type within an instance constructor of that struct type: such an assignment is considered a definite assignment of the hidden backing field of the auto-property. Thus, the following is allowed:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">struct</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">X</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// allowed, definitely assigns backing field</span>
        <span class="n">Y</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>      <span class="c1">// allowed, definitely assigns backing field</span>
    <span class="p">}</span>
</code></pre>
<h3 id="destructors">Destructors</h3>

<p>A struct is not permitted to declare a destructor.</p>

<h3 id="static-constructors">Static constructors</h3>

<p>Static constructors for structs follow most of the same rules as for classes. The execution of a static constructor for a struct type is triggered by the first of the following events to occur within an application domain:</p>

<ul>
<li> A static member of the struct type is referenced.</li>
<li> An explicitly declared constructor of the struct type is called.</li>
</ul>

<p>The creation of default values (<a href="structs.md#default-values">Default values</a>) of struct types does not trigger the static constructor. (An example of this is the initial value of elements in an array.)</p>

<h2 id="struct-examples">Struct examples</h2>

<p>The following shows two significant examples of using <code class="prettyprint">struct</code> types to create types that can be used similarly to the predefined types of the language, but with modified semantics.</p>

<h3 id="database-integer-type">Database integer type</h3>

<p>The <code class="prettyprint">DBInt</code> struct below implements an integer type that can represent the complete set of values of the <code class="prettyprint">int</code> type, plus an additional state that indicates an unknown value. A type with these characteristics is commonly used in databases.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">public</span> <span class="k">struct</span> <span class="nc">DBInt</span>
<span class="p">{</span>
    <span class="c1">// The Null member represents an unknown DBInt value.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DBInt</span> <span class="n">Null</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DBInt</span><span class="p">();</span>

    <span class="c1">// When the defined field is true, this DBInt represents a known value</span>
    <span class="c1">// which is stored in the value field. When the defined field is false,</span>
    <span class="c1">// this DBInt represents an unknown value, and the value field is 0.</span>

    <span class="kt">int</span> <span class="k">value</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">defined</span><span class="p">;</span>

    <span class="c1">// Private instance constructor. Creates a DBInt with a known value.</span>

    <span class="nf">DBInt</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">defined</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// The IsNull property is true if this DBInt represents an unknown value.</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsNull</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="p">!</span><span class="n">defined</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="c1">// The Value property is the known value of this DBInt, or 0 if this</span>
    <span class="c1">// DBInt represents an unknown value.</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="c1">// Implicit conversion from int to DBInt.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">DBInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBInt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Explicit conversion from DBInt to int. Throws an exception if the</span>
    <span class="c1">// given DBInt represents an unknown value.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">x</span><span class="p">.</span><span class="n">defined</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">?</span> <span class="p">-</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">+</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">-</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">*(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">*</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">/(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">/</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBInt</span> <span class="k">operator</span> <span class="p">%(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">%</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">!=</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">&gt;(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">&lt;(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">&gt;=(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;=</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">&lt;=(</span><span class="n">DBInt</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBInt</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span> <span class="p">&amp;&amp;</span> <span class="n">y</span><span class="p">.</span><span class="n">defined</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&lt;=</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">DBBool</span><span class="p">.</span><span class="n">Null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">DBInt</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="n">DBInt</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">DBInt</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">value</span> <span class="p">==</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&amp;&amp;</span> <span class="n">defined</span> <span class="p">==</span> <span class="n">x</span><span class="p">.</span><span class="n">defined</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">defined</span><span class="p">?</span> <span class="k">value</span><span class="p">.</span><span class="nf">ToString</span><span class="p">():</span> <span class="s">"DBInt.Null"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="database-boolean-type">Database boolean type</h3>

<p>The <code class="prettyprint">DBBool</code> struct below implements a three-valued logical type. The possible values of this type are <code class="prettyprint">DBBool.True</code>, <code class="prettyprint">DBBool.False</code>, and <code class="prettyprint">DBBool.Null</code>, where the <code class="prettyprint">Null</code> member indicates an unknown value. Such three-valued logical types are commonly used in databases.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">public</span> <span class="k">struct</span> <span class="nc">DBBool</span>
<span class="p">{</span>
    <span class="c1">// The three possible DBBool values.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DBBool</span> <span class="n">Null</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DBBool</span> <span class="n">False</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(-</span><span class="m">1</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">DBBool</span> <span class="n">True</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

    <span class="c1">// Private field that stores -1, 0, 1 for False, Null, True.</span>

    <span class="kt">sbyte</span> <span class="k">value</span><span class="p">;</span>

    <span class="c1">// Private instance constructor. The value parameter must be -1, 0, or 1.</span>

    <span class="nf">DBBool</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="p">(</span><span class="kt">sbyte</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Properties to examine the value of a DBBool. Return true if this</span>
    <span class="c1">// DBBool has the given value, false otherwise.</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsNull</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">value</span> <span class="p">==</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsFalse</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">value</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsTrue</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">value</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

    <span class="c1">// Implicit conversion from bool to DBBool. Maps true to DBBool.True and</span>
    <span class="c1">// false to DBBool.False.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">DBBool</span><span class="p">(</span><span class="kt">bool</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">?</span> <span class="n">True</span><span class="p">:</span> <span class="n">False</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Explicit conversion from DBBool to bool. Throws an exception if the</span>
    <span class="c1">// given DBBool is Null, otherwise returns true or false.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Equality operator. Returns Null if either operand is Null, otherwise</span>
    <span class="c1">// returns True or False.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBBool</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="m">0</span> <span class="p">||</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Null</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">?</span> <span class="n">True</span><span class="p">:</span> <span class="n">False</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Inequality operator. Returns Null if either operand is Null, otherwise</span>
    <span class="c1">// returns True or False.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBBool</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="m">0</span> <span class="p">||</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Null</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">!=</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">?</span> <span class="n">True</span><span class="p">:</span> <span class="n">False</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Logical negation operator. Returns True if the operand is False, Null</span>
    <span class="c1">// if the operand is Null, or False if the operand is True.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">!(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(-</span><span class="n">x</span><span class="p">.</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Logical AND operator. Returns False if either operand is False,</span>
    <span class="c1">// otherwise Null if either operand is Null, otherwise True.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">&amp;(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBBool</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Logical OR operator. Returns True if either operand is True, otherwise</span>
    <span class="c1">// Null if either operand is Null, otherwise False.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">DBBool</span> <span class="k">operator</span> <span class="p">|(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">,</span> <span class="n">DBBool</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBBool</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">?</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span><span class="p">:</span> <span class="n">y</span><span class="p">.</span><span class="k">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Definitely true operator. Returns true if the operand is True, false</span>
    <span class="c1">// otherwise.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="k">true</span><span class="p">(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Definitely false operator. Returns true if the operand is False, false</span>
    <span class="c1">// otherwise.</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="k">false</span><span class="p">(</span><span class="n">DBBool</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="k">value</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Equals</span><span class="p">(</span><span class="kt">object</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">DBBool</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">value</span> <span class="p">==</span> <span class="p">((</span><span class="n">DBBool</span><span class="p">)</span><span class="n">obj</span><span class="p">).</span><span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">int</span> <span class="nf">GetHashCode</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"DBBool.True"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"DBBool.False"</span><span class="p">;</span>
        <span class="k">return</span> <span class="s">"DBBool.Null"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
          <h1 id="arrays">Arrays</h1>

<p>An array is a data structure that contains a number of variables which are accessed through computed indices. The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</p>

<p>An array has a rank which determines the number of indices associated with each array element. The rank of an array is also referred to as the dimensions of the array. An array with a rank of one is called a <strong><em>single-dimensional array</em></strong>. An array with a rank greater than one is called a <strong><em>multi-dimensional array</em></strong>. Specific sized multi-dimensional arrays are often referred to as two-dimensional arrays, three-dimensional arrays, and so on.</p>

<p>Each dimension of an array has an associated length which is an integral number greater than or equal to zero. The dimension lengths are not part of the type of the array, but rather are established when an instance of the array type is created at run-time. The length of a dimension determines the valid range of indices for that dimension: For a dimension of length <code class="prettyprint">N</code>, indices can range from <code class="prettyprint">0</code> to <code class="prettyprint">N - 1</code> inclusive. The total number of elements in an array is the product of the lengths of each dimension in the array. If one or more of the dimensions of an array have a length of zero, the array is said to be empty.</p>

<p>The element type of an array can be any type, including an array type.</p>

<h2 id="array-types">Array types</h2>

<p>An array type is written as a <em>non_array_type</em> followed by one or more *rank_specifier*s:</p>
<pre class="highlight shell"><code>
array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : <span class="nb">type</span>
    ;

rank_specifier
    : <span class="s1">'['</span> dim_separator<span class="k">*</span> <span class="s1">']'</span>
    ;

dim_separator
    : <span class="s1">','</span>
    ;
</code></pre>
<p>A <em>non_array_type</em> is any <em>type</em> that is not itself an <em>array_type</em>.</p>

<p>The rank of an array type is given by the leftmost <em>rank_specifier</em> in the <em>array_type</em>: A <em>rank_specifier</em> indicates that the array is an array with a rank of one plus the number of &ldquo;<code class="prettyprint">,</code>&rdquo; tokens in the <em>rank_specifier</em>.</p>

<p>The element type of an array type is the type that results from deleting the leftmost <em>rank_specifier</em>:</p>

<ul>
<li> An array type of the form <code class="prettyprint">T[R]</code> is an array with rank <code class="prettyprint">R</code> and a non-array element type <code class="prettyprint">T</code>.</li>
<li> An array type of the form <code class="prettyprint">T[R][R1]...[Rn]</code> is an array with rank <code class="prettyprint">R</code> and an element type <code class="prettyprint">T[R1]...[Rn]</code>.</li>
</ul>

<p>In effect, the *rank_specifier*s are read from left to right before the final non-array element type. The type <code class="prettyprint">int[][,,][,]</code> is a single-dimensional array of three-dimensional arrays of two-dimensional arrays of <code class="prettyprint">int</code>.</p>

<p>At run-time, a value of an array type can be <code class="prettyprint">null</code> or a reference to an instance of that array type.</p>

<h3 id="the-system-array-type">The System.Array type</h3>

<p>The type <code class="prettyprint">System.Array</code> is the abstract base type of all array types. An implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from any array type to <code class="prettyprint">System.Array</code>, and an explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from <code class="prettyprint">System.Array</code> to any array type. Note that <code class="prettyprint">System.Array</code> is not itself an <em>array_type</em>. Rather, it is a <em>class_type</em> from which all *array_type*s are derived.</p>

<p>At run-time, a value of type <code class="prettyprint">System.Array</code> can be <code class="prettyprint">null</code> or a reference to an instance of any array type.</p>

<h3 id="arrays-and-the-generic-ilist-interface">Arrays and the generic IList interface</h3>

<p>A one-dimensional array <code class="prettyprint">T[]</code> implements the interface <code class="prettyprint">System.Collections.Generic.IList&lt;T&gt;</code> (<code class="prettyprint">IList&lt;T&gt;</code> for short) and its base interfaces. Accordingly, there is an implicit conversion from <code class="prettyprint">T[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces. In addition, if there is an implicit reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> then <code class="prettyprint">S[]</code> implements <code class="prettyprint">IList&lt;T&gt;</code> and there is an implicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>). If there is an explicit reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> then there is an explicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>). For example: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">string</span><span class="p">[]</span> <span class="n">sa</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[</span><span class="m">5</span><span class="p">];</span>
        <span class="kt">object</span><span class="p">[]</span> <span class="n">oa1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[</span><span class="m">5</span><span class="p">];</span>
        <span class="kt">object</span><span class="p">[]</span> <span class="n">oa2</span> <span class="p">=</span> <span class="n">sa</span><span class="p">;</span>

        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">lst1</span> <span class="p">=</span> <span class="n">sa</span><span class="p">;</span>                    <span class="c1">// Ok</span>
        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">lst2</span> <span class="p">=</span> <span class="n">oa1</span><span class="p">;</span>                   <span class="c1">// Error, cast needed</span>
        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">lst3</span> <span class="p">=</span> <span class="n">sa</span><span class="p">;</span>                    <span class="c1">// Ok</span>
        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">lst4</span> <span class="p">=</span> <span class="n">oa1</span><span class="p">;</span>                   <span class="c1">// Ok</span>

        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">lst5</span> <span class="p">=</span> <span class="p">(</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;)</span><span class="n">oa1</span><span class="p">;</span>    <span class="c1">// Exception</span>
        <span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">lst6</span> <span class="p">=</span> <span class="p">(</span><span class="n">IList</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;)</span><span class="n">oa2</span><span class="p">;</span>    <span class="c1">// Ok</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The assignment <code class="prettyprint">lst2 = oa1</code> generates a compile-time error since the conversion from <code class="prettyprint">object[]</code> to <code class="prettyprint">IList&lt;string&gt;</code> is an explicit conversion, not implicit. The cast <code class="prettyprint">(IList&lt;string&gt;)oa1</code> will cause an exception to be thrown at run-time since <code class="prettyprint">oa1</code> references an <code class="prettyprint">object[]</code> and not a <code class="prettyprint">string[]</code>. However the cast <code class="prettyprint">(IList&lt;string&gt;)oa2</code> will not cause an exception to be thrown since <code class="prettyprint">oa2</code> references a <code class="prettyprint">string[]</code>.</p>

<p>Whenever there is an implicit or explicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code>, there is also an explicit reference conversion from <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces to <code class="prettyprint">S[]</code> (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>).</p>

<p>When an array type <code class="prettyprint">S[]</code> implements <code class="prettyprint">IList&lt;T&gt;</code>, some of the members of the implemented interface may throw exceptions. The precise behavior of the implementation of the interface is beyond the scope of this specification.</p>

<h2 id="array-creation">Array creation</h2>

<p>Array instances are created by <em>array_creation_expression*s (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) or by field or local variable declarations that include an *array_initializer</em> (<a href="arrays.md#array-initializers">Array initializers</a>).</p>

<p>When an array instance is created, the rank and length of each dimension are established and then remain constant for the entire lifetime of the instance. In other words, it is not possible to change the rank of an existing array instance, nor is it possible to resize its dimensions.</p>

<p>An array instance is always of an array type. The <code class="prettyprint">System.Array</code> type is an abstract type that cannot be instantiated.</p>

<p>Elements of arrays created by *array_creation_expression*s are always initialized to their default value (<a href="variables.md#default-values">Default values</a>).</p>

<h2 id="array-element-access">Array element access</h2>

<p>Array elements are accessed using <em>element_access</em> expressions (<a href="expressions.md#array-access">Array access</a>) of the form <code class="prettyprint">A[I1, I2, ..., In]</code>, where <code class="prettyprint">A</code> is an expression of an array type and each <code class="prettyprint">Ix</code> is an expression of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, or can be implicitly converted to one or more of these types. The result of an array element access is a variable, namely the array element selected by the indices.</p>

<p>The elements of an array can be enumerated using a <code class="prettyprint">foreach</code> statement (<a href="statements.md#the-foreach-statement">The foreach statement</a>).</p>

<h2 id="array-members">Array members</h2>

<p>Every array type inherits the members declared by the <code class="prettyprint">System.Array</code> type.</p>

<h2 id="array-covariance">Array covariance</h2>

<p>For any two <em>reference_type*s <code class="prettyprint">A</code> and <code class="prettyprint">B</code>, if an implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) or explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from <code class="prettyprint">A</code> to <code class="prettyprint">B</code>, then the same reference conversion also exists from the array type <code class="prettyprint">A[R]</code> to the array type <code class="prettyprint">B[R]</code>, where <code class="prettyprint">R</code> is any given *rank_specifier</em> (but the same for both array types). This relationship is known as <strong><em>array covariance</em></strong>. Array covariance in particular means that a value of an array type <code class="prettyprint">A[R]</code> may actually be a reference to an instance of an array type <code class="prettyprint">B[R]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</p>

<p>Because of array covariance, assignments to elements of reference type arrays include a run-time check which ensures that the value being assigned to the array element is actually of a permitted type (<a href="expressions.md#simple-assignment">Simple assignment</a>). For example: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Fill</span><span class="p">(</span><span class="kt">object</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">object</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">index</span> <span class="p">+</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">string</span><span class="p">[]</span> <span class="n">strings</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">string</span><span class="p">[</span><span class="m">100</span><span class="p">];</span>
        <span class="nf">Fill</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="s">"Undefined"</span><span class="p">);</span>
        <span class="nf">Fill</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
        <span class="nf">Fill</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="m">90</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The assignment to <code class="prettyprint">array[i]</code> in the <code class="prettyprint">Fill</code> method implicitly includes a run-time check which ensures that the object referenced by <code class="prettyprint">value</code> is either <code class="prettyprint">null</code> or an instance that is compatible with the actual element type of <code class="prettyprint">array</code>. In <code class="prettyprint">Main</code>, the first two invocations of <code class="prettyprint">Fill</code> succeed, but the third invocation causes a <code class="prettyprint">System.ArrayTypeMismatchException</code> to be thrown upon executing the first assignment to <code class="prettyprint">array[i]</code>. The exception occurs because a boxed <code class="prettyprint">int</code> cannot be stored in a <code class="prettyprint">string</code> array.</p>

<p>Array covariance specifically does not extend to arrays of *value_type*s. For example, no conversion exists that permits an <code class="prettyprint">int[]</code> to be treated as an <code class="prettyprint">object[]</code>.</p>

<h2 id="array-initializers">Array initializers</h2>

<p>Array initializers may be specified in field declarations (<a href="classes.md#fields">Fields</a>), local variable declarations (<a href="statements.md#local-variable-declarations">Local variable declarations</a>), and array creation expressions (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>):</p>
<pre class="highlight shell"><code>
array_initializer
    : <span class="s1">'{'</span> variable_initializer_list? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> variable_initializer_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

variable_initializer_list
    : variable_initializer <span class="o">(</span><span class="s1">','</span> variable_initializer<span class="o">)</span><span class="k">*</span>
    ;

variable_initializer
    : expression
    | array_initializer
    ;
</code></pre>
<p>An array initializer consists of a sequence of variable initializers, enclosed by &ldquo;<code class="prettyprint">{</code>&rdquo; and &ldquo;<code class="prettyprint">}</code>&rdquo; tokens and separated by &ldquo;<code class="prettyprint">,</code>&rdquo; tokens. Each variable initializer is an expression or, in the case of a multi-dimensional array, a nested array initializer.</p>

<p>The context in which an array initializer is used determines the type of the array being initialized. In an array creation expression, the array type immediately precedes the initializer, or is inferred from the expressions in the array initializer. In a field or variable declaration, the array type is the type of the field or variable being declared. When an array initializer is used in a field or variable declaration, such as: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">8</span><span class="p">};</span>
</code></pre>
<p>it is simply shorthand for an equivalent array creation expression: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">8</span><span class="p">};</span>
</code></pre>
<p>For a single-dimensional array, the array initializer must consist of a sequence of expressions that are assignment compatible with the element type of the array. The expressions initialize array elements in increasing order, starting with the element at index zero. The number of expressions in the array initializer determines the length of the array instance being created. For example, the array initializer above creates an <code class="prettyprint">int[]</code> instance of length 5 and then initializes the instance with the following values:
<code class="prettyprint">csharp
a[0] = 0; a[1] = 2; a[2] = 4; a[3] = 6; a[4] = 8;
</code></p>

<p>For a multi-dimensional array, the array initializer must have as many levels of nesting as there are dimensions in the array. The outermost nesting level corresponds to the leftmost dimension and the innermost nesting level corresponds to the rightmost dimension. The length of each dimension of the array is determined by the number of elements at the corresponding nesting level in the array initializer. For each nested array initializer, the number of elements must be the same as the other array initializers at the same level. The example: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">b</span> <span class="p">=</span> <span class="p">{{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">},</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">},</span> <span class="p">{</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">},</span> <span class="p">{</span><span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">},</span> <span class="p">{</span><span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">}};</span>
</code></pre>
<p>creates a two-dimensional array with a length of five for the leftmost dimension and a length of two for the rightmost dimension: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">];</span>
</code></pre>
<p>and then initializes the array instance with the following values:
<code class="prettyprint">csharp
b[0, 0] = 0; b[0, 1] = 1;
b[1, 0] = 2; b[1, 1] = 3;
b[2, 0] = 4; b[2, 1] = 5;
b[3, 0] = 6; b[3, 1] = 7;
b[4, 0] = 8; b[4, 1] = 9;
</code></p>

<p>If a dimension other than the rightmost is given with length zero, the subsequent dimensions are assumed to also have length zero. The example: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">c</span> <span class="p">=</span> <span class="p">{};</span>
</code></pre>
<p>creates a two-dimensional array with a length of zero for both the leftmost and the rightmost dimension: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">c</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">];</span>
</code></pre>
<p>When an array creation expression includes both explicit dimension lengths and an array initializer, the lengths must be constant expressions and the number of elements at each nesting level must match the corresponding dimension length. Here are some examples: </p>
<pre class="highlight csharp tab-csharp"><code>
<span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">x</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">};</span>        <span class="c1">// OK</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">y</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">};</span>        <span class="c1">// Error, i not a constant</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">z</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>     <span class="c1">// Error, length/initializer mismatch</span>
</code></pre>
<p>Here, the initializer for <code class="prettyprint">y</code> results in a compile-time error because the dimension length expression is not a constant, and the initializer for <code class="prettyprint">z</code> results in a compile-time error because the length and the number of elements in the initializer do not agree.</p>

          <h1 id="interfaces">Interfaces</h1>

<p>An interface defines a contract. A class or struct that implements an interface must adhere to its contract. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</p>

<p>Interfaces can contain methods, properties, events, and indexers. The interface itself does not provide implementations for the members that it defines. The interface merely specifies the members that must be supplied by classes or structs that implement the interface.</p>

<h2 id="interface-declarations">Interface declarations</h2>

<p>An <em>interface_declaration</em> is a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>) that declares a new interface type.</p>
<pre class="highlight plaintext"><code>interface_declaration
    : attributes? interface_modifier* 'partial'? 'interface'
      identifier variant_type_parameter_list? interface_base?
      type_parameter_constraints_clause* interface_body ';'?
    ;
</code></pre>
<p>An <em>interface_declaration</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), followed by an optional set of <em>interface_modifier*s (<a href="interfaces.md#interface-modifiers">Interface modifiers</a>), followed by an optional <code class="prettyprint">partial</code> modifier, followed by the keyword <code class="prettyprint">interface</code> and an *identifier</em> that names the interface, followed by an optional <em>variant_type_parameter_list</em> specification (<a href="interfaces.md#variant-type-parameter-lists">Variant type parameter lists</a>), followed by an optional <em>interface_base</em> specification (<a href="interfaces.md#base-interfaces">Base interfaces</a>), followed by an optional <em>type_parameter_constraints_clause*s specification (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), followed by an *interface_body</em> (<a href="interfaces.md#interface-body">Interface body</a>), optionally followed by a semicolon.</p>

<h3 id="interface-modifiers">Interface modifiers</h3>

<p>An <em>interface_declaration</em> may optionally include a sequence of interface modifiers:</p>
<pre class="highlight plaintext"><code>interface_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | interface_modifier_unsafe
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in an interface declaration.</p>

<p>The <code class="prettyprint">new</code> modifier is only permitted on interfaces defined within a class. It specifies that the interface hides an inherited member by the same name, as described in <a href="classes.md#the-new-modifier">The new modifier</a>.</p>

<p>The <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers control the accessibility of the interface. Depending on the context in which the interface declaration occurs, only some of these modifiers may be permitted (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<h3 id="partial-modifier">Partial modifier</h3>

<p>The <code class="prettyprint">partial</code> modifier indicates that this <em>interface_declaration</em> is a partial type declaration. Multiple partial interface declarations with the same name within an enclosing namespace or type declaration combine to form one interface declaration, following the rules specified in <a href="classes.md#partial-types">Partial types</a>.</p>

<h3 id="variant-type-parameter-lists">Variant type parameter lists</h3>

<p>Variant type parameter lists can only occur on interface and delegate types. The difference from ordinary <em>type_parameter_list*s is the optional *variance_annotation</em> on each type parameter.</p>
<pre class="highlight plaintext"><code>variant_type_parameter_list
    : '&lt;' variant_type_parameters '&gt;'
    ;

variant_type_parameters
    : attributes? variance_annotation? type_parameter
    | variant_type_parameters ',' attributes? variance_annotation? type_parameter
    ;

variance_annotation
    : 'in'
    | 'out'
    ;
</code></pre>
<p>If the variance annotation is <code class="prettyprint">out</code>, the type parameter is said to be <strong><em>covariant</em></strong>. If the variance annotation is <code class="prettyprint">in</code>, the type parameter is said to be <strong><em>contravariant</em></strong>. If there is no variance annotation, the type parameter is said to be <strong><em>invariant</em></strong>.</p>

<p>In the example
<code class="prettyprint">csharp
interface C&lt;out X, in Y, Z&gt; 
{
  X M(Y y);
  Z P { get; set; }
}
</code>
<code class="prettyprint">X</code> is covariant, <code class="prettyprint">Y</code> is contravariant and <code class="prettyprint">Z</code> is invariant.</p>

<h4 id="variance-safety">Variance safety</h4>

<p>The occurrence of variance annotations in the type parameter list of a type restricts the places where types can occur within the type declaration.</p>

<p>A type <code class="prettyprint">T</code> is <strong><em>output-unsafe</em></strong> if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">T</code> is a contravariant type parameter</li>
<li> <code class="prettyprint">T</code> is an array type with an output-unsafe element type</li>
<li> <code class="prettyprint">T</code> is an interface or delegate type <code class="prettyprint">S&lt;A1,...,Ak&gt;</code> constructed from a generic type <code class="prettyprint">S&lt;X1,...,Xk&gt;</code> where for at least one <code class="prettyprint">Ai</code> one of the following holds:

<ul>
<li><code class="prettyprint">Xi</code> is covariant or invariant and <code class="prettyprint">Ai</code> is output-unsafe.</li>
<li><code class="prettyprint">Xi</code> is contravariant or invariant and <code class="prettyprint">Ai</code> is input-safe.</li>
</ul></li>
</ul>

<p>A type <code class="prettyprint">T</code> is <strong><em>input-unsafe</em></strong> if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">T</code> is a covariant type parameter</li>
<li> <code class="prettyprint">T</code> is an array type with an input-unsafe element type</li>
<li> <code class="prettyprint">T</code> is an interface or delegate type <code class="prettyprint">S&lt;A1,...,Ak&gt;</code> constructed from a generic type <code class="prettyprint">S&lt;X1,...,Xk&gt;</code> where for at least one <code class="prettyprint">Ai</code> one of the following holds:

<ul>
<li><code class="prettyprint">Xi</code> is covariant or invariant and <code class="prettyprint">Ai</code> is input-unsafe.</li>
<li><code class="prettyprint">Xi</code> is contravariant or invariant and <code class="prettyprint">Ai</code> is output-unsafe.</li>
</ul></li>
</ul>

<p>Intuitively, an output-unsafe type is prohibited in an output position, and an input-unsafe type is prohibited in an input position.</p>

<p>A type is <strong><em>output-safe</em></strong> if it is not output-unsafe, and <strong><em>input-safe</em></strong> if it is not input-unsafe.</p>

<h4 id="variance-conversion">Variance conversion</h4>

<p>The purpose of variance annotations is to provide for more lenient (but still type safe) conversions to interface and delegate types. To this end the definitions of implicit (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) and explicit conversions (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) make use of the notion of variance-convertibility, which is defined as follows:</p>

<p>A type <code class="prettyprint">T&lt;A1,...,An&gt;</code> is variance-convertible to a type <code class="prettyprint">T&lt;B1,...,Bn&gt;</code> if <code class="prettyprint">T</code> is either an interface or a delegate type declared with the variant type parameters <code class="prettyprint">T&lt;X1,...,Xn&gt;</code>, and for each variant type parameter <code class="prettyprint">Xi</code> one of the following holds:</p>

<ul>
<li> <code class="prettyprint">Xi</code> is covariant and an implicit reference or identity conversion exists from <code class="prettyprint">Ai</code> to <code class="prettyprint">Bi</code></li>
<li> <code class="prettyprint">Xi</code> is contravariant and an implicit reference or identity conversion exists from <code class="prettyprint">Bi</code> to <code class="prettyprint">Ai</code></li>
<li> <code class="prettyprint">Xi</code> is invariant and an identity conversion exists from <code class="prettyprint">Ai</code> to <code class="prettyprint">Bi</code></li>
</ul>

<h3 id="base-interfaces">Base interfaces</h3>

<p>An interface can inherit from zero or more interface types, which are called the <strong><em>explicit base interfaces</em></strong> of the interface. When an interface has one or more explicit base interfaces, then in the declaration of that interface, the interface identifier is followed by a colon and a comma separated list of base interface types.</p>
<pre class="highlight plaintext"><code>interface_base
    : ':' interface_type_list
    ;
</code></pre>
<p>For a constructed interface type, the explicit base interfaces are formed by taking the explicit base interface declarations on the generic type declaration, and substituting, for each <em>type_parameter</em> in the base interface declaration, the corresponding <em>type_argument</em> of the constructed type.</p>

<p>The explicit base interfaces of an interface must be at least as accessible as the interface itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>). For example, it is a compile-time error to specify a <code class="prettyprint">private</code> or <code class="prettyprint">internal</code> interface in the <em>interface_base</em> of a <code class="prettyprint">public</code> interface.</p>

<p>It is a compile-time error for an interface to directly or indirectly inherit from itself.</p>

<p>The <strong><em>base interfaces</em></strong> of an interface are the explicit base interfaces and their base interfaces. In other words, the set of base interfaces is the complete transitive closure of the explicit base interfaces, their explicit base interfaces, and so on. An interface inherits all members of its base interfaces. In the example
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface ITextBox: IControl
{
    void SetText(string text);
}</p>

<p>interface IListBox: IControl
{
    void SetItems(string[] items);
}</p>

<p>interface IComboBox: ITextBox, IListBox {}
&rdquo;<code class="prettyprint">
the base interfaces of</code>IComboBox<code class="prettyprint">are</code>IControl<code class="prettyprint">,</code>ITextBox<code class="prettyprint">, and</code>IListBox`.</p>

<p>In other words, the <code class="prettyprint">IComboBox</code> interface above inherits members <code class="prettyprint">SetText</code> and <code class="prettyprint">SetItems</code> as well as <code class="prettyprint">Paint</code>.</p>

<p>Every base interface of an interface must be output-safe (<a href="interfaces.md#variance-safety">Variance safety</a>). A class or struct that implements an interface also implicitly implements all of the interface&rsquo;s base interfaces.</p>

<h3 id="interface-body">Interface body</h3>

<p>The <em>interface_body</em> of an interface defines the members of the interface.</p>
<pre class="highlight plaintext"><code>interface_body
    : '{' interface_member_declaration* '}'
    ;
</code></pre>
<h2 id="interface-members">Interface members</h2>

<p>The members of an interface are the members inherited from the base interfaces and the members declared by the interface itself.</p>
<pre class="highlight plaintext"><code>interface_member_declaration
    : interface_method_declaration
    | interface_property_declaration
    | interface_event_declaration
    | interface_indexer_declaration
    ;
</code></pre>
<p>An interface declaration may declare zero or more members. The members of an interface must be methods, properties, events, or indexers. An interface cannot contain constants, fields, operators, instance constructors, destructors, or types, nor can an interface contain static members of any kind.</p>

<p>All interface members implicitly have public access. It is a compile-time error for interface member declarations to include any modifiers. In particular, interfaces members cannot be declared with the modifiers <code class="prettyprint">abstract</code>, <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, <code class="prettyprint">private</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, or <code class="prettyprint">static</code>.</p>

<p>The example
&ldquo;`csharp
public delegate void StringListEvent(IStringList sender);</p>

<p>public interface IStringList
{
    void Add(string s);
    int Count { get; }
    event StringListEvent Changed;
    string this[int index] { get; set; }
}
&rdquo;`
declares an interface that contains one each of the possible kinds of members: A method, a property, an event, and an indexer.</p>

<p>An <em>interface_declaration</em> creates a new declaration space (<a href="basic-concepts.md#declarations">Declarations</a>), and the <em>interface_member_declaration*s immediately contained by the *interface_declaration</em> introduce new members into this declaration space. The following rules apply to *interface_member_declaration*s:</p>

<ul>
<li> The name of a method must differ from the names of all properties and events declared in the same interface. In addition, the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of a method must differ from the signatures of all other methods declared in the same interface, and two methods declared in the same interface may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</li>
<li> The name of a property or event must differ from the names of all other members declared in the same interface.</li>
<li> The signature of an indexer must differ from the signatures of all other indexers declared in the same interface.</li>
</ul>

<p>The inherited members of an interface are specifically not part of the declaration space of the interface. Thus, an interface is allowed to declare a member with the same name or signature as an inherited member. When this occurs, the derived interface member is said to hide the base interface member. Hiding an inherited member is not considered an error, but it does cause the compiler to issue a warning. To suppress the warning, the declaration of the derived interface member must include a <code class="prettyprint">new</code> modifier to indicate that the derived member is intended to hide the base member. This topic is discussed further in <a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>.</p>

<p>If a <code class="prettyprint">new</code> modifier is included in a declaration that doesn&rsquo;t hide an inherited member, a warning is issued to that effect. This warning is suppressed by removing the <code class="prettyprint">new</code> modifier.</p>

<p>Note that the members in class <code class="prettyprint">object</code> are not, strictly speaking, members of any interface (<a href="interfaces.md#interface-members">Interface members</a>). However, the members in class <code class="prettyprint">object</code> are available via member lookup in any interface type (<a href="expressions.md#member-lookup">Member lookup</a>).</p>

<h3 id="interface-methods">Interface methods</h3>

<p>Interface methods are declared using *interface_method_declaration*s:</p>
<pre class="highlight plaintext"><code>interface_method_declaration
    : attributes? 'new'? return_type identifier type_parameter_list
      '(' formal_parameter_list? ')' type_parameter_constraints_clause* ';'
    ;
</code></pre>
<p>The <em>attributes</em>, <em>return_type</em>, <em>identifier</em>, and <em>formal_parameter_list</em> of an interface method declaration have the same meaning as those of a method declaration in a class (<a href="classes.md#methods">Methods</a>). An interface method declaration is not permitted to specify a method body, and the declaration therefore always ends with a semicolon.</p>

<p>Each formal parameter type of an interface method must be input-safe (<a href="interfaces.md#variance-safety">Variance safety</a>), and the return type must be either <code class="prettyprint">void</code> or output-safe. Furthermore, each class type constraint, interface type constraint and type parameter constraint on any type parameter of the method must be input-safe.</p>

<p>These rules ensure that any covariant or contravariant usage of the interface remains typesafe. For example,
<code class="prettyprint">csharp
interface I&lt;out T&gt; { void M&lt;U&gt;() where U : T; }
</code>
is illegal because the usage of <code class="prettyprint">T</code> as a type parameter constraint on <code class="prettyprint">U</code> is not input-safe.</p>

<p>Were this restriction not in place it would be possible to violate type safety in the following manner:
<code class="prettyprint">csharp
class B {}
class D : B{}
class E : B {}
class C : I&lt;D&gt; { public void M&lt;U&gt;() {...} }
...
I&lt;B&gt; b = new C();
b.M&lt;E&gt;();
</code>
This is actually a call to <code class="prettyprint">C.M&lt;E&gt;</code>. But that call requires that <code class="prettyprint">E</code> derive from <code class="prettyprint">D</code>, so type safety would be violated here.</p>

<h3 id="interface-properties">Interface properties</h3>

<p>Interface properties are declared using *interface_property_declaration*s:</p>
<pre class="highlight plaintext"><code>interface_property_declaration
    : attributes? 'new'? type identifier '{' interface_accessors '}'
    ;

interface_accessors
    : attributes? 'get' ';'
    | attributes? 'set' ';'
    | attributes? 'get' ';' attributes? 'set' ';'
    | attributes? 'set' ';' attributes? 'get' ';'
    ;
</code></pre>
<p>The <em>attributes</em>, <em>type</em>, and <em>identifier</em> of an interface property declaration have the same meaning as those of a property declaration in a class (<a href="classes.md#properties">Properties</a>).</p>

<p>The accessors of an interface property declaration correspond to the accessors of a class property declaration (<a href="classes.md#accessors">Accessors</a>), except that the accessor body must always be a semicolon. Thus, the accessors simply indicate whether the property is read-write, read-only, or write-only.</p>

<p>The type of an interface property must be output-safe if there is a get accessor, and must be input-safe if there is a set accessor.</p>

<h3 id="interface-events">Interface events</h3>

<p>Interface events are declared using *interface_event_declaration*s:</p>
<pre class="highlight plaintext"><code>interface_event_declaration
    : attributes? 'new'? 'event' type identifier ';'
    ;
</code></pre>
<p>The <em>attributes</em>, <em>type</em>, and <em>identifier</em> of an interface event declaration have the same meaning as those of an event declaration in a class (<a href="classes.md#events">Events</a>).</p>

<p>The type of an interface event must be input-safe.</p>

<h3 id="interface-indexers">Interface indexers</h3>

<p>Interface indexers are declared using *interface_indexer_declaration*s:</p>
<pre class="highlight plaintext"><code>interface_indexer_declaration
    : attributes? 'new'? type 'this' '[' formal_parameter_list ']' '{' interface_accessors '}'
    ;
</code></pre>
<p>The <em>attributes</em>, <em>type</em>, and <em>formal_parameter_list</em> of an interface indexer declaration have the same meaning as those of an indexer declaration in a class (<a href="classes.md#indexers">Indexers</a>).</p>

<p>The accessors of an interface indexer declaration correspond to the accessors of a class indexer declaration (<a href="classes.md#indexers">Indexers</a>), except that the accessor body must always be a semicolon. Thus, the accessors simply indicate whether the indexer is read-write, read-only, or write-only.</p>

<p>All the formal parameter types of an interface indexer must be input-safe . In addition, any <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> formal parameter types must also be output-safe. Note that even <code class="prettyprint">out</code> parameters are required to be input-safe, due to a limitiation of the underlying execution platform.</p>

<p>The type of an interface indexer must be output-safe if there is a get accessor, and must be input-safe if there is a set accessor.</p>

<h3 id="interface-member-access">Interface member access</h3>

<p>Interface members are accessed through member access (<a href="expressions.md#member-access">Member access</a>) and indexer access (<a href="expressions.md#indexer-access">Indexer access</a>) expressions of the form <code class="prettyprint">I.M</code> and <code class="prettyprint">I[A]</code>, where <code class="prettyprint">I</code> is an interface type, <code class="prettyprint">M</code> is a method, property, or event of that interface type, and <code class="prettyprint">A</code> is an indexer argument list.</p>

<p>For interfaces that are strictly single-inheritance (each interface in the inheritance chain has exactly zero or one direct base interface), the effects of the member lookup (<a href="expressions.md#member-lookup">Member lookup</a>), method invocation (<a href="expressions.md#method-invocations">Method invocations</a>), and indexer access (<a href="expressions.md#indexer-access">Indexer access</a>) rules are exactly the same as for classes and structs: More derived members hide less derived members with the same name or signature. However, for multiple-inheritance interfaces, ambiguities can occur when two or more unrelated base interfaces declare members with the same name or signature. This section shows several examples of such situations. In all cases, explicit casts can be used to resolve the ambiguities.</p>

<p>In the example
&ldquo;`csharp
interface IList
{
    int Count { get; set; }
}</p>

<p>interface ICounter
{
    void Count(int i);
}</p>

<p>interface IListCounter: IList, ICounter {}</p>

<p>class C
{
    void Test(IListCounter x) {
        x.Count(1);                  // Error
        x.Count = 1;                 // Error
        ((IList)x).Count = 1;        // Ok, invokes IList.Count.set
        ((ICounter)x).Count(1);      // Ok, invokes ICounter.Count
    }
}
&rdquo;<code class="prettyprint">
the first two statements cause compile-time errors because the member lookup ([Member lookup](expressions.md#member-lookup)) of</code>Count<code class="prettyprint">in</code>IListCounter<code class="prettyprint">is ambiguous. As illustrated by the example, the ambiguity is resolved by casting</code>x` to the appropriate base interface type. Such casts have no run-time costsâ€”they merely consist of viewing the instance as a less derived type at compile-time.</p>

<p>In the example
&ldquo;`csharp
interface IInteger
{
    void Add(int i);
}</p>

<p>interface IDouble
{
    void Add(double d);
}</p>

<p>interface INumber: IInteger, IDouble {}</p>

<p>class C
{
    void Test(INumber n) {
        n.Add(1);                // Invokes IInteger.Add
        n.Add(1.0);              // Only IDouble.Add is applicable
        ((IInteger)n).Add(1);    // Only IInteger.Add is a candidate
        ((IDouble)n).Add(1);     // Only IDouble.Add is a candidate
    }
}
&rdquo;<code class="prettyprint">
the invocation</code>n.Add(1)<code class="prettyprint">selects</code>IInteger.Add<code class="prettyprint">by applying the overload resolution rules of [Overload resolution](expressions.md#overload-resolution). Similarly the invocation</code>n.Add(1.0)<code class="prettyprint">selects</code>IDouble.Add`. When explicit casts are inserted, there is only one candidate method, and thus no ambiguity.</p>

<p>In the example
&ldquo;`csharp
interface IBase
{
    void F(int i);
}</p>

<p>interface ILeft: IBase
{
    new void F(int i);
}</p>

<p>interface IRight: IBase
{
    void G();
}</p>

<p>interface IDerived: ILeft, IRight {}</p>

<p>class A
{
    void Test(IDerived d) {
        d.F(1);                 // Invokes ILeft.F
        ((IBase)d).F(1);        // Invokes IBase.F
        ((ILeft)d).F(1);        // Invokes ILeft.F
        ((IRight)d).F(1);       // Invokes IBase.F
    }
}
&rdquo;<code class="prettyprint">
the</code>IBase.F<code class="prettyprint">member is hidden by the</code>ILeft.F<code class="prettyprint">member. The invocation</code>d.F(1)<code class="prettyprint">thus selects</code>ILeft.F<code class="prettyprint">, even though</code>IBase.F<code class="prettyprint">appears to not be hidden in the access path that leads through</code>IRight`.</p>

<p>The intuitive rule for hiding in multiple-inheritance interfaces is simply this: If a member is hidden in any access path, it is hidden in all access paths. Because the access path from <code class="prettyprint">IDerived</code> to <code class="prettyprint">ILeft</code> to <code class="prettyprint">IBase</code> hides <code class="prettyprint">IBase.F</code>, the member is also hidden in the access path from <code class="prettyprint">IDerived</code> to <code class="prettyprint">IRight</code> to <code class="prettyprint">IBase</code>.</p>

<h2 id="fully-qualified-interface-member-names">Fully qualified interface member names</h2>

<p>An interface member is sometimes referred to by its <strong><em>fully qualified name</em></strong>. The fully qualified name of an interface member consists of the name of the interface in which the member is declared, followed by a dot, followed by the name of the member. The fully qualified name of a member references the interface in which the member is declared. For example, given the declarations
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface ITextBox: IControl
{
    void SetText(string text);
}
&rdquo;<code class="prettyprint">
the fully qualified name of</code>Paint<code class="prettyprint">is</code>IControl.Paint<code class="prettyprint">and the fully qualified name of</code>SetText<code class="prettyprint">is</code>ITextBox.SetText`.</p>

<p>In the example above, it is not possible to refer to <code class="prettyprint">Paint</code> as <code class="prettyprint">ITextBox.Paint</code>.</p>

<p>When an interface is part of a namespace, the fully qualified name of an interface member includes the namespace name. For example
<code class="prettyprint">csharp
namespace System
{
    public interface ICloneable
    {
        object Clone();
    }
}
</code></p>

<p>Here, the fully qualified name of the <code class="prettyprint">Clone</code> method is <code class="prettyprint">System.ICloneable.Clone</code>.</p>

<h2 id="interface-implementations">Interface implementations</h2>

<p>Interfaces may be implemented by classes and structs. To indicate that a class or struct directly implements an interface, the interface identifier is included in the base class list of the class or struct. For example:
&ldquo;`csharp
interface ICloneable
{
    object Clone();
}</p>

<p>interface IComparable
{
    int CompareTo(object other);
}</p>

<p>class ListEntry: ICloneable, IComparable
{
    public object Clone() {&hellip;}
    public int CompareTo(object other) {&hellip;}
}
&rdquo;`</p>

<p>A class or struct that directly implements an interface also directly implements all of the interface&rsquo;s base interfaces implicitly. This is true even if the class or struct doesn&rsquo;t explicitly list all base interfaces in the base class list. For example:
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface ITextBox: IControl
{
    void SetText(string text);
}</p>

<p>class TextBox: ITextBox
{
    public void Paint() {&hellip;}
    public void SetText(string text) {&hellip;}
}
&rdquo;`</p>

<p>Here, class <code class="prettyprint">TextBox</code> implements both <code class="prettyprint">IControl</code> and <code class="prettyprint">ITextBox</code>.</p>

<p>When a class <code class="prettyprint">C</code> directly implements an interface, all classes derived from C also implement the interface implicitly. The base interfaces specified in a class declaration can be constructed interface types (<a href="types.md#constructed-types">Constructed types</a>). A base interface cannot be a type parameter on its own, though it can involve the type parameters that are in scope. The following code illustrates how a class can implement and extend constructed types:
&ldquo;`csharp
class C<U,V> {}</p>

<p>interface I1<V> {}</p>

<p>class D: C<string,int>, I1<string> {}</p>

<p>class E<T>: C<int,T>, I1<T> {}
&rdquo;`</p>

<p>The base interfaces of a generic class declaration must satisfy the uniqueness rule described in <a href="interfaces.md#uniqueness-of-implemented-interfaces">Uniqueness of implemented interfaces</a>.</p>

<h3 id="explicit-interface-member-implementations">Explicit interface member implementations</h3>

<p>For purposes of implementing interfaces, a class or struct may declare <strong><em>explicit interface member implementations</em></strong>. An explicit interface member implementation is a method, property, event, or indexer declaration that references a fully qualified interface member name. For example
&ldquo;`csharp
interface IList<T>
{
    T[] GetElements();
}</p>

<p>interface IDictionary<K,V>
{
    V this[K key];
    void Add(K key, V value);
}</p>

<p>class List<T>: IList<T>, IDictionary<int,T>
{
    T[] IList<T>.GetElements() {&hellip;}
    T IDictionary<int,T>.this[int index] {&hellip;}
    void IDictionary<int,T>.Add(int index, T value) {&hellip;}
}
&rdquo;`</p>

<p>Here <code class="prettyprint">IDictionary&lt;int,T&gt;.this</code> and <code class="prettyprint">IDictionary&lt;int,T&gt;.Add</code> are explicit interface member implementations.</p>

<p>In some cases, the name of an interface member may not be appropriate for the implementing class, in which case the interface member may be implemented using explicit interface member implementation. A class implementing a file abstraction, for example, would likely implement a <code class="prettyprint">Close</code> member function that has the effect of releasing the file resource, and implement the <code class="prettyprint">Dispose</code> method of the <code class="prettyprint">IDisposable</code> interface using explicit interface member implementation:
&ldquo;`csharp
interface IDisposable
{
    void Dispose();
}</p>

<p>class MyFile: IDisposable
{
    void IDisposable.Dispose() {
        Close();
    }</p>

<p>public void Close() {
        // Do what&rsquo;s necessary to close the file
        System.GC.SuppressFinalize(this);
    }
}
&rdquo;`</p>

<p>It is not possible to access an explicit interface member implementation through its fully qualified name in a method invocation, property access, or indexer access. An explicit interface member implementation can only be accessed through an interface instance, and is in that case referenced simply by its member name.</p>

<p>It is a compile-time error for an explicit interface member implementation to include access modifiers, and it is a compile-time error to include the modifiers <code class="prettyprint">abstract</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, or <code class="prettyprint">static</code>.</p>

<p>Explicit interface member implementations have different accessibility characteristics than other members. Because explicit interface member implementations are never accessible through their fully qualified name in a method invocation or a property access, they are in a sense private. However, since they can be accessed through an interface instance, they are in a sense also public.</p>

<p>Explicit interface member implementations serve two primary purposes:</p>

<ul>
<li> Because explicit interface member implementations are not accessible through class or struct instances, they allow interface implementations to be excluded from the public interface of a class or struct. This is particularly useful when a class or struct implements an internal interface that is of no interest to a consumer of that class or struct.</li>
<li> Explicit interface member implementations allow disambiguation of interface members with the same signature. Without explicit interface member implementations it would be impossible for a class or struct to have different implementations of interface members with the same signature and return type, as would it be impossible for a class or struct to have any implementation at all of interface members with the same signature but with different return types.</li>
</ul>

<p>For an explicit interface member implementation to be valid, the class or struct must name an interface in its base class list that contains a member whose fully qualified name, type, and parameter types exactly match those of the explicit interface member implementation. Thus, in the following class
<code class="prettyprint">csharp
class Shape: ICloneable
{
    object ICloneable.Clone() {...}
    int IComparable.CompareTo(object other) {...}    // invalid
}
</code>
the declaration of <code class="prettyprint">IComparable.CompareTo</code> results in a compile-time error because <code class="prettyprint">IComparable</code> is not listed in the base class list of <code class="prettyprint">Shape</code> and is not a base interface of <code class="prettyprint">ICloneable</code>. Likewise, in the declarations
&ldquo;`csharp
class Shape: ICloneable
{
    object ICloneable.Clone() {&hellip;}
}</p>

<p>class Ellipse: Shape
{
    object ICloneable.Clone() {&hellip;}    // invalid
}
&rdquo;<code class="prettyprint">
the declaration of</code>ICloneable.Clone<code class="prettyprint">in</code>Ellipse<code class="prettyprint">results in a compile-time error because</code>ICloneable<code class="prettyprint">is not explicitly listed in the base class list of</code>Ellipse`.</p>

<p>The fully qualified name of an interface member must reference the interface in which the member was declared. Thus, in the declarations
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface ITextBox: IControl
{
    void SetText(string text);
}</p>

<p>class TextBox: ITextBox
{
    void IControl.Paint() {&hellip;}
    void ITextBox.SetText(string text) {&hellip;}
}
&rdquo;<code class="prettyprint">
the explicit interface member implementation of</code>Paint<code class="prettyprint">must be written as</code>IControl.Paint`.</p>

<h3 id="uniqueness-of-implemented-interfaces">Uniqueness of implemented interfaces</h3>

<p>The interfaces implemented by a generic type declaration must remain unique for all possible constructed types. Without this rule, it would be impossible to determine the correct method to call for certain constructed types. For example, suppose a generic class declaration were permitted to be written as follows:
&ldquo;`csharp
interface I<T>
{
    void F();
}</p>

<p>class X<U,V>: I<U>, I<V>                    // Error: I<U> and I<V> conflict
{
    void I<U>.F() {&hellip;}
    void I<V>.F() {&hellip;}
}
&rdquo;`</p>

<p>Were this permitted, it would be impossible to determine which code to execute in the following case:
<code class="prettyprint">csharp
I&lt;int&gt; x = new X&lt;int,int&gt;();
x.F();
</code></p>

<p>To determine if the interface list of a generic type declaration is valid, the following steps are performed:</p>

<ul>
<li> Let <code class="prettyprint">L</code> be the list of interfaces directly specified in a generic class, struct, or interface declaration <code class="prettyprint">C</code>.</li>
<li> Add to <code class="prettyprint">L</code> any base interfaces of the interfaces already in <code class="prettyprint">L</code>.</li>
<li> Remove any duplicates from <code class="prettyprint">L</code>.</li>
<li> If any possible constructed type created from <code class="prettyprint">C</code> would, after type arguments are substituted into <code class="prettyprint">L</code>, cause two interfaces in <code class="prettyprint">L</code> to be identical, then the declaration of <code class="prettyprint">C</code> is invalid. Constraint declarations are not considered when determining all possible constructed types.</li>
</ul>

<p>In the class declaration <code class="prettyprint">X</code> above, the interface list <code class="prettyprint">L</code> consists of <code class="prettyprint">I&lt;U&gt;</code> and <code class="prettyprint">I&lt;V&gt;</code>. The declaration is invalid because any constructed type with <code class="prettyprint">U</code> and <code class="prettyprint">V</code> being the same type would cause these two interfaces to be identical types.</p>

<p>It is possible for interfaces specified at different inheritance levels to unify:
&ldquo;`csharp
interface I<T>
{
    void F();
}</p>

<p>class Base<U>: I<U>
{
    void I<U>.F() {&hellip;}
}</p>

<p>class Derived<U,V>: Base<U>, I<V>    // Ok
{
    void I<V>.F() {&hellip;}
}
&rdquo;`</p>

<p>This code is valid even though <code class="prettyprint">Derived&lt;U,V&gt;</code> implements both <code class="prettyprint">I&lt;U&gt;</code> and <code class="prettyprint">I&lt;V&gt;</code>. The code
<code class="prettyprint">csharp
I&lt;int&gt; x = new Derived&lt;int,int&gt;();
x.F();
</code>
invokes the method in <code class="prettyprint">Derived</code>, since <code class="prettyprint">Derived&lt;int,int&gt;</code> effectively re-implements <code class="prettyprint">I&lt;int&gt;</code> (<a href="interfaces.md#interface-re-implementation">Interface re-implementation</a>).</p>

<h3 id="implementation-of-generic-methods">Implementation of generic methods</h3>

<p>When a generic method implicitly implements an interface method, the constraints given for each method type parameter must be equivalent in both declarations (after any interface type parameters are replaced with the appropriate type arguments), where method type parameters are identified by ordinal positions, left to right.</p>

<p>When a generic method explicitly implements an interface method, however, no constraints are allowed on the implementing method. Instead, the constraints are inherited from the interface method</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">interface</span> <span class="n">I</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="n">F</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">void</span> <span class="n">G</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">B</span><span class="p">;</span>
    <span class="k">void</span> <span class="n">H</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="n">I</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="n">F</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{...}</span>                    <span class="c1">// Ok</span>
    <span class="k">public</span> <span class="k">void</span> <span class="n">G</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">C</span> <span class="p">{...}</span>         <span class="c1">// Ok</span>
    <span class="k">public</span> <span class="k">void</span> <span class="n">H</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="kt">string</span> <span class="p">{...}</span>    <span class="c1">// Error</span>
<span class="p">}</span>
</code></pre>
<p>The method <code class="prettyprint">C.F&lt;T&gt;</code> implicitly implements <code class="prettyprint">I&lt;object,C,string&gt;.F&lt;T&gt;</code>. In this case, <code class="prettyprint">C.F&lt;T&gt;</code> is not required (nor permitted) to specify the constraint <code class="prettyprint">T:object</code> since <code class="prettyprint">object</code> is an implicit constraint on all type parameters. The method <code class="prettyprint">C.G&lt;T&gt;</code> implicitly implements <code class="prettyprint">I&lt;object,C,string&gt;.G&lt;T&gt;</code> because the constraints match those in the interface, after the interface type parameters are replaced with the corresponding type arguments. The constraint for method <code class="prettyprint">C.H&lt;T&gt;</code> is an error because sealed types (<code class="prettyprint">string</code> in this case) cannot be used as constraints. Omitting the constraint would also be an error since constraints of implicit interface method implementations are required to match. Thus, it is impossible to implicitly implement <code class="prettyprint">I&lt;object,C,string&gt;.H&lt;T&gt;</code>. This interface method can only be implemented using an explicit interface member implementation:
&ldquo;`csharp
class C: I<object,C,string>
{
    &hellip;</p>

<p>public void H<U>(U u) where U: class {&hellip;}</p>

<p>void I<object,C,string>.H<T>(T t) {
        string s = t;    // Ok
        H<T>(t);
    }
}
&rdquo;`</p>

<p>In this example, the explicit interface member implementation invokes a public method having strictly weaker constraints. Note that the assignment from <code class="prettyprint">t</code> to <code class="prettyprint">s</code> is valid since <code class="prettyprint">T</code> inherits a constraint of <code class="prettyprint">T:string</code>, even though this constraint is not expressible in source code.</p>

<h3 id="interface-mapping">Interface mapping</h3>

<p>A class or struct must provide implementations of all members of the interfaces that are listed in the base class list of the class or struct. The process of locating implementations of interface members in an implementing class or struct is known as <strong><em>interface mapping</em></strong>.</p>

<p>Interface mapping for a class or struct <code class="prettyprint">C</code> locates an implementation for each member of each interface specified in the base class list of <code class="prettyprint">C</code>. The implementation of a particular interface member <code class="prettyprint">I.M</code>, where <code class="prettyprint">I</code> is the interface in which the member <code class="prettyprint">M</code> is declared, is determined by examining each class or struct <code class="prettyprint">S</code>, starting with <code class="prettyprint">C</code> and repeating for each successive base class of <code class="prettyprint">C</code>, until a match is located:</p>

<ul>
<li> If <code class="prettyprint">S</code> contains a declaration of an explicit interface member implementation that matches <code class="prettyprint">I</code> and <code class="prettyprint">M</code>, then this member is the implementation of <code class="prettyprint">I.M</code>.</li>
<li> Otherwise, if <code class="prettyprint">S</code> contains a declaration of a non-static public member that matches <code class="prettyprint">M</code>, then this member is the implementation of <code class="prettyprint">I.M</code>. If more than one member matches, it is unspecified which member is the implementation of <code class="prettyprint">I.M</code>. This situation can only occur if <code class="prettyprint">S</code> is a constructed type where the two members as declared in the generic type have different signatures, but the type arguments make their signatures identical.</li>
</ul>

<p>A compile-time error occurs if implementations cannot be located for all members of all interfaces specified in the base class list of <code class="prettyprint">C</code>. Note that the members of an interface include those members that are inherited from base interfaces.</p>

<p>For purposes of interface mapping, a class member <code class="prettyprint">A</code> matches an interface member <code class="prettyprint">B</code> when:</p>

<ul>
<li> <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are methods, and the name, type, and formal parameter lists of <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are identical.</li>
<li> <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are properties, the name and type of <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are identical, and <code class="prettyprint">A</code> has the same accessors as <code class="prettyprint">B</code> (<code class="prettyprint">A</code> is permitted to have additional accessors if it is not an explicit interface member implementation).</li>
<li> <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are events, and the name and type of <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are identical.</li>
<li> <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are indexers, the type and formal parameter lists of <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are identical, and <code class="prettyprint">A</code> has the same accessors as <code class="prettyprint">B</code> (<code class="prettyprint">A</code> is permitted to have additional accessors if it is not an explicit interface member implementation).</li>
</ul>

<p>Notable implications of the interface mapping algorithm are:</p>

<ul>
<li> Explicit interface member implementations take precedence over other members in the same class or struct when determining the class or struct member that implements an interface member.</li>
<li> Neither non-public nor static members participate in interface mapping.</li>
</ul>

<p>In the example
&ldquo;`csharp
interface ICloneable
{
    object Clone();
}</p>

<p>class C: ICloneable
{
    object ICloneable.Clone() {&hellip;}
    public object Clone() {&hellip;}
}
&rdquo;<code class="prettyprint">
the</code>ICloneable.Clone<code class="prettyprint">member of</code>C<code class="prettyprint">becomes the implementation of</code>Clone<code class="prettyprint">in</code>ICloneable` because explicit interface member implementations take precedence over other members.</p>

<p>If a class or struct implements two or more interfaces containing a member with the same name, type, and parameter types, it is possible to map each of those interface members onto a single class or struct member. For example
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface IForm
{
    void Paint();
}</p>

<p>class Page: IControl, IForm
{
    public void Paint() {&hellip;}
}
&rdquo;`</p>

<p>Here, the <code class="prettyprint">Paint</code> methods of both <code class="prettyprint">IControl</code> and <code class="prettyprint">IForm</code> are mapped onto the <code class="prettyprint">Paint</code> method in <code class="prettyprint">Page</code>. It is of course also possible to have separate explicit interface member implementations for the two methods.</p>

<p>If a class or struct implements an interface that contains hidden members, then some members must necessarily be implemented through explicit interface member implementations. For example
&ldquo;`csharp
interface IBase
{
    int P { get; }
}</p>

<p>interface IDerived: IBase
{
    new int P();
}
&rdquo;`</p>

<p>An implementation of this interface would require at least one explicit interface member implementation, and would take one of the following forms
&ldquo;`csharp
class C: IDerived
{
    int IBase.P { get {&hellip;} }
    int IDerived.P() {&hellip;}
}</p>

<p>class C: IDerived
{
    public int P { get {&hellip;} }
    int IDerived.P() {&hellip;}
}</p>

<p>class C: IDerived
{
    int IBase.P { get {&hellip;} }
    public int P() {&hellip;}
}
&rdquo;`</p>

<p>When a class implements multiple interfaces that have the same base interface, there can be only one implementation of the base interface. In the example
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>interface ITextBox: IControl
{
    void SetText(string text);
}</p>

<p>interface IListBox: IControl
{
    void SetItems(string[] items);
}</p>

<p>class ComboBox: IControl, ITextBox, IListBox
{
    void IControl.Paint() {&hellip;}
    void ITextBox.SetText(string text) {&hellip;}
    void IListBox.SetItems(string[] items) {&hellip;}
}
&rdquo;<code class="prettyprint">
it is not possible to have separate implementations for the</code>IControl<code class="prettyprint">named in the base class list, the</code>IControl<code class="prettyprint">inherited by</code>ITextBox<code class="prettyprint">, and the</code>IControl<code class="prettyprint">inherited by</code>IListBox<code class="prettyprint">. Indeed, there is no notion of a separate identity for these interfaces. Rather, the implementations of</code>ITextBox<code class="prettyprint">and</code>IListBox<code class="prettyprint">share the same implementation of</code>IControl<code class="prettyprint">, and</code>ComboBox<code class="prettyprint">is simply considered to implement three interfaces,</code>IControl<code class="prettyprint">,</code>ITextBox<code class="prettyprint">, and</code>IListBox`.</p>

<p>The members of a base class participate in interface mapping. In the example
&ldquo;`csharp
interface Interface1
{
    void F();
}</p>

<p>class Class1
{
    public void F() {}
    public void G() {}
}</p>

<p>class Class2: Class1, Interface1
{
    new public void G() {}
}
&rdquo;<code class="prettyprint">
the method</code>F<code class="prettyprint">in</code>Class1<code class="prettyprint">is used in</code>Class2<code class="prettyprint">&#39;s implementation of</code>Interface1`.</p>

<h3 id="interface-implementation-inheritance">Interface implementation inheritance</h3>

<p>A class inherits all interface implementations provided by its base classes.</p>

<p>Without explicitly <strong><em>re-implementing</em></strong> an interface, a derived class cannot in any way alter the interface mappings it inherits from its base classes. For example, in the declarations
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>class Control: IControl
{
    public void Paint() {&hellip;}
}</p>

<p>class TextBox: Control
{
    new public void Paint() {&hellip;}
}
<code class="prettyprint">
the `Paint` method in `TextBox` hides the `Paint` method in `Control`, but it does not alter the mapping of `Control.Paint` onto `IControl.Paint`, and calls to `Paint` through class instances and interface instances will have the following effects
</code>csharp
Control c = new Control();
TextBox t = new TextBox();
IControl ic = c;
IControl it = t;
c.Paint();            // invokes Control.Paint();
t.Paint();            // invokes TextBox.Paint();
ic.Paint();           // invokes Control.Paint();
it.Paint();           // invokes Control.Paint();
&rdquo;`</p>

<p>However, when an interface method is mapped onto a virtual method in a class, it is possible for derived classes to override the virtual method and alter the implementation of the interface. For example, rewriting the declarations above to
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>class Control: IControl
{
    public virtual void Paint() {&hellip;}
}</p>

<p>class TextBox: Control
{
    public override void Paint() {&hellip;}
}
<code class="prettyprint">
the following effects will now be observed
</code>csharp
Control c = new Control();
TextBox t = new TextBox();
IControl ic = c;
IControl it = t;
c.Paint();            // invokes Control.Paint();
t.Paint();            // invokes TextBox.Paint();
ic.Paint();           // invokes Control.Paint();
it.Paint();           // invokes TextBox.Paint();
&rdquo;`</p>

<p>Since explicit interface member implementations cannot be declared virtual, it is not possible to override an explicit interface member implementation. However, it is perfectly valid for an explicit interface member implementation to call another method, and that other method can be declared virtual to allow derived classes to override it. For example
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>class Control: IControl
{
    void IControl.Paint() { PaintControl(); }
    protected virtual void PaintControl() {&hellip;}
}</p>

<p>class TextBox: Control
{
    protected override void PaintControl() {&hellip;}
}
&rdquo;`</p>

<p>Here, classes derived from <code class="prettyprint">Control</code> can specialize the implementation of <code class="prettyprint">IControl.Paint</code> by overriding the <code class="prettyprint">PaintControl</code> method.</p>

<h3 id="interface-re-implementation">Interface re-implementation</h3>

<p>A class that inherits an interface implementation is permitted to <strong><em>re-implement</em></strong> the interface by including it in the base class list.</p>

<p>A re-implementation of an interface follows exactly the same interface mapping rules as an initial implementation of an interface. Thus, the inherited interface mapping has no effect whatsoever on the interface mapping established for the re-implementation of the interface. For example, in the declarations
&ldquo;`csharp
interface IControl
{
    void Paint();
}</p>

<p>class Control: IControl
{
    void IControl.Paint() {&hellip;}
}</p>

<p>class MyControl: Control, IControl
{
    public void Paint() {}
}
&rdquo;<code class="prettyprint">
the fact that</code>Control<code class="prettyprint">maps</code>IControl.Paint<code class="prettyprint">onto</code>Control.IControl.Paint<code class="prettyprint">doesn&#39;t affect the re-implementation in</code>MyControl<code class="prettyprint">, which maps</code>IControl.Paint<code class="prettyprint">onto</code>MyControl.Paint`.</p>

<p>Inherited public member declarations and inherited explicit interface member declarations participate in the interface mapping process for re-implemented interfaces. For example
&ldquo;`csharp
interface IMethods
{
    void F();
    void G();
    void H();
    void I();
}</p>

<p>class Base: IMethods
{
    void IMethods.F() {}
    void IMethods.G() {}
    public void H() {}
    public void I() {}
}</p>

<p>class Derived: Base, IMethods
{
    public void F() {}
    void IMethods.H() {}
}
&rdquo;`</p>

<p>Here, the implementation of <code class="prettyprint">IMethods</code> in <code class="prettyprint">Derived</code> maps the interface methods onto <code class="prettyprint">Derived.F</code>, <code class="prettyprint">Base.IMethods.G</code>, <code class="prettyprint">Derived.IMethods.H</code>, and <code class="prettyprint">Base.I</code>.</p>

<p>When a class implements an interface, it implicitly also implements all of that interface&rsquo;s base interfaces. Likewise, a re-implementation of an interface is also implicitly a re-implementation of all of the interface&rsquo;s base interfaces. For example
&ldquo;`csharp
interface IBase
{
    void F();
}</p>

<p>interface IDerived: IBase
{
    void G();
}</p>

<p>class C: IDerived
{
    void IBase.F() {&hellip;}
    void IDerived.G() {&hellip;}
}</p>

<p>class D: C, IDerived
{
    public void F() {&hellip;}
    public void G() {&hellip;}
}
&rdquo;`</p>

<p>Here, the re-implementation of <code class="prettyprint">IDerived</code> also re-implements <code class="prettyprint">IBase</code>, mapping <code class="prettyprint">IBase.F</code> onto <code class="prettyprint">D.F</code>.</p>

<h3 id="abstract-classes-and-interfaces">Abstract classes and interfaces</h3>

<p>Like a non-abstract class, an abstract class must provide implementations of all members of the interfaces that are listed in the base class list of the class. However, an abstract class is permitted to map interface methods onto abstract methods. For example
&ldquo;`csharp
interface IMethods
{
    void F();
    void G();
}</p>

<p>abstract class C: IMethods
{
    public abstract void F();
    public abstract void G();
}
&rdquo;`</p>

<p>Here, the implementation of <code class="prettyprint">IMethods</code> maps <code class="prettyprint">F</code> and <code class="prettyprint">G</code> onto abstract methods, which must be overridden in non-abstract classes that derive from <code class="prettyprint">C</code>.</p>

<p>Note that explicit interface member implementations cannot be abstract, but explicit interface member implementations are of course permitted to call abstract methods. For example
&ldquo;`csharp
interface IMethods
{
    void F();
    void G();
}</p>

<p>abstract class C: IMethods
{
    void IMethods.F() { FF(); }
    void IMethods.G() { GG(); }
    protected abstract void FF();
    protected abstract void GG();
}
&rdquo;`</p>

<p>Here, non-abstract classes that derive from <code class="prettyprint">C</code> would be required to override <code class="prettyprint">FF</code> and <code class="prettyprint">GG</code>, thus providing the actual implementation of <code class="prettyprint">IMethods</code>.</p>

          <h1 id="enums">Enums</h1>

<p>An <strong><em>enum type</em></strong> is a distinct value type (<a href="types.md#value-types">Value types</a>) that declares a set of named constants.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Color</span>
<span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Blue</span>
<span class="p">}</span>
</code></pre>
<p>declares an enum type named <code class="prettyprint">Color</code> with members <code class="prettyprint">Red</code>, <code class="prettyprint">Green</code>, and <code class="prettyprint">Blue</code>.</p>

<h2 id="enum-declarations">Enum declarations</h2>

<p>An enum declaration declares a new enum type. An enum declaration begins with the keyword <code class="prettyprint">enum</code>, and defines the name, accessibility, underlying type, and members of the enum.</p>
<pre class="highlight shell"><code>enum_declaration
    : attributes? enum_modifier<span class="k">*</span> <span class="s1">'enum'</span> identifier enum_base? enum_body <span class="s1">';'</span>?
    ;

enum_base
    : <span class="s1">':'</span> integral_type
    ;

enum_body
    : <span class="s1">'{'</span> enum_member_declarations? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> enum_member_declarations <span class="s1">','</span> <span class="s1">'}'</span>
    ;
</code></pre>
<p>Each enum type has a corresponding integral type called the <strong><em>underlying type</em></strong> of the enum type. This underlying type must be able to represent all the enumerator values defined in the enumeration. An enum declaration may explicitly declare an underlying type of <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code>. Note that <code class="prettyprint">char</code> cannot be used as an underlying type. An enum declaration that does not explicitly declare an underlying type has an underlying type of <code class="prettyprint">int</code>.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Color</span><span class="p">:</span> <span class="kt">long</span>
<span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Blue</span>
<span class="p">}</span>
</code></pre>
<p>declares an enum with an underlying type of <code class="prettyprint">long</code>. A developer might choose to use an underlying type of <code class="prettyprint">long</code>, as in the example, to enable the use of values that are in the range of <code class="prettyprint">long</code> but not in the range of <code class="prettyprint">int</code>, or to preserve this option for the future.</p>

<h2 id="enum-modifiers">Enum modifiers</h2>

<p>An <em>enum_declaration</em> may optionally include a sequence of enum modifiers:</p>
<pre class="highlight shell"><code>enum_modifier
    : <span class="s1">'new'</span>
    | <span class="s1">'public'</span>
    | <span class="s1">'protected'</span>
    | <span class="s1">'internal'</span>
    | <span class="s1">'private'</span>
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in an enum declaration.</p>

<p>The modifiers of an enum declaration have the same meaning as those of a class declaration (<a href="classes.md#class-modifiers">Class modifiers</a>). Note, however, that the <code class="prettyprint">abstract</code> and <code class="prettyprint">sealed</code> modifiers are not permitted in an enum declaration. Enums cannot be abstract and do not permit derivation.</p>

<h2 id="enum-members">Enum members</h2>

<p>The body of an enum type declaration defines zero or more enum members, which are the named constants of the enum type. No two enum members can have the same name.</p>
<pre class="highlight shell"><code>enum_member_declarations
    : enum_member_declaration <span class="o">(</span><span class="s1">','</span> enum_member_declaration<span class="o">)</span><span class="k">*</span>
    ;

enum_member_declaration
    : attributes? identifier <span class="o">(</span><span class="s1">'='</span> constant_expression<span class="o">)</span>?
    ;
</code></pre>
<p>Each enum member has an associated constant value. The type of this value is the underlying type for the containing enum. The constant value for each enum member must be in the range of the underlying type for the enum. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Color</span><span class="p">:</span> <span class="kt">uint</span>
<span class="p">{</span>
    <span class="n">Red</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span>
    <span class="n">Green</span> <span class="p">=</span> <span class="p">-</span><span class="m">2</span><span class="p">,</span>
    <span class="n">Blue</span> <span class="p">=</span> <span class="p">-</span><span class="m">3</span>
<span class="p">}</span>
</code></pre>
<p>results in a compile-time error because the constant values <code class="prettyprint">-1</code>, <code class="prettyprint">-2</code>, and <code class="prettyprint">-3</code> are not in the range of the underlying integral type <code class="prettyprint">uint</code>.</p>

<p>Multiple enum members may share the same associated value. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Color</span> 
<span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Blue</span><span class="p">,</span>

    <span class="n">Max</span> <span class="p">=</span> <span class="n">Blue</span>
<span class="p">}</span>
</code></pre>
<p>shows an enum in which two enum members &ndash; <code class="prettyprint">Blue</code> and <code class="prettyprint">Max</code> &ndash; have the same associated value.</p>

<p>The associated value of an enum member is assigned either implicitly or explicitly. If the declaration of the enum member has a <em>constant_expression</em> initializer, the value of that constant expression, implicitly converted to the underlying type of the enum, is the associated value of the enum member. If the declaration of the enum member has no initializer, its associated value is set implicitly, as follows:</p>

<ul>
<li> If the enum member is the first enum member declared in the enum type, its associated value is zero.</li>
<li> Otherwise, the associated value of the enum member is obtained by increasing the associated value of the textually preceding enum member by one. This increased value must be within the range of values that can be represented by the underlying type, otherwise a compile-time error occurs.</li>
</ul>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Color</span>
<span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span> <span class="p">=</span> <span class="m">10</span><span class="p">,</span>
    <span class="n">Blue</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">StringFromColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">));</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">StringFromColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">));</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">StringFromColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">string</span> <span class="nf">StringFromColor</span><span class="p">(</span><span class="n">Color</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">"Red = {0}"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">c</span><span class="p">);</span>

            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">"Green = {0}"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">c</span><span class="p">);</span>

            <span class="k">case</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">"Blue = {0}"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">c</span><span class="p">);</span>

            <span class="k">default</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">"Invalid color"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>prints out the enum member names and their associated values. The output is:</p>
<pre class="highlight shell"><code>Red <span class="o">=</span> 0
Green <span class="o">=</span> 10
Blue <span class="o">=</span> 11
</code></pre>
<p>for the following reasons:</p>

<ul>
<li> the enum member <code class="prettyprint">Red</code> is automatically assigned the value zero (since it has no initializer and is the first enum member);</li>
<li> the enum member <code class="prettyprint">Green</code> is explicitly given the value <code class="prettyprint">10</code>;</li>
<li> and the enum member <code class="prettyprint">Blue</code> is automatically assigned the value one greater than the member that textually precedes it.</li>
</ul>

<p>The associated value of an enum member may not, directly or indirectly, use the value of its own associated enum member. Other than this circularity restriction, enum member initializers may freely refer to other enum member initializers, regardless of their textual position. Within an enum member initializer, values of other enum members are always treated as having the type of their underlying type, so that casts are not necessary when referring to other enum members.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">enum</span> <span class="n">Circular</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="p">=</span> <span class="n">B</span><span class="p">,</span>
    <span class="n">B</span>
<span class="p">}</span>
</code></pre>
<p>results in a compile-time error because the declarations of <code class="prettyprint">A</code> and <code class="prettyprint">B</code> are circular. <code class="prettyprint">A</code> depends on <code class="prettyprint">B</code> explicitly, and <code class="prettyprint">B</code> depends on <code class="prettyprint">A</code> implicitly.</p>

<p>Enum members are named and scoped in a manner exactly analogous to fields within classes. The scope of an enum member is the body of its containing enum type. Within that scope, enum members can be referred to by their simple name. From all other code, the name of an enum member must be qualified with the name of its enum type. Enum members do not have any declared accessibility &ndash; an enum member is accessible if its containing enum type is accessible.</p>

<h2 id="the-system-enum-type">The System.Enum type</h2>

<p>The type <code class="prettyprint">System.Enum</code> is the abstract base class of all enum types (this is distinct and different from the underlying type of the enum type), and the members inherited from <code class="prettyprint">System.Enum</code> are available in any enum type. A boxing conversion (<a href="types.md#boxing-conversions">Boxing conversions</a>) exists from any enum type to <code class="prettyprint">System.Enum</code>, and an unboxing conversion (<a href="types.md#unboxing-conversions">Unboxing conversions</a>) exists from <code class="prettyprint">System.Enum</code> to any enum type.</p>

<p>Note that <code class="prettyprint">System.Enum</code> is not itself an <em>enum_type</em>. Rather, it is a <em>class_type</em> from which all *enum_type*s are derived. The type <code class="prettyprint">System.Enum</code> inherits from the type <code class="prettyprint">System.ValueType</code> (<a href="types.md#the-systemvaluetype-type">The System.ValueType type</a>), which, in turn, inherits from type <code class="prettyprint">object</code>. At run-time, a value of type <code class="prettyprint">System.Enum</code> can be <code class="prettyprint">null</code> or a reference to a boxed value of any enum type.</p>

<h2 id="enum-values-and-operations">Enum values and operations</h2>

<p>Each enum type defines a distinct type; an explicit enumeration conversion (<a href="conversions.md#explicit-enumeration-conversions">Explicit enumeration conversions</a>) is required to convert between an enum type and an integral type, or between two enum types. The set of values that an enum type can take on is not limited by its enum members. In particular, any value of the underlying type of an enum can be cast to the enum type, and is a distinct valid value of that enum type.</p>

<p>Enum members have the type of their containing enum type (except within other enum member initializers: see <a href="enums.md#enum-members">Enum members</a>). The value of an enum member declared in enum type <code class="prettyprint">E</code> with associated value <code class="prettyprint">v</code> is <code class="prettyprint">(E)v</code>.</p>

<p>The following operators can be used on values of enum types: <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, <code class="prettyprint">&gt;=</code>Â (<a href="expressions.md#enumeration-comparison-operators">Enumeration comparison operators</a>), binary <code class="prettyprint">+</code>Â (<a href="expressions.md#addition-operator">Addition operator</a>), binary <code class="prettyprint">-</code>Â (<a href="expressions.md#subtraction-operator">Subtraction operator</a>), <code class="prettyprint">^</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>Â (<a href="expressions.md#enumeration-logical-operators">Enumeration logical operators</a>), <code class="prettyprint">~</code>Â (<a href="expressions.md#bitwise-complement-operator">Bitwise complement operator</a>), <code class="prettyprint">++</code> and <code class="prettyprint">--</code>Â (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a> and <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>).</p>

<p>Every enum type automatically derives from the class <code class="prettyprint">System.Enum</code> (which, in turn, derives from <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">object</code>). Thus, inherited methods and properties of this class can be used on values of an enum type.</p>

          <h1 id="delegates">Delegates</h1>

<p>Delegates enable scenarios that other languagesâ€”such as C++, Pascal, and Modula &ndash; have addressed with function pointers. Unlike C++ function pointers, however, delegates are fully object oriented, and unlike C++ pointers to member functions, delegates encapsulate both an object instance and a method.</p>

<p>A delegate declaration defines a class that is derived from the class <code class="prettyprint">System.Delegate</code>. A delegate instance encapsulates an invocation list, which is a list of one or more methods, each of which is referred to as a callable entity. For instance methods, a callable entity consists of an instance and a method on that instance. For static methods, a callable entity consists of just a method. Invoking a delegate instance with an appropriate set of arguments causes each of the delegate&rsquo;s callable entities to be invoked with the given set of arguments.</p>

<p>An interesting and useful property of a delegate instance is that it does not know or care about the classes of the methods it encapsulates; all that matters is that those methods be compatible (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) with the delegate&rsquo;s type. This makes delegates perfectly suited for &ldquo;anonymous&rdquo; invocation.</p>

<h2 id="delegate-declarations">Delegate declarations</h2>

<p>A <em>delegate_declaration</em> is a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>) that declares a new delegate type.</p>
<pre class="highlight shell"><code>delegate_declaration
    : attributes? delegate_modifier<span class="k">*</span> <span class="s1">'delegate'</span> return_type
      identifier variant_type_parameter_list?
      <span class="s1">'('</span> formal_parameter_list? <span class="s1">')'</span> type_parameter_constraints_clause<span class="k">*</span> <span class="s1">';'</span>
    ;

delegate_modifier
    : <span class="s1">'new'</span>
    | <span class="s1">'public'</span>
    | <span class="s1">'protected'</span>
    | <span class="s1">'internal'</span>
    | <span class="s1">'private'</span>
    | delegate_modifier_unsafe
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in a delegate declaration.</p>

<p>The <code class="prettyprint">new</code> modifier is only permitted on delegates declared within another type, in which case it specifies that such a delegate hides an inherited member by the same name, as described in <a href="classes.md#the-new-modifier">The new modifier</a>.</p>

<p>The <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers control the accessibility of the delegate type. Depending on the context in which the delegate declaration occurs, some of these modifiers may not be permitted (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<p>The delegate&rsquo;s type name is <em>identifier</em>.</p>

<p>The optional <em>formal_parameter_list</em> specifies the parameters of the delegate, and <em>return_type</em> indicates the return type of the delegate.</p>

<p>The optional <em>variant_type_parameter_list</em> (<a href="interfaces.md#variant-type-parameter-lists">Variant type parameter lists</a>) specifies the type parameters to the delegate itself.</p>

<p>The return type of a delegate type must be either <code class="prettyprint">void</code>, or output-safe (<a href="interfaces.md#variance-safety">Variance safety</a>).</p>

<p>All the formal parameter types of a delegate type must be input-safe. Additionally, any <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> parameter types must also be output-safe. Note that even <code class="prettyprint">out</code> parameters are required to be input-safe, due to a limitiation of the underlying execution platform.</p>

<p>Delegate types in C# are name equivalent, not structurally equivalent. Specifically, two different delegate types that have the same parameter lists and return type are considered different delegate types. However, instances of two distinct but structurally equivalent delegate types may compare as equal (<a href="expressions.md#delegate-equality-operators">Delegate equality operators</a>).</p>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="kt">int</span> <span class="nf">D1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
    <span class="k">delegate</span> <span class="kt">int</span> <span class="nf">D2</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">g</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">double</span> <span class="n">l</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">M3</span><span class="p">(</span><span class="kt">int</span> <span class="n">g</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M4</span><span class="p">(</span><span class="kt">int</span> <span class="n">g</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>The methods <code class="prettyprint">A.M1</code> and <code class="prettyprint">B.M1</code>are compatible with both the delegate types <code class="prettyprint">D1</code> and <code class="prettyprint">D2</code> , since they have the same return type and parameter list; however, these delegate types are two different types, so they are not interchangeable. The methods <code class="prettyprint">B.M2</code>, <code class="prettyprint">B.M3</code>, and <code class="prettyprint">B.M4</code> are incompatible with the delegate types <code class="prettyprint">D1</code> and <code class="prettyprint">D2</code>, since they have different return types or parameter lists.</p>

<p>Like other generic type declarations, type arguments must be given to create a constructed delegate type. The parameter types and return type of a constructed delegate type are created by substituting, for each type parameter in the delegate declaration, the corresponding type argument of the constructed delegate type. The resulting return type and parameter types are used in determining what methods are compatible with a constructed delegate type. For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="kt">bool</span> <span class="n">Predicate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="k">value</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="nf">G</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>The method <code class="prettyprint">X.F</code> is compatible with the delegate type <code class="prettyprint">Predicate&lt;int&gt;</code> and the method <code class="prettyprint">X.G</code> is compatible with the delegate type <code class="prettyprint">Predicate&lt;string&gt;</code> .</p>

<p>The only way to declare a delegate type is via a <em>delegate_declaration</em>. A delegate type is a class type that is derived from <code class="prettyprint">System.Delegate</code>. Delegate types are implicitly <code class="prettyprint">sealed</code>, so it is not permissible to derive any type from a delegate type. It is also not permissible to derive a non-delegate class type from <code class="prettyprint">System.Delegate</code>. Note that <code class="prettyprint">System.Delegate</code> is not itself a delegate type; it is a class type from which all delegate types are derived.</p>

<p>C# provides special syntax for delegate instantiation and invocation. Except for instantiation, any operation that can be applied to a class or class instance can also be applied to a delegate class or instance, respectively. In particular, it is possible to access members of the <code class="prettyprint">System.Delegate</code> type via the usual member access syntax.</p>

<p>The set of methods encapsulated by a delegate instance is called an invocation list. When a delegate instance is created (<a href="delegates.md#delegate-compatibility">Delegate compatibility</a>) from a single method, it encapsulates that method, and its invocation list contains only one entry. However, when two non-null delegate instances are combined, their invocation lists are concatenated &ndash; in the order left operand then right operand &ndash; to form a new invocation list, which contains two or more entries.</p>

<p>Delegates are combined using the binary <code class="prettyprint">+</code> (<a href="expressions.md#addition-operator">Addition operator</a>) and <code class="prettyprint">+=</code> operators (<a href="expressions.md#compound-assignment">Compound assignment</a>). A delegate can be removed from a combination of delegates, using the binary <code class="prettyprint">-</code> (<a href="expressions.md#subtraction-operator">Subtraction operator</a>) and <code class="prettyprint">-=</code> operators (<a href="expressions.md#compound-assignment">Compound assignment</a>). Delegates can be compared for equality (<a href="expressions.md#delegate-equality-operators">Delegate equality operators</a>).</p>

<p>The following example shows the instantiation of a number of delegates, and their corresponding invocation lists:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="k">void</span> <span class="nf">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>

<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">D</span> <span class="n">cd1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M1</span><span class="p">);</span>      <span class="c1">// M1</span>
        <span class="n">D</span> <span class="n">cd2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M2</span><span class="p">);</span>      <span class="c1">// M2</span>
        <span class="n">D</span> <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>        <span class="c1">// M1 + M2</span>
        <span class="n">D</span> <span class="n">cd4</span> <span class="p">=</span> <span class="n">cd3</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>        <span class="c1">// M1 + M2 + M1</span>
        <span class="n">D</span> <span class="n">cd5</span> <span class="p">=</span> <span class="n">cd4</span> <span class="p">+</span> <span class="n">cd3</span><span class="p">;</span>        <span class="c1">// M1 + M2 + M1 + M1 + M2</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>
<p>When <code class="prettyprint">cd1</code> and <code class="prettyprint">cd2</code> are instantiated, they each encapsulate one method. When <code class="prettyprint">cd3</code> is instantiated, it has an invocation list of two methods, <code class="prettyprint">M1</code> and <code class="prettyprint">M2</code>, in that order. <code class="prettyprint">cd4</code>&lsquo;s invocation list contains <code class="prettyprint">M1</code>, <code class="prettyprint">M2</code>, and <code class="prettyprint">M1</code>, in that order. Finally, <code class="prettyprint">cd5</code>&rsquo;s invocation list contains <code class="prettyprint">M1</code>, <code class="prettyprint">M2</code>, <code class="prettyprint">M1</code>, <code class="prettyprint">M1</code>, and <code class="prettyprint">M2</code>, in that order. For more examples of combining (as well as removing) delegates, see <a href="delegates.md#delegate-invocation">Delegate invocation</a>.</p>

<h2 id="delegate-compatibility">Delegate compatibility</h2>

<p>A method or delegate <code class="prettyprint">M</code> is <strong><em>compatible</em></strong> with a delegate type <code class="prettyprint">D</code> if all of the following are true:</p>

<ul>
<li> <code class="prettyprint">D</code> and <code class="prettyprint">M</code> have the same number of parameters, and each parameter in <code class="prettyprint">D</code> has the same <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> modifiers as the corresponding parameter in <code class="prettyprint">M</code>.</li>
<li> For each value parameter (a parameter with no <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> modifier), an identity conversion (<a href="conversions.md#identity-conversion">Identity conversion</a>) or implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from the parameter type in <code class="prettyprint">D</code> to the corresponding parameter type in <code class="prettyprint">M</code>.</li>
<li> For each <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter, the parameter type in <code class="prettyprint">D</code> is the same as the parameter type in <code class="prettyprint">M</code>.</li>
<li> An identity or implicit reference conversion exists from the return type of <code class="prettyprint">M</code> to the return type of <code class="prettyprint">D</code>.</li>
</ul>

<h2 id="delegate-instantiation">Delegate instantiation</h2>

<p>An instance of a delegate is created by a <em>delegate_creation_expression</em> (<a href="expressions.md#delegate-creation-expressions">Delegate creation expressions</a>) or a conversion to a delegate type. The newly created delegate instance then refers to either:</p>

<ul>
<li> The static method referenced in the <em>delegate_creation_expression</em>, or</li>
<li> The target object (which cannot be <code class="prettyprint">null</code>) and instance method referenced in the <em>delegate_creation_expression</em>, or</li>
<li> Another delegate.</li>
</ul>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="k">void</span> <span class="nf">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> 
        <span class="n">D</span> <span class="n">cd1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M1</span><span class="p">);</span>        <span class="c1">// static method</span>
        <span class="n">C</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">C</span><span class="p">();</span>
        <span class="n">D</span> <span class="n">cd2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">M2</span><span class="p">);</span>        <span class="c1">// instance method</span>
        <span class="n">D</span> <span class="n">cd3</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">cd2</span><span class="p">);</span>        <span class="c1">// another delegate</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Once instantiated, delegate instances always refer to the same target object and method. Remember, when two delegates are combined, or one is removed from another, a new delegate results with its own invocation list; the invocation lists of the delegates combined or removed remain unchanged.</p>

<h2 id="delegate-invocation">Delegate invocation</h2>

<p>C# provides special syntax for invoking a delegate. When a non-null delegate instance whose invocation list contains one entry is invoked, it invokes the one method with the same arguments it was given, and returns the same value as the referred to method. (See <a href="expressions.md#delegate-invocations">Delegate invocations</a> for detailed information on delegate invocation.) If an exception occurs during the invocation of such a delegate, and that exception is not caught within the method that was invoked, the search for an exception catch clause continues in the method that called the delegate, as if that method had directly called the method to which that delegate referred.</p>

<p>Invocation of a delegate instance whose invocation list contains multiple entries proceeds by invoking each of the methods in the invocation list, synchronously, in order. Each method so called is passed the same set of arguments as was given to the delegate instance. If such a delegate invocation includes reference parameters (<a href="classes.md#reference-parameters">Reference parameters</a>), each method invocation will occur with a reference to the same variable; changes to that variable by one method in the invocation list will be visible to methods further down the invocation list. If the delegate invocation includes output parameters or a return value, their final value will come from the invocation of the last delegate in the list.</p>

<p>If an exception occurs during processing of the invocation of such a delegate, and that exception is not caught within the method that was invoked, the search for an exception catch clause continues in the method that called the delegate, and any methods further down the invocation list are not invoked.</p>

<p>Attempting to invoke a delegate instance whose value is null results in an exception of type <code class="prettyprint">System.NullReferenceException</code>.</p>

<p>The following example shows how to instantiate, combine, remove, and invoke delegates:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">delegate</span> <span class="k">void</span> <span class="nf">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.M1: "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.M2: "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">M3</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.M3: "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> 
        <span class="n">D</span> <span class="n">cd1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M1</span><span class="p">);</span>
        <span class="nf">cd1</span><span class="p">(-</span><span class="m">1</span><span class="p">);</span>                <span class="c1">// call M1</span>

        <span class="n">D</span> <span class="n">cd2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M2</span><span class="p">);</span>
        <span class="nf">cd2</span><span class="p">(-</span><span class="m">2</span><span class="p">);</span>                <span class="c1">// call M2</span>

        <span class="n">D</span> <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>                <span class="c1">// call M1 then M2</span>

        <span class="n">cd3</span> <span class="p">+=</span> <span class="n">cd1</span><span class="p">;</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">20</span><span class="p">);</span>                <span class="c1">// call M1, M2, then M1</span>

        <span class="n">C</span> <span class="n">c</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">C</span><span class="p">();</span>
        <span class="n">D</span> <span class="n">cd4</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">M3</span><span class="p">);</span>
        <span class="n">cd3</span> <span class="p">+=</span> <span class="n">cd4</span><span class="p">;</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>                <span class="c1">// call M1, M2, M1, then M3</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span><span class="p">;</span>             <span class="c1">// remove last M1</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">40</span><span class="p">);</span>                <span class="c1">// call M1, M2, then M3</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd4</span><span class="p">;</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">50</span><span class="p">);</span>                <span class="c1">// call M1 then M2</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span><span class="p">;</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>                <span class="c1">// call M1</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span><span class="p">;</span>             <span class="c1">// impossible removal is benign</span>
        <span class="nf">cd3</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>                <span class="c1">// call M1</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span><span class="p">;</span>             <span class="c1">// invocation list is empty so cd3 is null</span>

        <span class="nf">cd3</span><span class="p">(</span><span class="m">70</span><span class="p">);</span>                <span class="c1">// System.NullReferenceException thrown</span>

        <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span><span class="p">;</span>             <span class="c1">// impossible removal is benign</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>As shown in the statement <code class="prettyprint">cd3 += cd1;</code>, a delegate can be present in an invocation list multiple times. In this case, it is simply invoked once per occurrence. In an invocation list such as this, when that delegate is removed, the last occurrence in the invocation list is the one actually removed.</p>

<p>Immediately prior to the execution of the final statement, <code class="prettyprint">cd3 -= cd1;</code>, the delegate <code class="prettyprint">cd3</code> refers to an empty invocation list. Attempting to remove a delegate from an empty list (or to remove a non-existent delegate from a non-empty list) is not an error.</p>

<p>The output produced is:</p>
<pre class="highlight shell"><code>C.M1: -1
C.M2: -2
C.M1: 10
C.M2: 10
C.M1: 20
C.M2: 20
C.M1: 20
C.M1: 30
C.M2: 30
C.M1: 30
C.M3: 30
C.M1: 40
C.M2: 40
C.M3: 40
C.M1: 50
C.M2: 50
C.M1: 60
C.M1: 60
</code></pre>
          <h1 id="exceptions">Exceptions</h1>

<p>Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions. The exception mechanism in C# is quite similar to that of C++, with a few important differences:</p>

<ul>
<li> In C#, all exceptions must be represented by an instance of a class type derived from <code class="prettyprint">System.Exception</code>. In C++, any value of any type can be used to represent an exception.</li>
<li> In C#, a finally block (<a href="statements.md#the-try-statement">The try statement</a>) can be used to write termination code that executes in both normal execution and exceptional conditions. Such code is difficult to write in C++ without duplicating code.</li>
<li> In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</li>
</ul>

<h2 id="causes-of-exceptions">Causes of exceptions</h2>

<p>Exception can be thrown in two different ways.</p>

<ul>
<li> A <code class="prettyprint">throw</code> statement (<a href="statements.md#the-throw-statement">The throw statement</a>) throws an exception immediately and unconditionally. Control never reaches the statement immediately following the <code class="prettyprint">throw</code>.</li>
<li> Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally. For example, an integer division operation (<a href="expressions.md#division-operator">Division operator</a>) throws a <code class="prettyprint">System.DivideByZeroException</code> if the denominator is zero. See <a href="exceptions.md#common-exception-classes">Common Exception Classes</a> for a list of the various exceptions that can occur in this way.</li>
</ul>

<h2 id="the-system-exception-class">The System.Exception class</h2>

<p>The <code class="prettyprint">System.Exception</code> class is the base type of all exceptions. This class has a few notable properties that all exceptions share:</p>

<ul>
<li> <code class="prettyprint">Message</code> is a read-only property of type <code class="prettyprint">string</code> that contains a human-readable description of the reason for the exception.</li>
<li> <code class="prettyprint">InnerException</code> is a read-only property of type <code class="prettyprint">Exception</code>. If its value is non-null, it refers to the exception that caused the current exceptionâ€”that is, the current exception was raised in a catch block handling the <code class="prettyprint">InnerException</code>. Otherwise, its value is null, indicating that this exception was not caused by another exception. The number of exception objects chained together in this manner can be arbitrary.</li>
</ul>

<p>The value of these properties can be specified in calls to the instance constructor for <code class="prettyprint">System.Exception</code>.</p>

<h2 id="how-exceptions-are-handled">How exceptions are handled</h2>

<p>Exceptions are handled by a <code class="prettyprint">try</code> statement (<a href="statements.md#the-try-statement">The try statement</a>).</p>

<p>When an exception occurs, the system searches for the nearest <code class="prettyprint">catch</code> clause that can handle the exception, as determined by the run-time type of the exception. First, the current method is searched for a lexically enclosing <code class="prettyprint">try</code> statement, and the associated catch clauses of the try statement are considered in order. If that fails, the method that called the current method is searched for a lexically enclosing <code class="prettyprint">try</code> statement that encloses the point of the call to the current method. This search continues until a <code class="prettyprint">catch</code> clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown. A <code class="prettyprint">catch</code> clause that doesn&rsquo;t name an exception class can handle any exception.</p>

<p>Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause. Before execution of the catch clause begins, the system first executes, in order, any <code class="prettyprint">finally</code> clauses that were associated with try statements more nested that than the one that caught the exception.</p>

<p>If no matching catch clause is found, one of two things occurs:</p>

<ul>
<li> If the search for a matching catch clause reaches a static constructor (<a href="classes.md#static-constructors">Static constructors</a>) or static field initializer, then a <code class="prettyprint">System.TypeInitializationException</code> is thrown at the point that triggered the invocation of the static constructor. The inner exception of the <code class="prettyprint">System.TypeInitializationException</code> contains the exception that was originally thrown.</li>
<li> If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated. The impact of such termination is implementation-defined.</li>
</ul>

<p>Exceptions that occur during destructor execution are worth special mention. If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called. If there is no base class (as in the case of the <code class="prettyprint">object</code> type) or if there is no base class destructor, then the exception is discarded.</p>

<h2 id="common-exception-classes">Common Exception Classes</h2>

<p>The following exceptions are thrown by certain C# operations.</p>

<table><thead>
<tr>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">System.ArithmeticException</code></td>
<td>A base class for exceptions that occur during arithmetic operations, such as <code class="prettyprint">System.DivideByZeroException</code> and <code class="prettyprint">System.OverflowException</code>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.ArrayTypeMismatchException</code></td>
<td>Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</td>
</tr>
<tr>
<td><code class="prettyprint">System.DivideByZeroException</code></td>
<td>Thrown when an attempt to divide an integral value by zero occurs.</td>
</tr>
<tr>
<td><code class="prettyprint">System.IndexOutOfRangeException</code></td>
<td>Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</td>
</tr>
<tr>
<td><code class="prettyprint">System.InvalidCastException</code></td>
<td>Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</td>
</tr>
<tr>
<td><code class="prettyprint">System.NullReferenceException</code></td>
<td>Thrown when a <code class="prettyprint">null</code> reference is used in a way that causes the referenced object to be required.</td>
</tr>
<tr>
<td><code class="prettyprint">System.OutOfMemoryException</code></td>
<td>Thrown when an attempt to allocate memory (via <code class="prettyprint">new</code>) fails.</td>
</tr>
<tr>
<td><code class="prettyprint">System.OverflowException</code></td>
<td>Thrown when an arithmetic operation in a <code class="prettyprint">checked</code> context overflows.</td>
</tr>
<tr>
<td><code class="prettyprint">System.StackOverflowException</code></td>
<td>Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</td>
</tr>
<tr>
<td><code class="prettyprint">System.TypeInitializationException</code></td>
<td>Thrown when a static constructor throws an exception, and no <code class="prettyprint">catch</code> clauses exists to catch it.</td>
</tr>
</tbody></table>

          <h1 id="attributes">Attributes</h1>

<p>Much of the C# language enables the programmer to specify declarative information about the entities defined in the program. For example, the accessibility of a method in a class is specified by decorating it with the *method_modifier*s <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code>.</p>

<p>C# enables programmers to invent new kinds of declarative information, called <strong><em>attributes</em></strong>. Programmers can then attach attributes to various program entities, and retrieve attribute information in a run-time environment. For instance, a framework might define a <code class="prettyprint">HelpAttribute</code> attribute that can be placed on certain program elements (such as classes and methods) to provide a mapping from those program elements to their documentation.</p>

<p>Attributes are defined through the declaration of attribute classes (<a href="attributes.md#attribute-classes">Attribute classes</a>), which may have positional and named parameters (<a href="attributes.md#positional-and-named-parameters">Positional and named parameters</a>). Attributes are attached to entities in a C# program using attribute specifications (<a href="attributes.md#attribute-specification">Attribute specification</a>), and can be retrieved at run-time as attribute instances (<a href="attributes.md#attribute-instances">Attribute instances</a>).</p>

<h2 id="attribute-classes">Attribute classes</h2>

<p>A class that derives from the abstract class <code class="prettyprint">System.Attribute</code>, whether directly or indirectly, is an <strong><em>attribute class</em></strong>. The declaration of an attribute class defines a new kind of <strong><em>attribute</em></strong> that can be placed on a declaration. By convention, attribute classes are named with a suffix of <code class="prettyprint">Attribute</code>. Uses of an attribute may either include or omit this suffix.</p>

<h3 id="attribute-usage">Attribute usage</h3>

<p>The attribute <code class="prettyprint">AttributeUsage</code> (<a href="attributes.md#the-attributeusage-attribute">The AttributeUsage attribute</a>) is used to describe how an attribute class can be used.</p>

<p><code class="prettyprint">AttributeUsage</code> has a positional parameter (<a href="attributes.md#positional-and-named-parameters">Positional and named parameters</a>) that enables an attribute class to specify the kinds of declarations on which it can be used. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SimpleAttribute</span><span class="p">:</span> <span class="n">Attribute</span> 
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>defines an attribute class named <code class="prettyprint">SimpleAttribute</code> that can be placed on *class_declaration*s and *interface_declaration*s only. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Simple]</span> <span class="k">class</span> <span class="nc">Class1</span> <span class="p">{...}</span>

<span class="na">[Simple]</span> <span class="k">interface</span> <span class="n">Interface1</span> <span class="p">{...}</span>
</code></pre>
<p>shows several uses of the <code class="prettyprint">Simple</code> attribute. Although this attribute is defined with the name <code class="prettyprint">SimpleAttribute</code>, when this attribute is used, the <code class="prettyprint">Attribute</code> suffix may be omitted, resulting in the short name <code class="prettyprint">Simple</code>. Thus, the example above is semantically equivalent to the following:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[SimpleAttribute]</span> <span class="k">class</span> <span class="nc">Class1</span> <span class="p">{...}</span>

<span class="na">[SimpleAttribute]</span> <span class="k">interface</span> <span class="n">Interface1</span> <span class="p">{...}</span>
</code></pre>
<p><code class="prettyprint">AttributeUsage</code> has a named parameter (<a href="attributes.md#positional-and-named-parameters">Positional and named parameters</a>) called <code class="prettyprint">AllowMultiple</code>, which indicates whether the attribute can be specified more than once for a given entity. If <code class="prettyprint">AllowMultiple</code> for an attribute class is true, then that attribute class is a <strong><em>multi-use attribute class</em></strong>, and can be specified more than once on an entity. If <code class="prettyprint">AllowMultiple</code> for an attribute class is false or it is unspecified, then that attribute class is a <strong><em>single-use attribute class</em></strong>, and can be specified at most once on an entity.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AuthorAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AuthorAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>defines a multi-use attribute class named <code class="prettyprint">AuthorAttribute</code>. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Author("Brian Kernighan"), Author("Dennis Ritchie")]</span> 
<span class="k">class</span> <span class="nc">Class1</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>shows a class declaration with two uses of the <code class="prettyprint">Author</code> attribute.</p>

<p><code class="prettyprint">AttributeUsage</code> has another named parameter called <code class="prettyprint">Inherited</code>, which indicates whether the attribute, when specified on a base class, is also inherited by classes that derive from that base class. If <code class="prettyprint">Inherited</code> for an attribute class is true, then that attribute is inherited. If <code class="prettyprint">Inherited</code> for an attribute class is false then that attribute is not inherited. If it is unspecified, its default value is true.</p>

<p>An attribute class <code class="prettyprint">X</code> not having an <code class="prettyprint">AttributeUsage</code> attribute attached to it, as in</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">X</span><span class="p">:</span> <span class="n">Attribute</span> <span class="p">{...}</span>
</code></pre>
<p>is equivalent to the following:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span>
    <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">All</span><span class="p">,</span>
    <span class="n">AllowMultiple</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
    <span class="n">Inherited</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span>
<span class="p">]</span>
<span class="k">class</span> <span class="nc">X</span><span class="p">:</span> <span class="n">Attribute</span> <span class="p">{...}</span>
</code></pre>
<h3 id="positional-and-named-parameters">Positional and named parameters</h3>

<p>Attribute classes can have <strong><em>positional parameters</em></strong> and <strong><em>named parameters</em></strong>. Each public instance constructor for an attribute class defines a valid sequence of positional parameters for that attribute class. Each non-static public read-write field and property for an attribute class defines a named parameter for the attribute class.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.Class)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">HelpAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">HelpAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span>        <span class="c1">// Positional parameter</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Topic</span> <span class="p">{</span>                     <span class="c1">// Named parameter</span>
        <span class="k">get</span> <span class="p">{...}</span>
        <span class="k">set</span> <span class="p">{...}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Url</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{...}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>defines an attribute class named <code class="prettyprint">HelpAttribute</code> that has one positional parameter, <code class="prettyprint">url</code>, and one named parameter, <code class="prettyprint">Topic</code>. Although it is non-static and public, the property <code class="prettyprint">Url</code> does not define a named parameter, since it is not read-write.</p>

<p>This attribute class might be used as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Help("http://www.mycompany.com/.../Class1.htm")]</span>
<span class="k">class</span> <span class="nc">Class1</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="na">[Help("http://www.mycompany.com/.../Misc.htm", Topic = "Class2")]</span>
<span class="k">class</span> <span class="nc">Class2</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<h3 id="attribute-parameter-types">Attribute parameter types</h3>

<p>The types of positional and named parameters for an attribute class are limited to the <strong><em>attribute parameter types</em></strong>, which are:</p>

<ul>
<li> One of the following types: <code class="prettyprint">bool</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">char</code>, <code class="prettyprint">double</code>, <code class="prettyprint">float</code>, <code class="prettyprint">int</code>, <code class="prettyprint">long</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">string</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">ushort</code>.</li>
<li> The type <code class="prettyprint">object</code>.</li>
<li> The type <code class="prettyprint">System.Type</code>.</li>
<li> An enum type, provided it has public accessibility and the types in which it is nested (if any) also have public accessibility (<a href="attributes.md#attribute-specification">Attribute specification</a>).</li>
<li> Single-dimensional arrays of the above types.</li>
<li> A constructor argument or public field which does not have one of these types, cannot be used as a positional or named parameter in an attribute specification.</li>
</ul>

<h2 id="attribute-specification">Attribute specification</h2>

<p><strong><em>Attribute specification</em></strong> is the application of a previously defined attribute to a declaration. An attribute is a piece of additional declarative information that is specified for a declaration. Attributes can be specified at global scope (to specify attributes on the containing assembly or module) and for <em>type_declaration*s (<a href="namespaces.md#type-declarations">Type declarations</a>), *class_member_declaration*s (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), *interface_member_declaration*s (<a href="interfaces.md#interface-members">Interface members</a>), *struct_member_declaration*s (<a href="structs.md#struct-members">Struct members</a>), *enum_member_declaration*s (<a href="enums.md#enum-members">Enum members</a>), *accessor_declarations</em> (<a href="classes.md#accessors">Accessors</a>), <em>event_accessor_declarations</em> (<a href="classes.md#field-like-events">Field-like events</a>), and *formal_parameter_list*s (<a href="classes.md#method-parameters">Method parameters</a>).</p>

<p>Attributes are specified in <strong><em>attribute sections</em></strong>. An attribute section consists of a pair of square brackets, which surround a comma-separated list of one or more attributes. The order in which attributes are specified in such a list, and the order in which sections attached to the same program entity are arranged, is not significant. For instance, the attribute specifications <code class="prettyprint">[A][B]</code>, <code class="prettyprint">[B][A]</code>, <code class="prettyprint">[A,B]</code>, and <code class="prettyprint">[B,A]</code> are equivalent.</p>
<pre class="highlight plaintext"><code>global_attributes
    : global_attribute_section+
    ;

global_attribute_section
    : '[' global_attribute_target_specifier attribute_list ']'
    | '[' global_attribute_target_specifier attribute_list ',' ']'
    ;

global_attribute_target_specifier
    : global_attribute_target ':'
    ;

global_attribute_target
    : 'assembly'
    | 'module'
    ;

attributes
    : attribute_section+
    ;

attribute_section
    : '[' attribute_target_specifier? attribute_list ']'
    | '[' attribute_target_specifier? attribute_list ',' ']'
    ;

attribute_target_specifier
    : attribute_target ':'
    ;

attribute_target
    : 'field'
    | 'event'
    | 'method'
    | 'param'
    | 'property'
    | 'return'
    | 'type'
    ;

attribute_list
    : attribute (',' attribute)*
    ;

attribute
    : attribute_name attribute_arguments?
    ;

attribute_name
    : type_name
    ;

attribute_arguments
    : '(' positional_argument_list? ')'
    | '(' positional_argument_list ',' named_argument_list ')'
    | '(' named_argument_list ')'
    ;

positional_argument_list
    : positional_argument (',' positional_argument)*
    ;

positional_argument
    : attribute_argument_expression
    ;

named_argument_list
    : named_argument (','  named_argument)*
    ;

named_argument
    : identifier '=' attribute_argument_expression
    ;

attribute_argument_expression
    : expression
    ;
</code></pre>
<p>An attribute consists of an <em>attribute_name</em> and an optional list of positional and named arguments. The positional arguments (if any) precede the named arguments. A positional argument consists of an <em>attribute_argument_expression</em>; a named argument consists of a name, followed by an equal sign, followed by an <em>attribute_argument_expression</em>, which, together, are constrained by the same rules as simple assignment. The order of named arguments is not significant.</p>

<p>The <em>attribute_name</em> identifies an attribute class. If the form of <em>attribute_name</em> is <em>type_name</em> then this name must refer to an attribute class. Otherwise, a compile-time error occurs. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>

<span class="na">[Class1]</span> <span class="k">class</span> <span class="nc">Class2</span> <span class="p">{}</span>    <span class="c1">// Error</span>
</code></pre>
<p>results in a compile-time error because it attempts to use <code class="prettyprint">Class1</code> as an attribute class when <code class="prettyprint">Class1</code> is not an attribute class.</p>

<p>Certain contexts permit the specification of an attribute on more than one target. A program can explicitly specify the target by including an <em>attribute_target_specifier</em>. When an attribute is placed at the global level, a <em>global_attribute_target_specifier</em> is required. In all other locations, a reasonable default is applied, but an <em>attribute_target_specifier</em> can be used to affirm or override the default in certain ambiguous cases (or to just affirm the default in non-ambiguous cases). Thus, typically, *attribute_target_specifier*s can be omitted except at the global level. The potentially ambiguous contexts are resolved as follows:</p>

<ul>
<li> An attribute specified at global scope can apply either to the target assembly or the target module. No default exists for this context, so an <em>attribute_target_specifier</em> is always required in this context. The presence of the <code class="prettyprint">assembly</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the target assembly; the presence of the <code class="prettyprint">module</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the target module.</li>
<li> An attribute specified on a delegate declaration can apply either to the delegate being declared or to its return value. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the delegate. The presence of the <code class="prettyprint">type</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the delegate; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
<li> An attribute specified on a method declaration can apply either to the method being declared or to its return value. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the method. The presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the method; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
<li> An attribute specified on an operator declaration can apply either to the operator being declared or to its return value. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the operator. The presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the operator; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
<li> An attribute specified on an event declaration that omits event accessors can apply to the event being declared, to the associated field (if the event is not abstract), or to the associated add and remove methods. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the event. The presence of the <code class="prettyprint">event</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the event; the presence of the <code class="prettyprint">field</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the field; and the presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the methods.</li>
<li> An attribute specified on a get accessor declaration for a property or indexer declaration can apply either to the associated method or to its return value. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the method. The presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the method; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
<li> An attribute specified on a set accessor for a property or indexer declaration can apply either to the associated method or to its lone implicit parameter. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the method. The presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the method; the presence of the <code class="prettyprint">param</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the parameter; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
<li> An attribute specified on an add or remove accessor declaration for an event declaration can apply either to the associated method or to its lone parameter. In the absence of an <em>attribute_target_specifier</em>, the attribute applies to the method. The presence of the <code class="prettyprint">method</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the method; the presence of the <code class="prettyprint">param</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the parameter; the presence of the <code class="prettyprint">return</code> <em>attribute_target_specifier</em> indicates that the attribute applies to the return value.</li>
</ul>

<p>In other contexts, inclusion of an <em>attribute_target_specifier</em> is permitted but unnecessary. For instance, a class declaration may either include or omit the specifier <code class="prettyprint">type</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[type: Author("Brian Kernighan")]</span>
<span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>

<span class="na">[Author("Dennis Ritchie")]</span>
<span class="k">class</span> <span class="nc">Class2</span> <span class="p">{}</span>
</code></pre>
<p>It is an error to specify an invalid <em>attribute_target_specifier</em>. For instance, the specifier <code class="prettyprint">param</code> cannot be used on a class declaration:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[param: Author("Brian Kernighan")]</span>        <span class="c1">// Error</span>
<span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>
</code></pre>
<p>By convention, attribute classes are named with a suffix of <code class="prettyprint">Attribute</code>. An <em>attribute_name</em> of the form <em>type_name</em> may either include or omit this suffix. If an attribute class is found both with and without this suffix, an ambiguity is present, and a compile-time error results. If the <em>attribute_name</em> is spelled such that its right-most <em>identifier</em> is a verbatim identifier (<a href="lexical-structure.md#identifiers">Identifiers</a>), then only an attribute without a suffix is matched, thus enabling such an ambiguity to be resolved. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.All)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">X</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{}</span>

<span class="na">[AttributeUsage(AttributeTargets.All)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">XAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{}</span>

<span class="na">[X]</span>                     <span class="c1">// Error: ambiguity</span>
<span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>

<span class="na">[XAttribute]</span>            <span class="c1">// Refers to XAttribute</span>
<span class="k">class</span> <span class="nc">Class2</span> <span class="p">{}</span>

<span class="na">[@X]</span>                    <span class="c1">// Refers to X</span>
<span class="k">class</span> <span class="nc">Class3</span> <span class="p">{}</span>

<span class="na">[@XAttribute]</span>           <span class="c1">// Refers to XAttribute</span>
<span class="k">class</span> <span class="nc">Class4</span> <span class="p">{}</span>
</code></pre>
<p>shows two attribute classes named <code class="prettyprint">X</code> and <code class="prettyprint">XAttribute</code>. The attribute <code class="prettyprint">[X]</code> is ambiguous, since it could refer to either <code class="prettyprint">X</code> or <code class="prettyprint">XAttribute</code>. Using a verbatim identifier allows the exact intent to be specified in such rare cases. The attribute <code class="prettyprint">[XAttribute]</code> is not ambiguous (although it would be if there was an attribute class named <code class="prettyprint">XAttributeAttribute</code>!). If the declaration for class <code class="prettyprint">X</code> is removed, then both attributes refer to the attribute class named <code class="prettyprint">XAttribute</code>, as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.All)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">XAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{}</span>

<span class="na">[X]</span>                     <span class="c1">// Refers to XAttribute</span>
<span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>

<span class="na">[XAttribute]</span>            <span class="c1">// Refers to XAttribute</span>
<span class="k">class</span> <span class="nc">Class2</span> <span class="p">{}</span>

<span class="na">[@X]</span>                    <span class="c1">// Error: no attribute named "X"</span>
<span class="k">class</span> <span class="nc">Class3</span> <span class="p">{}</span>
</code></pre>
<p>It is a compile-time error to use a single-use attribute class more than once on the same entity. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.Class)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">HelpStringAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">HelpStringAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">string</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{...}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="na">[HelpString("Description of Class1")]</span>
<span class="na">[HelpString("Another description of Class1")]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>
</code></pre>
<p>results in a compile-time error because it attempts to use <code class="prettyprint">HelpString</code>, which is a single-use attribute class, more than once on the declaration of <code class="prettyprint">Class1</code>.</p>

<p>An expression <code class="prettyprint">E</code> is an <em>attribute_argument_expression</em> if all of the following statements are true:</p>

<ul>
<li> The type of <code class="prettyprint">E</code> is an attribute parameter type (<a href="attributes.md#attribute-parameter-types">Attribute parameter types</a>).</li>
<li> At compile-time, the value of <code class="prettyprint">E</code> can be resolved to one of the following:

<ul>
<li>A constant value.</li>
<li>A <code class="prettyprint">System.Type</code> object.</li>
<li>A one-dimensional array of *attribute_argument_expression*s.</li>
</ul></li>
</ul>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="na">[AttributeUsage(AttributeTargets.Class)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TestAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">P1</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{...}</span>
        <span class="k">set</span> <span class="p">{...}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Type</span> <span class="n">P2</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{...}</span>
        <span class="k">set</span> <span class="p">{...}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">object</span> <span class="n">P3</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{...}</span>
        <span class="k">set</span> <span class="p">{...}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="na">[Test(P1 = 1234, P3 = new int[]</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">},</span> <span class="n">P2</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">float</span><span class="p">))]</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{}</span>
</code></pre>
<p>A <em>typeof_expression</em> (<a href="expressions.md#the-typeof-operator">The typeof operator</a>) used as an attribute argument expression can reference a non-generic type, a closed constructed type, or an unbound generic type, but it cannot reference an open type. This is to ensure that the expression can be resolved at compile-time.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="n">Type</span> <span class="n">t</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">G</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">A</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">))]</span> <span class="n">T</span> <span class="n">t</span><span class="p">;</span>                  <span class="c1">// Error, open type in attribute</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">A</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;))]</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>        <span class="c1">// Ok, closed constructed type</span>
    <span class="p">[</span><span class="nf">A</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;&gt;))]</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>           <span class="c1">// Ok, unbound generic type</span>
<span class="p">}</span>
</code></pre>
<h2 id="attribute-instances">Attribute instances</h2>

<p>An <strong><em>attribute instance</em></strong> is an instance that represents an attribute at run-time. An attribute is defined with an attribute class, positional arguments, and named arguments. An attribute instance is an instance of the attribute class that is initialized with the positional and named arguments.</p>

<p>Retrieval of an attribute instance involves both compile-time and run-time processing, as described in the following sections.</p>

<h3 id="compilation-of-an-attribute">Compilation of an attribute</h3>

<p>The compilation of an <em>attribute</em> with attribute class <code class="prettyprint">T</code>, <em>positional_argument_list</em> <code class="prettyprint">P</code> and <em>named_argument_list</em> <code class="prettyprint">N</code>, consists of the following steps:</p>

<ul>
<li> Follow the compile-time processing steps for compiling an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(P)</code>. These steps either result in a compile-time error, or determine an instance constructor <code class="prettyprint">C</code> on <code class="prettyprint">T</code> that can be invoked at run-time.</li>
<li> If <code class="prettyprint">C</code> does not have public accessibility, then a compile-time error occurs.</li>
<li> For each <em>named_argument</em> <code class="prettyprint">Arg</code> in <code class="prettyprint">N</code>:

<ul>
<li>Let <code class="prettyprint">Name</code> be the <em>identifier</em> of the <em>named_argument</em> <code class="prettyprint">Arg</code>.</li>
<li><code class="prettyprint">Name</code> must identify a non-static read-write public field or property on <code class="prettyprint">T</code>. If <code class="prettyprint">T</code> has no such field or property, then a compile-time error occurs.</li>
</ul></li>
<li> Keep the following information for run-time instantiation of the attribute: the attribute class <code class="prettyprint">T</code>, the instance constructor <code class="prettyprint">C</code> on <code class="prettyprint">T</code>, the <em>positional_argument_list</em> <code class="prettyprint">P</code> and the <em>named_argument_list</em> <code class="prettyprint">N</code>.</li>
</ul>

<h3 id="run-time-retrieval-of-an-attribute-instance">Run-time retrieval of an attribute instance</h3>

<p>Compilation of an <em>attribute</em> yields an attribute class <code class="prettyprint">T</code>, an instance constructor <code class="prettyprint">C</code> on <code class="prettyprint">T</code>, a <em>positional_argument_list</em> <code class="prettyprint">P</code>, and a <em>named_argument_list</em> <code class="prettyprint">N</code>. Given this information, an attribute instance can be retrieved at run-time using the following steps:</p>

<ul>
<li> Follow the run-time processing steps for executing an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(P)</code>, using the instance constructor <code class="prettyprint">C</code> as determined at compile-time. These steps either result in an exception, or produce an instance <code class="prettyprint">O</code> of <code class="prettyprint">T</code>.</li>
<li> For each <em>named_argument</em> <code class="prettyprint">Arg</code> in <code class="prettyprint">N</code>, in order:

<ul>
<li>Let <code class="prettyprint">Name</code> be the <em>identifier</em> of the <em>named_argument</em> <code class="prettyprint">Arg</code>. If <code class="prettyprint">Name</code> does not identify a non-static public read-write field or property on <code class="prettyprint">O</code>, then an exception is thrown.</li>
<li>Let <code class="prettyprint">Value</code> be the result of evaluating the <em>attribute_argument_expression</em> of <code class="prettyprint">Arg</code>.</li>
<li>If <code class="prettyprint">Name</code> identifies a field on <code class="prettyprint">O</code>, then set this field to <code class="prettyprint">Value</code>.</li>
<li>Otherwise, <code class="prettyprint">Name</code> identifies a property on <code class="prettyprint">O</code>. Set this property to <code class="prettyprint">Value</code>.</li>
<li>The result is <code class="prettyprint">O</code>, an instance of the attribute class <code class="prettyprint">T</code> that has been initialized with the <em>positional_argument_list</em> <code class="prettyprint">P</code> and the <em>named_argument_list</em> <code class="prettyprint">N</code>.</li>
</ul></li>
</ul>

<h2 id="reserved-attributes">Reserved attributes</h2>

<p>A small number of attributes affect the language in some way. These attributes include:</p>

<ul>
<li> <code class="prettyprint">System.AttributeUsageAttribute</code> (<a href="attributes.md#the-attributeusage-attribute">The AttributeUsage attribute</a>), which is used to describe the ways in which an attribute class can be used.</li>
<li> <code class="prettyprint">System.Diagnostics.ConditionalAttribute</code> (<a href="attributes.md#the-conditional-attribute">The Conditional attribute</a>), which is used to define conditional methods.</li>
<li> <code class="prettyprint">System.ObsoleteAttribute</code> (<a href="attributes.md#the-obsolete-attribute">The Obsolete attribute</a>), which is used to mark a member as obsolete.</li>
<li> <code class="prettyprint">System.Runtime.CompilerServices.CallerLineNumberAttribute</code>, <code class="prettyprint">System.Runtime.CompilerServices.CallerFilePathAttribute</code> and <code class="prettyprint">System.Runtime.CompilerServices.CallerMemberNameAttribute</code> (<a href="attributes.md#caller-info-attributes">Caller info attributes</a>), which are used to supply information about the calling context to optional parameters.</li>
</ul>

<h3 id="the-attributeusage-attribute">The AttributeUsage attribute</h3>

<p>The attribute <code class="prettyprint">AttributeUsage</code> is used to describe the manner in which the attribute class can be used.</p>

<p>A class that is decorated with the <code class="prettyprint">AttributeUsage</code> attribute must derive from <code class="prettyprint">System.Attribute</code>, either directly or indirectly. Otherwise, a compile-time error occurs.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">System</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span><span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Class</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">AttributeUsageAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">AttributeUsageAttribute</span><span class="p">(</span><span class="n">AttributeTargets</span> <span class="n">validOn</span><span class="p">)</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">AllowMultiple</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="k">set</span> <span class="p">{...}</span> <span class="p">}</span>
        <span class="k">public</span> <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Inherited</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="k">set</span> <span class="p">{...}</span> <span class="p">}</span>
        <span class="k">public</span> <span class="k">virtual</span> <span class="n">AttributeTargets</span> <span class="n">ValidOn</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">enum</span> <span class="n">AttributeTargets</span>
    <span class="p">{</span>
        <span class="n">Assembly</span>     <span class="p">=</span> <span class="m">0x0001</span><span class="p">,</span>
        <span class="n">Module</span>       <span class="p">=</span> <span class="m">0x0002</span><span class="p">,</span>
        <span class="n">Class</span>        <span class="p">=</span> <span class="m">0x0004</span><span class="p">,</span>
        <span class="n">Struct</span>       <span class="p">=</span> <span class="m">0x0008</span><span class="p">,</span>
        <span class="n">Enum</span>         <span class="p">=</span> <span class="m">0x0010</span><span class="p">,</span>
        <span class="n">Constructor</span>  <span class="p">=</span> <span class="m">0x0020</span><span class="p">,</span>
        <span class="n">Method</span>       <span class="p">=</span> <span class="m">0x0040</span><span class="p">,</span>
        <span class="n">Property</span>     <span class="p">=</span> <span class="m">0x0080</span><span class="p">,</span>
        <span class="n">Field</span>        <span class="p">=</span> <span class="m">0x0100</span><span class="p">,</span>
        <span class="n">Event</span>        <span class="p">=</span> <span class="m">0x0200</span><span class="p">,</span>
        <span class="n">Interface</span>    <span class="p">=</span> <span class="m">0x0400</span><span class="p">,</span>
        <span class="n">Parameter</span>    <span class="p">=</span> <span class="m">0x0800</span><span class="p">,</span>
        <span class="n">Delegate</span>     <span class="p">=</span> <span class="m">0x1000</span><span class="p">,</span>
        <span class="n">ReturnValue</span>  <span class="p">=</span> <span class="m">0x2000</span><span class="p">,</span>

        <span class="n">All</span> <span class="p">=</span> <span class="n">Assembly</span> <span class="p">|</span> <span class="n">Module</span> <span class="p">|</span> <span class="n">Class</span> <span class="p">|</span> <span class="n">Struct</span> <span class="p">|</span> <span class="n">Enum</span> <span class="p">|</span> <span class="n">Constructor</span> <span class="p">|</span> 
            <span class="n">Method</span> <span class="p">|</span> <span class="n">Property</span> <span class="p">|</span> <span class="n">Field</span> <span class="p">|</span> <span class="n">Event</span> <span class="p">|</span> <span class="n">Interface</span> <span class="p">|</span> <span class="n">Parameter</span> <span class="p">|</span> 
            <span class="n">Delegate</span> <span class="p">|</span> <span class="n">ReturnValue</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="the-conditional-attribute">The Conditional attribute</h3>

<p>The attribute <code class="prettyprint">Conditional</code> enables the definition of <strong><em>conditional methods</em></strong> and <strong><em>conditional attribute classes</em></strong>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">System.Diagnostics</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span><span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Method</span> <span class="p">|</span> <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Class</span><span class="p">,</span> <span class="n">AllowMultiple</span> <span class="p">=</span> <span class="k">true</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">ConditionalAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ConditionalAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">conditionString</span><span class="p">)</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">ConditionString</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h4 id="conditional-methods">Conditional methods</h4>

<p>A method decorated with the <code class="prettyprint">Conditional</code> attribute is a conditional method. The <code class="prettyprint">Conditional</code> attribute indicates a condition by testing a conditional compilation symbol. Calls to a conditional method are either included or omitted depending on whether this symbol is defined at the point of the call. If the symbol is defined, the call is included; otherwise, the call (including evaluation of the receiver and parameters of the call) is omitted.</p>

<p>A conditional method is subject to the following restrictions:</p>

<ul>
<li> The conditional method must be a method in a <em>class_declaration</em> or <em>struct_declaration</em>. A compile-time error occurs if the <code class="prettyprint">Conditional</code> attribute is specified on a method in an interface declaration.</li>
<li> The conditional method must have a return type of <code class="prettyprint">void</code>.</li>
<li> The conditional method must not be marked with the <code class="prettyprint">override</code> modifier. A conditional method may be marked with the <code class="prettyprint">virtual</code> modifier, however. Overrides of such a method are implicitly conditional, and must not be explicitly marked with a <code class="prettyprint">Conditional</code> attribute.</li>
<li> The conditional method must not be an implementation of an interface method. Otherwise, a compile-time error occurs.</li>
</ul>

<p>In addition, a compile-time error occurs if a conditional method is used in a <em>delegate_creation_expression</em>. The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#define DEBUG
</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Class1</span> 
<span class="p">{</span>
    <span class="p">[</span><span class="nf">Conditional</span><span class="p">(</span><span class="s">"DEBUG"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Executed Class1.M"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Class2</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class1</span><span class="p">.</span><span class="nf">M</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>declares <code class="prettyprint">Class1.M</code> as a conditional method. <code class="prettyprint">Class2</code>&lsquo;s <code class="prettyprint">Test</code> method calls this method. Since the conditional compilation symbol <code class="prettyprint">DEBUG</code> is defined, if <code class="prettyprint">Class2.Test</code> is called, it will call <code class="prettyprint">M</code>. If the symbol <code class="prettyprint">DEBUG</code> had not been defined, then <code class="prettyprint">Class2.Test</code> would not call <code class="prettyprint">Class1.M</code>.</p>

<p>It is important to note that the inclusion or exclusion of a call to a conditional method is controlled by the conditional compilation symbols at the point of the call. In the example</p>

<p>File <code class="prettyprint">class1.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Class1</span> 
<span class="p">{</span>
    <span class="p">[</span><span class="nf">Conditional</span><span class="p">(</span><span class="s">"DEBUG"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Executed Class1.F"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>File <code class="prettyprint">class2.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#define DEBUG
</span>
<span class="k">class</span> <span class="nc">Class2</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class1</span><span class="p">.</span><span class="nf">F</span><span class="p">();</span>                <span class="c1">// F is called</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>File <code class="prettyprint">class3.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#undef DEBUG
</span>
<span class="k">class</span> <span class="nc">Class3</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">H</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class1</span><span class="p">.</span><span class="nf">F</span><span class="p">();</span>                <span class="c1">// F is not called</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>the classes <code class="prettyprint">Class2</code> and <code class="prettyprint">Class3</code> each contain calls to the conditional method <code class="prettyprint">Class1.F</code>, which is conditional based on whether or not <code class="prettyprint">DEBUG</code> is defined. Since this symbol is defined in the context of <code class="prettyprint">Class2</code> but not <code class="prettyprint">Class3</code>, the call to <code class="prettyprint">F</code> in <code class="prettyprint">Class2</code> is included, while the call to <code class="prettyprint">F</code> in <code class="prettyprint">Class3</code> is omitted.</p>

<p>The use of conditional methods in an inheritance chain can be confusing. Calls made to a conditional method through <code class="prettyprint">base</code>, of the form <code class="prettyprint">base.M</code>, are subject to the normal conditional method call rules. In the example</p>

<p>File <code class="prettyprint">class1.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Class1</span> 
<span class="p">{</span>
    <span class="p">[</span><span class="nf">Conditional</span><span class="p">(</span><span class="s">"DEBUG"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Class1.M executed"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>File <code class="prettyprint">class2.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Class2</span><span class="p">:</span> <span class="n">Class1</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Class2.M executed"</span><span class="p">);</span>
        <span class="k">base</span><span class="p">.</span><span class="nf">M</span><span class="p">();</span>                        <span class="c1">// base.M is not called!</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>File <code class="prettyprint">class3.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#define DEBUG
</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Class3</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Class2</span> <span class="n">c</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Class2</span><span class="p">();</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">M</span><span class="p">();</span>                            <span class="c1">// M is called</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code class="prettyprint">Class2</code> includes a call to the <code class="prettyprint">M</code> defined in its base class. This call is omitted because the base method is conditional based on the presence of the symbol <code class="prettyprint">DEBUG</code>, which is undefined. Thus, the method writes to the console &ldquo;<code class="prettyprint">Class2.M executed</code>&rdquo; only. Judicious use of *pp_declaration*s can eliminate such problems.</p>

<h4 id="conditional-attribute-classes">Conditional attribute classes</h4>

<p>An attribute class (<a href="attributes.md#attribute-classes">Attribute classes</a>) decorated with one or more <code class="prettyprint">Conditional</code> attributes is a <strong><em>conditional attribute class</em></strong>. A conditional attribute class is thus associated with the conditional compilation symbols declared in its <code class="prettyprint">Conditional</code> attributes. This example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
<span class="na">[Conditional("ALPHA")]</span>
<span class="na">[Conditional("BETA")]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TestAttribute</span> <span class="p">:</span> <span class="n">Attribute</span> <span class="p">{}</span>
</code></pre>
<p>declares <code class="prettyprint">TestAttribute</code> as a conditional attribute class associated with the conditional compilations symbols <code class="prettyprint">ALPHA</code> and <code class="prettyprint">BETA</code>.</p>

<p>Attribute specifications (<a href="attributes.md#attribute-specification">Attribute specification</a>) of a conditional attribute are included if one or more of its associated conditional compilation symbols is defined at the point of specification, otherwise the attribute specification is omitted.</p>

<p>It is important to note that the inclusion or exclusion of an attribute specification of a conditional attribute class is controlled by the conditional compilation symbols at the point of the specification. In the example</p>

<p>File <code class="prettyprint">test.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>

<span class="na">[Conditional("DEBUG")]</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">TestAttribute</span> <span class="p">:</span> <span class="n">Attribute</span> <span class="p">{}</span>
</code></pre>
<p>File <code class="prettyprint">class1.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#define DEBUG
</span>
<span class="na">[Test]</span>                <span class="c1">// TestAttribute is specified</span>

<span class="k">class</span> <span class="nc">Class1</span> <span class="p">{}</span>
</code></pre>
<p>File <code class="prettyprint">class2.cs</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="cp">#undef DEBUG
</span>
<span class="na">[Test]</span>                 <span class="c1">// TestAttribute is not specified</span>

<span class="k">class</span> <span class="nc">Class2</span> <span class="p">{}</span>
</code></pre>
<p>the classes <code class="prettyprint">Class1</code> and <code class="prettyprint">Class2</code> are each decorated with attribute <code class="prettyprint">Test</code>, which is conditional based on whether or not <code class="prettyprint">DEBUG</code> is defined. Since this symbol is defined in the context of <code class="prettyprint">Class1</code> but not <code class="prettyprint">Class2</code>, the specification of the <code class="prettyprint">Test</code> attribute on <code class="prettyprint">Class1</code> is included, while the specification of the <code class="prettyprint">Test</code> attribute on <code class="prettyprint">Class2</code> is omitted.</p>

<h3 id="the-obsolete-attribute">The Obsolete attribute</h3>

<p>The attribute <code class="prettyprint">Obsolete</code> is used to mark types and members of types that should no longer be used.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">System</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span>
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Class</span> <span class="p">|</span> 
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Struct</span> <span class="p">|</span>
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Enum</span> <span class="p">|</span> 
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Interface</span> <span class="p">|</span> 
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Delegate</span> <span class="p">|</span>
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Method</span> <span class="p">|</span> 
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Constructor</span> <span class="p">|</span>
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Property</span> <span class="p">|</span> 
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Field</span> <span class="p">|</span>
        <span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Event</span><span class="p">,</span>
        <span class="n">Inherited</span> <span class="p">=</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">ObsoleteAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ObsoleteAttribute</span><span class="p">()</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="nf">ObsoleteAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="nf">ObsoleteAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">error</span><span class="p">)</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Message</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsError</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>If a program uses a type or member that is decorated with the <code class="prettyprint">Obsolete</code> attribute, the compiler issues a warning or an error. Specifically, the compiler issues a warning if no error parameter is provided, or if the error parameter is provided and has the value <code class="prettyprint">false</code>. The compiler issues an error if the error parameter is specified and has the value <code class="prettyprint">true</code>.</p>

<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Obsolete("This class is obsolete; use class B instead")]</span>
<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">A</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">A</span><span class="p">();</span>         <span class="c1">// Warning</span>
        <span class="n">a</span><span class="p">.</span><span class="nf">F</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>the class <code class="prettyprint">A</code> is decorated with the <code class="prettyprint">Obsolete</code> attribute. Each use of <code class="prettyprint">A</code> in <code class="prettyprint">Main</code> results in a warning that includes the specified message, &ldquo;This class is obsolete; use class B instead.&rdquo;</p>

<h3 id="caller-info-attributes">Caller info attributes</h3>

<p>For purposes such as logging and reporting, it is sometimes useful for a function member to obtain certain compile-time information about the calling code. The caller info attributes provide a way to pass such information transparently.</p>

<p>When an optional parameter is annotated with one of the caller info attributes, omitting the corresponding argument in a call does not necessarily cause the default parameter value to be substituted. Instead, if the specified information about the calling context is available, that information will be passed as the argument value.</p>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System.Runtime.CompilerServices</span>

<span class="p">...</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span>
    <span class="p">[</span><span class="n">CallerLineNumber</span><span class="p">]</span> <span class="kt">int</span> <span class="n">line</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span>
    <span class="p">[</span><span class="n">CallerFilePath</span><span class="p">]</span>   <span class="kt">string</span> <span class="n">path</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span>
    <span class="p">[</span><span class="n">CallerMemberName</span><span class="p">]</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">=</span> <span class="k">null</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">((</span><span class="n">line</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">?</span> <span class="s">"No line"</span> <span class="p">:</span> <span class="s">"Line "</span><span class="p">+</span> <span class="n">line</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">((</span><span class="n">path</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="s">"No file path"</span> <span class="p">:</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">((</span><span class="n">name</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="s">"No member name"</span> <span class="p">:</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>A call to <code class="prettyprint">Log()</code> with no arguments would print the line number and file path of the call, as well as the name of the member within which the call occurred.</p>

<p>Caller info attributes can occur on optional parameters anywhere, including in delegate declarations. However, the specific caller info attributes have restrictions on the types of the parameters they can attribute, so that there will always be an implicit conversion from a substituted value to the parameter type.</p>

<p>It is an error to have the same caller info attribute on a parameter of both the defining and implementing part of a partial method declaration. Only caller info attributes in the defining part are applied, whereas caller info attributes occurring only in the implementing part are ignored.</p>

<p>Caller information does not affect overload resolution. As the attributed optional parameters are still omitted from the source code of the caller, overload resolution ignores those parameters in the same way it ignores other omitted optional parameters (<a href="expressions.md#overload-resolution">Overload resolution</a>).</p>

<p>Caller information is only substituted when a function is explicitly invoked in source code. Implicit invocations such as implicit parent constructor calls do not have a source location and will not substitute caller information. Also, calls that are dynamically bound will not substitute caller information. When a caller info attributed parameter is omitted in such cases, the specified default value of the parameter is used instead.</p>

<p>One exception is query-expressions. These are considered syntactic expansions, and if the calls they expand to omit optional parameters with caller info attributes, caller information will be substituted. The location used is the location of the query clause which the call was generated from.</p>

<p>If more than one caller info attribute is specified on a given parameter, they are preferred in the following order: <code class="prettyprint">CallerLineNumber</code>, <code class="prettyprint">CallerFilePath</code>, <code class="prettyprint">CallerMemberName</code>.</p>

<h4 id="the-callerlinenumber-attribute">The CallerLineNumber attribute</h4>

<p>The <code class="prettyprint">System.Runtime.CompilerServices.CallerLineNumberAttribute</code> is allowed on optional parameters when there is a standard implicit conversion (<a href="conversions.md#standard-implicit-conversions">Standard implicit conversions</a>) from the constant value <code class="prettyprint">int.MaxValue</code> to the parameter&rsquo;s type. This ensures that any non-negative line number up to that value can be passed without error.</p>

<p>If a function invocation from a location in source code omits an optional parameter with the <code class="prettyprint">CallerLineNumberAttribute</code>, then a numeric literal representing that location&rsquo;s line number is used as an argument to the invocation instead of the default parameter value.</p>

<p>If the invocation spans multiple lines, the line chosen is implementation-dependent.</p>

<p>Note that the line number may be affected by <code class="prettyprint">#line</code> directives (<a href="lexical-structure.md#line-directives">Line directives</a>).</p>

<h4 id="the-callerfilepath-attribute">The CallerFilePath attribute</h4>

<p>The <code class="prettyprint">System.Runtime.CompilerServices.CallerFilePathAttribute</code> is allowed on optional parameters when there is a standard implicit conversion (<a href="conversions.md#standard-implicit-conversions">Standard implicit conversions</a>) from <code class="prettyprint">string</code> to the parameter&rsquo;s type.</p>

<p>If a function invocation from a location in source code omits an optional parameter with the <code class="prettyprint">CallerFilePathAttribute</code>, then a string literal representing that location&rsquo;s file path is used as an argument to the invocation instead of the default parameter value.</p>

<p>The format of the file path is implementation-dependent.</p>

<p>Note that the file path may be affected by <code class="prettyprint">#line</code> directives (<a href="lexical-structure.md#line-directives">Line directives</a>).</p>

<h4 id="the-callermembername-attribute">The CallerMemberName attribute</h4>

<p>The <code class="prettyprint">System.Runtime.CompilerServices.CallerMemberNameAttribute</code> is allowed on optional parameters when there is a standard implicit conversion (<a href="conversions.md#standard-implicit-conversions">Standard implicit conversions</a>) from <code class="prettyprint">string</code> to the parameter&rsquo;s type.</p>

<p>If a function invocation from a location within the body of a function member or within an attribute applied to the function member itself or its return type, parameters or type parameters in source code omits an optional parameter with the <code class="prettyprint">CallerMemberNameAttribute</code>, then a string literal representing the name of that member is used as an argument to the invocation instead of the default parameter value.</p>

<p>For invocations that occur within generic methods, only the method name itself is used, without the type parameter list.</p>

<p>For invocations that occur within explicit interface member implementations, only the method name itself is used, without the preceding interface qualification.</p>

<p>For invocations that occur within property or event accessors, the member name used is that of the property or event itself.</p>

<p>For invocations that occur within indexer accessors, the member name used is that supplied by an <code class="prettyprint">IndexerNameAttribute</code> (<a href="attributes.md#the-indexername-attribute">The IndexerName attribute</a>) on the indexer member, if present, or the default name <code class="prettyprint">Item</code> otherwise.</p>

<p>For invocations that occur within declarations of instance constructors, static constructors, destructors and operators the member name used is implementation-dependent.</p>

<h2 id="attributes-for-interoperation">Attributes for Interoperation</h2>

<p>Note: This section is applicable only to the Microsoft .NET implementation of C#.</p>

<h3 id="interoperation-with-com-and-win32-components">Interoperation with COM and Win32 components</h3>

<p>The .NET run-time provides a large number of attributes that enable C# programs to interoperate with components written using COM and Win32 DLLs. For example, the <code class="prettyprint">DllImport</code> attribute can be used on a <code class="prettyprint">static extern</code> method to indicate that the implementation of the method is to be found in a Win32 DLL. These attributes are found in the <code class="prettyprint">System.Runtime.InteropServices</code> namespace, and detailed documentation for these attributes is found in the .NET runtime documentation.</p>

<h3 id="interoperation-with-other-net-languages">Interoperation with other .NET languages</h3>

<h4 id="the-indexername-attribute">The IndexerName attribute</h4>

<p>Indexers are implemented in .NET using indexed properties, and have a name in the .NET metadata. If no <code class="prettyprint">IndexerName</code> attribute is present for an indexer, then the name <code class="prettyprint">Item</code> is used by default. The <code class="prettyprint">IndexerName</code> attribute enables a developer to override this default and specify a different name.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">System.Runtime.CompilerServices.CSharp</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span><span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Property</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">IndexerNameAttribute</span><span class="p">:</span> <span class="n">Attribute</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">IndexerNameAttribute</span><span class="p">(</span><span class="kt">string</span> <span class="n">indexerName</span><span class="p">)</span> <span class="p">{...}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{...}</span> <span class="p">}</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
          <h1 id="unsafe-code">Unsafe code</h1>

<p>The core C# language, as defined in the preceding chapters, differs notably from C and C++ in its omission of pointers as a data type. Instead, C# provides references and the ability to create objects that are managed by a garbage collector. This design, coupled with other features, makes C# a much safer language than C or C++. In the core C# language it is simply not possible to have an uninitialized variable, a &ldquo;dangling&rdquo; pointer, or an expression that indexes an array beyond its bounds. Whole categories of bugs that routinely plague C and C++ programs are thus eliminated.</p>

<p>While practically every pointer type construct in C or C++ has a reference type counterpart in C#, nonetheless, there are situations where access to pointer types becomes a necessity. For example, interfacing with the underlying operating system, accessing a memory-mapped device, or implementing a time-critical algorithm may not be possible or practical without access to pointers. To address this need, C# provides the ability to write <strong><em>unsafe code</em></strong>.</p>

<p>In unsafe code it is possible to declare and operate on pointers, to perform conversions between pointers and integral types, to take the address of variables, and so forth. In a sense, writing unsafe code is much like writing C code within a C# program.</p>

<p>Unsafe code is in fact a &ldquo;safe&rdquo; feature from the perspective of both developers and users. Unsafe code must be clearly marked with the modifier <code class="prettyprint">unsafe</code>, so developers can&rsquo;t possibly use unsafe features accidentally, and the execution engine works to ensure that unsafe code cannot be executed in an untrusted environment.</p>

<h2 id="unsafe-contexts">Unsafe contexts</h2>

<p>The unsafe features of C# are available only in unsafe contexts. An unsafe context is introduced by including an <code class="prettyprint">unsafe</code> modifier in the declaration of a type or member, or by employing an <em>unsafe_statement</em>:</p>

<ul>
<li> A declaration of a class, struct, interface, or delegate may include an <code class="prettyprint">unsafe</code> modifier, in which case the entire textual extent of that type declaration (including the body of the class, struct, or interface) is considered an unsafe context.</li>
<li> A declaration of a field, method, property, event, indexer, operator, instance constructor, destructor, or static constructor may include an <code class="prettyprint">unsafe</code> modifier, in which case the entire textual extent of that member declaration is considered an unsafe context.</li>
<li> An <em>unsafe_statement</em> enables the use of an unsafe context within a <em>block</em>. The entire textual extent of the associated <em>block</em> is considered an unsafe context.</li>
</ul>

<p>The associated grammar productions are shown below.</p>
<pre class="highlight shell"><code>class_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

struct_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

interface_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

delegate_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

field_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

method_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

property_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

event_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

indexer_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

operator_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

constructor_modifier_unsafe
    : <span class="s1">'unsafe'</span>
    ;

destructor_declaration_unsafe
    : attributes? <span class="s1">'extern'</span>? <span class="s1">'unsafe'</span>? <span class="s1">'~'</span> identifier <span class="s1">'('</span> <span class="s1">')'</span> destructor_body
    | attributes? <span class="s1">'unsafe'</span>? <span class="s1">'extern'</span>? <span class="s1">'~'</span> identifier <span class="s1">'('</span> <span class="s1">')'</span> destructor_body
    ;

static_constructor_modifiers_unsafe
    : <span class="s1">'extern'</span>? <span class="s1">'unsafe'</span>? <span class="s1">'static'</span>
    | <span class="s1">'unsafe'</span>? <span class="s1">'extern'</span>? <span class="s1">'static'</span>
    | <span class="s1">'extern'</span>? <span class="s1">'static'</span> <span class="s1">'unsafe'</span>?
    | <span class="s1">'unsafe'</span>? <span class="s1">'static'</span> <span class="s1">'extern'</span>?
    | <span class="s1">'static'</span> <span class="s1">'extern'</span>? <span class="s1">'unsafe'</span>?
    | <span class="s1">'static'</span> <span class="s1">'unsafe'</span>? <span class="s1">'extern'</span>?
    ;

embedded_statement_unsafe
    : unsafe_statement
    | fixed_statement
    ;

unsafe_statement
    : <span class="s1">'unsafe'</span> block
    ;
</code></pre>
<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">Node</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Node</span><span class="p">*</span> <span class="n">Left</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Node</span><span class="p">*</span> <span class="n">Right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>the <code class="prettyprint">unsafe</code> modifier specified in the struct declaration causes the entire textual extent of the struct declaration to become an unsafe context. Thus, it is possible to declare the <code class="prettyprint">Left</code> and <code class="prettyprint">Right</code> fields to be of a pointer type. The example above could also be written</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">Node</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">unsafe</span> <span class="n">Node</span><span class="p">*</span> <span class="n">Left</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">unsafe</span> <span class="n">Node</span><span class="p">*</span> <span class="n">Right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Here, the <code class="prettyprint">unsafe</code> modifiers in the field declarations cause those declarations to be considered unsafe contexts.</p>

<p>Other than establishing an unsafe context, thus permitting the use of pointer types, the <code class="prettyprint">unsafe</code> modifier has no effect on a type or a member. In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">unsafe</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">char</span><span class="p">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">base</span><span class="p">.</span><span class="nf">F</span><span class="p">();</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>the <code class="prettyprint">unsafe</code> modifier on the <code class="prettyprint">F</code> method in <code class="prettyprint">A</code> simply causes the textual extent of <code class="prettyprint">F</code> to become an unsafe context in which the unsafe features of the language can be used. In the override of <code class="prettyprint">F</code> in <code class="prettyprint">B</code>, there is no need to re-specify the <code class="prettyprint">unsafe</code> modifier &ndash; unless, of course, the <code class="prettyprint">F</code> method in <code class="prettyprint">B</code> itself needs access to unsafe features.</p>

<p>The situation is slightly different when a pointer type is part of the method&rsquo;s signature</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">unsafe</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">unsafe</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>Here, because <code class="prettyprint">F</code>&lsquo;s signature includes a pointer type, it can only be written in an unsafe context. However, the unsafe context can be introduced by either making the entire class unsafe, as is the case in <code class="prettyprint">A</code>, or by including an <code class="prettyprint">unsafe</code> modifier in the method declaration, as is the case in <code class="prettyprint">B</code>.</p>

<h2 id="pointer-types">Pointer types</h2>

<p>In an unsafe context, a <em>type</em> (<a href="types.md#types">Types</a>) may be a <em>pointer_type</em> as well as a <em>value_type</em> or a <em>reference_type</em>. However, a <em>pointer_type</em> may also be used in a <code class="prettyprint">typeof</code> expression (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) outside of an unsafe context as such usage is not unsafe.</p>
<pre class="highlight shell"><code>type_unsafe
    : pointer_type
    ;
</code></pre>
<p>A <em>pointer_type</em> is written as an <em>unmanaged_type</em> or the keyword <code class="prettyprint">void</code>, followed by a <code class="prettyprint">*</code> token:</p>
<pre class="highlight shell"><code>pointer_type
    : unmanaged_type <span class="s1">'*'</span>
    | <span class="s1">'void'</span> <span class="s1">'*'</span>
    ;

unmanaged_type
    : <span class="nb">type</span>
    ;
</code></pre>
<p>The type specified before the <code class="prettyprint">*</code> in a pointer type is called the <strong><em>referent type</em></strong> of the pointer type. It represents the type of the variable to which a value of the pointer type points.</p>

<p>Unlike references (values of reference types), pointers are not tracked by the garbage collector &ndash; the garbage collector has no knowledge of pointers and the data to which they point. For this reason a pointer is not permitted to point to a reference or to a struct that contains references, and the referent type of a pointer must be an <em>unmanaged_type</em>.</p>

<p>An <em>unmanaged_type</em> is any type that isn&rsquo;t a <em>reference_type</em> or constructed type, and doesn&rsquo;t contain <em>reference_type</em> or constructed type fields at any level of nesting. In other words, an <em>unmanaged_type</em> is one of the following:</p>

<ul>
<li> <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, or <code class="prettyprint">bool</code>.</li>
<li> Any <em>enum_type</em>.</li>
<li> Any <em>pointer_type</em>.</li>
<li> Any user-defined <em>struct_type</em> that is not a constructed type and contains fields of *unmanaged_type*s only.</li>
</ul>

<p>The intuitive rule for mixing of pointers and references is that referents of references (objects) are permitted to contain pointers, but referents of pointers are not permitted to contain references.</p>

<p>Some examples of pointer types are given in the table below:</p>

<table><thead>
<tr>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">byte*</code></td>
<td>Pointer to <code class="prettyprint">byte</code></td>
</tr>
<tr>
<td><code class="prettyprint">char*</code></td>
<td>Pointer to <code class="prettyprint">char</code></td>
</tr>
<tr>
<td><code class="prettyprint">int**</code></td>
<td>Pointer to pointer to <code class="prettyprint">int</code></td>
</tr>
<tr>
<td><code class="prettyprint">int*[]</code></td>
<td>Single-dimensional array of pointers to <code class="prettyprint">int</code></td>
</tr>
<tr>
<td><code class="prettyprint">void*</code></td>
<td>Pointer to unknown type</td>
</tr>
</tbody></table>

<p>For a given implementation, all pointer types must have the same size and representation.</p>

<p>Unlike C and C++, when multiple pointers are declared in the same declaration, in C# the <code class="prettyprint">*</code> is written along with the underlying type only, not as a prefix punctuator on each pointer name. For example</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span><span class="p">*</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">;</span>    <span class="c1">// NOT as int *pi, *pj;</span>
</code></pre>
<p>The value of a pointer having type <code class="prettyprint">T*</code> represents the address of a variable of type <code class="prettyprint">T</code>. The pointer indirection operator <code class="prettyprint">*</code> (<a href="unsafe-code.md#pointer-indirection">Pointer indirection</a>) may be used to access this variable. For example, given a variable <code class="prettyprint">P</code> of type <code class="prettyprint">int*</code>, the expression <code class="prettyprint">*P</code> denotes the <code class="prettyprint">int</code> variable found at the address contained in <code class="prettyprint">P</code>.</p>

<p>Like an object reference, a pointer may be <code class="prettyprint">null</code>. Applying the indirection operator to a <code class="prettyprint">null</code> pointer results in implementation-defined behavior. A pointer with value <code class="prettyprint">null</code> is represented by all-bits-zero.</p>

<p>The <code class="prettyprint">void*</code> type represents a pointer to an unknown type. Because the referent type is unknown, the indirection operator cannot be applied to a pointer of type <code class="prettyprint">void*</code>, nor can any arithmetic be performed on such a pointer. However, a pointer of type <code class="prettyprint">void*</code> can be cast to any other pointer type (and vice versa).</p>

<p>Pointer types are a separate category of types. Unlike reference types and value types, pointer types do not inherit from <code class="prettyprint">object</code> and no conversions exist between pointer types and <code class="prettyprint">object</code>. In particular, boxing and unboxing (<a href="types.md#boxing-and-unboxing">Boxing and unboxing</a>) are not supported for pointers. However, conversions are permitted between different pointer types and between pointer types and the integral types. This is described in <a href="unsafe-code.md#pointer-conversions">Pointer conversions</a>.</p>

<p>A <em>pointer_type</em> cannot be used as a type argument (<a href="types.md#constructed-types">Constructed types</a>), and type inference (<a href="expressions.md#type-inference">Type inference</a>) fails on generic method calls that would have inferred a type argument to be a pointer type.</p>

<p>A <em>pointer_type</em> may be used as the type of a volatile field (<a href="classes.md#volatile-fields">Volatile fields</a>).</p>

<p>Although pointers can be passed as <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters, doing so can cause undefined behavior, since the pointer may well be set to point to a local variable which no longer exists when the called method returns, or the fixed object to which it used to point, is no longer fixed. For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="k">value</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span><span class="p">*</span> <span class="n">pi1</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">int</span><span class="p">*</span> <span class="n">pi2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="n">pi1</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">i</span><span class="p">;</span>

        <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">pj</span> <span class="p">=</span> <span class="p">&amp;</span><span class="k">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="n">pi2</span> <span class="p">=</span> <span class="n">pj</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">px1</span><span class="p">;</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">px2</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">i</span><span class="p">;</span>

            <span class="nf">F</span><span class="p">(</span><span class="k">out</span> <span class="n">px1</span><span class="p">,</span> <span class="k">ref</span> <span class="n">px2</span><span class="p">);</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"*px1 = {0}, *px2 = {1}"</span><span class="p">,</span>
                <span class="p">*</span><span class="n">px1</span><span class="p">,</span> <span class="p">*</span><span class="n">px2</span><span class="p">);</span>    <span class="c1">// undefined behavior</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A method can return a value of some type, and that type can be a pointer. For example, when given a pointer to a contiguous sequence of <code class="prettyprint">int</code>s, that sequence&rsquo;s element count, and some other <code class="prettyprint">int</code> value, the following method returns the address of that value in that sequence, if a match occurs; otherwise it returns <code class="prettyprint">null</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">unsafe</span> <span class="k">static</span> <span class="kt">int</span><span class="p">*</span> <span class="nf">Find</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">pi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(*</span><span class="n">pi</span> <span class="p">==</span> <span class="k">value</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">pi</span><span class="p">;</span>
        <span class="p">++</span><span class="n">pi</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>In an unsafe context, several constructs are available for operating on pointers:</p>

<ul>
<li> The <code class="prettyprint">*</code> operator may be used to perform pointer indirection (<a href="unsafe-code.md#pointer-indirection">Pointer indirection</a>).</li>
<li> The <code class="prettyprint">-&gt;</code> operator may be used to access a member of a struct through a pointer (<a href="unsafe-code.md#pointer-member-access">Pointer member access</a>).</li>
<li> The <code class="prettyprint">[]</code> operator may be used to index a pointer (<a href="unsafe-code.md#pointer-element-access">Pointer element access</a>).</li>
<li> The <code class="prettyprint">&amp;</code> operator may be used to obtain the address of a variable (<a href="unsafe-code.md#the-address-of-operator">The address-of operator</a>).</li>
<li> The <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators may be used to increment and decrement pointers (<a href="unsafe-code.md#pointer-increment-and-decrement">Pointer increment and decrement</a>).</li>
<li> The <code class="prettyprint">+</code> and <code class="prettyprint">-</code> operators may be used to perform pointer arithmetic (<a href="unsafe-code.md#pointer-arithmetic">Pointer arithmetic</a>).</li>
<li> The <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">=&gt;</code> operators may be used to compare pointers (<a href="unsafe-code.md#pointer-comparison">Pointer comparison</a>).</li>
<li> The <code class="prettyprint">stackalloc</code> operator may be used to allocate memory from the call stack (<a href="unsafe-code.md#fixed-size-buffers">Fixed size buffers</a>).</li>
<li> The <code class="prettyprint">fixed</code> statement may be used to temporarily fix a variable so its address can be obtained (<a href="unsafe-code.md#the-fixed-statement">The fixed statement</a>).</li>
</ul>

<h2 id="fixed-and-moveable-variables">Fixed and moveable variables</h2>

<p>The address-of operator (<a href="unsafe-code.md#the-address-of-operator">The address-of operator</a>) and the <code class="prettyprint">fixed</code> statement (<a href="unsafe-code.md#the-fixed-statement">The fixed statement</a>) divide variables into two categories: <strong><em>Fixed variables</em></strong> and <strong><em>moveable variables</em></strong>.</p>

<p>Fixed variables reside in storage locations that are unaffected by operation of the garbage collector. (Examples of fixed variables include local variables, value parameters, and variables created by dereferencing pointers.) On the other hand, moveable variables reside in storage locations that are subject to relocation or disposal by the garbage collector. (Examples of moveable variables include fields in objects and elements of arrays.)</p>

<p>The <code class="prettyprint">&amp;</code> operator (<a href="unsafe-code.md#the-address-of-operator">The address-of operator</a>) permits the address of a fixed variable to be obtained without restrictions. However, because a moveable variable is subject to relocation or disposal by the garbage collector, the address of a moveable variable can only be obtained using a <code class="prettyprint">fixed</code> statement (<a href="unsafe-code.md#the-fixed-statement">The fixed statement</a>), and that address remains valid only for the duration of that <code class="prettyprint">fixed</code> statement.</p>

<p>In precise terms, a fixed variable is one of the following:</p>

<ul>
<li> A variable resulting from a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) that refers to a local variable or a value parameter, unless the variable is captured by an anonymous function.</li>
<li> A variable resulting from a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">V.I</code>, where <code class="prettyprint">V</code> is a fixed variable of a <em>struct_type</em>.</li>
<li> A variable resulting from a <em>pointer_indirection_expression</em> (<a href="unsafe-code.md#pointer-indirection">Pointer indirection</a>) of the form <code class="prettyprint">*P</code>, a <em>pointer_member_access</em> (<a href="unsafe-code.md#pointer-member-access">Pointer member access</a>) of the form <code class="prettyprint">P-&gt;I</code>, or a <em>pointer_element_access</em> (<a href="unsafe-code.md#pointer-element-access">Pointer element access</a>) of the form <code class="prettyprint">P[E]</code>.</li>
</ul>

<p>All other variables are classified as moveable variables.</p>

<p>Note that a static field is classified as a moveable variable. Also note that a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter is classified as a moveable variable, even if the argument given for the parameter is a fixed variable. Finally, note that a variable produced by dereferencing a pointer is always classified as a fixed variable.</p>

<h2 id="pointer-conversions">Pointer conversions</h2>

<p>In an unsafe context, the set of available implicit conversions (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) is extended to include the following implicit pointer conversions:</p>

<ul>
<li> From any <em>pointer_type</em> to the type <code class="prettyprint">void*</code>.</li>
<li> From the <code class="prettyprint">null</code> literal to any <em>pointer_type</em>.</li>
</ul>

<p>Additionally, in an unsafe context, the set of available explicit conversions (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) is extended to include the following explicit pointer conversions:</p>

<ul>
<li> From any <em>pointer_type</em> to any other <em>pointer_type</em>.</li>
<li> From <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code> to any <em>pointer_type</em>.</li>
<li> From any <em>pointer_type</em> to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code>.</li>
</ul>

<p>Finally, in an unsafe context, the set of standard implicit conversions (<a href="conversions.md#standard-implicit-conversions">Standard implicit conversions</a>) includes the following pointer conversion:</p>

<ul>
<li> From any <em>pointer_type</em> to the type <code class="prettyprint">void*</code>.</li>
</ul>

<p>Conversions between two pointer types never change the actual pointer value. In other words, a conversion from one pointer type to another has no effect on the underlying address given by the pointer.</p>

<p>When one pointer type is converted to another, if the resulting pointer is not correctly aligned for the pointed-to type, the behavior is undefined if the result is dereferenced. In general, the concept &ldquo;correctly aligned&rdquo; is transitive: if a pointer to type <code class="prettyprint">A</code> is correctly aligned for a pointer to type <code class="prettyprint">B</code>, which, in turn, is correctly aligned for a pointer to type <code class="prettyprint">C</code>, then a pointer to type <code class="prettyprint">A</code> is correctly aligned for a pointer to type <code class="prettyprint">C</code>.</p>

<p>Consider the following case in which a variable having one type is accessed via a pointer to a different type:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">char</span> <span class="n">c</span> <span class="p">=</span> <span class="sc">'A'</span><span class="p">;</span>
<span class="kt">char</span><span class="p">*</span> <span class="n">pc</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="k">void</span><span class="p">*</span> <span class="n">pv</span> <span class="p">=</span> <span class="n">pc</span><span class="p">;</span>
<span class="kt">int</span><span class="p">*</span> <span class="n">pi</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">*)</span><span class="n">pv</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="p">*</span><span class="n">pi</span><span class="p">;</span>         <span class="c1">// undefined</span>
<span class="p">*</span><span class="n">pi</span> <span class="p">=</span> <span class="m">123456</span><span class="p">;</span>        <span class="c1">// undefined</span>
</code></pre>
<p>When a pointer type is converted to a pointer to byte, the result points to the lowest addressed byte of the variable. Successive increments of the result, up to the size of the variable, yield pointers to the remaining bytes of that variable. For example, the following method displays each of the eight bytes in a double as a hexadecimal value:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="n">d</span> <span class="p">=</span> <span class="m">123.456</span><span class="n">e23</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
           <span class="kt">byte</span><span class="p">*</span> <span class="n">pb</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)&amp;</span><span class="n">d</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
               <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0:X2} "</span><span class="p">,</span> <span class="p">*</span><span class="n">pb</span><span class="p">++);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Of course, the output produced depends on endianness.</p>

<p>Mappings between pointers and integers are implementation-defined. However, on 32* and 64-bit CPU architectures with a linear address space, conversions of pointers to or from integral types typically behave exactly like conversions of <code class="prettyprint">uint</code> or <code class="prettyprint">ulong</code> values, respectively, to or from those integral types.</p>

<h3 id="pointer-arrays">Pointer arrays</h3>

<p>In an unsafe context, arrays of pointers can be constructed. Only some of the conversions that apply to other array types are allowed on pointer arrays:</p>

<ul>
<li> The implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) from any <em>array_type</em> to <code class="prettyprint">System.Array</code> and the interfaces it implements also applies to pointer arrays. However, any attempt to access the array elements through <code class="prettyprint">System.Array</code> or the interfaces it implements will result in an exception at run-time, as pointer types are not convertible to <code class="prettyprint">object</code>.</li>
<li> The implicit and explicit reference conversions (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>, <a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) from a single-dimensional array type <code class="prettyprint">S[]</code> to <code class="prettyprint">System.Collections.Generic.IList&lt;T&gt;</code> and its generic base interfaces never apply to pointer arrays, since pointer types cannot be used as type arguments, and there are no conversions from pointer types to non-pointer types.</li>
<li> The explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) from <code class="prettyprint">System.Array</code> and the interfaces it implements to any <em>array_type</em> applies to pointer arrays.</li>
<li> The explicit reference conversions (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) from <code class="prettyprint">System.Collections.Generic.IList&lt;S&gt;</code> and its base interfaces to a single-dimensional array type <code class="prettyprint">T[]</code> never applies to pointer arrays, since pointer types cannot be used as type arguments, and there are no conversions from pointer types to non-pointer types.</li>
</ul>

<p>These restrictions mean that the expansion for the <code class="prettyprint">foreach</code> statement over arrays described in <a href="statements.md#the-foreach-statement">The foreach statement</a> cannot be applied to pointer arrays. Instead, a foreach statement of the form</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">foreach</span> <span class="p">(</span><span class="n">V</span> <span class="n">v</span> <span class="k">in</span> <span class="n">x</span><span class="p">)</span> <span class="n">embedded_statement</span>
</code></pre>
<p>where the type of <code class="prettyprint">x</code> is an array type of the form <code class="prettyprint">T[,,...,]</code>, <code class="prettyprint">N</code> is the number of dimensions minus 1 and <code class="prettyprint">T</code> or <code class="prettyprint">V</code> is a pointer type, is expanded using nested for-loops as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">{</span>
    <span class="n">T</span><span class="p">[,,...,]</span> <span class="n">a</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetLowerBound</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i0</span> <span class="p">&lt;=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetUpperBound</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">i0</span><span class="p">++)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i1</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetLowerBound</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="n">i1</span> <span class="p">&lt;=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetUpperBound</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="n">i1</span><span class="p">++)</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iN</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetLowerBound</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> <span class="n">iN</span> <span class="p">&lt;=</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetUpperBound</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> <span class="n">iN</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">V</span> <span class="n">v</span> <span class="p">=</span> <span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,...,</span><span class="n">iN</span><span class="p">);</span>
        <span class="n">embedded_statement</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The variables <code class="prettyprint">a</code>, <code class="prettyprint">i0</code>, <code class="prettyprint">i1</code>, &hellip;, <code class="prettyprint">iN</code> are not visible to or accessible to <code class="prettyprint">x</code> or the <em>embedded_statement</em> or any other source code of the program. The variable <code class="prettyprint">v</code> is read-only in the embedded statement. If there is not an explicit conversion (<a href="unsafe-code.md#pointer-conversions">Pointer conversions</a>) from <code class="prettyprint">T</code> (the element type) to <code class="prettyprint">V</code>, an error is produced and no further steps are taken. If <code class="prettyprint">x</code> has the value <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown at run-time.</p>

<h2 id="pointers-in-expressions">Pointers in expressions</h2>

<p>In an unsafe context, an expression may yield a result of a pointer type, but outside an unsafe context it is a compile-time error for an expression to be of a pointer type. In precise terms, outside an unsafe context a compile-time error occurs if any <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>), <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), <em>invocation_expression</em> (<a href="expressions.md#invocation-expressions">Invocation expressions</a>), or <em>element_access</em> (<a href="expressions.md#element-access">Element access</a>) is of a pointer type.</p>

<p>In an unsafe context, the <em>primary_no_array_creation_expression</em> (<a href="expressions.md#primary-expressions">Primary expressions</a>) and <em>unary_expression</em> (<a href="expressions.md#unary-operators">Unary operators</a>) productions permit the following additional constructs:</p>
<pre class="highlight shell"><code>primary_no_array_creation_expression_unsafe
    : pointer_member_access
    | pointer_element_access
    | sizeof_expression
    ;

unary_expression_unsafe
    : pointer_indirection_expression
    | addressof_expression
    ;
</code></pre>
<p>These constructs are described in the following sections. The precedence and associativity of the unsafe operators is implied by the grammar.</p>

<h3 id="pointer-indirection">Pointer indirection</h3>

<p>A <em>pointer_indirection_expression</em> consists of an asterisk (<code class="prettyprint">*</code>) followed by a <em>unary_expression</em>.</p>
<pre class="highlight shell"><code>pointer_indirection_expression
    : <span class="s1">'*'</span> unary_expression
    ;
</code></pre>
<p>The unary <code class="prettyprint">*</code> operator denotes pointer indirection and is used to obtain the variable to which a pointer points. The result of evaluating <code class="prettyprint">*P</code>, where <code class="prettyprint">P</code> is an expression of a pointer type <code class="prettyprint">T*</code>, is a variable of type <code class="prettyprint">T</code>. It is a compile-time error to apply the unary <code class="prettyprint">*</code> operator to an expression of type <code class="prettyprint">void*</code> or to an expression that isn&rsquo;t of a pointer type.</p>

<p>The effect of applying the unary <code class="prettyprint">*</code> operator to a <code class="prettyprint">null</code> pointer is implementation-defined. In particular, there is no guarantee that this operation throws a <code class="prettyprint">System.NullReferenceException</code>.</p>

<p>If an invalid value has been assigned to the pointer, the behavior of the unary <code class="prettyprint">*</code> operator is undefined. Among the invalid values for dereferencing a pointer by the unary <code class="prettyprint">*</code> operator are an address inappropriately aligned for the type pointed to (see example in <a href="unsafe-code.md#pointer-conversions">Pointer conversions</a>), and the address of a variable after the end of its lifetime.</p>

<p>For purposes of definite assignment analysis, a variable produced by evaluating an expression of the form <code class="prettyprint">*P</code> is considered initially assigned (<a href="variables.md#initially-assigned-variables">Initially assigned variables</a>).</p>

<h3 id="pointer-member-access">Pointer member access</h3>

<p>A <em>pointer_member_access</em> consists of a <em>primary_expression</em>, followed by a &ldquo;<code class="prettyprint">-&gt;</code>&rdquo; token, followed by an <em>identifier</em> and an optional <em>type_argument_list</em>.</p>
<pre class="highlight shell"><code>pointer_member_access
    : primary_expression <span class="s1">'-&gt;'</span> identifier
    ;
</code></pre>
<p>In a pointer member access of the form <code class="prettyprint">P-&gt;I</code>, <code class="prettyprint">P</code> must be an expression of a pointer type other than <code class="prettyprint">void*</code>, and <code class="prettyprint">I</code> must denote an accessible member of the type to which <code class="prettyprint">P</code> points.</p>

<p>A pointer member access of the form <code class="prettyprint">P-&gt;I</code> is evaluated exactly as <code class="prettyprint">(*P).I</code>. For a description of the pointer indirection operator (<code class="prettyprint">*</code>), see <a href="unsafe-code.md#pointer-indirection">Pointer indirection</a>. For a description of the member access operator (<code class="prettyprint">.</code>), see <a href="expressions.md#member-access">Member access</a>.</p>

<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"("</span> <span class="p">+</span> <span class="n">x</span> <span class="p">+</span> <span class="s">","</span> <span class="p">+</span> <span class="n">y</span> <span class="p">+</span> <span class="s">")"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="n">point</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">Point</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">point</span><span class="p">;</span>
            <span class="n">p</span><span class="p">-&gt;</span><span class="n">x</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
            <span class="n">p</span><span class="p">-&gt;</span><span class="n">y</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">p</span><span class="p">-&gt;</span><span class="nf">ToString</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>the <code class="prettyprint">-&gt;</code> operator is used to access fields and invoke a method of a struct through a pointer. Because the operation <code class="prettyprint">P-&gt;I</code> is precisely equivalent to <code class="prettyprint">(*P).I</code>, the <code class="prettyprint">Main</code> method could equally well have been written:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Point</span> <span class="n">point</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">Point</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">point</span><span class="p">;</span>
            <span class="p">(*</span><span class="n">p</span><span class="p">).</span><span class="n">x</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
            <span class="p">(*</span><span class="n">p</span><span class="p">).</span><span class="n">y</span> <span class="p">=</span> <span class="m">20</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">((*</span><span class="n">p</span><span class="p">).</span><span class="nf">ToString</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="pointer-element-access">Pointer element access</h3>

<p>A <em>pointer_element_access</em> consists of a <em>primary_no_array_creation_expression</em> followed by an expression enclosed in &ldquo;<code class="prettyprint">[</code>&rdquo; and &ldquo;<code class="prettyprint">]</code>&rdquo;.</p>
<pre class="highlight shell"><code>pointer_element_access
    : primary_no_array_creation_expression <span class="s1">'['</span> expression <span class="s1">']'</span>
    ;
</code></pre>
<p>In a pointer element access of the form <code class="prettyprint">P[E]</code>, <code class="prettyprint">P</code> must be an expression of a pointer type other than <code class="prettyprint">void*</code>, and <code class="prettyprint">E</code> must be an expression that can be implicitly converted to <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code>.</p>

<p>A pointer element access of the form <code class="prettyprint">P[E]</code> is evaluated exactly as <code class="prettyprint">*(P + E)</code>. For a description of the pointer indirection operator (<code class="prettyprint">*</code>), see <a href="unsafe-code.md#pointer-indirection">Pointer indirection</a>. For a description of the pointer addition operator (<code class="prettyprint">+</code>), see <a href="unsafe-code.md#pointer-arithmetic">Pointer arithmetic</a>.</p>

<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">char</span><span class="p">[</span><span class="m">256</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">256</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>a pointer element access is used to initialize the character buffer in a <code class="prettyprint">for</code> loop. Because the operation <code class="prettyprint">P[E]</code> is precisely equivalent to <code class="prettyprint">*(P + E)</code>, the example could equally well have been written:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">char</span><span class="p">[</span><span class="m">256</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">256</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">*(</span><span class="n">p</span> <span class="p">+</span> <span class="n">i</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The pointer element access operator does not check for out-of-bounds errors and the behavior when accessing an out-of-bounds element is undefined. This is the same as C and C++.</p>

<h3 id="the-address-of-operator">The address-of operator</h3>

<p>An <em>addressof_expression</em> consists of an ampersand (<code class="prettyprint">&amp;</code>) followed by a <em>unary_expression</em>.</p>
<pre class="highlight shell"><code>addressof_expression
    : <span class="s1">'&amp;'</span> unary_expression
    ;
</code></pre>
<p>Given an expression <code class="prettyprint">E</code> which is of a type <code class="prettyprint">T</code> and is classified as a fixed variable (<a href="unsafe-code.md#fixed-and-moveable-variables">Fixed and moveable variables</a>), the construct <code class="prettyprint">&amp;E</code> computes the address of the variable given by <code class="prettyprint">E</code>. The type of the result is <code class="prettyprint">T*</code> and is classified as a value. A compile-time error occurs if <code class="prettyprint">E</code> is not classified as a variable, if <code class="prettyprint">E</code> is classified as a read-only local variable, or if <code class="prettyprint">E</code> denotes a moveable variable. In the last case, a fixed statement (<a href="unsafe-code.md#the-fixed-statement">The fixed statement</a>) can be used to temporarily &ldquo;fix&rdquo; the variable before obtaining its address. As stated in <a href="expressions.md#member-access">Member access</a>, outside an instance constructor or static constructor for a struct or class that defines a <code class="prettyprint">readonly</code> field, that field is considered a value, not a variable. As such, its address cannot be taken. Similarly, the address of a constant cannot be taken.</p>

<p>The <code class="prettyprint">&amp;</code> operator does not require its argument to be definitely assigned, but following an <code class="prettyprint">&amp;</code> operation, the variable to which the operator is applied is considered definitely assigned in the execution path in which the operation occurs. It is the responsibility of the programmer to ensure that correct initialization of the variable actually does take place in this situation.</p>

<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">i</span><span class="p">;</span>
            <span class="p">*</span><span class="n">p</span> <span class="p">=</span> <span class="m">123</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p><code class="prettyprint">i</code> is considered definitely assigned following the <code class="prettyprint">&amp;i</code> operation used to initialize <code class="prettyprint">p</code>. The assignment to <code class="prettyprint">*p</code> in effect initializes <code class="prettyprint">i</code>, but the inclusion of this initialization is the responsibility of the programmer, and no compile-time error would occur if the assignment was removed.</p>

<p>The rules of definite assignment for the <code class="prettyprint">&amp;</code> operator exist such that redundant initialization of local variables can be avoided. For example, many external APIs take a pointer to a structure which is filled in by the API. Calls to such APIs typically pass the address of a local struct variable, and without the rule, redundant initialization of the struct variable would be required.</p>

<h3 id="pointer-increment-and-decrement">Pointer increment and decrement</h3>

<p>In an unsafe context, the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a> and <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>) can be applied to pointer variables of all types except <code class="prettyprint">void*</code>. Thus, for every pointer type <code class="prettyprint">T*</code>, the following operators are implicitly defined:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">++(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">--(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The operators produce the same results as <code class="prettyprint">x + 1</code> and <code class="prettyprint">x - 1</code>, respectively (<a href="unsafe-code.md#pointer-arithmetic">Pointer arithmetic</a>). In other words, for a pointer variable of type <code class="prettyprint">T*</code>, the <code class="prettyprint">++</code> operator adds <code class="prettyprint">sizeof(T)</code> to the address contained in the variable, and the <code class="prettyprint">--</code> operator subtracts <code class="prettyprint">sizeof(T)</code> from the address contained in the variable.</p>

<p>If a pointer increment or decrement operation overflows the domain of the pointer type, the result is implementation-defined, but no exceptions are produced.</p>

<h3 id="pointer-arithmetic">Pointer arithmetic</h3>

<p>In an unsafe context, the <code class="prettyprint">+</code> and <code class="prettyprint">-</code> operators (<a href="expressions.md#addition-operator">Addition operator</a> and <a href="expressions.md#subtraction-operator">Subtraction operator</a>) can be applied to values of all pointer types except <code class="prettyprint">void*</code>. Thus, for every pointer type <code class="prettyprint">T*</code>, the following operators are implicitly defined:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>

<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>

<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
<span class="n">T</span><span class="p">*</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>

<span class="kt">long</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">T</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>Given an expression <code class="prettyprint">P</code> of a pointer type <code class="prettyprint">T*</code> and an expression <code class="prettyprint">N</code> of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code>, the expressions <code class="prettyprint">P + N</code> and <code class="prettyprint">N + P</code> compute the pointer value of type <code class="prettyprint">T*</code> that results from adding <code class="prettyprint">N * sizeof(T)</code> to the address given by <code class="prettyprint">P</code>. Likewise, the expression <code class="prettyprint">P - N</code> computes the pointer value of type <code class="prettyprint">T*</code> that results from subtracting <code class="prettyprint">N * sizeof(T)</code> from the address given by <code class="prettyprint">P</code>.</p>

<p>Given two expressions, <code class="prettyprint">P</code> and <code class="prettyprint">Q</code>, of a pointer type <code class="prettyprint">T*</code>, the expression <code class="prettyprint">P - Q</code> computes the difference between the addresses given by <code class="prettyprint">P</code> and <code class="prettyprint">Q</code> and then divides that difference by <code class="prettyprint">sizeof(T)</code>. The type of the result is always <code class="prettyprint">long</code>. In effect, <code class="prettyprint">P - Q</code> is computed as <code class="prettyprint">((long)(P) - (long)(Q)) / sizeof(T)</code>.</p>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">values</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">int</span><span class="p">[</span><span class="m">20</span><span class="p">];</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">values</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
            <span class="kt">int</span><span class="p">*</span> <span class="n">q</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">values</span><span class="p">[</span><span class="m">15</span><span class="p">];</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"p - q = {0}"</span><span class="p">,</span> <span class="n">p</span> <span class="p">-</span> <span class="n">q</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"q - p = {0}"</span><span class="p">,</span> <span class="n">q</span> <span class="p">-</span> <span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>which produces the output:</p>
<pre class="highlight shell"><code>p - q <span class="o">=</span> -14
q - p <span class="o">=</span> 14
</code></pre>
<p>If a pointer arithmetic operation overflows the domain of the pointer type, the result is truncated in an implementation-defined fashion, but no exceptions are produced.</p>

<h3 id="pointer-comparison">Pointer comparison</h3>

<p>In an unsafe context, the <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">=&gt;</code> operators (<a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a>) can be applied to values of all pointer types. The pointer comparison operators are:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">&lt;(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">&gt;(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">&lt;=(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">&gt;=(</span><span class="k">void</span><span class="p">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>Because an implicit conversion exists from any pointer type to the <code class="prettyprint">void*</code> type, operands of any pointer type can be compared using these operators. The comparison operators compare the addresses given by the two operands as if they were unsigned integers.</p>

<h3 id="the-sizeof-operator">The sizeof operator</h3>

<p>The <code class="prettyprint">sizeof</code> operator returns the number of bytes occupied by a variable of a given type. The type specified as an operand to <code class="prettyprint">sizeof</code> must be an <em>unmanaged_type</em> (<a href="unsafe-code.md#pointer-types">Pointer types</a>).</p>
<pre class="highlight shell"><code>sizeof_expression
    : <span class="s1">'sizeof'</span> <span class="s1">'('</span> unmanaged_type <span class="s1">')'</span>
    ;
</code></pre>
<p>The result of the <code class="prettyprint">sizeof</code> operator is a value of type <code class="prettyprint">int</code>. For certain predefined types, the <code class="prettyprint">sizeof</code> operator yields a constant value as shown in the table below.</p>

<table><thead>
<tr>
<th><strong>Expression</strong></th>
<th><strong>Result</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">sizeof(sbyte)</code></td>
<td><code class="prettyprint">1</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(byte)</code></td>
<td><code class="prettyprint">1</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(short)</code></td>
<td><code class="prettyprint">2</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(ushort)</code></td>
<td><code class="prettyprint">2</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(int)</code></td>
<td><code class="prettyprint">4</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(uint)</code></td>
<td><code class="prettyprint">4</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(long)</code></td>
<td><code class="prettyprint">8</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(ulong)</code></td>
<td><code class="prettyprint">8</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(char)</code></td>
<td><code class="prettyprint">2</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(float)</code></td>
<td><code class="prettyprint">4</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(double)</code></td>
<td><code class="prettyprint">8</code></td>
</tr>
<tr>
<td><code class="prettyprint">sizeof(bool)</code></td>
<td><code class="prettyprint">1</code></td>
</tr>
</tbody></table>

<p>For all other types, the result of the <code class="prettyprint">sizeof</code> operator is implementation-defined and is classified as a value, not a constant.</p>

<p>The order in which members are packed into a struct is unspecified.</p>

<p>For alignment purposes, there may be unnamed padding at the beginning of a struct, within a struct, and at the end of the struct. The contents of the bits used as padding are indeterminate.</p>

<p>When applied to an operand that has struct type, the result is the total number of bytes in a variable of that type, including any padding.</p>

<h2 id="the-fixed-statement">The fixed statement</h2>

<p>In an unsafe context, the <em>embedded_statement</em> (<a href="statements.md#statements">Statements</a>) production permits an additional construct, the <code class="prettyprint">fixed</code> statement, which is used to &ldquo;fix&rdquo; a moveable variable such that its address remains constant for the duration of the statement.</p>
<pre class="highlight shell"><code>fixed_statement
    : <span class="s1">'fixed'</span> <span class="s1">'('</span> pointer_type fixed_pointer_declarators <span class="s1">')'</span> embedded_statement
    ;

fixed_pointer_declarators
    : fixed_pointer_declarator <span class="o">(</span><span class="s1">','</span>  fixed_pointer_declarator<span class="o">)</span><span class="k">*</span>
    ;

fixed_pointer_declarator
    : identifier <span class="s1">'='</span> fixed_pointer_initializer
    ;

fixed_pointer_initializer
    : <span class="s1">'&amp;'</span> variable_reference
    | expression
    ;
</code></pre>
<p>Each <em>fixed_pointer_declarator</em> declares a local variable of the given <em>pointer_type</em> and initializes that local variable with the address computed by the corresponding <em>fixed_pointer_initializer</em>. A local variable declared in a <code class="prettyprint">fixed</code> statement is accessible in any <em>fixed_pointer_initializer*s occurring to the right of that variable&rsquo;s declaration, and in the *embedded_statement</em> of the <code class="prettyprint">fixed</code> statement. A local variable declared by a <code class="prettyprint">fixed</code> statement is considered read-only. A compile-time error occurs if the embedded statement attempts to modify this local variable (via assignment or the <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators) or pass it as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</p>

<p>A <em>fixed_pointer_initializer</em> can be one of the following:</p>

<ul>
<li> The token &ldquo;<code class="prettyprint">&amp;</code>&rdquo; followed by a <em>variable_reference</em> (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>) to a moveable variable (<a href="unsafe-code.md#fixed-and-moveable-variables">Fixed and moveable variables</a>) of an unmanaged type <code class="prettyprint">T</code>, provided the type <code class="prettyprint">T*</code> is implicitly convertible to the pointer type given in the <code class="prettyprint">fixed</code> statement. In this case, the initializer computes the address of the given variable, and the variable is guaranteed to remain at a fixed address for the duration of the <code class="prettyprint">fixed</code> statement.</li>
<li> An expression of an <em>array_type</em> with elements of an unmanaged type <code class="prettyprint">T</code>, provided the type <code class="prettyprint">T*</code> is implicitly convertible to the pointer type given in the <code class="prettyprint">fixed</code> statement. In this case, the initializer computes the address of the first element in the array, and the entire array is guaranteed to remain at a fixed address for the duration of the <code class="prettyprint">fixed</code> statement. If the array expression is null or if the array has zero elements, the initializer computes an address equal to zero.</li>
<li> An expression of type <code class="prettyprint">string</code>, provided the type <code class="prettyprint">char*</code> is implicitly convertible to the pointer type given in the <code class="prettyprint">fixed</code> statement. In this case, the initializer computes the address of the first character in the string, and the entire string is guaranteed to remain at a fixed address for the duration of the <code class="prettyprint">fixed</code> statement. The behavior of the <code class="prettyprint">fixed</code> statement is implementation-defined if the string expression is null.</li>
<li> A <em>simple_name</em> or <em>member_access</em> that references a fixed size buffer member of a moveable variable, provided the type of the fixed size buffer member is implicitly convertible to the pointer type given in the <code class="prettyprint">fixed</code> statement. In this case, the initializer computes a pointer to the first element of the fixed size buffer (<a href="unsafe-code.md#fixed-size-buffers-in-expressions">Fixed size buffers in expressions</a>), and the fixed size buffer is guaranteed to remain at a fixed address for the duration of the <code class="prettyprint">fixed</code> statement.</li>
</ul>

<p>For each address computed by a <em>fixed_pointer_initializer</em> the <code class="prettyprint">fixed</code> statement ensures that the variable referenced by the address is not subject to relocation or disposal by the garbage collector for the duration of the <code class="prettyprint">fixed</code> statement. For example, if the address computed by a <em>fixed_pointer_initializer</em> references a field of an object or an element of an array instance, the <code class="prettyprint">fixed</code> statement guarantees that the containing object instance is not relocated or disposed of during the lifetime of the statement.</p>

<p>It is the programmer&rsquo;s responsibility to ensure that pointers created by <code class="prettyprint">fixed</code> statements do not survive beyond execution of those statements. For example, when pointers created by <code class="prettyprint">fixed</code> statements are passed to external APIs, it is the programmer&rsquo;s responsibility to ensure that the APIs retain no memory of these pointers.</p>

<p>Fixed objects may cause fragmentation of the heap (because they can&rsquo;t be moved). For that reason, objects should be fixed only when absolutely necessary and then only for the shortest amount of time possible.</p>

<p>The example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">*</span><span class="n">p</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Test</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Test</span><span class="p">();</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">a</span><span class="p">)</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>demonstrates several uses of the <code class="prettyprint">fixed</code> statement. The first statement fixes and obtains the address of a static field, the second statement fixes and obtains the address of an instance field, and the third statement fixes and obtains the address of an array element. In each case it would have been an error to use the regular <code class="prettyprint">&amp;</code> operator since the variables are all classified as moveable variables.</p>

<p>The fourth <code class="prettyprint">fixed</code> statement in the example above produces a similar result to the third.</p>

<p>This example of the <code class="prettyprint">fixed</code> statement uses <code class="prettyprint">string</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">=</span> <span class="s">"xx"</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">name</span><span class="p">)</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="s">"xx"</span><span class="p">)</span> <span class="nf">F</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In an unsafe context array elements of single-dimensional arrays are stored in increasing index order, starting with index <code class="prettyprint">0</code> and ending with index <code class="prettyprint">Length - 1</code>. For multi-dimensional arrays, array elements are stored such that the indices of the rightmost dimension are increased first, then the next left dimension, and so on to the left. Within a <code class="prettyprint">fixed</code> statement that obtains a pointer <code class="prettyprint">p</code> to an array instance <code class="prettyprint">a</code>, the pointer values ranging from <code class="prettyprint">p</code> to <code class="prettyprint">p + a.Length - 1</code> represent addresses of the elements in the array. Likewise, the variables ranging from <code class="prettyprint">p[0]</code> to <code class="prettyprint">p[a.Length - 1]</code> represent the actual array elements. Given the way in which arrays are stored, we can treat an array of any dimension as though it were linear.</p>

<p>For example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span><span class="p">[,,]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">];</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>    <span class="c1">// treat as linear</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="p">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">k</span> <span class="p">&lt;</span> <span class="m">4</span><span class="p">;</span> <span class="p">++</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"[{0},{1},{2}] = {3,2} "</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]);</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>which produces the output:</p>
<pre class="highlight shell"><code><span class="o">[</span>0,0,0] <span class="o">=</span>  0 <span class="o">[</span>0,0,1] <span class="o">=</span>  1 <span class="o">[</span>0,0,2] <span class="o">=</span>  2 <span class="o">[</span>0,0,3] <span class="o">=</span>  3
<span class="o">[</span>0,1,0] <span class="o">=</span>  4 <span class="o">[</span>0,1,1] <span class="o">=</span>  5 <span class="o">[</span>0,1,2] <span class="o">=</span>  6 <span class="o">[</span>0,1,3] <span class="o">=</span>  7
<span class="o">[</span>0,2,0] <span class="o">=</span>  8 <span class="o">[</span>0,2,1] <span class="o">=</span>  9 <span class="o">[</span>0,2,2] <span class="o">=</span> 10 <span class="o">[</span>0,2,3] <span class="o">=</span> 11
<span class="o">[</span>1,0,0] <span class="o">=</span> 12 <span class="o">[</span>1,0,1] <span class="o">=</span> 13 <span class="o">[</span>1,0,2] <span class="o">=</span> 14 <span class="o">[</span>1,0,3] <span class="o">=</span> 15
<span class="o">[</span>1,1,0] <span class="o">=</span> 16 <span class="o">[</span>1,1,1] <span class="o">=</span> 17 <span class="o">[</span>1,1,2] <span class="o">=</span> 18 <span class="o">[</span>1,1,3] <span class="o">=</span> 19
<span class="o">[</span>1,2,0] <span class="o">=</span> 20 <span class="o">[</span>1,2,1] <span class="o">=</span> 21 <span class="o">[</span>1,2,2] <span class="o">=</span> 22 <span class="o">[</span>1,2,3] <span class="o">=</span> 23
</code></pre>
<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Fill</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">count</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span> <span class="n">count</span><span class="p">--)</span> <span class="p">*</span><span class="n">p</span><span class="p">++</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">100</span><span class="p">];</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">fixed</span> <span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">a</span><span class="p">)</span> <span class="nf">Fill</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>a <code class="prettyprint">fixed</code> statement is used to fix an array so its address can be passed to a method that takes a pointer.</p>

<p>In the example:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">Font</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">fixed</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">PutString</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="p">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="p">&gt;</span> <span class="n">bufSize</span><span class="p">)</span> <span class="n">len</span> <span class="p">=</span> <span class="n">bufSize</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">bufSize</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Font</span> <span class="n">f</span><span class="p">;</span>

    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Test</span> <span class="n">test</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Test</span><span class="p">();</span>
        <span class="n">test</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">size</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="k">fixed</span> <span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">test</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">PutString</span><span class="p">(</span><span class="s">"Times New Roman"</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="m">32</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>a fixed statement is used to fix a fixed size buffer of a struct so its address can be used as a pointer.</p>

<p>A <code class="prettyprint">char*</code> value produced by fixing a string instance always points to a null-terminated string. Within a fixed statement that obtains a pointer <code class="prettyprint">p</code> to a string instance <code class="prettyprint">s</code>, the pointer values ranging from <code class="prettyprint">p</code> to <code class="prettyprint">p + s.Length - 1</code> represent addresses of the characters in the string, and the pointer value <code class="prettyprint">p + s.Length</code> always points to a null character (the character with value <code class="prettyprint">&#39;\0&#39;</code>).</p>

<p>Modifying objects of managed type through fixed pointers can results in undefined behavior. For example, because strings are immutable, it is the programmer&rsquo;s responsibility to ensure that the characters referenced by a pointer to a fixed string are not modified.</p>

<p>The automatic null-termination of strings is particularly convenient when calling external APIs that expect &ldquo;C-style&rdquo; strings. Note, however, that a string instance is permitted to contain null characters. If such null characters are present, the string will appear truncated when treated as a null-terminated <code class="prettyprint">char*</code>.</p>

<h2 id="fixed-size-buffers">Fixed size buffers</h2>

<p>Fixed size buffers are used to declare &ldquo;C style&rdquo; in-line arrays as members of structs, and are primarily useful for interfacing with unmanaged APIs.</p>

<h3 id="fixed-size-buffer-declarations">Fixed size buffer declarations</h3>

<p>A <strong><em>fixed size buffer</em></strong> is a member that represents storage for a fixed length buffer of variables of a given type. A fixed size buffer declaration introduces one or more fixed size buffers of a given element type. Fixed size buffers are only permitted in struct declarations and can only occur in unsafe contexts (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>).</p>
<pre class="highlight shell"><code>struct_member_declaration_unsafe
    : fixed_size_buffer_declaration
    ;

fixed_size_buffer_declaration
    : attributes? fixed_size_buffer_modifier<span class="k">*</span> <span class="s1">'fixed'</span> buffer_element_type fixed_size_buffer_declarator+ <span class="s1">';'</span>
    ;

fixed_size_buffer_modifier
    : <span class="s1">'new'</span>
    | <span class="s1">'public'</span>
    | <span class="s1">'protected'</span>
    | <span class="s1">'internal'</span>
    | <span class="s1">'private'</span>
    | <span class="s1">'unsafe'</span>
    ;

buffer_element_type
    : <span class="nb">type</span>
    ;

fixed_size_buffer_declarator
    : identifier <span class="s1">'['</span> constant_expression <span class="s1">']'</span>
    ;
</code></pre>
<p>A fixed size buffer declaration may include a set of attributes (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">new</code> modifier (<a href="classes.md#modifiers">Modifiers</a>), a valid combination of the four access modifiers (<a href="classes.md#type-parameters-and-constraints">Type parameters and constraints</a>) and an <code class="prettyprint">unsafe</code> modifier (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>). The attributes and modifiers apply to all of the members declared by the fixed size buffer declaration. It is an error for the same modifier to appear multiple times in a fixed size buffer declaration.</p>

<p>A fixed size buffer declaration is not permitted to include the <code class="prettyprint">static</code> modifier.</p>

<p>The buffer element type of a fixed size buffer declaration specifies the element type of the buffer(s) introduced by the declaration. The buffer element type must be one of the predefined types <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, or <code class="prettyprint">bool</code>.</p>

<p>The buffer element type is followed by a list of fixed size buffer declarators, each of which introduces a new member. A fixed size buffer declarator consists of an identifier that names the member, followed by a constant expression enclosed in <code class="prettyprint">[</code> and <code class="prettyprint">]</code> tokens. The constant expression denotes the number of elements in the member introduced by that fixed size buffer declarator. The type of the constant expression must be implicitly convertible to type <code class="prettyprint">int</code>, and the value must be a non-zero positive integer.</p>

<p>The elements of a fixed size buffer are guaranteed to be laid out sequentially in memory.</p>

<p>A fixed size buffer declaration that declares multiple fixed size buffers is equivalent to multiple declarations of a single fixed size buffer declation with the same attributes, and element types. For example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
   <span class="k">public</span> <span class="k">fixed</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="m">5</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="m">10</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="m">100</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
<p>is equivalent to</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
   <span class="k">public</span> <span class="k">fixed</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="m">5</span><span class="p">];</span>
   <span class="k">public</span> <span class="k">fixed</span> <span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="m">10</span><span class="p">];</span>
   <span class="k">public</span> <span class="k">fixed</span> <span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="m">100</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
<h3 id="fixed-size-buffers-in-expressions">Fixed size buffers in expressions</h3>

<p>Member lookup (<a href="expressions.md#operators">Operators</a>) of a fixed size buffer member proceeds exactly like member lookup of a field.</p>

<p>A fixed size buffer can be referenced in an expression using a <em>simple_name</em> (<a href="expressions.md#type-inference">Type inference</a>) or a <em>member_access</em> (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>).</p>

<p>When a fixed size buffer member is referenced as a simple name, the effect is the same as a member access of the form <code class="prettyprint">this.I</code>, where <code class="prettyprint">I</code> is the fixed size buffer member.</p>

<p>In a member access of the form <code class="prettyprint">E.I</code>, if <code class="prettyprint">E</code> is of a struct type and a member lookup of <code class="prettyprint">I</code> in that struct type identifies a fixed size member, then <code class="prettyprint">E.I</code> is evaluated an classified as follows:</p>

<ul>
<li> If the expression <code class="prettyprint">E.I</code> does not occur in an unsafe context, a compile-time error occurs.</li>
<li> If <code class="prettyprint">E</code> is classified as a value, a compile-time error occurs.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is a moveable variable (<a href="unsafe-code.md#fixed-and-moveable-variables">Fixed and moveable variables</a>) and the expression <code class="prettyprint">E.I</code> is not a <em>fixed_pointer_initializer</em> (<a href="unsafe-code.md#the-fixed-statement">The fixed statement</a>), a compile-time error occurs.</li>
<li> Otherwise, <code class="prettyprint">E</code> references a fixed variable and the result of the expression is a pointer to the first element of the fixed size buffer member <code class="prettyprint">I</code> in <code class="prettyprint">E</code>. The result is of type <code class="prettyprint">S*</code>, where <code class="prettyprint">S</code> is the element type of <code class="prettyprint">I</code>, and is classified as a value.</li>
</ul>

<p>The subsequent elements of the fixed size buffer can be accessed using pointer operations from the first element. Unlike access to arrays, access to the elements of a fixed size buffer is an unsafe operation and is not range checked.</p>

<p>The following example declares and uses a struct with a fixed size buffer member.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">unsafe</span> <span class="k">struct</span> <span class="nc">Font</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">public</span> <span class="k">fixed</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">PutString</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="p">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="p">&gt;</span> <span class="n">bufSize</span><span class="p">)</span> <span class="n">len</span> <span class="p">=</span> <span class="n">bufSize</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">bufSize</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">unsafe</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Font</span> <span class="n">f</span><span class="p">;</span>
        <span class="n">f</span><span class="p">.</span><span class="n">size</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
        <span class="nf">PutString</span><span class="p">(</span><span class="s">"Times New Roman"</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="m">32</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="definite-assignment-checking">Definite assignment checking</h3>

<p>Fixed size buffers are not subject to definite assignment checking (<a href="variables.md#definite-assignment">Definite assignment</a>), and fixed size buffer members are ignored for purposes of definite assignment checking of struct type variables.</p>

<p>When the outermost containing struct variable of a fixed size buffer member is a static variable, an instance variable of a class instance, or an array element, the elements of the fixed size buffer are automatically initialized to their default values (<a href="variables.md#default-values">Default values</a>). In all other cases, the initial content of a fixed size buffer is undefined.</p>

<h2 id="stack-allocation">Stack allocation</h2>

<p>In an unsafe context, a local variable declaration (<a href="statements.md#local-variable-declarations">Local variable declarations</a>) may include a stack allocation initializer which allocates memory from the call stack.</p>
<pre class="highlight shell"><code>local_variable_initializer_unsafe
    : stackalloc_initializer
    ;

stackalloc_initializer
    : <span class="s1">'stackalloc'</span> unmanaged_type <span class="s1">'['</span> expression <span class="s1">']'</span>
    ;
</code></pre>
<p>The <em>unmanaged_type</em> indicates the type of the items that will be stored in the newly allocated location, and the <em>expression</em> indicates the number of these items. Taken together, these specify the required allocation size. Since the size of a stack allocation cannot be negative, it is a compile-time error to specify the number of items as a <em>constant_expression</em> that evaluates to a negative value.</p>

<p>A stack allocation initializer of the form <code class="prettyprint">stackalloc T[E]</code> requires <code class="prettyprint">T</code> to be an unmanaged type (<a href="unsafe-code.md#pointer-types">Pointer types</a>) and <code class="prettyprint">E</code> to be an expression of type <code class="prettyprint">int</code>. The construct allocates <code class="prettyprint">E * sizeof(T)</code> bytes from the call stack and returns a pointer, of type <code class="prettyprint">T*</code>, to the newly allocated block. If <code class="prettyprint">E</code> is a negative value, then the behavior is undefined. If <code class="prettyprint">E</code> is zero, then no allocation is made, and the pointer returned is implementation-defined. If there is not enough memory available to allocate a block of the given size, a <code class="prettyprint">System.StackOverflowException</code> is thrown.</p>

<p>The content of the newly allocated memory is undefined.</p>

<p>Stack allocation initializers are not permitted in <code class="prettyprint">catch</code> or <code class="prettyprint">finally</code> blocks (<a href="statements.md#the-try-statement">The try statement</a>).</p>

<p>There is no way to explicitly free memory allocated using <code class="prettyprint">stackalloc</code>. All stack allocated memory blocks created during the execution of a function member are automatically discarded when that function member returns. This corresponds to the <code class="prettyprint">alloca</code> function, an extension commonly found in C and C++ implementations.</p>

<p>In the example</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">string</span> <span class="nf">IntToString</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="k">value</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">?</span> <span class="k">value</span><span class="p">:</span> <span class="p">-</span><span class="k">value</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">char</span><span class="p">*</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">char</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>
            <span class="kt">char</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">+</span> <span class="m">16</span><span class="p">;</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="p">*--</span><span class="n">p</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">n</span> <span class="p">%</span> <span class="m">10</span> <span class="p">+</span> <span class="sc">'0'</span><span class="p">);</span>
                <span class="n">n</span> <span class="p">/=</span> <span class="m">10</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="p">!=</span> <span class="m">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">*--</span><span class="n">p</span> <span class="p">=</span> <span class="sc">'-'</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">buffer</span> <span class="p">+</span> <span class="m">16</span> <span class="p">-</span> <span class="n">p</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">IntToString</span><span class="p">(</span><span class="m">12345</span><span class="p">));</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">IntToString</span><span class="p">(-</span><span class="m">999</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>a <code class="prettyprint">stackalloc</code> initializer is used in the <code class="prettyprint">IntToString</code> method to allocate a buffer of 16 characters on the stack. The buffer is automatically discarded when the method returns.</p>

<h2 id="dynamic-memory-allocation">Dynamic memory allocation</h2>

<p>Except for the <code class="prettyprint">stackalloc</code> operator, C# provides no predefined constructs for managing non-garbage collected memory. Such services are typically provided by supporting class libraries or imported directly from the underlying operating system. For example, the <code class="prettyprint">Memory</code> class below illustrates how the heap functions of an underlying operating system might be accessed from C#:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Runtime.InteropServices</span><span class="p">;</span>

<span class="k">public</span> <span class="k">unsafe</span> <span class="k">class</span> <span class="nc">Memory</span>
<span class="p">{</span>
    <span class="c1">// Handle for the process heap. This handle is used in all calls to the</span>
    <span class="c1">// HeapXXX APIs in the methods below.</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">ph</span> <span class="p">=</span> <span class="nf">GetProcessHeap</span><span class="p">();</span>

    <span class="c1">// Private instance constructor to prevent instantiation.</span>
    <span class="k">private</span> <span class="nf">Memory</span><span class="p">()</span> <span class="p">{}</span>

    <span class="c1">// Allocates a memory block of the given size. The allocated memory is</span>
    <span class="c1">// automatically initialized to zero.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span><span class="p">*</span> <span class="nf">Alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">void</span><span class="p">*</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">HeapAlloc</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Copies count bytes from src to dst. The source and destination</span>
    <span class="c1">// blocks are permitted to overlap.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Copy</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="n">src</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">byte</span><span class="p">*</span> <span class="n">ps</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)</span><span class="n">src</span><span class="p">;</span>
        <span class="kt">byte</span><span class="p">*</span> <span class="n">pd</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ps</span> <span class="p">&gt;</span> <span class="n">pd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(;</span> <span class="n">count</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span> <span class="n">count</span><span class="p">--)</span> <span class="p">*</span><span class="n">pd</span><span class="p">++</span> <span class="p">=</span> <span class="p">*</span><span class="n">ps</span><span class="p">++;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ps</span> <span class="p">&lt;</span> <span class="n">pd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ps</span> <span class="p">+=</span> <span class="n">count</span><span class="p">,</span> <span class="n">pd</span> <span class="p">+=</span> <span class="n">count</span><span class="p">;</span> <span class="n">count</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span> <span class="n">count</span><span class="p">--)</span> <span class="p">*--</span><span class="n">pd</span> <span class="p">=</span> <span class="p">*--</span><span class="n">ps</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Frees a memory block.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Free</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="nf">HeapFree</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Re-allocates a memory block. If the reallocation request is for a</span>
    <span class="c1">// larger size, the additional region of memory is automatically</span>
    <span class="c1">// initialized to zero.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span><span class="p">*</span> <span class="nf">ReAlloc</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">void</span><span class="p">*</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">HeapReAlloc</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">OutOfMemoryException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Returns the size of a memory block.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">HeapSize</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Heap API flags</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">HEAP_ZERO_MEMORY</span> <span class="p">=</span> <span class="m">0x00000008</span><span class="p">;</span>

    <span class="c1">// Heap API functions</span>
    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">)]</span>
    <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">GetProcessHeap</span><span class="p">();</span>

    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">)]</span>
    <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span><span class="p">*</span> <span class="nf">HeapAlloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">hHeap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">)]</span>
    <span class="k">static</span> <span class="k">extern</span> <span class="kt">bool</span> <span class="nf">HeapFree</span><span class="p">(</span><span class="kt">int</span> <span class="n">hHeap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">);</span>

    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">)]</span>
    <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span><span class="p">*</span> <span class="nf">HeapReAlloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">hHeap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"kernel32"</span><span class="p">)]</span>
    <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">HeapSize</span><span class="p">(</span><span class="kt">int</span> <span class="n">hHeap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="n">block</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>An example that uses the <code class="prettyprint">Memory</code> class is given below:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="kt">byte</span><span class="p">*</span> <span class="n">buffer</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*)</span><span class="n">Memory</span><span class="p">.</span><span class="nf">Alloc</span><span class="p">(</span><span class="m">256</span><span class="p">);</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">256</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
                <span class="kt">byte</span><span class="p">[]</span> <span class="n">array</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">256</span><span class="p">];</span>
                <span class="k">fixed</span> <span class="p">(</span><span class="kt">byte</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">array</span><span class="p">)</span> <span class="n">Memory</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="m">256</span><span class="p">);</span> 
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span>
                <span class="n">Memory</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">256</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The example allocates 256 bytes of memory through <code class="prettyprint">Memory.Alloc</code> and initializes the memory block with values increasing from 0 to 255. It then allocates a 256 element byte array and uses <code class="prettyprint">Memory.Copy</code> to copy the contents of the memory block into the byte array. Finally, the memory block is freed using <code class="prettyprint">Memory.Free</code> and the contents of the byte array are output on the console.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="csharp">csharp</a>
                <a href="#" data-language-name="bash">bash</a>
          </div>
      </div>
    </div>
  </body>
</html>
