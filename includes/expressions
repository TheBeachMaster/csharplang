<h1 id="expressions">Expressions</h1>

<p>An expression is a sequence of operators and operands. This chapter defines the syntax, order of evaluation of operands and operators, and meaning of expressions.</p>

<h2 id="expression-classifications">Expression classifications</h2>

<p>An expression is classified as one of the following:</p>

<ul>
<li> A value. Every value has an associated type.</li>
<li> A variable. Every variable has an associated type, namely the declared type of the variable.</li>
<li> A namespace. An expression with this classification can only appear as the left hand side of a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>). In any other context, an expression classified as a namespace causes a compile-time error.</li>
<li> A type. An expression with this classification can only appear as the left hand side of a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), or as an operand for the <code class="prettyprint">as</code> operator (<a href="expressions.md#the-as-operator">The as operator</a>), the <code class="prettyprint">is</code> operator (<a href="expressions.md#the-is-operator">The is operator</a>), or the <code class="prettyprint">typeof</code> operator (<a href="expressions.md#the-typeof-operator">The typeof operator</a>). In any other context, an expression classified as a type causes a compile-time error.</li>
<li> A method group, which is a set of overloaded methods resulting from a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>). A method group may have an associated instance expression and an associated type argument list. When an instance method is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>). A method group is permitted in an <em>invocation_expression</em> (<a href="expressions.md#invocation-expressions">Invocation expressions</a>) , a <em>delegate_creation_expression</em> (<a href="expressions.md#delegate-creation-expressions">Delegate creation expressions</a>) and as the left hand side of an is operator, and can be implicitly converted to a compatible delegate type (<a href="conversions.md#method-group-conversions">Method group conversions</a>). In any other context, an expression classified as a method group causes a compile-time error.</li>
<li> A null literal. An expression with this classification can be implicitly converted to a reference type or nullable type.</li>
<li> An anonymous function. An expression with this classification can be implicitly converted to a compatible delegate type or expression tree type.</li>
<li> A property access. Every property access has an associated type, namely the type of the property. Furthermore, a property access may have an associated instance expression. When an accessor (the <code class="prettyprint">get</code> or <code class="prettyprint">set</code> block) of an instance property access is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
<li> An event access. Every event access has an associated type, namely the type of the event. Furthermore, an event access may have an associated instance expression. An event access may appear as the left hand operand of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators (<a href="expressions.md#event-assignment">Event assignment</a>). In any other context, an expression classified as an event access causes a compile-time error.</li>
<li> An indexer access. Every indexer access has an associated type, namely the element type of the indexer. Furthermore, an indexer access has an associated instance expression and an associated argument list. When an accessor (the <code class="prettyprint">get</code> or <code class="prettyprint">set</code> block) of an indexer access is invoked, the result of evaluating the instance expression becomes the instance represented by <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>), and the result of evaluating the argument list becomes the parameter list of the invocation.</li>
<li> Nothing. This occurs when the expression is an invocation of a method with a return type of <code class="prettyprint">void</code>. An expression classified as nothing is only valid in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>).</li>
</ul>

<p>The final result of an expression is never a namespace, type, method group, or event access. Rather, as noted above, these categories of expressions are intermediate constructs that are only permitted in certain contexts.</p>

<p>A property access or indexer access is always reclassified as a value by performing an invocation of the <em>get accessor</em> or the <em>set accessor</em>. The particular accessor is determined by the context of the property or indexer access: If the access is the target of an assignment, the <em>set accessor</em> is invoked to assign a new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). Otherwise, the <em>get accessor</em> is invoked to obtain the current value (<a href="expressions.md#values-of-expressions">Values of expressions</a>).</p>

<h3 id="values-of-expressions">Values of expressions</h3>

<p>Most of the constructs that involve an expression ultimately require the expression to denote a <strong><em>value</em></strong>. In such cases, if the actual expression denotes a namespace, a type, a method group, or nothing, a compile-time error occurs. However, if the expression denotes a property access, an indexer access, or a variable, the value of the property, indexer, or variable is implicitly substituted:</p>

<ul>
<li> The value of a variable is simply the value currently stored in the storage location identified by the variable. A variable must be considered definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before its value can be obtained, or otherwise a compile-time error occurs.</li>
<li> The value of a property access expression is obtained by invoking the <em>get accessor</em> of the property. If the property has no <em>get accessor</em>, a compile-time error occurs. Otherwise, a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is performed, and the result of the invocation becomes the value of the property access expression.</li>
<li> The value of an indexer access expression is obtained by invoking the <em>get accessor</em> of the indexer. If the indexer has no <em>get accessor</em>, a compile-time error occurs. Otherwise, a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is performed with the argument list associated with the indexer access expression, and the result of the invocation becomes the value of the indexer access expression.</li>
</ul>

<h2 id="static-and-dynamic-binding">Static and Dynamic Binding</h2>

<p>The process of determining the meaning of an operation based on the type or value of constituent expressions (arguments, operands, receivers) is often referred to as <strong><em>binding</em></strong>. For instance the meaning of a method call is determined based on the type of the receiver and arguments. The meaning of an operator is determined based on the type of its operands.</p>

<p>In C# the meaning of an operation is usually determined at compile-time, based on the compile-time type of its constituent expressions. Likewise, if an expression contains an error, the error is detected and reported by the compiler. This approach is known as <strong><em>static binding</em></strong>.</p>

<p>However, if an expression is a dynamic expression (i.e. has the type <code class="prettyprint">dynamic</code>) this indicates that any binding that it participates in should be based on its run-time type (i.e. the actual type of the object it denotes at run-time) rather than the type it has at compile-time. The binding of such an operation is therefore deferred until the time where the operation is to be executed during the running of the program. This is referred to as <strong><em>dynamic binding</em></strong>.</p>

<p>When an operation is dynamically bound, little or no checking is performed by the compiler. Instead if the run-time binding fails, errors are reported as exceptions at run-time.</p>

<p>The following operations in C# are subject to binding:</p>

<ul>
<li> Member access: <code class="prettyprint">e.M</code></li>
<li> Method invocation: <code class="prettyprint">e.M(e1, ..., eN)</code></li>
<li> Delegate invocaton:<code class="prettyprint">e(e1, ..., eN)</code></li>
<li> Element access: <code class="prettyprint">e[e1, ..., eN]</code></li>
<li> Object creation: <code class="prettyprint">new C(e1, ..., eN)</code></li>
<li> Overloaded unary operators: <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, <code class="prettyprint">true</code>, <code class="prettyprint">false</code></li>
<li> Overloaded binary operators: <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">||</code>, <code class="prettyprint">??</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">==</code>,<code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, <code class="prettyprint">&lt;=</code></li>
<li> Assignment operators: <code class="prettyprint">=</code>, <code class="prettyprint">+=</code>, <code class="prettyprint">-=</code>, <code class="prettyprint">*=</code>, <code class="prettyprint">/=</code>, <code class="prettyprint">%=</code>, <code class="prettyprint">&amp;=</code>, <code class="prettyprint">|=</code>, <code class="prettyprint">^=</code>, <code class="prettyprint">&lt;&lt;=</code>, <code class="prettyprint">&gt;&gt;=</code></li>
<li> Implicit and explicit conversions</li>
</ul>

<p>When no dynamic expressions are involved, C# defaults to static binding, which means that the compile-time types of constituent expressions are used in the selection process. However, when one of the constituent expressions in the operations listed above is a dynamic expression, the operation is instead dynamically bound.</p>

<h3 id="binding-time">Binding-time</h3>

<p>Static binding takes place at compile-time, whereas dynamic binding takes place at run-time. In the following sections, the term <strong><em>binding-time</em></strong> refers to either compile-time or run-time, depending on when the binding takes place.</p>

<p>The following example illustrates the notions of static and dynamic binding and of binding-time:
&ldquo;`csharp
object  o = 5;
dynamic d = 5;</p>

<p>Console.WriteLine(5);  // static  binding to Console.WriteLine(int)
Console.WriteLine(o);  // static  binding to Console.WriteLine(object)
Console.WriteLine(d);  // dynamic binding to Console.WriteLine(int)
&rdquo;`</p>

<p>The first two calls are statically bound: the overload of <code class="prettyprint">Console.WriteLine</code> is picked based on the compile-time type of their argument. Thus, the binding-time is compile-time.</p>

<p>The third call is dynamically bound: the overload of <code class="prettyprint">Console.WriteLine</code> is picked based on the run-time type of its argument. This happens because the argument is a dynamic expression &ndash; its compile-time type is <code class="prettyprint">dynamic</code>. Thus, the binding-time for the third call is run-time.</p>

<h3 id="dynamic-binding">Dynamic binding</h3>

<p>The purpose of dynamic binding is to allow C# programs to interact with <strong><em>dynamic objects</em></strong>, i.e. objects that do not follow the normal rules of the C# type system. Dynamic objects may be objects from other programming languages with different types systems, or they may be objects that are programmatically setup to implement their own binding semantics for different operations.</p>

<p>The mechanism by which a dynamic object implements its own semantics is implementation defined. A given interface &ndash; again implementation defined &ndash; is implemented by dynamic objects to signal to the C# run-time that they have special semantics. Thus, whenever operations on a dynamic object are dynamically bound, their own binding semantics, rather than those of C# as specified in this document, take over.</p>

<p>While the purpose of dynamic binding is to allow interoperation with dynamic objects, C# allows dynamic binding on all objects, whether they are dynamic or not. This allows for a smoother integration of dynamic objects, as the results of operations on them may not themselves be dynamic objects, but are still of a type unknown to the programmer at compile-time. Also dynamic binding can help eliminate error-prone reflection-based code even when no objects involved are dynamic objects.</p>

<p>The following sections describe for each construct in the language exactly when dynamic binding is applied, what compile time checking &ndash; if any &ndash; is applied, and what the compile-time result and expression classification is.</p>

<h3 id="types-of-constituent-expressions">Types of constituent expressions</h3>

<p>When an operation is statically bound, the type of a constituent expression (e.g. a receiver, and argument, an index or an operand) is always considered to be the compile-time type of that expression.</p>

<p>When an operation is dynamically bound, the type of a constituent expression is determined in different ways depending on the compile-time type of the constituent expression:</p>

<ul>
<li> A constituent expression of compile-time type <code class="prettyprint">dynamic</code> is considered to have the type of the actual value that the expression evaluates to at runtime</li>
<li> A constituent expression whose compile-time type is a type parameter is considered to have the type which the type parameter is bound to at runtime</li>
<li> Otherwise the constituent expression is considered to have its compile-time type.</li>
</ul>

<h2 id="operators">Operators</h2>

<p>Expressions are constructed from <strong><em>operands</em></strong> and <strong><em>operators</em></strong>. The operators of an expression indicate which operations to apply to the operands. Examples of operators include <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, and <code class="prettyprint">new</code>. Examples of operands include literals, fields, local variables, and expressions.</p>

<p>There are three kinds of operators:</p>

<ul>
<li> Unary operators. The unary operators take one operand and use either prefix notation (such as <code class="prettyprint">--x</code>) or postfix notation (such as <code class="prettyprint">x++</code>).</li>
<li> Binary operators. The binary operators take two operands and all use infix notation (such as <code class="prettyprint">x + y</code>).</li>
<li> Ternary operator. Only one ternary operator, <code class="prettyprint">?:</code>, exists; it takes three operands and uses infix notation (<code class="prettyprint">c ? x : y</code>).</li>
</ul>

<p>The order of evaluation of operators in an expression is determined by the <strong><em>precedence</em></strong> and <strong><em>associativity</em></strong> of the operators (<a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>).</p>

<p>Operands in an expression are evaluated from left to right. For example, in <code class="prettyprint">F(i) + G(i++) * H(i)</code>, method <code class="prettyprint">F</code> is called using the old value of <code class="prettyprint">i</code>, then method <code class="prettyprint">G</code> is called with the old value of <code class="prettyprint">i</code>, and, finally, method <code class="prettyprint">H</code> is called with the new value of <code class="prettyprint">i</code>. This is separate from and unrelated to operator precedence.</p>

<p>Certain operators can be <strong><em>overloaded</em></strong>. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type (<a href="expressions.md#operator-overloading">Operator overloading</a>).</p>

<h3 id="operator-precedence-and-associativity">Operator precedence and associativity</h3>

<p>When an expression contains multiple operators, the <strong><em>precedence</em></strong> of the operators controls the order in which the individual operators are evaluated. For example, the expression <code class="prettyprint">x + y * z</code> is evaluated as <code class="prettyprint">x + (y * z)</code> because the <code class="prettyprint">*</code> operator has higher precedence than the binary <code class="prettyprint">+</code> operator. The precedence of an operator is established by the definition of its associated grammar production. For example, an <em>additive_expression</em> consists of a sequence of <em>multiplicative_expression*s separated by <code class="prettyprint">+</code> or <code class="prettyprint">-</code> operators, thus giving the <code class="prettyprint">+</code> and <code class="prettyprint">-</code> operators lower precedence than the `</em><code class="prettyprint">,</code>/<code class="prettyprint">, and</code>%` operators.</p>

<p>The following table summarizes all operators in order of precedence from highest to lowest:</p>

<table><thead>
<tr>
<th><strong>Section</strong></th>
<th><strong>Category</strong></th>
<th><strong>Operators</strong></th>
</tr>
</thead><tbody>
<tr>
<td><a href="expressions.md#primary-expressions">Primary expressions</a></td>
<td>Primary</td>
<td><code class="prettyprint">x.y</code>  <code class="prettyprint">f(x)</code>  <code class="prettyprint">a[x]</code>  <code class="prettyprint">x++</code>  <code class="prettyprint">x--</code>  <code class="prettyprint">new</code>  <code class="prettyprint">typeof</code>  <code class="prettyprint">default</code>  <code class="prettyprint">checked</code>  <code class="prettyprint">unchecked</code>  <code class="prettyprint">delegate</code></td>
</tr>
<tr>
<td><a href="expressions.md#unary-operators">Unary operators</a></td>
<td>Unary</td>
<td><code class="prettyprint">+</code>  <code class="prettyprint">*</code>  <code class="prettyprint">!</code>  <code class="prettyprint">~</code>  <code class="prettyprint">++x</code>  <code class="prettyprint">--x</code>  <code class="prettyprint">(T)x</code></td>
</tr>
<tr>
<td><a href="expressions.md#arithmetic-operators">Arithmetic operators</a></td>
<td>Multiplicative</td>
<td><code class="prettyprint">*</code>  <code class="prettyprint">/</code>  <code class="prettyprint">%</code></td>
</tr>
<tr>
<td><a href="expressions.md#arithmetic-operators">Arithmetic operators</a></td>
<td>Additive</td>
<td><code class="prettyprint">+</code>  <code class="prettyprint">-</code></td>
</tr>
<tr>
<td><a href="expressions.md#shift-operators">Shift operators</a></td>
<td>Shift</td>
<td><code class="prettyprint">&lt;&lt;</code>  <code class="prettyprint">&gt;&gt;</code></td>
</tr>
<tr>
<td><a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a></td>
<td>Relational and type testing</td>
<td><code class="prettyprint">&lt;</code>  <code class="prettyprint">&gt;</code>  <code class="prettyprint">&lt;=</code>  <code class="prettyprint">&gt;=</code>  <code class="prettyprint">is</code>  <code class="prettyprint">as</code></td>
</tr>
<tr>
<td><a href="expressions.md#relational-and-type-testing-operators">Relational and type-testing operators</a></td>
<td>Equality</td>
<td><code class="prettyprint">==</code>  <code class="prettyprint">!=</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical AND</td>
<td><code class="prettyprint">&amp;</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical XOR</td>
<td><code class="prettyprint">^</code></td>
</tr>
<tr>
<td><a href="expressions.md#logical-operators">Logical operators</a></td>
<td>Logical OR</td>
<td>`\</td>
</tr>
<tr>
<td><a href="expressions.md#conditional-logical-operators">Conditional logical operators</a></td>
<td>Conditional AND</td>
<td><code class="prettyprint">&amp;&amp;</code></td>
</tr>
<tr>
<td><a href="expressions.md#conditional-logical-operators">Conditional logical operators</a></td>
<td>Conditional OR</td>
<td>`\</td>
</tr>
<tr>
<td><a href="expressions.md#the-null-coalescing-operator">The null coalescing operator</a></td>
<td>Null coalescing</td>
<td><code class="prettyprint">??</code></td>
</tr>
<tr>
<td><a href="expressions.md#conditional-operator">Conditional operator</a></td>
<td>Conditional</td>
<td><code class="prettyprint">?:</code></td>
</tr>
<tr>
<td><a href="expressions.md#assignment-operators">Assignment operators</a>, <a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a></td>
<td>Assignment and lambda expression</td>
<td><code class="prettyprint">=</code>  <code class="prettyprint">*=</code>  <code class="prettyprint">/=</code>  <code class="prettyprint">%=</code>  <code class="prettyprint">+=</code>  <code class="prettyprint">-=</code>  <code class="prettyprint">&lt;&lt;=</code>  <code class="prettyprint">&gt;&gt;=</code>  <code class="prettyprint">&amp;=</code>  <code class="prettyprint">^=</code>  `\</td>
</tr>
</tbody></table>

<p>When an operand occurs between two operators with the same precedence, the associativity of the operators controls the order in which the operations are performed:</p>

<ul>
<li> Except for the assignment operators and the null coalescing operator, all binary operators are <strong><em>left-associative</em></strong>, meaning that operations are performed from left to right. For example, <code class="prettyprint">x + y + z</code> is evaluated as <code class="prettyprint">(x + y) + z</code>.</li>
<li> The assignment operators, the null coalescing operator and the conditional operator (<code class="prettyprint">?:</code>) are <strong><em>right-associative</em></strong>, meaning that operations are performed from right to left. For example, <code class="prettyprint">x = y = z</code> is evaluated as <code class="prettyprint">x = (y = z)</code>.</li>
</ul>

<p>Precedence and associativity can be controlled using parentheses. For example, <code class="prettyprint">x + y * z</code> first multiplies <code class="prettyprint">y</code> by <code class="prettyprint">z</code> and then adds the result to <code class="prettyprint">x</code>, but <code class="prettyprint">(x + y) * z</code> first adds <code class="prettyprint">x</code> and <code class="prettyprint">y</code> and then multiplies the result by <code class="prettyprint">z</code>.</p>

<h3 id="operator-overloading">Operator overloading</h3>

<p>All unary and binary operators have predefined implementations that are automatically available in any expression. In addition to the predefined implementations, user-defined implementations can be introduced by including <code class="prettyprint">operator</code> declarations in classes and structs (<a href="classes.md#operators">Operators</a>). User-defined operator implementations always take precedence over predefined operator implementations: Only when no applicable user-defined operator implementations exist will the predefined operator implementations be considered, as described in <a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a> and <a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>.</p>

<p>The <strong><em>overloadable unary operators</em></strong> are:
<code class="prettyprint">csharp
+   -   !   ~   ++   --   true   false
</code></p>

<p>Although <code class="prettyprint">true</code> and <code class="prettyprint">false</code> are not used explicitly in expressions (and therefore are not included in the precedence table in <a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>), they are considered operators because they are invoked in several expression contexts: boolean expressions (<a href="expressions.md#boolean-expressions">Boolean expressions</a>) and expressions involving the conditional (<a href="expressions.md#conditional-operator">Conditional operator</a>), and conditional logical operators (<a href="expressions.md#conditional-logical-operators">Conditional logical operators</a>).</p>

<p>The <strong><em>overloadable binary operators</em></strong> are:
<code class="prettyprint">csharp
+   -   *   /   %   &amp;   |   ^   &lt;&lt;   &gt;&gt;   ==   !=   &gt;   &lt;   &gt;=   &lt;=
</code></p>

<p>Only the operators listed above can be overloaded. In particular, it is not possible to overload member access, method invocation, or the <code class="prettyprint">=</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">||</code>, <code class="prettyprint">??</code>, <code class="prettyprint">?:</code>, <code class="prettyprint">=&gt;</code>, <code class="prettyprint">checked</code>, <code class="prettyprint">unchecked</code>, <code class="prettyprint">new</code>, <code class="prettyprint">typeof</code>, <code class="prettyprint">default</code>, <code class="prettyprint">as</code>, and <code class="prettyprint">is</code> operators.</p>

<p>When a binary operator is overloaded, the corresponding assignment operator, if any, is also implicitly overloaded. For example, an overload of operator <code class="prettyprint">*</code> is also an overload of operator <code class="prettyprint">*=</code>. This is described further in <a href="expressions.md#compound-assignment">Compound assignment</a>. Note that the assignment operator itself (<code class="prettyprint">=</code>) cannot be overloaded. An assignment always performs a simple bit-wise copy of a value into a variable.</p>

<p>Cast operations, such as <code class="prettyprint">(T)x</code>, are overloaded by providing user-defined conversions (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>).</p>

<p>Element access, such as <code class="prettyprint">a[x]</code>, is not considered an overloadable operator. Instead, user-defined indexing is supported through indexers (<a href="classes.md#indexers">Indexers</a>).</p>

<p>In expressions, operators are referenced using operator notation, and in declarations, operators are referenced using functional notation. The following table shows the relationship between operator and functional notations for unary and binary operators. In the first entry, <em>op</em> denotes any overloadable unary prefix operator. In the second entry, <em>op</em> denotes the unary postfix <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators. In the third entry, <em>op</em> denotes any overloadable binary operator.</p>

<table><thead>
<tr>
<th><strong>Operator notation</strong></th>
<th><strong>Functional notation</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">op x</code></td>
<td><code class="prettyprint">operator op(x)</code></td>
</tr>
<tr>
<td><code class="prettyprint">x op</code></td>
<td><code class="prettyprint">operator op(x)</code></td>
</tr>
<tr>
<td><code class="prettyprint">x op y</code></td>
<td><code class="prettyprint">operator op(x,y)</code></td>
</tr>
</tbody></table>

<p>User-defined operator declarations always require at least one of the parameters to be of the class or struct type that contains the operator declaration. Thus, it is not possible for a user-defined operator to have the same signature as a predefined operator.</p>

<p>User-defined operator declarations cannot modify the syntax, precedence, or associativity of an operator. For example, the <code class="prettyprint">/</code> operator is always a binary operator, always has the precedence level specified in <a href="expressions.md#operator-precedence-and-associativity">Operator precedence and associativity</a>, and is always left-associative.</p>

<p>While it is possible for a user-defined operator to perform any computation it pleases, implementations that produce results other than those that are intuitively expected are strongly discouraged. For example, an implementation of <code class="prettyprint">operator ==</code> should compare the two operands for equality and return an appropriate <code class="prettyprint">bool</code> result.</p>

<p>The descriptions of individual operators in <a href="expressions.md#primary-expressions">Primary expressions</a> through <a href="expressions.md#conditional-logical-operators">Conditional logical operators</a> specify the predefined implementations of the operators and any additional rules that apply to each operator. The descriptions make use of the terms <strong><em>unary operator overload resolution</em></strong>, <strong><em>binary operator overload resolution</em></strong>, and <strong><em>numeric promotion</em></strong>, definitions of which are found in the following sections.</p>

<h3 id="unary-operator-overload-resolution">Unary operator overload resolution</h3>

<p>An operation of the form <code class="prettyprint">op x</code> or <code class="prettyprint">x op</code>, where <code class="prettyprint">op</code> is an overloadable unary operator, and <code class="prettyprint">x</code> is an expression of type <code class="prettyprint">X</code>, is processed as follows:</p>

<ul>
<li> The set of candidate user-defined operators provided by <code class="prettyprint">X</code> for the operation <code class="prettyprint">operator op(x)</code> is determined using the rules of <a href="expressions.md#candidate-user-defined-operators">Candidate user-defined operators</a>.</li>
<li> If the set of candidate user-defined operators is not empty, then this becomes the set of candidate operators for the operation. Otherwise, the predefined unary <code class="prettyprint">operator op</code> implementations, including their lifted forms, become the set of candidate operators for the operation. The predefined implementations of a given operator are specified in the description of the operator (<a href="expressions.md#primary-expressions">Primary expressions</a> and <a href="expressions.md#unary-operators">Unary operators</a>).</li>
<li> The overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a> are applied to the set of candidate operators to select the best operator with respect to the argument list <code class="prettyprint">(x)</code>, and this operator becomes the result of the overload resolution process. If overload resolution fails to select a single best operator, a binding-time error occurs.</li>
</ul>

<h3 id="binary-operator-overload-resolution">Binary operator overload resolution</h3>

<p>An operation of the form <code class="prettyprint">x op y</code>, where <code class="prettyprint">op</code> is an overloadable binary operator, <code class="prettyprint">x</code> is an expression of type <code class="prettyprint">X</code>, and <code class="prettyprint">y</code> is an expression of type <code class="prettyprint">Y</code>, is processed as follows:</p>

<ul>
<li> The set of candidate user-defined operators provided by <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> for the operation <code class="prettyprint">operator op(x,y)</code> is determined. The set consists of the union of the candidate operators provided by <code class="prettyprint">X</code> and the candidate operators provided by <code class="prettyprint">Y</code>, each determined using the rules of <a href="expressions.md#candidate-user-defined-operators">Candidate user-defined operators</a>. If <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> are the same type, or if <code class="prettyprint">X</code> and <code class="prettyprint">Y</code> are derived from a common base type, then shared candidate operators only occur in the combined set once.</li>
<li> If the set of candidate user-defined operators is not empty, then this becomes the set of candidate operators for the operation. Otherwise, the predefined binary <code class="prettyprint">operator op</code> implementations, including their lifted forms,  become the set of candidate operators for the operation. The predefined implementations of a given operator are specified in the description of the operator (<a href="expressions.md#arithmetic-operators">Arithmetic operators</a> through <a href="expressions.md#conditional-logical-operators">Conditional logical operators</a>). For predefined enum and delegate operators, the only operators considered are those defined by an enum or delegate type that is the binding-time type of one of the operands.</li>
<li> The overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a> are applied to the set of candidate operators to select the best operator with respect to the argument list <code class="prettyprint">(x,y)</code>, and this operator becomes the result of the overload resolution process. If overload resolution fails to select a single best operator, a binding-time error occurs.</li>
</ul>

<h3 id="candidate-user-defined-operators">Candidate user-defined operators</h3>

<p>Given a type <code class="prettyprint">T</code> and an operation <code class="prettyprint">operator op(A)</code>, where <code class="prettyprint">op</code> is an overloadable operator and <code class="prettyprint">A</code> is an argument list, the set of candidate user-defined operators provided by <code class="prettyprint">T</code> for <code class="prettyprint">operator op(A)</code> is determined as follows:</p>

<ul>
<li> Determine the type <code class="prettyprint">T0</code>. If <code class="prettyprint">T</code> is a nullable type, <code class="prettyprint">T0</code> is its underlying type, otherwise <code class="prettyprint">T0</code> is equal to <code class="prettyprint">T</code>.</li>
<li> For all <code class="prettyprint">operator op</code> declarations in <code class="prettyprint">T0</code> and all lifted forms of such operators, if at least one operator is applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>) with respect to the argument list <code class="prettyprint">A</code>, then the set of candidate operators consists of all such applicable operators in <code class="prettyprint">T0</code>.</li>
<li> Otherwise, if <code class="prettyprint">T0</code> is <code class="prettyprint">object</code>, the set of candidate operators is empty.</li>
<li> Otherwise, the set of candidate operators provided by <code class="prettyprint">T0</code> is the set of candidate operators provided by the direct base class of <code class="prettyprint">T0</code>, or the effective base class of <code class="prettyprint">T0</code> if <code class="prettyprint">T0</code> is a type parameter.</li>
</ul>

<h3 id="numeric-promotions">Numeric promotions</h3>

<p>Numeric promotion consists of automatically performing certain implicit conversions of the operands of the predefined unary and binary numeric operators. Numeric promotion is not a distinct mechanism, but rather an effect of applying overload resolution to the predefined operators. Numeric promotion specifically does not affect evaluation of user-defined operators, although user-defined operators can be implemented to exhibit similar effects.</p>

<p>As an example of numeric promotion, consider the predefined implementations of the binary <code class="prettyprint">*</code> operator:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">uint</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">long</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">ulong</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">float</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">double</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">decimal</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>When overload resolution rules (<a href="expressions.md#overload-resolution">Overload resolution</a>) are applied to this set of operators, the effect is to select the first of the operators for which implicit conversions exist from the operand types. For example, for the operation <code class="prettyprint">b * s</code>, where <code class="prettyprint">b</code> is a <code class="prettyprint">byte</code> and <code class="prettyprint">s</code> is a <code class="prettyprint">short</code>, overload resolution selects <code class="prettyprint">operator *(int,int)</code> as the best operator. Thus, the effect is that <code class="prettyprint">b</code> and <code class="prettyprint">s</code> are converted to <code class="prettyprint">int</code>, and the type of the result is <code class="prettyprint">int</code>. Likewise, for the operation <code class="prettyprint">i * d</code>, where <code class="prettyprint">i</code> is an <code class="prettyprint">int</code> and <code class="prettyprint">d</code> is a <code class="prettyprint">double</code>, overload resolution selects <code class="prettyprint">operator *(double,double)</code> as the best operator.</p>

<h4 id="unary-numeric-promotions">Unary numeric promotions</h4>

<p>Unary numeric promotion occurs for the operands of the predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, and <code class="prettyprint">~</code> unary operators. Unary numeric promotion simply consists of converting operands of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, or <code class="prettyprint">char</code> to type <code class="prettyprint">int</code>. Additionally, for the unary <code class="prettyprint">-</code> operator, unary numeric promotion converts operands of type <code class="prettyprint">uint</code> to type <code class="prettyprint">long</code>.</p>

<h4 id="binary-numeric-promotions">Binary numeric promotions</h4>

<p>Binary numeric promotion occurs for the operands of the predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, and <code class="prettyprint">&lt;=</code> binary operators. Binary numeric promotion implicitly converts both operands to a common type which, in case of the non-relational operators, also becomes the result type of the operation. Binary numeric promotion consists of applying the following rules, in the order they appear here:</p>

<ul>
<li> If either operand is of type <code class="prettyprint">decimal</code>, the other operand is converted to type <code class="prettyprint">decimal</code>, or a binding-time error occurs if the other operand is of type <code class="prettyprint">float</code> or <code class="prettyprint">double</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">double</code>, the other operand is converted to type <code class="prettyprint">double</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">float</code>, the other operand is converted to type <code class="prettyprint">float</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">ulong</code>, the other operand is converted to type <code class="prettyprint">ulong</code>, or a binding-time error occurs if the other operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">long</code>, the other operand is converted to type <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">uint</code> and the other operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, or <code class="prettyprint">int</code>, both operands are converted to type <code class="prettyprint">long</code>.</li>
<li> Otherwise, if either operand is of type <code class="prettyprint">uint</code>, the other operand is converted to type <code class="prettyprint">uint</code>.</li>
<li> Otherwise, both operands are converted to type <code class="prettyprint">int</code>.</li>
</ul>

<p>Note that the first rule disallows any operations that mix the <code class="prettyprint">decimal</code> type with the <code class="prettyprint">double</code> and <code class="prettyprint">float</code> types. The rule follows from the fact that there are no implicit conversions between the <code class="prettyprint">decimal</code> type and the <code class="prettyprint">double</code> and <code class="prettyprint">float</code> types.</p>

<p>Also note that it is not possible for an operand to be of type <code class="prettyprint">ulong</code> when the other operand is of a signed integral type. The reason is that no integral type exists that can represent the full range of <code class="prettyprint">ulong</code> as well as the signed integral types.</p>

<p>In both of the above cases, a cast expression can be used to explicitly convert one operand to a type that is compatible with the other operand.</p>

<p>In the example
<code class="prettyprint">csharp
decimal AddPercent(decimal x, double percent) {
    return x * (1.0 + percent / 100.0);
}
</code>
a binding-time error occurs because a <code class="prettyprint">decimal</code> cannot be multiplied by a <code class="prettyprint">double</code>. The error is resolved by explicitly converting the second operand to <code class="prettyprint">decimal</code>, as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">decimal</span> <span class="nf">AddPercent</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">percent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="p">(</span><span class="kt">decimal</span><span class="p">)(</span><span class="m">1.0</span> <span class="p">+</span> <span class="n">percent</span> <span class="p">/</span> <span class="m">100.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="lifted-operators">Lifted operators</h3>

<p><strong><em>Lifted operators</em></strong> permit predefined and user-defined operators that operate on non-nullable value types to also be used with nullable forms of those types. Lifted operators are constructed from predefined and user-defined operators that meet certain requirements, as described in the following:</p>

<ul>
<li><p>For the unary operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">+</span>  <span class="p">++</span>  <span class="p">-</span>  <span class="p">--</span>  <span class="p">!</span>  <span class="p">~</span>
</code></pre>
<p>a lifted form of an operator exists if the operand and result types are both non-nullable value types. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to the operand and result types. The lifted operator produces a null value if the operand is null. Otherwise, the lifted operator unwraps the operand, applies the underlying operator, and wraps the result.</p></li>
<li><p>For the binary operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">+</span>  <span class="p">-</span>  <span class="p">*</span>  <span class="p">/</span>  <span class="p">%</span>  <span class="p">&amp;</span>  <span class="p">|</span>  <span class="p">^</span>  <span class="p">&lt;&lt;</span>  <span class="p">&gt;&gt;</span>
</code></pre>
<p>a lifted form of an operator exists if the operand and result types are all non-nullable value types. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand and result type. The lifted operator produces a null value if one or both operands are null (an exception being the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators of the <code class="prettyprint">bool?</code> type, as described in <a href="expressions.md#boolean-logical-operators">Boolean logical operators</a>). Otherwise, the lifted operator unwraps the operands, applies the underlying operator, and wraps the result.</p></li>
<li><p>For the equality operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">==</span>  <span class="p">!=</span>
</code></pre>
<p>a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is <code class="prettyprint">bool</code>. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand type. The lifted operator considers two null values equal, and a null value unequal to any non-null value. If both operands are non-null, the lifted operator unwraps the operands and applies the underlying operator to produce the <code class="prettyprint">bool</code> result.</p></li>
<li><p>For the relational operators</p>
<pre class="highlight csharp tab-csharp"><code><span class="p">&lt;</span>  <span class="p">&gt;</span>  <span class="p">&lt;=</span>  <span class="p">&gt;=</span>
</code></pre>
<p>a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is <code class="prettyprint">bool</code>. The lifted form is constructed by adding a single <code class="prettyprint">?</code> modifier to each operand type. The lifted operator produces the value <code class="prettyprint">false</code> if one or both operands are null. Otherwise, the lifted operator unwraps the operands and applies the underlying operator to produce the <code class="prettyprint">bool</code> result.</p></li>
</ul>

<h2 id="member-lookup">Member lookup</h2>

<p>A member lookup is the process whereby the meaning of a name in the context of a type is determined. A member lookup can occur as part of evaluating a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) in an expression. If the <em>simple_name</em> or <em>member_access</em> occurs as the <em>primary_expression</em> of an <em>invocation_expression</em> (<a href="expressions.md#method-invocations">Method invocations</a>), the member is said to be invoked.</p>

<p>If a member is a method or event, or if it is a constant, field or property of either a delegate type (<a href="delegates.md#delegates">Delegates</a>) or the type <code class="prettyprint">dynamic</code> (<a href="types.md#the-dynamic-type">The dynamic type</a>), then the member is said to be <em>invocable</em>.</p>

<p>Member lookup considers not only the name of a member but also the number of type parameters the member has and whether the member is accessible. For the purposes of member lookup, generic methods and nested generic types have the number of type parameters indicated in their respective declarations and all other members have zero type parameters.</p>

<p>A member lookup of a name <code class="prettyprint">N</code> with <code class="prettyprint">K</code> type parameters in a type <code class="prettyprint">T</code> is processed as follows:</p>

<ul>
<li> First, a set of accessible members named <code class="prettyprint">N</code> is determined:

<ul>
<li>If <code class="prettyprint">T</code> is a type parameter, then the set is the union of the sets of accessible members named <code class="prettyprint">N</code> in each of the types specified as a primary constraint or secondary constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) for <code class="prettyprint">T</code>, along with the set of accessible members named <code class="prettyprint">N</code> in <code class="prettyprint">object</code>.</li>
<li>Otherwise, the set consists of all accessible (<a href="basic-concepts.md#member-access">Member access</a>) members named <code class="prettyprint">N</code> in <code class="prettyprint">T</code>, including inherited members and the accessible members named <code class="prettyprint">N</code> in <code class="prettyprint">object</code>. If <code class="prettyprint">T</code> is a constructed type, the set of members is obtained by substituting type arguments as described in <a href="classes.md#members-of-constructed-types">Members of constructed types</a>. Members that include an <code class="prettyprint">override</code> modifier are excluded from the set.</li>
</ul></li>
<li> Next, if <code class="prettyprint">K</code> is zero, all nested types whose declarations include type parameters are removed. If <code class="prettyprint">K</code> is not zero, all members with a different number of type parameters are removed. Note that when <code class="prettyprint">K</code> is zero, methods having type parameters are not removed, since the type inference process (<a href="expressions.md#type-inference">Type inference</a>) might be able to infer the type arguments.</li>
<li> Next, if the member is <em>invoked</em>, all non-<em>invocable</em> members are removed from the set.</li>
<li> Next, members that are hidden by other members are removed from the set. For every member <code class="prettyprint">S.M</code> in the set, where <code class="prettyprint">S</code> is the type in which the member <code class="prettyprint">M</code> is declared, the following rules are applied:

<ul>
<li>If <code class="prettyprint">M</code> is a constant, field, property, event, or enumeration member, then all members declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a type declaration, then all non-types declared in a base type of <code class="prettyprint">S</code> are removed from the set, and all type declarations with the same number of type parameters as <code class="prettyprint">M</code> declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a method, then all non-method members declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
</ul></li>
<li> Next, interface members that are hidden by class members are removed from the set. This step only has an effect if <code class="prettyprint">T</code> is a type parameter and <code class="prettyprint">T</code> has both an effective base class other than <code class="prettyprint">object</code> and a non-empty effective interface set (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For every member <code class="prettyprint">S.M</code> in the set, where <code class="prettyprint">S</code> is the type in which the member <code class="prettyprint">M</code> is declared, the following rules are applied if <code class="prettyprint">S</code> is a class declaration other than <code class="prettyprint">object</code>:

<ul>
<li>If <code class="prettyprint">M</code> is a constant, field, property, event, enumeration member, or type declaration, then all members declared in an interface declaration are removed from the set.</li>
<li>If <code class="prettyprint">M</code> is a method, then all non-method members declared in an interface declaration are removed from the set, and all methods with the same signature as <code class="prettyprint">M</code> declared in an interface declaration are removed from the set.</li>
</ul></li>
<li> Finally, having removed hidden members, the result of the lookup is determined:

<ul>
<li>If the set consists of a single member that is not a method, then this member is the result of the lookup.</li>
<li>Otherwise, if the set contains only methods, then this group of methods is the result of the lookup.</li>
<li>Otherwise, the lookup is ambiguous, and a binding-time error occurs.</li>
</ul></li>
</ul>

<p>For member lookups in types other than type parameters and interfaces, and member lookups in interfaces that are strictly single-inheritance (each interface in the inheritance chain has exactly zero or one direct base interface), the effect of the lookup rules is simply that derived members hide base members with the same name or signature. Such single-inheritance lookups are never ambiguous. The ambiguities that can possibly arise from member lookups in multiple-inheritance interfaces are described in <a href="interfaces.md#interface-member-access">Interface member access</a>.</p>

<h3 id="base-types">Base types</h3>

<p>For purposes of member lookup, a type <code class="prettyprint">T</code> is considered to have the following base types:</p>

<ul>
<li> If <code class="prettyprint">T</code> is <code class="prettyprint">object</code>, then <code class="prettyprint">T</code> has no base type.</li>
<li> If <code class="prettyprint">T</code> is an <em>enum_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Enum</code>, <code class="prettyprint">System.ValueType</code>, and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>struct_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>class_type</em>, the base types of <code class="prettyprint">T</code> are the base classes of <code class="prettyprint">T</code>, including the class type <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is an <em>interface_type</em>, the base types of <code class="prettyprint">T</code> are the base interfaces of <code class="prettyprint">T</code> and the class type <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is an <em>array_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Array</code> and <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> is a <em>delegate_type</em>, the base types of <code class="prettyprint">T</code> are the class types <code class="prettyprint">System.Delegate</code> and <code class="prettyprint">object</code>.</li>
</ul>

<h2 id="function-members">Function members</h2>

<p>Function members are members that contain executable statements. Function members are always members of types and cannot be members of namespaces. C# defines the following categories of function members:</p>

<ul>
<li> Methods</li>
<li> Properties</li>
<li> Events</li>
<li> Indexers</li>
<li> User-defined operators</li>
<li> Instance constructors</li>
<li> Static constructors</li>
<li> Destructors</li>
</ul>

<p>Except for destructors and static constructors (which cannot be invoked explicitly), the statements contained in function members are executed through function member invocations. The actual syntax for writing a function member invocation depends on the particular function member category.</p>

<p>The argument list (<a href="expressions.md#argument-lists">Argument lists</a>) of a function member invocation provides actual values or variable references for the parameters of the function member.</p>

<p>Invocations of generic methods may employ type inference to determine the set of type arguments to pass to the method. This process is described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<p>Invocations of methods, indexers, operators and instance constructors employ overload resolution to determine which of a candidate set of function members to invoke. This process is described in <a href="expressions.md#overload-resolution">Overload resolution</a>.</p>

<p>Once a particular function member has been identified at binding-time, possibly through overload resolution, the actual run-time process of invoking the function member is described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The following table summarizes the processing that takes place in constructs involving the six categories of function members that can be explicitly invoked. In the table, <code class="prettyprint">e</code>, <code class="prettyprint">x</code>, <code class="prettyprint">y</code>, and <code class="prettyprint">value</code> indicate expressions classified as variables or values, <code class="prettyprint">T</code> indicates an expression classified as a type, <code class="prettyprint">F</code> is the simple name of a method, and <code class="prettyprint">P</code> is the simple name of a property.</p>

<table><thead>
<tr>
<th><strong>Construct</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td>Method invocation</td>
<td><code class="prettyprint">F(x,y)</code></td>
<td>Overload resolution is applied to select the best method <code class="prettyprint">F</code> in the containing class or struct. The method is invoked with the argument list <code class="prettyprint">(x,y)</code>. If the method is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.F(x,y)</code></td>
<td>Overload resolution is applied to select the best method <code class="prettyprint">F</code> in the class or struct <code class="prettyprint">T</code>. A binding-time error occurs if the method is not <code class="prettyprint">static</code>. The method is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.F(x,y)</code></td>
<td>Overload resolution is applied to select the best method F in the class, struct, or interface given by the type of <code class="prettyprint">e</code>. A binding-time error occurs if the method is <code class="prettyprint">static</code>. The method is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td>Property access</td>
<td><code class="prettyprint">P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the containing class or struct is invoked. A compile-time error occurs if <code class="prettyprint">P</code> is write-only. If <code class="prettyprint">P</code> is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the containing class or struct is invoked with the argument list <code class="prettyprint">(value)</code>. A compile-time error occurs if <code class="prettyprint">P</code> is read-only. If <code class="prettyprint">P</code> is not <code class="prettyprint">static</code>, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the class or struct <code class="prettyprint">T</code> is invoked. A compile-time error occurs if <code class="prettyprint">P</code> is not <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the class or struct <code class="prettyprint">T</code> is invoked with the argument list <code class="prettyprint">(value)</code>. A compile-time error occurs if <code class="prettyprint">P</code> is not <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is read-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.P</code></td>
<td>The <code class="prettyprint">get</code> accessor of the property <code class="prettyprint">P</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">P</code> is <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.P = value</code></td>
<td>The <code class="prettyprint">set</code> accessor of the property <code class="prettyprint">P</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(value)</code>. A binding-time error occurs if <code class="prettyprint">P</code> is <code class="prettyprint">static</code> or if <code class="prettyprint">P</code> is read-only.</td>
</tr>
<tr>
<td>Event access</td>
<td><code class="prettyprint">E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the containing class or struct is invoked. If <code class="prettyprint">E</code> is not static, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the containing class or struct is invoked. If <code class="prettyprint">E</code> is not static, the instance expression is <code class="prettyprint">this</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the class or struct <code class="prettyprint">T</code> is invoked. A binding-time error occurs if <code class="prettyprint">E</code> is not static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">T.E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the class or struct <code class="prettyprint">T</code> is invoked. A binding-time error occurs if <code class="prettyprint">E</code> is not static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.E += value</code></td>
<td>The <code class="prettyprint">add</code> accessor of the event <code class="prettyprint">E</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">E</code> is static.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e.E -= value</code></td>
<td>The <code class="prettyprint">remove</code> accessor of the event <code class="prettyprint">E</code> in the class, struct, or interface given by the type of <code class="prettyprint">e</code> is invoked with the instance expression <code class="prettyprint">e</code>. A binding-time error occurs if <code class="prettyprint">E</code> is static.</td>
</tr>
<tr>
<td>Indexer access</td>
<td><code class="prettyprint">e[x,y]</code></td>
<td>Overload resolution is applied to select the best indexer in the class, struct, or interface given by the type of e. The <code class="prettyprint">get</code> accessor of the indexer is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y)</code>. A binding-time error occurs if the indexer is write-only.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">e[x,y] = value</code></td>
<td>Overload resolution is applied to select the best indexer in the class, struct, or interface given by the type of <code class="prettyprint">e</code>. The <code class="prettyprint">set</code> accessor of the indexer is invoked with the instance expression <code class="prettyprint">e</code> and the argument list <code class="prettyprint">(x,y,value)</code>. A binding-time error occurs if the indexer is read-only.</td>
</tr>
<tr>
<td>Operator invocation</td>
<td><code class="prettyprint">-x</code></td>
<td>Overload resolution is applied to select the best unary operator in the class or struct given by the type of <code class="prettyprint">x</code>. The selected operator is invoked with the argument list <code class="prettyprint">(x)</code>.</td>
</tr>
<tr>
<td></td>
<td><code class="prettyprint">x + y</code></td>
<td>Overload resolution is applied to select the best binary operator in the classes or structs given by the types of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>. The selected operator is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
<tr>
<td>Instance constructor invocation</td>
<td><code class="prettyprint">new T(x,y)</code></td>
<td>Overload resolution is applied to select the best instance constructor in the class or struct <code class="prettyprint">T</code>. The instance constructor is invoked with the argument list <code class="prettyprint">(x,y)</code>.</td>
</tr>
</tbody></table>

<h3 id="argument-lists">Argument lists</h3>

<p>Every function member and delegate invocation includes an argument list which provides actual values or variable references for the parameters of the function member. The syntax for specifying the argument list of a function member invocation depends on the function member category:</p>

<ul>
<li> For instance constructors, methods, indexers and delegates, the arguments are specified as an <em>argument_list</em>, as described below. For indexers, when invoking the <code class="prettyprint">set</code> accessor, the argument list additionally includes the expression specified as the right operand of the assignment operator.</li>
<li> For properties, the argument list is empty when invoking the <code class="prettyprint">get</code> accessor, and consists of the expression specified as the right operand of the assignment operator when invoking the <code class="prettyprint">set</code> accessor.</li>
<li> For events, the argument list consists of the expression specified as the right operand of the <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator.</li>
<li> For user-defined operators, the argument list consists of the single operand of the unary operator or the two operands of the binary operator.</li>
</ul>

<p>The arguments of properties (<a href="classes.md#properties">Properties</a>), events (<a href="classes.md#events">Events</a>), and user-defined operators (<a href="classes.md#operators">Operators</a>) are always passed as value parameters (<a href="classes.md#value-parameters">Value parameters</a>). The arguments of indexers (<a href="classes.md#indexers">Indexers</a>) are always passed as value parameters (<a href="classes.md#value-parameters">Value parameters</a>) or parameter arrays (<a href="classes.md#parameter-arrays">Parameter arrays</a>). Reference and output parameters are not supported for these categories of function members.</p>

<p>The arguments of an instance constructor, method, indexer or delegate invocation are specified as an <em>argument_list</em>:</p>
<pre class="highlight shell"><code>argument_list
    : argument <span class="o">(</span><span class="s1">','</span> argument<span class="o">)</span><span class="k">*</span>
    ;

argument
    : argument_name? argument_value
    ;

argument_name
    : identifier <span class="s1">':'</span>
    ;

argument_value
    : expression
    | <span class="s1">'ref'</span> variable_reference
    | <span class="s1">'out'</span> variable_reference
    ;
</code></pre>
<p>An <em>argument_list</em> consists of one or more <em>argument*s, separated by commas. Each argument consists of an optional  *argument_name</em> followed by an <em>argument_value</em>. An <em>argument</em> with an <em>argument_name</em> is referred to as a <strong><em>named argument</em></strong>, whereas an <em>argument</em> without an <em>argument_name</em> is a <strong><em>positional argument</em></strong>. It is an error for a positional argument to appear after a named argument in an <em>argument_list</em>.</p>

<p>The <em>argument_value</em> can take one of the following forms:</p>

<ul>
<li> An <em>expression</em>, indicating that the argument is passed as a value parameter (<a href="classes.md#value-parameters">Value parameters</a>).</li>
<li> The keyword <code class="prettyprint">ref</code> followed by a <em>variable_reference</em> (<a href="variables.md#variable-references">Variable references</a>), indicating that the argument is passed as a reference parameter (<a href="classes.md#reference-parameters">Reference parameters</a>). A variable must be definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) before it can be passed as a reference parameter. The keyword <code class="prettyprint">out</code> followed by a <em>variable_reference</em> (<a href="variables.md#variable-references">Variable references</a>), indicating that the argument is passed as an output parameter (<a href="classes.md#output-parameters">Output parameters</a>). A variable is considered definitely assigned (<a href="variables.md#definite-assignment">Definite assignment</a>) following a function member invocation in which the variable is passed as an output parameter.</li>
</ul>

<h4 id="corresponding-parameters">Corresponding parameters</h4>

<p>For each argument in an argument list there has to be a corresponding parameter in the function member or delegate being invoked.</p>

<p>The parameter list used in the following is determined as follows:</p>

<ul>
<li> For virtual methods and indexers defined in classes, the parameter list is picked from the most specific declaration or override of the function member, starting with the static type of the receiver, and searching through its base classes.</li>
<li> For interface methods and indexers, the parameter list is picked form the most specific definition of the member, starting with the interface type and searching through the base interfaces. If no unique parameter list is found, a parameter list with inaccessible names and no optional parameters is constructed, so that invocations cannot use named parameters or omit optional arguments.</li>
<li> For partial methods, the parameter list of the defining partial method declaration is used.</li>
<li> For all other function members and delegates there is only a single parameter list, which is the one used.</li>
</ul>

<p>The position of an argument or parameter is defined as the number of arguments or parameters preceding it in the argument list or parameter list.</p>

<p>The corresponding parameters for function member arguments are established as follows:</p>

<ul>
<li> Arguments in the <em>argument_list</em> of instance constructors, methods, indexers and delegates:

<ul>
<li>A positional argument where a fixed parameter occurs at the same position in the parameter list corresponds to that parameter.</li>
<li>A positional argument of a function member with a parameter array invoked in its normal form corresponds to the parameter  array, which must occur at the same position in the parameter list.</li>
<li>A positional argument of a function member with a parameter array invoked in its expanded form, where no fixed parameter occurs at the same position in the parameter list, corresponds to an element in the parameter array.</li>
<li>A named argument corresponds to the parameter of the same name in the parameter list.</li>
<li>For indexers, when invoking the <code class="prettyprint">set</code> accessor, the expression specified as the right operand of the assignment operator corresponds to the implicit <code class="prettyprint">value</code> parameter of the <code class="prettyprint">set</code> accessor declaration.</li>
</ul></li>
<li> For properties, when invoking the <code class="prettyprint">get</code> accessor there are no arguments. When invoking the <code class="prettyprint">set</code> accessor, the expression specified as the right operand of the assignment operator corresponds to the implicit <code class="prettyprint">value</code> parameter of the <code class="prettyprint">set</code> accessor declaration.</li>
<li> For user-defined unary operators (including conversions), the single operand corresponds to the single parameter of the operator declaration.</li>
<li> For user-defined binary operators, the left operand corresponds to the first parameter, and the right operand corresponds to the second parameter of the operator declaration.</li>
</ul>

<h4 id="run-time-evaluation-of-argument-lists">Run-time evaluation of argument lists</h4>

<p>During the run-time processing of a function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>), the expressions or variable references of an argument list are evaluated in order, from left to right, as follows:</p>

<ul>
<li> For a value parameter, the argument expression is evaluated and an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the corresponding parameter type is performed. The resulting value becomes the initial value of the value parameter in the function member invocation.</li>
<li> For a reference or output parameter, the variable reference is evaluated and the resulting storage location becomes the storage location represented by the parameter in the function member invocation. If the variable reference given as a reference or output parameter is an array element of a <em>reference_type</em>, a run-time check is performed to ensure that the element type of the array is identical to the type of the parameter. If this check fails, a <code class="prettyprint">System.ArrayTypeMismatchException</code> is thrown.</li>
</ul>

<p>Methods, indexers, and instance constructors may declare their right-most parameter to be a parameter array (<a href="classes.md#parameter-arrays">Parameter arrays</a>). Such function members are invoked either in their normal form or in their expanded form depending on which is applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>):</p>

<ul>
<li> When a function member with a parameter array is invoked in its normal form, the argument given for the parameter array must be a single expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the parameter array type. In this case, the parameter array acts precisely like a value parameter.</li>
<li> When a function member with a parameter array is invoked in its expanded form, the invocation must specify zero or more positional arguments for the parameter array, where each argument is an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the element type of the parameter array. In this case, the invocation creates an instance of the parameter array type with a length corresponding to the number of arguments, initializes the elements of the array instance with the given argument values, and uses the newly created array instance as the actual argument.</li>
</ul>

<p>The expressions of an argument list are always evaluated in the order they are written. Thus, the example
&ldquo;`csharp
class Test
{
    static void F(int x, int y = -1, int z = -2) {
        System.Console.WriteLine(&quot;x = {0}, y = {1}, z = {2}&rdquo;, x, y, z);
    }</p>

<p>static void Main() {
        int i = 0;
        F(i++, i++, i++);
        F(z: i++, x: i++);
    }
}
<code class="prettyprint">
produces the output
</code>bash
x = 0, y = 1, z = 2
x = 4, y = -1, z = 3
&ldquo;`</p>

<p>The array co-variance rules (<a href="arrays.md#array-covariance">Array covariance</a>) permit a value of an array type <code class="prettyprint">A[]</code> to be a reference to an instance of an array type <code class="prettyprint">B[]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>. Because of these rules, when an array element of a <em>reference_type</em> is passed as a reference or output parameter, a run-time check is required to ensure that the actual element type of the array is identical to that of the parameter. In the example
&rdquo;`csharp
class Test
{
    static void F(ref object x) {&hellip;}</p>

<p>static void Main() {
        object[] a = new object[10];
        object[] b = new string[10];
        F(ref a[0]);        // Ok
        F(ref b[1]);        // ArrayTypeMismatchException
    }
}
&ldquo;<code class="prettyprint">
the second invocation of</code>F<code class="prettyprint">causes a</code>System.ArrayTypeMismatchException<code class="prettyprint">to be thrown because the actual element type of</code>b<code class="prettyprint">is</code>string<code class="prettyprint">and not</code>object`.</p>

<p>When a function member with a parameter array is invoked in its expanded form, the invocation is processed exactly as if an array creation expression with an array initializer (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) was inserted around the expanded parameters. For example, given the declaration
<code class="prettyprint">csharp
void F(int x, int y, params object[] args);
</code>
the following invocations of the expanded form of the method
<code class="prettyprint">csharp
F(10, 20);
F(10, 20, 30, 40);
F(10, 20, 1, &quot;hello&quot;, 3.0);
</code>
correspond exactly to
<code class="prettyprint">csharp
F(10, 20, new object[] {});
F(10, 20, new object[] {30, 40});
F(10, 20, new object[] {1, &quot;hello&quot;, 3.0});
</code></p>

<p>In particular, note that an empty array is created when there are zero arguments given for the parameter array.</p>

<p>When arguments are omitted from a function member with corresponding optional parameters, the default arguments of the function member declaration are implicitly passed. Because these are always constant, their evaluation will not impact the evaluation order of the remaining arguments.</p>

<h3 id="type-inference">Type inference</h3>

<p>When a generic method is called without specifying type arguments, a <strong><em>type inference</em></strong> process attempts to infer type arguments for the call. The presence of type inference allows a more convenient syntax to be used for calling a generic method, and allows the programmer to avoid specifying redundant type information. For example, given the method declaration:
&rdquo;`csharp
class Chooser
{
    static Random rand = new Random();</p>

<p>public static T Choose<T>(T first, T second) {
        return (rand.Next(2) == 0)? first: second;
    }
}
<code class="prettyprint">
it is possible to invoke the `Choose` method without explicitly specifying a type argument:
</code>csharp
int i = Chooser.Choose(5, 213);                 // Calls Choose<int></p>

<p>string s = Chooser.Choose(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;);        // Calls Choose<string>
&ldquo;`</p>

<p>Through type inference, the type arguments <code class="prettyprint">int</code> and <code class="prettyprint">string</code> are determined from the arguments to the method.</p>

<p>Type inference occurs as part of the binding-time processing of a method invocation (<a href="expressions.md#method-invocations">Method invocations</a>) and takes place before the overload resolution step of the invocation. When a particular method group is specified in a method invocation, and no type arguments are specified as part of the method invocation, type inference is applied to each generic method in the method group. If type inference succeeds, then the inferred type arguments are used to determine the types of arguments for subsequent overload resolution. If overload resolution chooses a generic method as the one to invoke, then the inferred type arguments are used as the actual type arguments for the invocation. If type inference for a particular method fails, that method does not participate in overload resolution. The failure of type inference, in and of itself, does not cause a binding-time error. However, it often leads to a binding-time error when overload resolution then fails to find any applicable methods.</p>

<p>If the supplied number of arguments is different than the number of parameters in the method, then inference immediately fails. Otherwise, assume that the generic method has the following signature:
<code class="prettyprint">csharp
Tr M&lt;X1,...,Xn&gt;(T1 x1, ..., Tm xm)
</code></p>

<p>With a method call of the form <code class="prettyprint">M(E1...Em)</code> the task of type inference is to find unique type arguments <code class="prettyprint">S1...Sn</code> for each of the type parameters <code class="prettyprint">X1...Xn</code> so that the call <code class="prettyprint">M&lt;S1...Sn&gt;(E1...Em)</code> becomes valid.</p>

<p>During the process of inference each type parameter <code class="prettyprint">Xi</code> is either <em>fixed</em> to a particular type <code class="prettyprint">Si</code> or <em>unfixed</em> with an associated set of <em>bounds</em>. Each of the bounds is some type <code class="prettyprint">T</code>. Initially each type variable <code class="prettyprint">Xi</code> is unfixed with an empty set of bounds.</p>

<p>Type inference takes place in phases. Each phase will try to infer type arguments for more type variables based on the findings of the previous phase. The first phase makes some initial inferences of bounds, whereas the second phase fixes type variables to specific types and infers further bounds. The second phase may have to be repeated a number of times.</p>

<p><em>Note:</em> Type inference takes place not only when a generic method is called. Type inference for conversion of method groups is described in <a href="expressions.md#type-inference-for-conversion-of-method-groups">Type inference for conversion of method groups</a> and finding the best common type of a set of expressions is described in <a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>.</p>

<h4 id="the-first-phase">The first phase</h4>

<p>For each of the method arguments <code class="prettyprint">Ei</code>:</p>

<ul>
<li>  If <code class="prettyprint">Ei</code> is an anonymous function, an <em>explicit parameter type inference</em> (<a href="expressions.md#explicit-parameter-type-inferences">Explicit parameter type inferences</a>) is made from <code class="prettyprint">Ei</code> to <code class="prettyprint">Ti</code></li>
<li>  Otherwise, if <code class="prettyprint">Ei</code> has a type <code class="prettyprint">U</code> and <code class="prettyprint">xi</code> is a value parameter then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Ti</code>.</li>
<li>  Otherwise, if <code class="prettyprint">Ei</code> has a type <code class="prettyprint">U</code> and <code class="prettyprint">xi</code> is a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter then an <em>exact inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Ti</code>.</li>
<li>  Otherwise, no inference is made for this argument.</li>
</ul>

<h4 id="the-second-phase">The second phase</h4>

<p>The second phase proceeds as follows:</p>

<ul>
<li>  All <em>unfixed</em> type variables <code class="prettyprint">Xi</code> which do not <em>depend on</em> (<a href="expressions.md#dependence">Dependence</a>) any <code class="prettyprint">Xj</code> are fixed (<a href="expressions.md#fixing">Fixing</a>).</li>
<li>  If no such type variables exist, all <em>unfixed</em> type variables <code class="prettyprint">Xi</code> are <em>fixed</em> for which all of the following hold:

<ul>
<li>  There is at least one type variable <code class="prettyprint">Xj</code> that depends on <code class="prettyprint">Xi</code></li>
<li>  <code class="prettyprint">Xi</code> has a non-empty set of bounds</li>
</ul></li>
<li>  If no such type variables exist and there are still <em>unfixed</em> type variables, type inference fails.</li>
<li>  Otherwise, if no further <em>unfixed</em> type variables exist, type inference succeeds.</li>
<li>  Otherwise, for all arguments <code class="prettyprint">Ei</code> with corresponding parameter type <code class="prettyprint">Ti</code> where the <em>output types</em> (<a href="expressions.md#output-types">Output types</a>) contain <em>unfixed</em> type variables <code class="prettyprint">Xj</code> but the <em>input types</em> (<a href="expressions.md#input-types">Input types</a>) do not, an <em>output type inference</em> (<a href="expressions.md#output-type-inferences">Output type inferences</a>) is made <em>from</em> <code class="prettyprint">Ei</code> <em>to</em> <code class="prettyprint">Ti</code>. Then the second phase is repeated.</li>
</ul>

<h4 id="input-types">Input types</h4>

<p>If <code class="prettyprint">E</code> is a method group or implicitly typed anonymous function and <code class="prettyprint">T</code> is a delegate type or expression tree type then all the parameter types of <code class="prettyprint">T</code> are <em>input types</em> of <code class="prettyprint">E</code> <em>with type</em> <code class="prettyprint">T</code>.</p>

<h4 id="output-types">Output types</h4>

<p>If <code class="prettyprint">E</code> is a method group or an anonymous function and <code class="prettyprint">T</code> is a delegate type or expression tree type then the return type of <code class="prettyprint">T</code> is an <em>output type of</em> <code class="prettyprint">E</code> <em>with type</em> <code class="prettyprint">T</code>.</p>

<h4 id="dependence">Dependence</h4>

<p>An <em>unfixed</em> type variable <code class="prettyprint">Xi</code> <em>depends directly on</em> an unfixed type variable <code class="prettyprint">Xj</code> if for some argument <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code> <code class="prettyprint">Xj</code> occurs in an <em>input type</em> of <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code> and <code class="prettyprint">Xi</code> occurs in an <em>output type</em> of <code class="prettyprint">Ek</code> with type <code class="prettyprint">Tk</code>.</p>

<p><code class="prettyprint">Xj</code> <em>depends on</em> <code class="prettyprint">Xi</code> if <code class="prettyprint">Xj</code> <em>depends directly on</em> <code class="prettyprint">Xi</code> or if <code class="prettyprint">Xi</code> <em>depends directly on</em> <code class="prettyprint">Xk</code> and <code class="prettyprint">Xk</code> <em>depends on</em> <code class="prettyprint">Xj</code>. Thus &quot;depends on&rdquo; is the transitive but not reflexive closure of &ldquo;depends directly on&rdquo;.</p>

<h4 id="output-type-inferences">Output type inferences</h4>

<p>An <em>output type inference</em> is made <em>from</em> an expression <code class="prettyprint">E</code> <em>to</em> a type <code class="prettyprint">T</code> in the following way:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an anonymous function with inferred return type  <code class="prettyprint">U</code> (<a href="expressions.md#inferred-return-type">Inferred return type</a>) and <code class="prettyprint">T</code> is a delegate type or expression tree type with return type <code class="prettyprint">Tb</code>, then a <em>lower-bound inference</em> (<a href="expressions.md#lower-bound-inferences">Lower-bound inferences</a>) is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Tb</code>.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is a method group and <code class="prettyprint">T</code> is a delegate type or expression tree type with parameter types <code class="prettyprint">T1...Tk</code> and return type <code class="prettyprint">Tb</code>, and overload resolution of <code class="prettyprint">E</code> with the types <code class="prettyprint">T1...Tk</code> yields a single method with return type <code class="prettyprint">U</code>, then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">Tb</code>.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is an expression with type <code class="prettyprint">U</code>, then a <em>lower-bound inference</em> is made <em>from</em> <code class="prettyprint">U</code> <em>to</em> <code class="prettyprint">T</code>.</li>
<li> Otherwise, no inferences are made.</li>
</ul>

<h4 id="explicit-parameter-type-inferences">Explicit parameter type inferences</h4>

<p>An <em>explicit parameter type inference</em> is made <em>from</em> an expression <code class="prettyprint">E</code> <em>to</em> a type <code class="prettyprint">T</code> in the following way:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an explicitly typed anonymous function with parameter types <code class="prettyprint">U1...Uk</code> and <code class="prettyprint">T</code> is a delegate type or expression tree type with parameter types <code class="prettyprint">V1...Vk</code> then for each <code class="prettyprint">Ui</code> an <em>exact inference</em> (<a href="expressions.md#exact-inferences">Exact inferences</a>) is made <em>from</em> <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code>.</li>
</ul>

<h4 id="exact-inferences">Exact inferences</h4>

<p>An <em>exact inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li><p>If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of exact bounds for <code class="prettyprint">Xi</code>.</p></li>
<li><p>Otherwise, sets <code class="prettyprint">V1...Vk</code> and <code class="prettyprint">U1...Uk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> and <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code>  of the same rank</li>
<li> <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code> and <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code></li>
<li> <code class="prettyprint">V</code> is a constructed type <code class="prettyprint">C&lt;V1...Vk&gt;</code>and <code class="prettyprint">U</code> is a constructed type <code class="prettyprint">C&lt;U1...Uk&gt;</code></li>
</ul></li>
</ul>

<p>If any of these cases apply then an <em>exact inference</em> is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code>.</p>

<ul>
<li> Otherwise no inferences are made.</li>
</ul>

<h4 id="lower-bound-inferences">Lower-bound inferences</h4>

<p>A <em>lower-bound inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li> If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of lower bounds for <code class="prettyprint">Xi</code>.</li>
<li> Otherwise, if <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code>and <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code> then a lower bound inference is made from <code class="prettyprint">U1</code> to <code class="prettyprint">V1</code>.</li>
<li><p>Otherwise, sets <code class="prettyprint">U1...Uk</code> and <code class="prettyprint">V1...Vk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> and <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code> (or a type parameter whose effective base type is <code class="prettyprint">U1[...]</code>) of the same rank</li>
<li> <code class="prettyprint">V</code> is one of <code class="prettyprint">IEnumerable&lt;V1&gt;</code>, <code class="prettyprint">ICollection&lt;V1&gt;</code> or <code class="prettyprint">IList&lt;V1&gt;</code> and <code class="prettyprint">U</code> is a one-dimensional array type <code class="prettyprint">U1[]</code>(or a type parameter whose effective base type is <code class="prettyprint">U1[]</code>)</li>
<li> <code class="prettyprint">V</code> is a constructed class, struct, interface or delegate type <code class="prettyprint">C&lt;V1...Vk&gt;</code> and there is a unique type <code class="prettyprint">C&lt;U1...Uk&gt;</code> such that <code class="prettyprint">U</code> (or, if <code class="prettyprint">U</code> is a type parameter, its effective base class or any member of its effective interface set) is identical to, inherits from (directly or indirectly), or implements (directly or indirectly) <code class="prettyprint">C&lt;U1...Uk&gt;</code>.</li>
</ul>

<p>(The &ldquo;uniqueness&rdquo; restriction means that in the case interface <code class="prettyprint">C&lt;T&gt; {} class U: C&lt;X&gt;, C&lt;Y&gt; {}</code>, then no inference is made when inferring from <code class="prettyprint">U</code> to <code class="prettyprint">C&lt;T&gt;</code> because <code class="prettyprint">U1</code> could be <code class="prettyprint">X</code> or <code class="prettyprint">Y</code>.)</p></li>
</ul>

<p>If any of these cases apply then an inference is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code> as follows:</p>

<ul>
<li> If <code class="prettyprint">Ui</code> is not known to be a reference type then an <em>exact inference</em> is made</li>
<li> Otherwise, if <code class="prettyprint">U</code> is an array type then a <em>lower-bound inference</em> is made</li>
<li> Otherwise, if <code class="prettyprint">V</code> is <code class="prettyprint">C&lt;V1...Vk&gt;</code> then inference depends on the i-th type parameter of <code class="prettyprint">C</code>:

<ul>
<li> If it is covariant then a <em>lower-bound inference</em> is made.</li>
<li> If it is contravariant then an <em>upper-bound inference</em> is made.</li>
<li> If it is invariant then an <em>exact inference</em> is made.

<ul>
<li> Otherwise, no inferences are made.</li>
</ul></li>
</ul></li>
</ul>

<h4 id="upper-bound-inferences">Upper-bound inferences</h4>

<p>An <em>upper-bound inference</em> <em>from</em> a type <code class="prettyprint">U</code> <em>to</em> a type <code class="prettyprint">V</code> is made as follows:</p>

<ul>
<li> If <code class="prettyprint">V</code> is one of the <em>unfixed</em> <code class="prettyprint">Xi</code> then <code class="prettyprint">U</code> is added to the set of upper bounds for <code class="prettyprint">Xi</code>.</li>
<li><p>Otherwise, sets <code class="prettyprint">V1...Vk</code> and <code class="prettyprint">U1...Uk</code> are determined by checking if any of the following cases apply:</p>

<ul>
<li> <code class="prettyprint">U</code> is an array type <code class="prettyprint">U1[...]</code> and <code class="prettyprint">V</code> is an array type <code class="prettyprint">V1[...]</code> of the same rank</li>
<li> <code class="prettyprint">U</code> is one of <code class="prettyprint">IEnumerable&lt;Ue&gt;</code>, <code class="prettyprint">ICollection&lt;Ue&gt;</code> or <code class="prettyprint">IList&lt;Ue&gt;</code> and <code class="prettyprint">V</code> is a one-dimensional array type <code class="prettyprint">Ve[]</code></li>
<li> <code class="prettyprint">U</code> is the type <code class="prettyprint">U1?</code> and <code class="prettyprint">V</code> is the type <code class="prettyprint">V1?</code></li>
<li> <code class="prettyprint">U</code> is constructed class, struct, interface or delegate type <code class="prettyprint">C&lt;U1...Uk&gt;</code> and <code class="prettyprint">V</code> is a class, struct, interface or delegate type which is identical to, inherits from (directly or indirectly), or implements (directly or indirectly) a unique type <code class="prettyprint">C&lt;V1...Vk&gt;</code></li>
</ul>

<p>(The &ldquo;uniqueness&rdquo; restriction means that if we have <code class="prettyprint">interface C&lt;T&gt;{} class V&lt;Z&gt;: C&lt;X&lt;Z&gt;&gt;, C&lt;Y&lt;Z&gt;&gt;{}</code>, then no inference is made when inferring from <code class="prettyprint">C&lt;U1&gt;</code> to <code class="prettyprint">V&lt;Q&gt;</code>. Inferences are not made from <code class="prettyprint">U1</code> to either <code class="prettyprint">X&lt;Q&gt;</code> or <code class="prettyprint">Y&lt;Q&gt;</code>.)</p></li>
</ul>

<p>If any of these cases apply then an inference is made <em>from</em> each <code class="prettyprint">Ui</code> <em>to</em> the corresponding <code class="prettyprint">Vi</code> as follows:
   *  If  <code class="prettyprint">Ui</code> is not known to be a reference type then an <em>exact inference</em> is made
   *  Otherwise, if <code class="prettyprint">V</code> is an array type then an <em>upper-bound inference</em> is made
   *  Otherwise, if <code class="prettyprint">U</code> is <code class="prettyprint">C&lt;U1...Uk&gt;</code> then inference depends on the i-th type parameter of <code class="prettyprint">C</code>:
      *  If it is covariant then an <em>upper-bound inference</em> is made.
      *  If it is contravariant then a <em>lower-bound inference</em> is made.
      *  If it is invariant then an <em>exact inference</em> is made.
*  Otherwise, no inferences are made.   </p>

<h4 id="fixing">Fixing</h4>

<p>An <em>unfixed</em> type variable <code class="prettyprint">Xi</code> with a set of bounds is <em>fixed</em> as follows:</p>

<ul>
<li> The set of <em>candidate types</em> <code class="prettyprint">Uj</code> starts out as the set of all types in the set of bounds for <code class="prettyprint">Xi</code>.</li>
<li> We then examine each bound for <code class="prettyprint">Xi</code> in turn: For each exact bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> which are not identical to <code class="prettyprint">U</code> are removed from the candidate set. For each lower bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> to which there is <em>not</em> an implicit conversion from <code class="prettyprint">U</code> are removed from the candidate set. For each upper bound <code class="prettyprint">U</code> of <code class="prettyprint">Xi</code> all types <code class="prettyprint">Uj</code> from which there is <em>not</em> an implicit conversion to <code class="prettyprint">U</code> are removed from the candidate set.</li>
<li> If among the remaining candidate types <code class="prettyprint">Uj</code> there is a unique type <code class="prettyprint">V</code> from which there is an implicit conversion to all the other candidate types, then <code class="prettyprint">Xi</code> is fixed to <code class="prettyprint">V</code>.</li>
<li> Otherwise, type inference fails.</li>
</ul>

<h4 id="inferred-return-type">Inferred return type</h4>

<p>The inferred return type of an anonymous function <code class="prettyprint">F</code> is used during type inference and overload resolution. The inferred return type can only be determined for an anonymous function where all parameter types are known, either because they are explicitly given, provided through an anonymous function conversion or inferred during type inference on an enclosing generic method invocation.</p>

<p>The <strong><em>inferred result type</em></strong> is determined as follows:</p>

<ul>
<li> If the body of <code class="prettyprint">F</code> is an <em>expression</em> that has a type, then the inferred result type of <code class="prettyprint">F</code> is the type of that expression.</li>
<li> If the body of <code class="prettyprint">F</code> is a <em>block</em> and the set of expressions in the block&rsquo;s <code class="prettyprint">return</code> statements has a best common type <code class="prettyprint">T</code> (<a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>), then the inferred result type of <code class="prettyprint">F</code> is <code class="prettyprint">T</code>.</li>
<li> Otherwise, a result type cannot be inferred for <code class="prettyprint">F</code>.</li>
</ul>

<p>The <strong><em>inferred return type</em></strong> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">F</code> is async and the body of <code class="prettyprint">F</code> is either an expression classified as nothing (<a href="expressions.md#expression-classifications">Expression classifications</a>), or a statement block where no return statements have expressions, the inferred return type is <code class="prettyprint">System.Threading.Tasks.Task</code></li>
<li> If <code class="prettyprint">F</code> is async and has an inferred result type <code class="prettyprint">T</code>, the inferred return type is <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code>.</li>
<li> If <code class="prettyprint">F</code> is non-async and has an inferred result type <code class="prettyprint">T</code>, the inferred return type is <code class="prettyprint">T</code>.</li>
<li> Otherwise a return type cannot be inferred for <code class="prettyprint">F</code>.</li>
</ul>

<p>As an example of type inference involving anonymous functions, consider the <code class="prettyprint">Select</code> extension method declared in the <code class="prettyprint">System.Linq.Enumerable</code> class:
<code class="prettyprint">csharp
namespace System.Linq
{
    public static class Enumerable
    {
        public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;(
            this IEnumerable&lt;TSource&gt; source,
            Func&lt;TSource,TResult&gt; selector)
        {
            foreach (TSource element in source) yield return selector(element);
        }
    }
}
</code></p>

<p>Assuming the <code class="prettyprint">System.Linq</code> namespace was imported with a <code class="prettyprint">using</code> clause, and given a class <code class="prettyprint">Customer</code> with a <code class="prettyprint">Name</code> property of type <code class="prettyprint">string</code>, the <code class="prettyprint">Select</code> method can be used to select the names of a list of customers:
<code class="prettyprint">csharp
List&lt;Customer&gt; customers = GetCustomerList();
IEnumerable&lt;string&gt; names = customers.Select(c =&gt; c.Name);
</code></p>

<p>The extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>) of <code class="prettyprint">Select</code> is processed by rewriting the invocation to a static method invocation:
<code class="prettyprint">csharp
IEnumerable&lt;string&gt; names = Enumerable.Select(customers, c =&gt; c.Name);
</code></p>

<p>Since type arguments were not explicitly specified, type inference is used to infer the type arguments. First, the <code class="prettyprint">customers</code> argument is related to the <code class="prettyprint">source</code> parameter, inferring <code class="prettyprint">T</code> to be <code class="prettyprint">Customer</code>. Then, using the anonymous function type inference process described above, <code class="prettyprint">c</code> is given type <code class="prettyprint">Customer</code>, and the expression <code class="prettyprint">c.Name</code> is related to the return type of the <code class="prettyprint">selector</code> parameter, inferring <code class="prettyprint">S</code> to be <code class="prettyprint">string</code>. Thus, the invocation is equivalent to
<code class="prettyprint">csharp
Sequence.Select&lt;Customer,string&gt;(customers, (Customer c) =&gt; c.Name)
</code>
and the result is of type <code class="prettyprint">IEnumerable&lt;string&gt;</code>.</p>

<p>The following example demonstrates how anonymous function type inference allows type information to &ldquo;flow&rdquo; between arguments in a generic method invocation. Given the method:
<code class="prettyprint">csharp
static Z F&lt;X,Y,Z&gt;(X value, Func&lt;X,Y&gt; f1, Func&lt;Y,Z&gt; f2) {
    return f2(f1(value));
}
</code></p>

<p>Type inference for the invocation:
<code class="prettyprint">csharp
double seconds = F(&quot;1:15:30&quot;, s =&gt; TimeSpan.Parse(s), t =&gt; t.TotalSeconds);
</code>
proceeds as follows: First, the argument <code class="prettyprint">&quot;1:15:30&quot;</code> is related to the <code class="prettyprint">value</code> parameter, inferring <code class="prettyprint">X</code> to be <code class="prettyprint">string</code>. Then, the parameter of the first anonymous function, <code class="prettyprint">s</code>, is given the inferred type <code class="prettyprint">string</code>, and the expression <code class="prettyprint">TimeSpan.Parse(s)</code> is related to the return type of <code class="prettyprint">f1</code>, inferring <code class="prettyprint">Y</code> to be <code class="prettyprint">System.TimeSpan</code>. Finally, the parameter of the second anonymous function, <code class="prettyprint">t</code>, is given the inferred type <code class="prettyprint">System.TimeSpan</code>, and the expression <code class="prettyprint">t.TotalSeconds</code> is related to the return type of <code class="prettyprint">f2</code>, inferring <code class="prettyprint">Z</code> to be <code class="prettyprint">double</code>. Thus, the result of the invocation is of type <code class="prettyprint">double</code>.</p>

<h4 id="type-inference-for-conversion-of-method-groups">Type inference for conversion of method groups</h4>

<p>Similar to calls of generic methods, type inference must also be applied when a method group <code class="prettyprint">M</code> containing a generic method is converted to a given delegate type <code class="prettyprint">D</code> (<a href="conversions.md#method-group-conversions">Method group conversions</a>). Given a method
<code class="prettyprint">csharp
Tr M&lt;X1...Xn&gt;(T1 x1 ... Tm xm)
</code>
and the method group <code class="prettyprint">M</code> being assigned to the delegate type <code class="prettyprint">D</code> the task of type inference is to find type arguments <code class="prettyprint">S1...Sn</code> so that the expression:
<code class="prettyprint">csharp
M&lt;S1...Sn&gt;
</code>
becomes compatible (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) with <code class="prettyprint">D</code>.</p>

<p>Unlike the type inference algorithm for generic method calls, in this case there are only argument <em>types</em>, no argument <em>expressions</em>. In particular, there are no anonymous functions and hence no need for multiple phases of inference.</p>

<p>Instead, all <code class="prettyprint">Xi</code> are considered <em>unfixed</em>, and a <em>lower-bound inference</em> is made <em>from</em> each argument type <code class="prettyprint">Uj</code> of <code class="prettyprint">D</code> <em>to</em> the corresponding parameter type <code class="prettyprint">Tj</code> of <code class="prettyprint">M</code>. If for any of the <code class="prettyprint">Xi</code> no bounds were found, type inference fails. Otherwise, all <code class="prettyprint">Xi</code> are <em>fixed</em> to corresponding <code class="prettyprint">Si</code>, which are the result of type inference.</p>

<h4 id="finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</h4>

<p>In some cases, a common type needs to be inferred for a set of expressions. In particular, the element types of implicitly typed arrays and the return types of anonymous functions with <em>block</em> bodies are found in this way.</p>

<p>Intuitively, given a set of expressions <code class="prettyprint">E1...Em</code> this inference should be equivalent to calling a method
<code class="prettyprint">csharp
Tr M&lt;X&gt;(X x1 ... X xm)
</code>
with the <code class="prettyprint">Ei</code> as arguments.</p>

<p>More precisely, the inference starts out with an <em>unfixed</em> type variable <code class="prettyprint">X</code>. <em>Output type inferences</em> are then made <em>from</em> each <code class="prettyprint">Ei</code> <em>to</em> <code class="prettyprint">X</code>. Finally, <code class="prettyprint">X</code> is <em>fixed</em> and, if successful, the resulting type <code class="prettyprint">S</code> is the resulting best common type for the expressions. If no such <code class="prettyprint">S</code> exists, the expressions have no best common type.</p>

<h3 id="overload-resolution">Overload resolution</h3>

<p>Overload resolution is a binding-time mechanism for selecting the best function member to invoke given an argument list and a set of candidate function members. Overload resolution selects the function member to invoke in the following distinct contexts within C#:</p>

<ul>
<li> Invocation of a method named in an <em>invocation_expression</em> (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> Invocation of an instance constructor named in an <em>object_creation_expression</em> (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>).</li>
<li> Invocation of an indexer accessor through an <em>element_access</em> (<a href="expressions.md#element-access">Element access</a>).</li>
<li> Invocation of a predefined or user-defined operator referenced in an expression (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a> and <a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>).</li>
</ul>

<p>Each of these contexts defines the set of candidate function members and the list of arguments in its own unique way, as described in detail in the sections listed above. For example, the set of candidates for a method invocation does not include methods marked <code class="prettyprint">override</code> (<a href="expressions.md#member-lookup">Member lookup</a>), and methods in a base class are not candidates if any method in a derived class is applicable (<a href="expressions.md#method-invocations">Method invocations</a>).</p>

<p>Once the candidate function members and the argument list have been identified, the selection of the best function member is the same in all cases:</p>

<ul>
<li> Given the set of applicable candidate function members, the best function member in that set is located. If the set contains only one function member, then that function member is the best function member. Otherwise, the best function member is the one function member that is better than all other function members with respect to the given argument list, provided that each function member is compared to all other function members using the rules in <a href="expressions.md#better-function-member">Better function member</a>. If there is not exactly one function member that is better than all other function members, then the function member invocation is ambiguous and a binding-time error occurs.</li>
</ul>

<p>The following sections define the exact meanings of the terms <strong><em>applicable function member</em></strong> and <strong><em>better function member</em></strong>.</p>

<h4 id="applicable-function-member">Applicable function member</h4>

<p>A function member is said to be an <strong><em>applicable function member</em></strong> with respect to an argument list <code class="prettyprint">A</code> when all of the following are true:</p>

<ul>
<li> Each argument in <code class="prettyprint">A</code> corresponds to a parameter in the function member declaration as described in <a href="expressions.md#corresponding-parameters">Corresponding parameters</a>, and any parameter to which no argument corresponds is an optional parameter.</li>
<li> For each argument in <code class="prettyprint">A</code>, the parameter passing mode of the argument (i.e., value, <code class="prettyprint">ref</code>, or <code class="prettyprint">out</code>) is identical to the parameter passing mode of the corresponding parameter, and

<ul>
<li> for a value parameter or a parameter array, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from the argument to the type of the corresponding parameter, or</li>
<li> for a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter, the type of the argument is identical to the type of the corresponding parameter. After all, a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter is an alias for the argument passed.</li>
</ul></li>
</ul>

<p>For a function member that includes a parameter array, if the function member is applicable by the above rules, it is said to be applicable in its <strong><em>normal form</em></strong>. If a function member that includes a parameter array is not applicable in its normal form, the function member may instead be applicable in its <strong><em>expanded form</em></strong>:</p>

<ul>
<li> The expanded form is constructed by replacing the parameter array in the function member declaration with zero or more value parameters of the element type of the parameter array such that the number of arguments in the argument list <code class="prettyprint">A</code> matches the total number of parameters. If <code class="prettyprint">A</code> has fewer arguments than the number of fixed parameters in the function member declaration, the expanded form of the function member cannot be constructed and is thus not applicable.</li>
<li> Otherwise, the expanded form is applicable if for each argument in <code class="prettyprint">A</code> the parameter passing mode of the argument is identical to the parameter passing mode of the corresponding parameter, and

<ul>
<li> for a fixed value parameter or a value parameter created by the expansion, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from the type of the argument to the type of the corresponding parameter, or</li>
<li> for a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter, the type of the argument is identical to the type of the corresponding parameter.</li>
</ul></li>
</ul>

<h4 id="better-function-member">Better function member</h4>

<p>For the purposes of determining the better function member, a stripped-down argument list A is constructed containing just the argument expressions themselves in the order they appear in the original argument list.</p>

<p>Parameter lists for each of the candidate function members are constructed in the following way:</p>

<ul>
<li> The expanded form is used if the function member was applicable only in the expanded form.</li>
<li> Optional parameters with no corresponding arguments are removed from the parameter list</li>
<li> The parameters are reordered so that they occur at the same position as the corresponding argument in the argument list.</li>
</ul>

<p>Given an argument list <code class="prettyprint">A</code> with a set of argument expressions <code class="prettyprint">{E1, E2, ..., En}</code> and two applicable function members <code class="prettyprint">Mp</code> and <code class="prettyprint">Mq</code> with parameter types <code class="prettyprint">{P1, P2, ..., Pn}</code> and <code class="prettyprint">{Q1, Q2, ..., Qn}</code>, <code class="prettyprint">Mp</code> is defined to be a <strong><em>better function member</em></strong> than <code class="prettyprint">Mq</code> if</p>

<ul>
<li> for each argument, the implicit conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Qx</code> is not better than the implicit conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Px</code>, and</li>
<li> for at least one argument, the conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Px</code> is better than the conversion from <code class="prettyprint">Ex</code> to <code class="prettyprint">Qx</code>.</li>
</ul>

<p>When performing this evaluation, if <code class="prettyprint">Mp</code> or <code class="prettyprint">Mq</code> is applicable in its expanded form, then <code class="prettyprint">Px</code> or <code class="prettyprint">Qx</code> refers to a parameter in the expanded form of the parameter list.</p>

<p>In case the parameter type sequences <code class="prettyprint">{P1, P2, ..., Pn}</code> and <code class="prettyprint">{Q1, Q2, ..., Qn}</code> are equivalent (i.e. each <code class="prettyprint">Pi</code> has an identity conversion to the corresponding <code class="prettyprint">Qi</code>), the following tie-breaking rules are applied, in order, to determine the better function member.</p>

<ul>
<li> If <code class="prettyprint">Mp</code> is a non-generic method and <code class="prettyprint">Mq</code> is a generic method, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> is applicable in its normal form and <code class="prettyprint">Mq</code> has a <code class="prettyprint">params</code> array and is applicable only in its expanded form, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> has more declared parameters than <code class="prettyprint">Mq</code>, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>. This can occur if both methods have <code class="prettyprint">params</code> arrays and are applicable only in their expanded forms.</li>
<li> Otherwise if all parameters of <code class="prettyprint">Mp</code> have a corresponding argument whereas default arguments need to be substituted for at least one optional parameter in <code class="prettyprint">Mq</code> then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>.</li>
<li> Otherwise, if <code class="prettyprint">Mp</code> has more specific parameter types than <code class="prettyprint">Mq</code>, then <code class="prettyprint">Mp</code> is better than <code class="prettyprint">Mq</code>. Let <code class="prettyprint">{R1, R2, ..., Rn}</code> and <code class="prettyprint">{S1, S2, ..., Sn}</code> represent the uninstantiated and unexpanded parameter types of <code class="prettyprint">Mp</code> and <code class="prettyprint">Mq</code>. <code class="prettyprint">Mp</code>&lsquo;s parameter types are more specific than <code class="prettyprint">Mq</code>&rsquo;s if, for each parameter, <code class="prettyprint">Rx</code> is not less specific than <code class="prettyprint">Sx</code>, and, for at least one parameter, <code class="prettyprint">Rx</code> is more specific than <code class="prettyprint">Sx</code>:

<ul>
<li> A type parameter is less specific than a non-type parameter.</li>
<li> Recursively, a constructed type is more specific than another constructed type (with the same number of type arguments) if at least one type argument is more specific and no type argument is less specific than the corresponding type argument in the other.</li>
<li> An array type is more specific than another array type (with the same number of dimensions) if the element type of the first is more specific than the element type of the second.</li>
</ul></li>
<li> Otherwise if one member is a non-lifted operator and  the other is a lifted operator, the non-lifted one is better.</li>
<li> Otherwise, neither function member is better.</li>
</ul>

<h4 id="better-conversion-from-expression">Better conversion from expression</h4>

<p>Given an implicit conversion <code class="prettyprint">C1</code> that converts from an expression <code class="prettyprint">E</code> to a type <code class="prettyprint">T1</code>, and an implicit conversion <code class="prettyprint">C2</code> that converts from an expression <code class="prettyprint">E</code> to a type <code class="prettyprint">T2</code>, <code class="prettyprint">C1</code> is a <strong><em>better conversion</em></strong> than <code class="prettyprint">C2</code> if <code class="prettyprint">E</code> does not exactly match <code class="prettyprint">T2</code> and at least one of the following holds:</p>

<ul>
<li><code class="prettyprint">E</code> exactly matches <code class="prettyprint">T1</code> (<a href="expressions.md#exactly-matching-expression">Exactly matching Expression</a>)</li>
<li><code class="prettyprint">T1</code> is a better conversion target than <code class="prettyprint">T2</code> (<a href="expressions.md#better-conversion-target">Better conversion target</a>)</li>
</ul>

<h4 id="exactly-matching-expression">Exactly matching Expression</h4>

<p>Given an expression <code class="prettyprint">E</code> and a type <code class="prettyprint">T</code>, <code class="prettyprint">E</code> exactly matches <code class="prettyprint">T</code> if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">E</code> has a type <code class="prettyprint">S</code>, and an identity conversion exists from <code class="prettyprint">S</code> to <code class="prettyprint">T</code></li>
<li> <code class="prettyprint">E</code> is an anonymous function, <code class="prettyprint">T</code> is either a delegate type <code class="prettyprint">D</code> or an expression tree type <code class="prettyprint">Expression&lt;D&gt;</code> and one of the following holds:

<ul>
<li> An inferred return type <code class="prettyprint">X</code> exists for <code class="prettyprint">E</code> in the context of the parameter list of <code class="prettyprint">D</code> (<a href="expressions.md#inferred-return-type">Inferred return type</a>), and an identity conversion exists from <code class="prettyprint">X</code> to the return type of <code class="prettyprint">D</code></li>
<li> Either <code class="prettyprint">E</code> is non-async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Y</code> or <code class="prettyprint">E</code> is async and <code class="prettyprint">D</code> has a return type <code class="prettyprint">Task&lt;Y&gt;</code>, and one of the following holds:

<ul>
<li>The body of <code class="prettyprint">E</code> is an expression that exactly matches <code class="prettyprint">Y</code></li>
<li>The body of <code class="prettyprint">E</code> is a statement block where every return statement returns an expression that exactly matches <code class="prettyprint">Y</code></li>
</ul></li>
</ul></li>
</ul>

<h4 id="better-conversion-target">Better conversion target</h4>

<p>Given two different types <code class="prettyprint">T1</code> and <code class="prettyprint">T2</code>, <code class="prettyprint">T1</code> is a better conversion target than <code class="prettyprint">T2</code> if no implicit conversion from <code class="prettyprint">T2</code> to <code class="prettyprint">T1</code> exists, and at least one of the following holds:</p>

<ul>
<li> An implicit conversion from <code class="prettyprint">T1</code> to <code class="prettyprint">T2</code> exists</li>
<li> <code class="prettyprint">T1</code> is either a delegate type <code class="prettyprint">D1</code> or an expression tree type <code class="prettyprint">Expression&lt;D1&gt;</code>, <code class="prettyprint">T2</code> is either a delegate type <code class="prettyprint">D2</code> or an expression tree type <code class="prettyprint">Expression&lt;D2&gt;</code>, <code class="prettyprint">D1</code> has a return type <code class="prettyprint">S1</code> and one of the following holds:

<ul>
<li><code class="prettyprint">D2</code> is void returning</li>
<li><code class="prettyprint">D2</code> has a return type <code class="prettyprint">S2</code>, and <code class="prettyprint">S1</code> is a better conversion target than <code class="prettyprint">S2</code></li>
</ul></li>
<li> <code class="prettyprint">T1</code> is <code class="prettyprint">Task&lt;S1&gt;</code>, <code class="prettyprint">T2</code> is <code class="prettyprint">Task&lt;S2&gt;</code>, and <code class="prettyprint">S1</code> is a better conversion target than <code class="prettyprint">S2</code></li>
<li> <code class="prettyprint">T1</code> is <code class="prettyprint">S1</code> or <code class="prettyprint">S1?</code> where <code class="prettyprint">S1</code> is a signed integral type, and <code class="prettyprint">T2</code> is <code class="prettyprint">S2</code> or <code class="prettyprint">S2?</code> where <code class="prettyprint">S2</code> is an unsigned integral type. Specifically:

<ul>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">sbyte</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">byte</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">short</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">int</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code></li>
<li><code class="prettyprint">S1</code> is <code class="prettyprint">long</code> and <code class="prettyprint">S2</code> is <code class="prettyprint">ulong</code></li>
</ul></li>
</ul>

<h4 id="overloading-in-generic-classes">Overloading in generic classes</h4>

<p>While signatures as declared must be unique, it is possible that substitution of type arguments results in identical signatures. In such cases, the tie-breaking rules of overload resolution above will pick the most specific member.</p>

<p>The following examples show overloads that are valid and invalid according to this rule:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">interface</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{...}</span>

<span class="k">interface</span> <span class="n">I2</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">G1</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="nf">F1</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">);</span>                  <span class="c1">// Overload resulotion for G&lt;int&gt;.F1</span>
    <span class="kt">int</span> <span class="nf">F1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>                <span class="c1">// will pick non-generic</span>

    <span class="k">void</span> <span class="nf">F2</span><span class="p">(</span><span class="n">I1</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">);</span>             <span class="c1">// Valid overload</span>
    <span class="k">void</span> <span class="nf">F2</span><span class="p">(</span><span class="n">I2</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">G2</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F3</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">,</span> <span class="n">V</span> <span class="n">v</span><span class="p">);</span>            <span class="c1">// Valid, but overload resolution for</span>
    <span class="k">void</span> <span class="nf">F3</span><span class="p">(</span><span class="n">V</span> <span class="n">v</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>            <span class="c1">// G2&lt;int,int&gt;.F3 will fail</span>

    <span class="k">void</span> <span class="nf">F4</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">,</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v</span><span class="p">);</span>        <span class="c1">// Valid, but overload resolution for    </span>
    <span class="k">void</span> <span class="nf">F4</span><span class="p">(</span><span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>        <span class="c1">// G2&lt;I1&lt;int&gt;,int&gt;.F4 will fail</span>

    <span class="k">void</span> <span class="nf">F5</span><span class="p">(</span><span class="n">U</span> <span class="n">u1</span><span class="p">,</span> <span class="n">I1</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">v2</span><span class="p">);</span>      <span class="c1">// Valid overload</span>
    <span class="k">void</span> <span class="nf">F5</span><span class="p">(</span><span class="n">V</span> <span class="n">v1</span><span class="p">,</span> <span class="n">U</span> <span class="n">u2</span><span class="p">);</span>

    <span class="k">void</span> <span class="nf">F6</span><span class="p">(</span><span class="k">ref</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>             <span class="c1">// valid overload</span>
    <span class="k">void</span> <span class="nf">F6</span><span class="p">(</span><span class="k">out</span> <span class="n">V</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<h3 id="compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</h3>

<p>For most dynamically bound operations the set of possible candidates for resolution is unknown at compile-time. In certain cases, however the candidate set is known at compile-time:</p>

<ul>
<li> Static method calls with dynamic arguments</li>
<li> Instance method calls where the receiver is not a dynamic expression</li>
<li> Indexer calls where the receiver is not a dynamic expression</li>
<li> Constructor calls with dynamic arguments</li>
</ul>

<p>In these cases a limited compile-time check is performed for each candidate to see if any of them could possibly apply at run-time.This check consists of the following steps:</p>

<ul>
<li> Partial type inference: Any type argument that does not depend directly or indirectly on an argument of type <code class="prettyprint">dynamic</code> is inferred using the rules of <a href="expressions.md#type-inference">Type inference</a>. The remaining type arguments are unknown.</li>
<li> Partial applicability check: Applicability is checked according to <a href="expressions.md#applicable-function-member">Applicable function member</a>, but ignoring parameters whose types are unknown.</li>
<li> If no candidate passes this test, a compile-time error occurs.</li>
</ul>

<h3 id="function-member-invocation">Function member invocation</h3>

<p>This section describes the process that takes place at run-time to invoke a particular function member. It is assumed that a binding-time process has already determined the particular member to invoke, possibly by applying overload resolution to a set of candidate function members.</p>

<p>For purposes of describing the invocation process, function members are divided into two categories:</p>

<ul>
<li> Static function members. These are instance constructors, static methods, static property accessors, and user-defined operators. Static function members are always non-virtual.</li>
<li> Instance function members. These are instance methods, instance property accessors, and indexer accessors. Instance function members are either non-virtual or virtual, and are always invoked on a particular instance. The instance is computed by an instance expression, and it becomes accessible within the function member as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
</ul>

<p>The run-time processing of a function member invocation consists of the following steps, where <code class="prettyprint">M</code> is the function member and, if <code class="prettyprint">M</code> is an instance member, <code class="prettyprint">E</code> is the instance expression:</p>

<ul>
<li><p>If <code class="prettyprint">M</code> is a static function member:</p>

<ul>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li><code class="prettyprint">M</code> is invoked.</li>
</ul></li>
<li><p>If <code class="prettyprint">M</code> is an instance function member declared in a <em>value_type</em>:</p>

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, then no further steps are executed.</li>
<li>If <code class="prettyprint">E</code> is not classified as a variable, then a temporary local variable of <code class="prettyprint">E</code>&rsquo;s type is created and the value of <code class="prettyprint">E</code> is assigned to that variable. <code class="prettyprint">E</code> is then reclassified as a reference to that temporary local variable. The temporary variable is accessible as <code class="prettyprint">this</code> within <code class="prettyprint">M</code>, but not in any other way. Thus, only when <code class="prettyprint">E</code> is a true variable is it possible for the caller to observe the changes that <code class="prettyprint">M</code> makes to <code class="prettyprint">this</code>.</li>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li><code class="prettyprint">M</code> is invoked. The variable referenced by <code class="prettyprint">E</code> becomes the variable referenced by <code class="prettyprint">this</code>.</li>
</ul></li>
<li><p>If <code class="prettyprint">M</code> is an instance function member declared in a <em>reference_type</em>:</p>

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, then no further steps are executed.</li>
<li>The argument list is evaluated as described in <a href="expressions.md#argument-lists">Argument lists</a>.</li>
<li>If the type of <code class="prettyprint">E</code> is a <em>value_type</em>, a boxing conversion (<a href="types.md#boxing-conversions">Boxing conversions</a>) is performed to convert <code class="prettyprint">E</code> to type <code class="prettyprint">object</code>, and <code class="prettyprint">E</code> is considered to be of type <code class="prettyprint">object</code> in the following steps. In this case, <code class="prettyprint">M</code> could only be a member of <code class="prettyprint">System.Object</code>.</li>
<li>The value of <code class="prettyprint">E</code> is checked to be valid. If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li>The function member implementation to invoke is determined:

<ul>
<li>If the binding-time type of <code class="prettyprint">E</code> is an interface, the function member to invoke is the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>. This function member is determined by applying the interface mapping rules (<a href="interfaces.md#interface-mapping">Interface mapping</a>) to determine the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>.</li>
<li>Otherwise, if <code class="prettyprint">M</code> is a virtual function member, the function member to invoke is the implementation of <code class="prettyprint">M</code> provided by the run-time type of the instance referenced by <code class="prettyprint">E</code>. This function member is determined by applying the rules for determining the most derived implementation (<a href="classes.md#virtual-methods">Virtual methods</a>) of <code class="prettyprint">M</code> with respect to the run-time type of the instance referenced by <code class="prettyprint">E</code>.</li>
<li>Otherwise, <code class="prettyprint">M</code> is a non-virtual function member, and the function member to invoke is <code class="prettyprint">M</code> itself.</li>
</ul></li>
<li>The function member implementation determined in the step above is invoked. The object referenced by <code class="prettyprint">E</code> becomes the object referenced by <code class="prettyprint">this</code>.</li>
</ul></li>
</ul>

<h4 id="invocations-on-boxed-instances">Invocations on boxed instances</h4>

<p>A function member implemented in a <em>value_type</em> can be invoked through a boxed instance of that <em>value_type</em> in the following situations:</p>

<ul>
<li> When the function member is an <code class="prettyprint">override</code> of a method inherited from type <code class="prettyprint">object</code> and is invoked through an instance expression of type <code class="prettyprint">object</code>.</li>
<li> When the function member is an implementation of an interface function member and is invoked through an instance expression of an <em>interface_type</em>.</li>
<li> When the function member is invoked through a delegate.</li>
</ul>

<p>In these situations, the boxed instance is considered to contain a variable of the <em>value_type</em>, and this variable becomes the variable referenced by <code class="prettyprint">this</code> within the function member invocation. In particular, this means that when a function member is invoked on a boxed instance, it is possible for the function member to modify the value contained in the boxed instance.</p>

<h2 id="primary-expressions">Primary expressions</h2>

<p>Primary expressions include the simplest forms of expressions.</p>
<pre class="highlight shell"><code>primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

primary_no_array_creation_expression
    : literal
    | interpolated_string
    | simple_name
    | parenthesized_expression
    | member_access
    | invocation_expression
    | element_access
    | this_access
    | base_access
    | post_increment_expression
    | post_decrement_expression
    | object_creation_expression
    | delegate_creation_expression
    | anonymous_object_creation_expression
    | typeof_expression
    | checked_expression
    | unchecked_expression
    | default_value_expression
    | nameof_expression
    | anonymous_method_expression
    | primary_no_array_creation_expression_unsafe
    ;
</code></pre>
<p>Primary expressions are divided between *array_creation_expression*s and *primary_no_array_creation_expression*s. Treating array-creation-expression in this way, rather than listing it along with the other simple expression forms, enables the grammar to disallow potentially confusing code such as
<code class="prettyprint">csharp
object o = new int[3][1];
</code>
which would otherwise be interpreted as
<code class="prettyprint">csharp
object o = (new int[3])[1];
</code></p>

<h3 id="literals">Literals</h3>

<p>A <em>primary_expression</em> that consists of a <em>literal</em> (<a href="lexical-structure.md#literals">Literals</a>) is classified as a value.</p>

<h3 id="interpolated-strings">Interpolated strings</h3>

<p>An <em>interpolated_string_expression</em> consists of a <code class="prettyprint">$</code> sign followed by a regular or verbatim string literal, wherein holes, delimited by <code class="prettyprint">{</code> and <code class="prettyprint">}</code>, enclose expressions and formatting specifications. An interpolated string expression is the result of an <em>interpolated_string_literal</em> that has been broken up into individual tokens, as described in <a href="lexical-structure.md#interpolated-string-literals">Interpolated string literals</a>.</p>
<pre class="highlight shell"><code>interpolated_string_expression
    : <span class="s1">'$'</span> interpolated_regular_string
    | <span class="s1">'$'</span> interpolated_verbatim_string
    ;

interpolated_regular_string
    : interpolated_regular_string_whole
    | interpolated_regular_string_start interpolated_regular_string_body interpolated_regular_string_end
    ;

interpolated_regular_string_body
    : interpolation <span class="o">(</span>interpolated_regular_string_mid interpolation<span class="o">)</span><span class="k">*</span>
    ;

interpolation
    : expression
    | expression <span class="s1">','</span> constant_expression
    ;

interpolated_verbatim_string
    : interpolated_verbatim_string_whole
    | interpolated_verbatim_string_start interpolated_verbatim_string_body interpolated_verbatim_string_end
    ;

interpolated_verbatim_string_body
    : interpolation <span class="o">(</span>interpolated_verbatim_string_mid interpolation<span class="o">)</span>+
    ;
</code></pre>
<p>The <em>constant_expression</em> in an interpolation must have an implicit conversion to <code class="prettyprint">int</code>.</p>

<p>An <em>interpolated_string_expression</em> is classified as a value. If it is immediately converted to <code class="prettyprint">System.IFormattable</code> or <code class="prettyprint">System.FormattableString</code> with an implicit interpolated string conversion (<a href="conversions.md#implicit-interpolated-string-conversions">Implicit interpolated string conversions</a>), the interpolated string expression has that type. Otherwise, it has the type <code class="prettyprint">string</code>.</p>

<p>If the type of an interpolated string is <code class="prettyprint">System.IFormattable</code> or <code class="prettyprint">System.FormattableString</code>, the meaning is a call to <code class="prettyprint">System.Runtime.CompilerServices.FormattableStringFactory.Create</code>. If the type is <code class="prettyprint">string</code>, the meaning of the expression is a call to <code class="prettyprint">string.Format</code>. In both cases, the argument list of the call consists of a format string literal with placeholders for each interpolation, and an argument for each expression corresponding to the place holders.</p>

<p>The format string literal is constructed as follows, where <code class="prettyprint">N</code> is the number of interpolations in the <em>interpolated_string_expression</em>:</p>

<ul>
<li> If an <em>interpolated_regular_string_whole</em> or an <em>interpolated_verbatim_string_whole</em> follows the <code class="prettyprint">$</code> sign, then the format string literal is that token.</li>
<li> Otherwise, the format string literal consists of: 

<ul>
<li> First the <em>interpolated_regular_string_start</em> or <em>interpolated_verbatim_string_start</em></li>
<li> Then for each number <code class="prettyprint">I</code> from <code class="prettyprint">0</code> to <code class="prettyprint">N-1</code>: 

<ul>
<li>The decimal representation of <code class="prettyprint">I</code></li>
<li>Then, if the corresponding <em>interpolation</em> has a <em>constant_expression</em>, a <code class="prettyprint">,</code> (comma) followed by the decimal representation of the value of the <em>constant_expression</em></li>
<li>Then the <em>interpolated_regular_string_mid</em>, <em>interpolated_regular_string_end</em>, <em>interpolated_verbatim_string_mid</em> or <em>interpolated_verbatim_string_end</em> immediately following the corresponding interpolation.</li>
</ul></li>
</ul></li>
</ul>

<p>The subsequent arguments are simply the <em>expressions</em> from the <em>interpolations</em> (if any), in order.</p>

<p>TODO: examples.</p>

<h3 id="simple-names">Simple names</h3>

<p>A <em>simple_name</em> consists of an identifier, optionally followed by a type argument list:</p>
<pre class="highlight shell"><code>simple_name
    : identifier type_argument_list?
    ;
</code></pre>
<p>A <em>simple_name</em> is either of the form <code class="prettyprint">I</code> or of the form <code class="prettyprint">I&lt;A1,...,Ak&gt;</code>, where <code class="prettyprint">I</code> is a single identifier and <code class="prettyprint">&lt;A1,...,Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">K</code> to be zero. The <em>simple_name</em> is evaluated and classified as follows:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and the <em>simple_name</em> appears within a <em>block</em> and if the <em>block</em>&rsquo;s (or an enclosing <em>block</em>&rsquo;s) local variable declaration space (<a href="basic-concepts.md#declarations">Declarations</a>) contains a local variable, parameter or constant with name <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that local variable, parameter or constant and is classified as a variable or value.</li>
<li> If <code class="prettyprint">K</code> is zero and the <em>simple_name</em> appears within the body of a generic method declaration and if that declaration includes a type parameter with name <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that type parameter.</li>
<li><p>Otherwise, for each instance type <code class="prettyprint">T</code> (<a href="classes.md#the-instance-type">The instance type</a>), starting with the instance type of the immediately enclosing type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and the declaration of <code class="prettyprint">T</code> includes a type parameter with name <code class="prettyprint">I</code>, then the <em>simple_name</em> refers to that type parameter.</li>
<li> Otherwise, if a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">T</code> with <code class="prettyprint">K</code> type arguments produces a match:

<ul>
<li>If <code class="prettyprint">T</code> is the instance type of the immediately enclosing class or struct type and the lookup identifies one or more methods, the result is a method group with an associated instance expression of <code class="prettyprint">this</code>. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li>Otherwise, if <code class="prettyprint">T</code> is the instance type of the immediately enclosing class or struct type, if the lookup identifies an instance member, and if the reference occurs within the body of an instance constructor, an instance method, or an instance accessor, the result is the same as a member access (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">this.I</code>. This can only happen when <code class="prettyprint">K</code> is zero.</li>
<li>Otherwise, the result is the same as a member access (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">T.I</code> or <code class="prettyprint">T.I&lt;A1,...,Ak&gt;</code>. In this case, it is a binding-time error for the <em>simple_name</em> to refer to an instance member.</li>
</ul></li>
</ul></li>
<li><p>Otherwise, for each namespace <code class="prettyprint">N</code>, starting with the namespace in which the <em>simple_name</em> occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and <code class="prettyprint">I</code> is the name of a namespace in <code class="prettyprint">N</code>, then:

<ul>
<li>If the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with a namespace or type, then the <em>simple_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>simple_name</em> refers to the namespace named <code class="prettyprint">I</code> in <code class="prettyprint">N</code>.</li>
</ul></li>
<li> Otherwise, if <code class="prettyprint">N</code> contains an accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with a namespace or type, then the <em>simple_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the type constructed with the given type arguments.</li>
</ul></li>
<li> Otherwise, if the location where the <em>simple_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with an imported namespace or type, then the <em>simple_name</em> refers to that namespace or type.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_static_directive*s of the namespace declaration contain exactly one accessible type or non-extension static membre having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the *simple_name</em> refers to that type or member constructed with the given type arguments.</li>
<li>Otherwise, if the namespaces and types imported by the <em>using_namespace_directive*s of the namespace declaration contain more than one accessible type or non-extension-method static member having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the *simple_name</em> is ambiguous and an error occurs.</li>
</ul></li>
</ul></li>
</ul>

<p>Note that this entire step is exactly parallel to the corresponding step in the processing of a <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>).</p>

<ul>
<li> Otherwise, the <em>simple_name</em> is undefined and a compile-time error occurs.</li>
</ul>

<h3 id="parenthesized-expressions">Parenthesized expressions</h3>

<p>A <em>parenthesized_expression</em> consists of an <em>expression</em> enclosed in parentheses.</p>
<pre class="highlight shell"><code>parenthesized_expression
    : <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>A <em>parenthesized_expression</em> is evaluated by evaluating the <em>expression</em> within the parentheses. If the <em>expression</em> within the parentheses denotes a namespace or type, a compile-time error occurs. Otherwise, the result of the <em>parenthesized_expression</em> is the result of the evaluation of the contained <em>expression</em>.</p>

<h3 id="member-access">Member access</h3>

<p>A <em>member_access</em> consists of a <em>primary_expression</em>, a <em>predefined_type</em>, or a <em>qualified_alias_member</em>, followed by a &ldquo;<code class="prettyprint">.</code>&rdquo; token, followed by an <em>identifier</em>, optionally followed by a <em>type_argument_list</em>.</p>
<pre class="highlight shell"><code>member_access
    : primary_expression <span class="s1">'.'</span> identifier type_argument_list?
    | predefined_type <span class="s1">'.'</span> identifier type_argument_list?
    | qualified_alias_member <span class="s1">'.'</span> identifier
    ;

predefined_type
    : <span class="s1">'bool'</span>   | <span class="s1">'byte'</span>  | <span class="s1">'char'</span>  | <span class="s1">'decimal'</span> | <span class="s1">'double'</span> | <span class="s1">'float'</span> | <span class="s1">'int'</span> | <span class="s1">'long'</span>
    | <span class="s1">'object'</span> | <span class="s1">'sbyte'</span> | <span class="s1">'short'</span> | <span class="s1">'string'</span>  | <span class="s1">'uint'</span>   | <span class="s1">'ulong'</span> | <span class="s1">'ushort'</span>
    ;
</code></pre>
<p>The <em>qualified_alias_member</em> production is defined in <a href="namespaces.md#namespace-alias-qualifiers">Namespace alias qualifiers</a>.</p>

<p>A <em>member_access</em> is either of the form <code class="prettyprint">E.I</code> or of the form <code class="prettyprint">E.I&lt;A1, ..., Ak&gt;</code>, where <code class="prettyprint">E</code> is a primary-expression, <code class="prettyprint">I</code> is a single identifier and <code class="prettyprint">&lt;A1, ..., Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">K</code> to be zero.</p>

<p>A <em>member_access</em> with a <em>primary_expression</em> of type <code class="prettyprint">dynamic</code> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compiler classifies the member access as a property access of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>member_access</em> are then applied at run-time, using the run-time type instead of the compile-time type of the <em>primary_expression</em>. If this run-time classification leads to a method group, then the member access must be the <em>primary_expression</em> of an <em>invocation_expression</em>.</p>

<p>The <em>member_access</em> is evaluated and classified as follows:</p>

<ul>
<li> If <code class="prettyprint">K</code> is zero and <code class="prettyprint">E</code> is a namespace and <code class="prettyprint">E</code> contains a nested namespace with name <code class="prettyprint">I</code>, then the result is that namespace.</li>
<li> Otherwise, if <code class="prettyprint">E</code> is a namespace and <code class="prettyprint">E</code> contains an accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the result is that type constructed with the given type arguments.</li>
<li> If <code class="prettyprint">E</code> is a <em>predefined_type</em> or a <em>primary_expression</em> classified as a type, if <code class="prettyprint">E</code> is not a type parameter, and if a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">E</code> with <code class="prettyprint">K</code> type parameters produces a match, then <code class="prettyprint">E.I</code> is evaluated and classified as follows:

<ul>
<li> If <code class="prettyprint">I</code> identifies a type, then the result is that type constructed with the given type arguments.</li>
<li> If <code class="prettyprint">I</code> identifies one or more methods, then the result is a method group with no associated instance expression. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> property, then the result is a property access with no associated instance expression.</li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> field:

<ul>
<li>If the field is <code class="prettyprint">readonly</code> and the reference occurs outside the static constructor of the class or struct in which the field is declared, then the result is a value, namely the value of the static field <code class="prettyprint">I</code> in <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the static field <code class="prettyprint">I</code> in <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies a <code class="prettyprint">static</code> event:

<ul>
<li>If the reference occurs within the class or struct in which the event is declared, and the event was declared without <em>event_accessor_declarations</em> (<a href="classes.md#events">Events</a>), then <code class="prettyprint">E.I</code> is processed exactly as if <code class="prettyprint">I</code> were a static field.</li>
<li>Otherwise, the result is an event access with no associated instance expression.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies a constant, then the result is a value, namely the value of that constant.</li>
<li>If <code class="prettyprint">I</code> identifies an enumeration member, then the result is a value, namely the value of that enumeration member.</li>
<li>Otherwise, <code class="prettyprint">E.I</code> is an invalid member reference, and a compile-time error occurs.</li>
</ul></li>
<li> If <code class="prettyprint">E</code> is a property access, indexer access, variable, or value, the type of which is <code class="prettyprint">T</code>, and a member lookup (<a href="expressions.md#member-lookup">Member lookup</a>) of <code class="prettyprint">I</code> in <code class="prettyprint">T</code> with <code class="prettyprint">K</code> type arguments produces a match, then <code class="prettyprint">E.I</code> is evaluated and classified as follows:

<ul>
<li> First, if <code class="prettyprint">E</code> is a property or indexer access, then the value of the property or indexer access is obtained (<a href="expressions.md#values-of-expressions">Values of expressions</a>) and <code class="prettyprint">E</code> is reclassified as a value.</li>
<li> If <code class="prettyprint">I</code> identifies one or more methods, then the result is a method group with an associated instance expression of <code class="prettyprint">E</code>. If a type argument list was specified, it is used in calling a generic method (<a href="expressions.md#method-invocations">Method invocations</a>).</li>
<li> If <code class="prettyprint">I</code> identifies an instance property,

<ul>
<li>If <code class="prettyprint">E</code> is <code class="prettyprint">this</code>, <code class="prettyprint">I</code> identifies an automatically implemented property (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>) without a setter, and the reference occurs within an instance constructor for a class or struct type <code class="prettyprint">T</code>, then the result is a variable, namely the hidden backing field for the auto-property given by <code class="prettyprint">I</code> in the instance of <code class="prettyprint">T</code> given by <code class="prettyprint">this</code>.</li>
<li>Otherwise, the result is a property access with an associated instance expression of <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">T</code> is a <em>class_type</em> and <code class="prettyprint">I</code> identifies an instance field of that <em>class_type</em>:

<ul>
<li>If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, then a <code class="prettyprint">System.NullReferenceException</code> is thrown.</li>
<li>Otherwise, if the field is <code class="prettyprint">readonly</code> and the reference occurs outside an instance constructor of the class in which the field is declared, then the result is a value, namely the value of the field <code class="prettyprint">I</code> in the object referenced by <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the field <code class="prettyprint">I</code> in the object referenced by <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">T</code> is a <em>struct_type</em> and <code class="prettyprint">I</code> identifies an instance field of that <em>struct_type</em>:

<ul>
<li>If <code class="prettyprint">E</code> is a value, or if the field is <code class="prettyprint">readonly</code> and the reference occurs outside an instance constructor of the struct in which the field is declared, then the result is a value, namely the value of the field <code class="prettyprint">I</code> in the struct instance given by <code class="prettyprint">E</code>.</li>
<li>Otherwise, the result is a variable, namely the field <code class="prettyprint">I</code> in the struct instance given by <code class="prettyprint">E</code>.</li>
</ul></li>
<li> If <code class="prettyprint">I</code> identifies an instance event:

<ul>
<li>If the reference occurs within the class or struct in which the event is declared, and the event was declared without <em>event_accessor_declarations</em> (<a href="classes.md#events">Events</a>), and the reference does not occur as the left-hand side of a <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator, then <code class="prettyprint">E.I</code> is processed exactly as if <code class="prettyprint">I</code> was an instance field.</li>
<li>Otherwise, the result is an event access with an associated instance expression of <code class="prettyprint">E</code>.</li>
</ul></li>
</ul></li>
<li> Otherwise, an attempt is made to process <code class="prettyprint">E.I</code> as an extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). If this fails, <code class="prettyprint">E.I</code> is an invalid member reference, and a binding-time error occurs.</li>
</ul>

<h4 id="identical-simple-names-and-type-names">Identical simple names and type names</h4>

<p>In a member access of the form <code class="prettyprint">E.I</code>, if <code class="prettyprint">E</code> is a single identifier, and if the meaning of <code class="prettyprint">E</code> as a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) is a constant, field, property, local variable, or parameter with the same type as the meaning of <code class="prettyprint">E</code> as a <em>type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>), then both possible meanings of <code class="prettyprint">E</code> are permitted. The two possible meanings of <code class="prettyprint">E.I</code> are never ambiguous, since <code class="prettyprint">I</code> must necessarily be a member of the type <code class="prettyprint">E</code> in both cases. In other words, the rule simply permits access to the static members and nested types of <code class="prettyprint">E</code> where a compile-time error would otherwise have occurred. For example:
&ldquo;`csharp
struct Color
{
    public static readonly Color White = new Color(&hellip;);
    public static readonly Color Black = new Color(&hellip;);</p>

<p>public Color Complement() {&hellip;}
}</p>

<p>class A
{
    public Color Color;                // Field Color of type Color</p>

<p>void F() {
        Color = Color.Black;           // References Color.Black static member
        Color = Color.Complement();    // Invokes Complement() on Color field
    }</p>

<p>static void G() {
        Color c = Color.White;         // References Color.White static member
    }
}
&rdquo;`</p>

<h4 id="grammar-ambiguities">Grammar ambiguities</h4>

<p>The productions for <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) and <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) can give rise to ambiguities in the grammar for expressions. For example, the statement:
<code class="prettyprint">bash
F(G&lt;A,B&gt;(7));
</code>
could be interpreted as a call to <code class="prettyprint">F</code> with two arguments, <code class="prettyprint">G &lt; A</code> and <code class="prettyprint">B &gt; (7)</code>. Alternatively, it could be interpreted as a call to <code class="prettyprint">F</code> with one argument, which is a call to a generic method <code class="prettyprint">G</code> with two type arguments and one regular argument.</p>

<p>If a sequence of tokens can be parsed (in context) as a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>), <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), or <em>pointer_member_access</em> (<a href="unsafe-code.md#pointer-member-access">Pointer member access</a>) ending with a <em>type_argument_list</em> (<a href="types.md#type-arguments">Type arguments</a>), the token immediately following the closing <code class="prettyprint">&gt;</code> token is examined. If it is one of
<code class="prettyprint">csharp
(  )  ]  }  :  ;  ,  .  ?  ==  !=  |  ^
</code>
then the <em>type_argument_list</em> is retained as part of the <em>simple_name</em>, <em>member_access</em> or <em>pointer_member_access</em> and any other possible parse of the sequence of tokens is discarded. Otherwise, the <em>type_argument_list</em> is not considered to be part of the <em>simple_name</em>, <em>member_access</em> or <em>pointer_member_access</em>, even if there is no other possible parse of the sequence of tokens. Note that these rules are not applied when parsing a <em>type_argument_list</em> in a <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>). The statement
<code class="prettyprint">csharp
F(G&lt;A,B&gt;(7));
</code>
will, according to this rule, be interpreted as a call to <code class="prettyprint">F</code> with one argument, which is a call to a generic method <code class="prettyprint">G</code> with two type arguments and one regular argument. The statements
<code class="prettyprint">csharp
F(G &lt; A, B &gt; 7);
F(G &lt; A, B &gt;&gt; 7);
</code>
will each be interpreted as a call to <code class="prettyprint">F</code> with two arguments. The statement
<code class="prettyprint">csharp
x = F &lt; A &gt; +y;
</code>
will be interpreted as a less than operator, greater than operator, and unary plus operator, as if the statement had been written <code class="prettyprint">x = (F &lt; A) &gt; (+y)</code>, instead of as a <em>simple_name</em> with a <em>type_argument_list</em> followed by a binary plus operator. In the statement
<code class="prettyprint">csharp
x = y is C&lt;T&gt; + z;
</code>
the tokens <code class="prettyprint">C&lt;T&gt;</code> are interpreted as a <em>namespace_or_type_name</em> with a <em>type_argument_list</em>.</p>

<h3 id="invocation-expressions">Invocation expressions</h3>

<p>An <em>invocation_expression</em> is used to invoke a method.</p>
<pre class="highlight shell"><code>invocation_expression
    : primary_expression <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>An <em>invocation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) if at least one of the following holds:</p>

<ul>
<li>The <em>primary_expression</em> has compile-time type <code class="prettyprint">dynamic</code>.</li>
<li>At least one argument of the optional <em>argument_list</em> has compile-time type <code class="prettyprint">dynamic</code> and the <em>primary_expression</em> does not have a delegate type.</li>
</ul>

<p>In this case the compiler classifies the <em>invocation_expression</em> as a value of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>invocation_expression</em> are then applied at run-time, using the run-time type instead of the compile-time type of those of the <em>primary_expression</em> and arguments which have the compile-time type <code class="prettyprint">dynamic</code>. If the <em>primary_expression</em> does not have compile-time type <code class="prettyprint">dynamic</code>, then the method invocation undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The <em>primary_expression</em> of an <em>invocation_expression</em> must be a method group or a value of a <em>delegate_type</em>. If the <em>primary_expression</em> is a method group, the <em>invocation_expression</em> is a method invocation (<a href="expressions.md#method-invocations">Method invocations</a>). If the <em>primary_expression</em> is a value of a <em>delegate_type</em>, the <em>invocation_expression</em> is a delegate invocation (<a href="expressions.md#delegate-invocations">Delegate invocations</a>). If the <em>primary_expression</em> is neither a method group nor a value of a <em>delegate_type</em>, a binding-time error occurs.</p>

<p>The optional <em>argument_list</em> (<a href="expressions.md#argument-lists">Argument lists</a>) provides values or variable references for the parameters of the method.</p>

<p>The result of evaluating an <em>invocation_expression</em> is classified as follows:</p>

<ul>
<li> If the <em>invocation_expression</em> invokes a method or delegate that returns <code class="prettyprint">void</code>, the result is nothing. An expression that is classified as nothing is permitted only in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>) or as the body of a <em>lambda_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>). Otherwise a binding-time error occurs.</li>
<li> Otherwise, the result is a value of the type returned by the method or delegate.</li>
</ul>

<h4 id="method-invocations">Method invocations</h4>

<p>For a method invocation, the <em>primary_expression</em> of the <em>invocation_expression</em> must be a method group. The method group identifies the one method to invoke or the set of overloaded methods from which to choose a specific method to invoke. In the latter case, determination of the specific method to invoke is based on the context provided by the types of the arguments in the <em>argument_list</em>.</p>

<p>The binding-time processing of a method invocation of the form <code class="prettyprint">M(A)</code>, where <code class="prettyprint">M</code> is a method group (possibly including a <em>type_argument_list</em>), and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> The set of candidate methods for the method invocation is constructed. For each method <code class="prettyprint">F</code> associated with the method group <code class="prettyprint">M</code>:

<ul>
<li> If <code class="prettyprint">F</code> is non-generic, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li><code class="prettyprint">M</code> has no type argument list, and</li>
<li><code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
<li> If <code class="prettyprint">F</code> is generic and <code class="prettyprint">M</code> has no type argument list, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li>Type inference (<a href="expressions.md#type-inference">Type inference</a>) succeeds, inferring a list of type arguments for the call, and</li>
<li>Once the inferred type arguments are substituted for the corresponding method type parameters, all constructed types in the parameter list of F satisfy their constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>), and the parameter list of <code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
<li> If <code class="prettyprint">F</code> is generic and <code class="prettyprint">M</code> includes a type argument list, <code class="prettyprint">F</code> is a candidate when:

<ul>
<li><code class="prettyprint">F</code> has the same number of method type parameters as were supplied in the type argument list, and</li>
<li>Once the type arguments are substituted for the corresponding method type parameters, all constructed types in the parameter list of F satisfy their constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>), and the parameter list of <code class="prettyprint">F</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>).</li>
</ul></li>
</ul></li>
<li> The set of candidate methods is reduced to contain only methods from the most derived types: For each method <code class="prettyprint">C.F</code> in the set, where <code class="prettyprint">C</code> is the type in which the method <code class="prettyprint">F</code> is declared, all methods declared in a base type of <code class="prettyprint">C</code> are removed from the set. Furthermore, if <code class="prettyprint">C</code> is a class type other than <code class="prettyprint">object</code>, all methods declared in an interface type are removed from the set. (This latter rule only has affect when the method group was the result of a member lookup on a type parameter having an effective base class other than object and a non-empty effective interface set.)</li>
<li> If the resulting set of candidate methods is empty, then further processing along the following steps are abandoned, and instead an attempt is made to process the invocation as an extension method invocation (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>). If this fails, then no applicable methods exist, and a binding-time error occurs.</li>
<li> The best method of the set of candidate methods is identified using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. If a single best method cannot be identified, the method invocation is ambiguous, and a binding-time error occurs. When performing overload resolution, the parameters of a generic method are considered after substituting the type arguments (supplied or inferred) for the corresponding method type parameters.</li>
<li> Final validation of the chosen best method is performed:

<ul>
<li>The method is validated in the context of the method group: If the best method is a static method, the method group must have resulted from a <em>simple_name</em> or a <em>member_access</em> through a type. If the best method is an instance method, the method group must have resulted from a <em>simple_name</em>, a <em>member_access</em> through a variable or value, or a <em>base_access</em>. If neither of these requirements is true, a binding-time error occurs.</li>
<li>If the best method is a generic method, the type arguments (supplied or inferred) are checked against the constraints (<a href="types.md#satisfying-constraints">Satisfying constraints</a>) declared on the generic method. If any type argument does not satisfy the corresponding constraint(s) on the type parameter, a binding-time error occurs.</li>
</ul></li>
</ul>

<p>Once a method has been selected and validated at binding-time by the above steps, the actual run-time invocation is processed according to the rules of function member invocation described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The intuitive effect of the resolution rules described above is as follows: To locate the particular method invoked by a method invocation, start with the type indicated by the method invocation and proceed up the inheritance chain until at least one applicable, accessible, non-override method declaration is found. Then perform type inference and overload resolution on the set of applicable, accessible, non-override methods declared in that type and invoke the method thus selected. If no method was found, try instead to process the invocation as an extension method invocation.</p>

<h4 id="extension-method-invocations">Extension method invocations</h4>

<p>In a method invocation (<a href="expressions.md#invocations-on-boxed-instances">Invocations on boxed instances</a>) of one of the forms
&ldquo;`csharp
expr . identifier ( )</p>

<p>expr . identifier ( args )</p>

<p>expr . identifier &lt; typeargs &gt; ( )</p>

<p>expr . identifier &lt; typeargs &gt; ( args )
&rdquo;<code class="prettyprint">
if the normal processing of the invocation finds no applicable methods, an attempt is made to process the construct as an extension method invocation. If *expr* or any of the *args* has compile-time type</code>dynamic`, extension methods will not apply.</p>

<p>The objective is to find the best <em>type_name</em> <code class="prettyprint">C</code>, so that the corresponding static method invocation can take place:
&ldquo;`csharp
C . identifier ( expr )</p>

<p>C . identifier ( expr , args )</p>

<p>C . identifier &lt; typeargs &gt; ( expr )</p>

<p>C . identifier &lt; typeargs &gt; ( expr , args )
&rdquo;`</p>

<p>An extension method <code class="prettyprint">Ci.Mj</code> is <strong><em>eligible</em></strong> if:</p>

<ul>
<li> <code class="prettyprint">Ci</code> is a non-generic, non-nested class</li>
<li> The name of <code class="prettyprint">Mj</code> is <em>identifier</em></li>
<li> <code class="prettyprint">Mj</code> is accessible and applicable when applied to the arguments as a static method as shown above</li>
<li> An implicit identity, reference or boxing conversion exists from <em>expr</em> to the type of the first parameter of <code class="prettyprint">Mj</code>.</li>
</ul>

<p>The search for <code class="prettyprint">C</code> proceeds as follows:</p>

<ul>
<li> Starting with the closest enclosing namespace declaration, continuing with each enclosing namespace declaration, and ending with the containing compilation unit, successive attempts are made to find a candidate set of extension methods:

<ul>
<li>If the given namespace or compilation unit directly contains non-generic type declarations <code class="prettyprint">Ci</code> with eligible extension methods <code class="prettyprint">Mj</code>, then the set of those extension methods is the candidate set.</li>
<li>If types <code class="prettyprint">Ci</code> imported by <em>using_static_declarations</em> and directly declared in namespaces imported by *using_namespace_directive*s in the given namespace or compilation unit directly contain eligible extension methods <code class="prettyprint">Mj</code>, then the set of those extension methods is the candidate set.</li>
</ul></li>
<li> If no candidate set is found in any enclosing namespace declaration or compilation unit, a compile-time error occurs.</li>
<li> Otherwise, overload resolution is applied to the candidate set as described in (<a href="expressions.md#overload-resolution">Overload resolution</a>). If no single best method is found, a compile-time error occurs.</li>
<li> <code class="prettyprint">C</code> is the type within which the best method is declared as an extension method.</li>
</ul>

<p>Using <code class="prettyprint">C</code> as a target, the method call is then processed as a static method invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>).</p>

<p>The preceding rules mean that instance methods take precedence over extension methods, that extension methods available in inner namespace declarations take precedence over extension methods available in outer namespace declarations, and that extension methods declared directly in a namespace take precedence over extension methods imported into that same namespace with a using namespace directive. For example:
&ldquo;`csharp
public static class E
{
    public static void F(this object obj, int i) { }</p>

<p>public static void F(this object obj, string s) { }
}</p>

<p>class A { }</p>

<p>class B
{
    public void F(int i) { }
}</p>

<p>class C
{
    public void F(object obj) { }
}</p>

<p>class X
{
    static void Test(A a, B b, C c) {
        a.F(1);              // E.F(object, int)
        a.F(&quot;hello&rdquo;);        // E.F(object, string)</p>

<p>b.F(1);              // B.F(int)
        b.F(&ldquo;hello&rdquo;);        // E.F(object, string)</p>

<p>c.F(1);              // C.F(object)
        c.F(&ldquo;hello&rdquo;);        // C.F(object)
    }
}
&ldquo;`</p>

<p>In the example, <code class="prettyprint">B</code>&rsquo;s method takes precedence over the first extension method, and <code class="prettyprint">C</code>&rsquo;s method takes precedence over both extension methods.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.G({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">H</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C.H({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N1</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">D</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"D.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"D.G({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">N2</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">N1</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">E</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">this</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"E.F({0})"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Test</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="m">1.F</span><span class="p">();</span>
            <span class="m">2.</span><span class="nf">G</span><span class="p">();</span>
            <span class="m">3.</span><span class="nf">H</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The output of this example is:
<code class="prettyprint">bash
E.F(1)
D.G(2)
C.H(3)
</code>
<code class="prettyprint">D.G</code> takes precendece over <code class="prettyprint">C.G</code>, and <code class="prettyprint">E.F</code> takes precedence over both <code class="prettyprint">D.F</code> and <code class="prettyprint">C.F</code>.</p>

<h4 id="delegate-invocations">Delegate invocations</h4>

<p>For a delegate invocation, the <em>primary_expression</em> of the <em>invocation_expression</em> must be a value of a <em>delegate_type</em>. Furthermore, considering the <em>delegate_type</em> to be a function member with the same parameter list as the <em>delegate_type</em>, the <em>delegate_type</em> must be applicable (<a href="expressions.md#applicable-function-member">Applicable function member</a>) with respect to the <em>argument_list</em> of the <em>invocation_expression</em>.</p>

<p>The run-time processing of a delegate invocation of the form <code class="prettyprint">D(A)</code>, where <code class="prettyprint">D</code> is a <em>primary_expression</em> of a <em>delegate_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> <code class="prettyprint">D</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li> The value of <code class="prettyprint">D</code> is checked to be valid. If the value of <code class="prettyprint">D</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li> Otherwise, <code class="prettyprint">D</code> is a reference to a delegate instance. Function member invocations (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) are performed on each of the callable entities in the invocation list of the delegate. For callable entities consisting of an instance and instance method, the instance for the invocation is the instance contained in the callable entity.</li>
</ul>

<h3 id="element-access">Element access</h3>

<p>An <em>element_access</em> consists of a <em>primary_no_array_creation_expression</em>, followed by a &rdquo;<code class="prettyprint">[</code>&ldquo; token, followed by an <em>argument_list</em>, followed by a &rdquo;<code class="prettyprint">]</code>&ldquo; token. The <em>argument_list</em> consists of one or more *argument*s, separated by commas.</p>
<pre class="highlight shell"><code>element_access
    : primary_no_array_creation_expression <span class="s1">'['</span> expression_list <span class="s1">']'</span>
    ;
</code></pre>
<p>The <em>argument_list</em> of an <em>element_access</em> is not allowed to contain <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> arguments.</p>

<p>An <em>element_access</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) if at least one of the following holds:</p>

<ul>
<li>The <em>primary_no_array_creation_expression</em> has compile-time type <code class="prettyprint">dynamic</code>.</li>
<li>At least one expression of the <em>argument_list</em> has compile-time type <code class="prettyprint">dynamic</code> and the <em>primary_no_array_creation_expression</em> does not have an array type.</li>
</ul>

<p>In this case the compiler classifies the <em>element_access</em> as a value of type <code class="prettyprint">dynamic</code>. The rules below to determine the meaning of the <em>element_access</em> are then applied at run-time, using the run-time type instead of the compile-time type of those of the <em>primary_no_array_creation_expression</em> and <em>argument_list</em> expressions which have the compile-time type <code class="prettyprint">dynamic</code>. If the <em>primary_no_array_creation_expression</em> does not have compile-time type <code class="prettyprint">dynamic</code>, then the element access undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>If the <em>primary_no_array_creation_expression</em> of an <em>element_access</em> is a value of an <em>array_type</em>, the <em>element_access</em> is an array access (<a href="expressions.md#array-access">Array access</a>). Otherwise, the <em>primary_no_array_creation_expression</em> must be a variable or value of a class, struct, or interface type that has one or more indexer members, in which case the <em>element_access</em> is an indexer access (<a href="expressions.md#indexer-access">Indexer access</a>).</p>

<h4 id="array-access">Array access</h4>

<p>For an array access, the <em>primary_no_array_creation_expression</em> of the <em>element_access</em> must be a value of an <em>array_type</em>. Furthermore, the <em>argument_list</em> of an array access is not allowed to contain named arguments.The number of expressions in the <em>argument_list</em> must be the same as the rank of the <em>array_type</em>, and each expression must be of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, or must be implicitly convertible to one or more of these types.</p>

<p>The result of evaluating an array access is a variable of the element type of the array, namely the array element selected by the value(s) of the expression(s) in the <em>argument_list</em>.</p>

<p>The run-time processing of an array access of the form <code class="prettyprint">P[A]</code>, where <code class="prettyprint">P</code> is a <em>primary_no_array_creation_expression</em> of an <em>array_type</em> and <code class="prettyprint">A</code> is an <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> <code class="prettyprint">P</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li> The index expressions of the <em>argument_list</em> are evaluated in order, from left to right. Following evaluation of each index expression, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to one of the following types is performed: <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>. The first type in this list for which an implicit conversion exists is chosen. For instance, if the index expression is of type <code class="prettyprint">short</code> then an implicit conversion to <code class="prettyprint">int</code> is performed, since implicit conversions from <code class="prettyprint">short</code> to <code class="prettyprint">int</code> and from <code class="prettyprint">short</code> to <code class="prettyprint">long</code> are possible. If evaluation of an index expression or the subsequent implicit conversion causes an exception, then no further index expressions are evaluated and no further steps are executed.</li>
<li> The value of <code class="prettyprint">P</code> is checked to be valid. If the value of <code class="prettyprint">P</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li> The value of each expression in the <em>argument_list</em> is checked against the actual bounds of each dimension of the array instance referenced by <code class="prettyprint">P</code>. If one or more values are out of range, a <code class="prettyprint">System.IndexOutOfRangeException</code> is thrown and no further steps are executed.</li>
<li> The location of the array element given by the index expression(s) is computed, and this location becomes the result of the array access.</li>
</ul>

<h4 id="indexer-access">Indexer access</h4>

<p>For an indexer access, the <em>primary_no_array_creation_expression</em> of the <em>element_access</em> must be a variable or value of a class, struct, or interface type, and this type must implement one or more indexers that are applicable with respect to the <em>argument_list</em> of the <em>element_access</em>.</p>

<p>The binding-time processing of an indexer access of the form <code class="prettyprint">P[A]</code>, where <code class="prettyprint">P</code> is a <em>primary_no_array_creation_expression</em> of a class, struct, or interface type <code class="prettyprint">T</code>, and <code class="prettyprint">A</code> is an <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li> The set of indexers provided by <code class="prettyprint">T</code> is constructed. The set consists of all indexers declared in <code class="prettyprint">T</code> or a base type of <code class="prettyprint">T</code> that are not <code class="prettyprint">override</code> declarations and are accessible in the current context (<a href="basic-concepts.md#member-access">Member access</a>).</li>
<li> The set is reduced to those indexers that are applicable and not hidden by other indexers. The following rules are applied to each indexer <code class="prettyprint">S.I</code> in the set, where <code class="prettyprint">S</code> is the type in which the indexer <code class="prettyprint">I</code> is declared:

<ul>
<li>If <code class="prettyprint">I</code> is not applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>), then <code class="prettyprint">I</code> is removed from the set.</li>
<li>If <code class="prettyprint">I</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>), then all indexers declared in a base type of <code class="prettyprint">S</code> are removed from the set.</li>
<li>If <code class="prettyprint">I</code> is applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>) and <code class="prettyprint">S</code> is a class type other than <code class="prettyprint">object</code>, all indexers declared in an interface are removed from the set.</li>
</ul></li>
<li> If the resulting set of candidate indexers is empty, then no applicable indexers exist, and a binding-time error occurs.</li>
<li> The best indexer of the set of candidate indexers is identified using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. If a single best indexer cannot be identified, the indexer access is ambiguous, and a binding-time error occurs.</li>
<li> The index expressions of the <em>argument_list</em> are evaluated in order, from left to right. The result of processing the indexer access is an expression classified as an indexer access. The indexer access expression references the indexer determined in the step above, and has an associated instance expression of <code class="prettyprint">P</code> and an associated argument list of <code class="prettyprint">A</code>.</li>
</ul>

<p>Depending on the context in which it is used, an indexer access causes invocation of either the <em>get accessor</em> or the <em>set accessor</em> of the indexer. If the indexer access is the target of an assignment, the <em>set accessor</em> is invoked to assign a new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). In all other cases, the <em>get accessor</em> is invoked to obtain the current value (<a href="expressions.md#values-of-expressions">Values of expressions</a>).</p>

<h3 id="this-access">This access</h3>

<p>A <em>this_access</em> consists of the reserved word <code class="prettyprint">this</code>.</p>
<pre class="highlight shell"><code>this_access
    : <span class="s1">'this'</span>
    ;
</code></pre>
<p>A <em>this_access</em> is permitted only in the <em>block</em> of an instance constructor, an instance method, or an instance accessor. It has one of the following meanings:</p>

<ul>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance constructor of a class, it is classified as a value. The type of the value is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the class within which the usage occurs, and the value is a reference to the object being constructed.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance method or instance accessor of a class, it is classified as a value. The type of the value is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the class within which the usage occurs, and the value is a reference to the object for which the method or accessor was invoked.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance constructor of a struct, it is classified as a variable. The type of the variable is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the struct within which the usage occurs, and the variable represents the struct being constructed. The <code class="prettyprint">this</code> variable of an instance constructor of a struct behaves exactly the same as an <code class="prettyprint">out</code> parameter of the struct type—in particular, this means that the variable must be definitely assigned in every execution path of the instance constructor.</li>
<li> When <code class="prettyprint">this</code> is used in a <em>primary_expression</em> within an instance method or instance accessor of a struct, it is classified as a variable. The type of the variable is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the struct within which the usage occurs.

<ul>
<li>If the method or accessor is not an iterator (<a href="classes.md#iterators">Iterators</a>), the <code class="prettyprint">this</code> variable represents the struct for which the method or accessor was invoked, and behaves exactly the same as a <code class="prettyprint">ref</code> parameter of the struct type.</li>
<li>If the method or accessor is an iterator, the <code class="prettyprint">this</code> variable represents a copy of the struct for which the method or accessor was invoked, and behaves exactly the same as a value parameter of the struct type.</li>
</ul></li>
</ul>

<p>Use of <code class="prettyprint">this</code> in a <em>primary_expression</em> in a context other than the ones listed above is a compile-time error. In particular, it is not possible to refer to <code class="prettyprint">this</code> in a static method, a static property accessor, or in a <em>variable_initializer</em> of a field declaration.</p>

<h3 id="base-access">Base access</h3>

<p>A <em>base_access</em> consists of the reserved word <code class="prettyprint">base</code> followed by either a &rdquo;<code class="prettyprint">.</code>&ldquo; token and an identifier or an <em>argument_list</em> enclosed in square brackets:</p>
<pre class="highlight shell"><code>base_access
    : <span class="s1">'base'</span> <span class="s1">'.'</span> identifier
    | <span class="s1">'base'</span> <span class="s1">'['</span> expression_list <span class="s1">']'</span>
    ;
</code></pre>
<p>A <em>base_access</em> is used to access base class members that are hidden by similarly named members in the current class or struct. A <em>base_access</em> is permitted only in the <em>block</em> of an instance constructor, an instance method, or an instance accessor. When <code class="prettyprint">base.I</code> occurs in a class or struct, <code class="prettyprint">I</code> must denote a member of the base class of that class or struct. Likewise, when <code class="prettyprint">base[E]</code> occurs in a class, an applicable indexer must exist in the base class.</p>

<p>At binding-time, <em>base_access</em> expressions of the form <code class="prettyprint">base.I</code> and <code class="prettyprint">base[E]</code> are evaluated exactly as if they were written <code class="prettyprint">((B)this).I</code> and <code class="prettyprint">((B)this)[E]</code>, where <code class="prettyprint">B</code> is the base class of the class or struct in which the construct occurs. Thus, <code class="prettyprint">base.I</code> and <code class="prettyprint">base[E]</code> correspond to <code class="prettyprint">this.I</code> and <code class="prettyprint">this[E]</code>, except <code class="prettyprint">this</code> is viewed as an instance of the base class.</p>

<p>When a <em>base_access</em> references a virtual function member (a method, property, or indexer), the determination of which function member to invoke at run-time (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) is changed. The function member that is invoked is determined by finding the most derived implementation (<a href="classes.md#virtual-methods">Virtual methods</a>) of the function member with respect to <code class="prettyprint">B</code> (instead of with respect to the run-time type of <code class="prettyprint">this</code>, as would be usual in a non-base access). Thus, within an <code class="prettyprint">override</code> of a <code class="prettyprint">virtual</code> function member, a <em>base_access</em> can be used to invoke the inherited implementation of the function member. If the function member referenced by a <em>base_access</em> is abstract, a binding-time error occurs.</p>

<h3 id="postfix-increment-and-decrement-operators">Postfix increment and decrement operators</h3>
<pre class="highlight shell"><code>post_increment_expression
    : primary_expression <span class="s1">'++'</span>
    ;

post_decrement_expression
    : primary_expression <span class="s1">'--'</span>
    ;
</code></pre>
<p>The operand of a postfix increment or decrement operation must be an expression classified as a variable, a property access, or an indexer access. The result of the operation is a value of the same type as the operand.</p>

<p>If the <em>primary_expression</em> has the compile-time type <code class="prettyprint">dynamic</code> then the operator is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), the <em>post_increment_expression</em> or <em>post_decrement_expression</em> has the compile-time type <code class="prettyprint">dynamic</code> and the following rules are applied at run-time using the run-time type of the <em>primary_expression</em>.</p>

<p>If the operand of a postfix increment or decrement operation is a property or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>Unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. Predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators exist for the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, and any enum type. The predefined <code class="prettyprint">++</code> operators return the value produced by adding 1 to the operand, and the predefined <code class="prettyprint">--</code> operators return the value produced by subtracting 1 from the operand. In a <code class="prettyprint">checked</code> context, if the result of this addition or subtraction is outside the range of the result type and the result type is an integral type or enum type, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The run-time processing of a postfix increment or decrement operation of the form <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li>The value of <code class="prettyprint">x</code> is saved.</li>
<li>The selected operator is invoked with the saved value of <code class="prettyprint">x</code> as its argument.</li>
<li>The value returned by the operator is stored in the location given by the evaluation of <code class="prettyprint">x</code>.</li>
<li>The saved value of <code class="prettyprint">x</code> becomes the result of the operation.</li>
</ul></li>
<li>  If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor invocations.</li>
<li>The <code class="prettyprint">get</code> accessor of <code class="prettyprint">x</code> is invoked and the returned value is saved.</li>
<li>The selected operator is invoked with the saved value of <code class="prettyprint">x</code> as its argument.</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value returned by the operator as its <code class="prettyprint">value</code> argument.</li>
<li>The saved value of <code class="prettyprint">x</code> becomes the result of the operation.</li>
</ul></li>
</ul>

<p>The <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators also support prefix notation (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>). Typically, the result of <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> is the value of <code class="prettyprint">x</code> before the operation, whereas the result of <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> is the value of <code class="prettyprint">x</code> after the operation. In either case, <code class="prettyprint">x</code> itself has the same value after the operation.</p>

<p>An <code class="prettyprint">operator ++</code> or <code class="prettyprint">operator --</code> implementation can be invoked using either postfix or prefix notation. It is not possible to have separate operator implementations for the two notations.</p>

<h3 id="the-new-operator">The new operator</h3>

<p>The <code class="prettyprint">new</code> operator is used to create new instances of types.</p>

<p>There are three forms of <code class="prettyprint">new</code> expressions:</p>

<ul>
<li> Object creation expressions are used to create new instances of class types and value types.</li>
<li> Array creation expressions are used to create new instances of array types.</li>
<li> Delegate creation expressions are used to create new instances of delegate types.</li>
</ul>

<p>The <code class="prettyprint">new</code> operator implies creation of an instance of a type, but does not necessarily imply dynamic allocation of memory. In particular, instances of value types require no additional memory beyond the variables in which they reside, and no dynamic allocations occur when <code class="prettyprint">new</code> is used to create instances of value types.</p>

<h4 id="object-creation-expressions">Object creation expressions</h4>

<p>An <em>object_creation_expression</em> is used to create a new instance of a <em>class_type</em> or a <em>value_type</em>.</p>
<pre class="highlight shell"><code>object_creation_expression
    : <span class="s1">'new'</span> <span class="nb">type</span> <span class="s1">'('</span> argument_list? <span class="s1">')'</span> object_or_collection_initializer?
    | <span class="s1">'new'</span> <span class="nb">type </span>object_or_collection_initializer
    ;

object_or_collection_initializer
    : object_initializer
    | collection_initializer
    ;
</code></pre>
<p>The <em>type</em> of an <em>object_creation_expression</em> must be a <em>class_type</em>, a <em>value_type</em> or a <em>type_parameter</em>. The <em>type</em> cannot be an <code class="prettyprint">abstract</code> <em>class_type</em>.</p>

<p>The optional <em>argument_list</em> (<a href="expressions.md#argument-lists">Argument lists</a>) is permitted only if the <em>type</em> is a <em>class_type</em> or a <em>struct_type</em>.</p>

<p>An object creation expression can omit the constructor argument list and enclosing parentheses provided it includes an object initializer or collection initializer. Omitting the constructor argument list and enclosing parentheses is equivalent to specifying an empty argument list.</p>

<p>Processing of an object creation expression that includes an object initializer or collection initializer consists of first processing the instance constructor and then processing the member or element initializations specified by the object initializer (<a href="expressions.md#object-initializers">Object initializers</a>) or collection initializer (<a href="expressions.md#collection-initializers">Collection initializers</a>).</p>

<p>If any of the arguments in the optional <em>argument_list</em> has the compile-time type <code class="prettyprint">dynamic</code> then the <em>object_creation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>) and the following rules are applied at run-time using the run-time type of those arguments of the <em>argument_list</em> that have the compile time type <code class="prettyprint">dynamic</code>. However, the object creation undergoes a limited compile time check as described in <a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>.</p>

<p>The binding-time processing of an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(A)</code>, where <code class="prettyprint">T</code> is a <em>class_type</em> or a <em>value_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">T</code> is a <em>value_type</em> and <code class="prettyprint">A</code> is not present:

<ul>
<li>The <em>object_creation_expression</em> is a default constructor invocation. The result of the <em>object_creation_expression</em> is a value of type <code class="prettyprint">T</code>, namely the default value for <code class="prettyprint">T</code> as defined in <a href="types.md#the-systemvaluetype-type">The System.ValueType type</a>.</li>
</ul></li>
<li>  Otherwise, if <code class="prettyprint">T</code> is a <em>type_parameter</em> and <code class="prettyprint">A</code> is not present:

<ul>
<li>If no value type constraint or constructor constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) has been specified for <code class="prettyprint">T</code>, a binding-time error occurs.</li>
<li>The result of the <em>object_creation_expression</em> is a value of the run-time type that the type parameter has been bound to, namely the result of invoking the default constructor of that type. The run-time type may be a reference type or a value type.</li>
</ul></li>
<li>  Otherwise, if <code class="prettyprint">T</code> is a <em>class_type</em> or a <em>struct_type</em>:

<ul>
<li>If <code class="prettyprint">T</code> is an <code class="prettyprint">abstract</code> <em>class_type</em>, a compile-time error occurs.</li>
<li>The instance constructor to invoke is determined using the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors declared in <code class="prettyprint">T</code> which are applicable with respect to <code class="prettyprint">A</code> (<a href="expressions.md#applicable-function-member">Applicable function member</a>). If the set of candidate instance constructors is empty, or if a single best instance constructor cannot be identified, a binding-time error occurs.</li>
<li>The result of the <em>object_creation_expression</em> is a value of type <code class="prettyprint">T</code>, namely the value produced by invoking the instance constructor determined in the step above.</li>
</ul></li>
<li> Otherwise, the <em>object_creation_expression</em> is invalid, and a binding-time error occurs.</li>
</ul>

<p>Even if the <em>object_creation_expression</em> is dynamically bound, the compile-time type is still <code class="prettyprint">T</code>.</p>

<p>The run-time processing of an <em>object_creation_expression</em> of the form <code class="prettyprint">new T(A)</code>, where <code class="prettyprint">T</code> is <em>class_type</em> or a <em>struct_type</em> and <code class="prettyprint">A</code> is an optional <em>argument_list</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">T</code> is a <em>class_type</em>:

<ul>
<li>A new instance of class <code class="prettyprint">T</code> is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li>All fields of the new instance are initialized to their default values (<a href="variables.md#default-values">Default values</a>).</li>
<li>The instance constructor is invoked according to the rules of function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>). A reference to the newly allocated instance is automatically passed to the instance constructor and the instance can be accessed from within that constructor as <code class="prettyprint">this</code>.</li>
</ul></li>
<li>  If <code class="prettyprint">T</code> is a <em>struct_type</em>:

<ul>
<li>An instance of type <code class="prettyprint">T</code> is created by allocating a temporary local variable. Since an instance constructor of a <em>struct_type</em> is required to definitely assign a value to each field of the instance being created, no initialization of the temporary variable is necessary.</li>
<li>The instance constructor is invoked according to the rules of function member invocation (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>). A reference to the newly allocated instance is automatically passed to the instance constructor and the instance can be accessed from within that constructor as <code class="prettyprint">this</code>.</li>
</ul></li>
</ul>

<h4 id="object-initializers">Object initializers</h4>

<p>An <strong><em>object initializer</em></strong> specifies values for zero or more fields, properties or indexed elements of an object.</p>
<pre class="highlight shell"><code>object_initializer
    : <span class="s1">'{'</span> member_initializer_list? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> member_initializer_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

member_initializer_list
    : member_initializer <span class="o">(</span><span class="s1">','</span> member_initializer<span class="o">)</span><span class="k">*</span>
    ;

member_initializer
    : initializer_target <span class="s1">'='</span> initializer_value
    ;

initializer_target
    : identifier
    | <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    ;

initializer_value
    : expression
    | object_or_collection_initializer
    ;
</code></pre>
<p>An object initializer consists of a sequence of member initializers, enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas. Each <em>member_initializer</em> designates a target for the initialization. An <em>identifier</em> must name an accessible field or property of the object being initialized, whereas an <em>argument_list</em> enclosed in square brackets must specify arguments for an accessible indexer on the object being initialized. It is an error for an object initializer to include more than one member initializer for the same field or property.</p>

<p>Each <em>initializer_target</em> is followed by an equals sign and either an expression, an object initializer or a collection initializer. It is not possible for expressions within the object initializer to refer to the newly created object it is initializing.</p>

<p>A member initializer that specifies an expression after the equals sign is processed in the same way as an assignment (<a href="expressions.md#simple-assignment">Simple assignment</a>) to the target.</p>

<p>A member initializer that specifies an object initializer after the equals sign is a <strong><em>nested object initializer</em></strong>, i.e. an initialization of an embedded object. Instead of assigning a new value to the field or property, the assignments in the nested object initializer are treated as assignments to members of the field or property. Nested object initializers cannot be applied to properties with a value type, or to read-only fields with a value type.</p>

<p>A member initializer that specifies a collection initializer after the equals sign is an initialization of an embedded collection. Instead of assigning a new collection to the target field, property or indexer, the elements given in the initializer are added to the collection referenced by the target. The target must be of a collection type that satisfies the requirements specified in <a href="expressions.md#collection-initializers">Collection initializers</a>.</p>

<p>The arguments to an index initializer will always be evaluated exactly once. Thus, even if the arguments end up never getting used (e.g. because of an empty nested initializer), they will be evaluated for their side effects.</p>

<p>The following class represents a point with two coordinates:
&rdquo;`csharp
public class Point
{
    int x, y;</p>

<p>public int X { get { return x; } set { x = value; } }
    public int Y { get { return y; } set { y = value; } }
}
&ldquo;`</p>

<p>An instance of <code class="prettyprint">Point</code> can be created and initialized as follows:
<code class="prettyprint">csharp
Point a = new Point { X = 0, Y = 1 };
</code>
which has the same effect as
<code class="prettyprint">csharp
Point __a = new Point();
__a.X = 0;
__a.Y = 1; 
Point a = __a;
</code>
where <code class="prettyprint">__a</code> is an otherwise invisible and inaccessible temporary variable. The following class represents a rectangle created from two points:
&rdquo;`csharp
public class Rectangle
{
    Point p1, p2;</p>

<p>public Point P1 { get { return p1; } set { p1 = value; } }
    public Point P2 { get { return p2; } set { p2 = value; } }
}
&ldquo;`</p>

<p>An instance of <code class="prettyprint">Rectangle</code> can be created and initialized as follows:
<code class="prettyprint">csharp
Rectangle r = new Rectangle {
    P1 = new Point { X = 0, Y = 1 },
    P2 = new Point { X = 2, Y = 3 }
};
</code>
which has the same effect as
<code class="prettyprint">csharp
Rectangle __r = new Rectangle();
Point __p1 = new Point();
__p1.X = 0;
__p1.Y = 1;
__r.P1 = __p1;
Point __p2 = new Point();
__p2.X = 2;
__p2.Y = 3;
__r.P2 = __p2; 
Rectangle r = __r;
</code>
where <code class="prettyprint">__r</code>, <code class="prettyprint">__p1</code> and <code class="prettyprint">__p2</code> are temporary variables that are otherwise invisible and inaccessible.</p>

<p>If <code class="prettyprint">Rectangle</code>&rsquo;s constructor allocates the two embedded <code class="prettyprint">Point</code> instances
&rdquo;`csharp
public class Rectangle
{
    Point p1 = new Point();
    Point p2 = new Point();</p>

<p>public Point P1 { get { return p1; } }
    public Point P2 { get { return p2; } }
}
<code class="prettyprint">
the following construct can be used to initialize the embedded `Point` instances instead of assigning new instances:
</code>csharp
Rectangle r = new Rectangle {
    P1 = { X = 0, Y = 1 },
    P2 = { X = 2, Y = 3 }
};
<code class="prettyprint">
which has the same effect as
</code>csharp
Rectangle __r = new Rectangle();
__r.P1.X = 0;
__r.P1.Y = 1;
__r.P2.X = 2;
__r.P2.Y = 3;
Rectangle r = __r;
&ldquo;`</p>

<p>Given an appropriate definition of C, the following example:
<code class="prettyprint">csharp
var c = new C {
    x = true,
    y = { a = &quot;Hello&quot; },
    z = { 1, 2, 3 },
    [&quot;x&quot;] = 5,
    [0,0] = { &quot;a&quot;, &quot;b&quot; },
    [1,2] = {}
};
</code>
is equivalent to this series of assignments:
<code class="prettyprint">csharp
C __c = new C();
__c.x = true;
__c.y.a = &quot;Hello&quot;;
__c.z.Add(1); 
__c.z.Add(2);
__c.z.Add(3);
string __i1 = &quot;x&quot;;
__c[__i1] = 5;
int __i2 = 0, __i3 = 0;
__c[__i2,__i3].Add(&quot;a&quot;);
__c[__i2,__i3].Add(&quot;b&quot;);
int __i4 = 1, __i5 = 2;
var c = __c;
</code>
where <code class="prettyprint">__c</code>, etc., are generated variables that are invisible and inaccessible to the source code. Note that the arguments for <code class="prettyprint">[0,0]</code> are evaluated only once, and the arguments for <code class="prettyprint">[1,2]</code> are evaluated once even though they are never used.</p>

<h4 id="collection-initializers">Collection initializers</h4>

<p>A collection initializer specifies the elements of a collection.</p>
<pre class="highlight shell"><code>collection_initializer
    : <span class="s1">'{'</span> element_initializer_list <span class="s1">'}'</span>
    | <span class="s1">'{'</span> element_initializer_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

element_initializer_list
    : element_initializer <span class="o">(</span><span class="s1">','</span> element_initializer<span class="o">)</span><span class="k">*</span>
    ;

element_initializer
    : non_assignment_expression
    | <span class="s1">'{'</span> expression_list <span class="s1">'}'</span>
    ;

expression_list
    : expression <span class="o">(</span><span class="s1">','</span> expression<span class="o">)</span><span class="k">*</span>
    ;
</code></pre>
<p>A collection initializer consists of a sequence of element initializers, enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas. Each element initializer specifies an element to be added to the collection object being initialized, and consists of a list of expressions enclosed by <code class="prettyprint">{</code> and <code class="prettyprint">}</code> tokens and separated by commas.  A single-expression element initializer can be written without braces, but cannot then be an assignment expression, to avoid ambiguity with member initializers. The <em>non_assignment_expression</em> production is defined in <a href="expressions.md#expression">Expression</a>.</p>

<p>The following is an example of an object creation expression that includes a collection initializer:
<code class="prettyprint">csharp
List&lt;int&gt; digits = new List&lt;int&gt; { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
</code></p>

<p>The collection object to which a collection initializer is applied must be of a type that implements <code class="prettyprint">System.Collections.IEnumerable</code> or a compile-time error occurs. For each specified element in order, the collection initializer invokes an <code class="prettyprint">Add</code> method on the target object with the expression list of the element initializer as argument list, applying normal member lookup and overload resolution for each invocation. Thus, the collection object must have an applicable instance or extension method with the name <code class="prettyprint">Add</code> for each element initializer.</p>

<p>The following class represents a contact with a name and a list of phone numbers:
&rdquo;`csharp
public class Contact
{
    string name;
    List<string> phoneNumbers = new List<string>();</p>

<p>public string Name { get { return name; } set { name = value; } }</p>

<p>public List<string> PhoneNumbers { get { return phoneNumbers; } }
}
&ldquo;`</p>

<p>A <code class="prettyprint">List&lt;Contact&gt;</code> can be created and initialized as follows:
<code class="prettyprint">csharp
var contacts = new List&lt;Contact&gt; {
    new Contact {
        Name = &quot;Chris Smith&quot;,
        PhoneNumbers = { &quot;206-555-0101&quot;, &quot;425-882-8080&quot; }
    },
    new Contact {
        Name = &quot;Bob Harris&quot;,
        PhoneNumbers = { &quot;650-555-0199&quot; }
    }
};
</code>
which has the same effect as
<code class="prettyprint">csharp
var __clist = new List&lt;Contact&gt;();
Contact __c1 = new Contact();
__c1.Name = &quot;Chris Smith&quot;;
__c1.PhoneNumbers.Add(&quot;206-555-0101&quot;);
__c1.PhoneNumbers.Add(&quot;425-882-8080&quot;);
__clist.Add(__c1);
Contact __c2 = new Contact();
__c2.Name = &quot;Bob Harris&quot;;
__c2.PhoneNumbers.Add(&quot;650-555-0199&quot;);
__clist.Add(__c2);
var contacts = __clist;
</code>
where <code class="prettyprint">__clist</code>, <code class="prettyprint">__c1</code> and <code class="prettyprint">__c2</code> are temporary variables that are otherwise invisible and inaccessible.</p>

<h4 id="array-creation-expressions">Array creation expressions</h4>

<p>An <em>array_creation_expression</em> is used to create a new instance of an <em>array_type</em>.</p>
<pre class="highlight shell"><code>array_creation_expression
    : <span class="s1">'new'</span> non_array_type <span class="s1">'['</span> expression_list <span class="s1">']'</span> rank_specifier<span class="k">*</span> array_initializer?
    | <span class="s1">'new'</span> array_type array_initializer
    | <span class="s1">'new'</span> rank_specifier array_initializer
    ;
</code></pre>
<p>An array creation expression of the first form allocates an array instance of the type that results from deleting each of the individual expressions from the expression list. For example, the array creation expression <code class="prettyprint">new int[10,20]</code> produces an array instance of type <code class="prettyprint">int[,]</code>, and the array creation expression <code class="prettyprint">new int[10][,]</code> produces an array of type <code class="prettyprint">int[][,]</code>. Each expression in the expression list must be of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, or <code class="prettyprint">ulong</code>, or implicitly convertible to one or more of these types. The value of each expression determines the length of the corresponding dimension in the newly allocated array instance. Since the length of an array dimension must be nonnegative, it is a compile-time error to have a <em>constant_expression</em> with a negative value in the expression list.</p>

<p>Except in an unsafe context (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>), the layout of arrays is unspecified.</p>

<p>If an array creation expression of the first form includes an array initializer, each expression in the expression list must be a constant and the rank and dimension lengths specified by the expression list must match those of the array initializer.</p>

<p>In an array creation expression of the second or third form, the rank of the specified array type or rank specifier must match that of the array initializer. The individual dimension lengths are inferred from the number of elements in each of the corresponding nesting levels of the array initializer. Thus, the expression
<code class="prettyprint">csharp
new int[,] {{0, 1}, {2, 3}, {4, 5}}
</code>
exactly corresponds to
<code class="prettyprint">csharp
new int[3, 2] {{0, 1}, {2, 3}, {4, 5}}
</code></p>

<p>An array creation expression of the third form is referred to as an <strong><em>implicitly typed array creation expression</em></strong>. It is similar to the second form, except that the element type of the array is not explicitly given, but determined as the best common type (<a href="expressions.md#finding-the-best-common-type-of-a-set-of-expressions">Finding the best common type of a set of expressions</a>) of the set of expressions in the array initializer. For a multidimensional array, i.e., one where the <em>rank_specifier</em> contains at least one comma, this set comprises all *expression*s found in nested *array_initializer*s.</p>

<p>Array initializers are described further in <a href="arrays.md#array-initializers">Array initializers</a>.</p>

<p>The result of evaluating an array creation expression is classified as a value, namely a reference to the newly allocated array instance. The run-time processing of an array creation expression consists of the following steps:</p>

<ul>
<li> The dimension length expressions of the <em>expression_list</em> are evaluated in order, from left to right. Following evaluation of each expression, an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to one of the following types is performed: <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>. The first type in this list for which an implicit conversion exists is chosen. If evaluation of an expression or the subsequent implicit conversion causes an exception, then no further expressions are evaluated and no further steps are executed.</li>
<li> The computed values for the dimension lengths are validated as follows. If one or more of the values are less than zero, a <code class="prettyprint">System.OverflowException</code> is thrown and no further steps are executed.</li>
<li> An array instance with the given dimension lengths is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li> All elements of the new array instance are initialized to their default values (<a href="variables.md#default-values">Default values</a>).</li>
<li> If the array creation expression contains an array initializer, then each expression in the array initializer is evaluated and assigned to its corresponding array element. The evaluations and assignments are performed in the order the expressions are written in the array initializer—in other words, elements are initialized in increasing index order, with the rightmost dimension increasing first. If evaluation of a given expression or the subsequent assignment to the corresponding array element causes an exception, then no further elements are initialized (and the remaining elements will thus have their default values).</li>
</ul>

<p>An array creation expression permits instantiation of an array with elements of an array type, but the elements of such an array must be manually initialized. For example, the statement
<code class="prettyprint">csharp
int[][] a = new int[100][];
</code>
creates a single-dimensional array with 100 elements of type <code class="prettyprint">int[]</code>. The initial value of each element is <code class="prettyprint">null</code>. It is not possible for the same array creation expression to also instantiate the sub-arrays, and the statement
<code class="prettyprint">csharp
int[][] a = new int[100][5];        // Error
</code>
results in a compile-time error. Instantiation of the sub-arrays must instead be performed manually, as in
<code class="prettyprint">csharp
int[][] a = new int[100][];
for (int i = 0; i &lt; 100; i++) a[i] = new int[5];
</code></p>

<p>When an array of arrays has a &quot;rectangular&rdquo; shape, that is when the sub-arrays are all of the same length, it is more efficient to use a multi-dimensional array. In the example above, instantiation of the array of arrays creates 101 objects—one outer array and 100 sub-arrays. In contrast,
<code class="prettyprint">csharp
int[,] = new int[100, 5];
</code>
creates only a single object, a two-dimensional array, and accomplishes the allocation in a single statement.</p>

<p>The following are examples of implicitly typed array creation expressions:
&ldquo;`csharp
var a = new[] { 1, 10, 100, 1000 };                       // int[]</p>

<p>var b = new[] { 1, 1.5, 2, 2.5 };                         // double[]</p>

<p>var c = new[,] { { &quot;hello&rdquo;, null }, { &ldquo;world&rdquo;, &ldquo;!&rdquo; } };   // string[,]</p>

<p>var d = new[] { 1, &ldquo;one&rdquo;, 2, &ldquo;two&rdquo; };                     // Error
&ldquo;`</p>

<p>The last expression causes a compile-time error because neither <code class="prettyprint">int</code> nor <code class="prettyprint">string</code> is implicitly convertible to the other, and so there is no best common type. An explicitly typed array creation expression must be used in this case, for example specifying the type to be <code class="prettyprint">object[]</code>. Alternatively, one of the elements can be cast to a common base type, which would then become the inferred element type.</p>

<p>Implicitly typed array creation expressions can be combined with anonymous object initializers (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) to create anonymously typed data structures. For example:
<code class="prettyprint">csharp
var contacts = new[] {
    new {
        Name = &quot;Chris Smith&quot;,
        PhoneNumbers = new[] { &quot;206-555-0101&quot;, &quot;425-882-8080&quot; }
    },
    new {
        Name = &quot;Bob Harris&quot;,
        PhoneNumbers = new[] { &quot;650-555-0199&quot; }
    }
};
</code></p>

<h4 id="delegate-creation-expressions">Delegate creation expressions</h4>

<p>A <em>delegate_creation_expression</em> is used to create a new instance of a <em>delegate_type</em>.</p>
<pre class="highlight shell"><code>delegate_creation_expression
    : <span class="s1">'new'</span> delegate_type <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>The argument of a delegate creation expression must be a method group, an anonymous function or a value of either the compile time type <code class="prettyprint">dynamic</code> or a <em>delegate_type</em>. If the argument is a method group, it identifies the method and, for an instance method, the object for which to create a delegate. If the argument is an anonymous function it directly defines the parameters and method body of the delegate target. If the argument is a value it identifies a delegate instance of which to create a copy.</p>

<p>If the <em>expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, the <em>delegate_creation_expression</em> is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>), and the rules below are applied at run-time using the run-time type of the <em>expression</em>. Otherwise the rules are applied at compile-time.</p>

<p>The binding-time processing of a <em>delegate_creation_expression</em> of the form <code class="prettyprint">new D(E)</code>, where <code class="prettyprint">D</code> is a <em>delegate_type</em> and <code class="prettyprint">E</code> is an <em>expression</em>, consists of the following steps:</p>

<ul>
<li> If <code class="prettyprint">E</code> is a method group, the delegate creation expression is processed in the same way as a method group conversion (<a href="conversions.md#method-group-conversions">Method group conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li> If <code class="prettyprint">E</code> is an anonymous function, the delegate creation expression is processed in the same way as an anonymous function conversion (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li> If <code class="prettyprint">E</code> is a value, <code class="prettyprint">E</code> must be compatible (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) with <code class="prettyprint">D</code>, and the result is a reference to a newly created delegate of type <code class="prettyprint">D</code> that refers to the same invocation list as <code class="prettyprint">E</code>. If <code class="prettyprint">E</code> is not compatible with <code class="prettyprint">D</code>, a compile-time error occurs.</li>
</ul>

<p>The run-time processing of a <em>delegate_creation_expression</em> of the form <code class="prettyprint">new D(E)</code>, where <code class="prettyprint">D</code> is a <em>delegate_type</em> and <code class="prettyprint">E</code> is an <em>expression</em>, consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">E</code> is a method group, the delegate creation expression is evaluated as a method group conversion (<a href="conversions.md#method-group-conversions">Method group conversions</a>) from <code class="prettyprint">E</code> to <code class="prettyprint">D</code>.</li>
<li>  If <code class="prettyprint">E</code> is an anonymous function, the delegate creation is evaluated as an anonymous function conversion from <code class="prettyprint">E</code> to <code class="prettyprint">D</code> (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</li>
<li>  If <code class="prettyprint">E</code> is a value of a <em>delegate_type</em>:

<ul>
<li><code class="prettyprint">E</code> is evaluated. If this evaluation causes an exception, no further steps are executed.</li>
<li>If the value of <code class="prettyprint">E</code> is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown and no further steps are executed.</li>
<li>A new instance of the delegate type <code class="prettyprint">D</code> is allocated. If there is not enough memory available to allocate the new instance, a <code class="prettyprint">System.OutOfMemoryException</code> is thrown and no further steps are executed.</li>
<li>The new delegate instance is initialized with the same invocation list as the delegate instance given by <code class="prettyprint">E</code>.</li>
</ul></li>
</ul>

<p>The invocation list of a delegate is determined when the delegate is instantiated and then remains constant for the entire lifetime of the delegate. In other words, it is not possible to change the target callable entities of a delegate once it has been created. When two delegates are combined or one is removed from another (<a href="delegates.md#delegate-declarations">Delegate declarations</a>), a new delegate results; no existing delegate has its contents changed.</p>

<p>It is not possible to create a delegate that refers to a property, indexer, user-defined operator, instance constructor, destructor, or static constructor.</p>

<p>As described above, when a delegate is created from a method group, the formal parameter list and return type of the delegate determine which of the overloaded methods to select. In the example
&rdquo;`csharp
delegate double DoubleFunc(double x);</p>

<p>class A
{
    DoubleFunc f = new DoubleFunc(Square);</p>

<p>static float Square(float x) {
        return x * x;
    }</p>

<p>static double Square(double x) {
        return x * x;
    }
}
&ldquo;<code class="prettyprint">
the</code>A.f<code class="prettyprint">field is initialized with a delegate that refers to the second</code>Square<code class="prettyprint">method because that method exactly matches the formal parameter list and return type of</code>DoubleFunc<code class="prettyprint">. Had the second</code>Square` method not been present, a compile-time error would have occurred.</p>

<h4 id="anonymous-object-creation-expressions">Anonymous object creation expressions</h4>

<p>An <em>anonymous_object_creation_expression</em> is used to create an object of an anonymous type.</p>
<pre class="highlight shell"><code>anonymous_object_creation_expression
    : <span class="s1">'new'</span> anonymous_object_initializer
    ;

anonymous_object_initializer
    : <span class="s1">'{'</span> member_declarator_list? <span class="s1">'}'</span>
    | <span class="s1">'{'</span> member_declarator_list <span class="s1">','</span> <span class="s1">'}'</span>
    ;

member_declarator_list
    : member_declarator <span class="o">(</span><span class="s1">','</span> member_declarator<span class="o">)</span><span class="k">*</span>
    ;

member_declarator
    : simple_name
    | member_access
    | base_access
    | null_conditional_member_access
    | identifier <span class="s1">'='</span> expression
    ;
</code></pre>
<p>An anonymous object initializer declares an anonymous type and returns an instance of that type. An anonymous type is a nameless class type that inherits directly from <code class="prettyprint">object</code>. The members of an anonymous type are a sequence of read-only properties inferred from the anonymous object initializer used to create an instance of the type. Specifically, an anonymous object initializer of the form
<code class="prettyprint">csharp
new { p1 = e1, p2 = e2, ..., pn = en }
</code>
declares an anonymous type of the form
&rdquo;`csharp
class __Anonymous1
{
    private readonly T1 f1;
    private readonly T2 f2;
    &hellip;
    private readonly Tn fn;</p>

<p>public __Anonymous1(T1 a1, T2 a2, &hellip;, Tn an) {
        f1 = a1;
        f2 = a2;
        &hellip;
        fn = an;
    }</p>

<p>public T1 p1 { get { return f1; } }
    public T2 p2 { get { return f2; } }
    &hellip;
    public Tn pn { get { return fn; } }</p>

<p>public override bool Equals(object __o) { &hellip; }
    public override int GetHashCode() { &hellip; }
}
&ldquo;<code class="prettyprint">
where each</code>Tx<code class="prettyprint">is the type of the corresponding expression</code>ex`. The expression used in a <em>member_declarator</em> must have a type. Thus, it is a compile-time error for an expression in a <em>member_declarator</em> to be null or an anonymous function. It is also a compile-time error for the expression to have an unsafe type.</p>

<p>The names of an anonymous type and of the parameter to its <code class="prettyprint">Equals</code> method are automatically generated by the compiler and cannot be referenced in program text.</p>

<p>Within the same program, two anonymous object initializers that specify a sequence of properties of the same names and compile-time types in the same order will produce instances of the same anonymous type.</p>

<p>In the example
<code class="prettyprint">csharp
var p1 = new { Name = &quot;Lawnmower&quot;, Price = 495.00 };
var p2 = new { Name = &quot;Shovel&quot;, Price = 26.95 };
p1 = p2;
</code>
the assignment on the last line is permitted because <code class="prettyprint">p1</code> and <code class="prettyprint">p2</code> are of the same anonymous type.</p>

<p>The <code class="prettyprint">Equals</code> and <code class="prettyprint">GetHashcode</code> methods on anonymous types override the methods inherited from <code class="prettyprint">object</code>, and are defined in terms of the <code class="prettyprint">Equals</code> and <code class="prettyprint">GetHashcode</code> of the properties, so that two instances of the same anonymous type are equal if and only if all their properties are equal.</p>

<p>A member declarator can be abbreviated to a simple name (<a href="expressions.md#type-inference">Type inference</a>), a member access (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>), a base access (<a href="expressions.md#base-access">Base access</a>) or a null-conditional member access (<a href="expressions.md#null-conditional-expressions-as-projection-initializers">Null-conditional expressions as projection initializers</a>). This is called a <strong><em>projection initializer</em></strong> and is shorthand for a declaration of and assignment to a property with the same name. Specifically, member declarators of the forms
<code class="prettyprint">csharp
identifier
expr.identifier
</code>
are precisely equivalent to the following, respectively:
<code class="prettyprint">csharp
identifier = identifier
identifier = expr.identifier
</code></p>

<p>Thus, in a projection initializer the <em>identifier</em> selects both the value and the field or property to which the value is assigned. Intuitively, a projection initializer projects not just a value, but also the name of the value.</p>

<h3 id="the-typeof-operator">The typeof operator</h3>

<p>The <code class="prettyprint">typeof</code> operator is used to obtain the <code class="prettyprint">System.Type</code> object for a type.</p>
<pre class="highlight shell"><code>typeof_expression
    : <span class="s1">'typeof'</span> <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span>
    | <span class="s1">'typeof'</span> <span class="s1">'('</span> unbound_type_name <span class="s1">')'</span>
    | <span class="s1">'typeof'</span> <span class="s1">'('</span> <span class="s1">'void'</span> <span class="s1">')'</span>
    ;

unbound_type_name
    : identifier generic_dimension_specifier?
    | identifier <span class="s1">'::'</span> identifier generic_dimension_specifier?
    | unbound_type_name <span class="s1">'.'</span> identifier generic_dimension_specifier?
    ;

generic_dimension_specifier
    : <span class="s1">'&lt;'</span> comma<span class="k">*</span> <span class="s1">'&gt;'</span>
    ;

comma
    : <span class="s1">','</span>
    ;
</code></pre>
<p>The first form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <em>type</em>. The result of an expression of this form is the <code class="prettyprint">System.Type</code> object for the indicated type. There is only one <code class="prettyprint">System.Type</code> object for any given type. This means that for a type <code class="prettyprint">T</code>, <code class="prettyprint">typeof(T) == typeof(T)</code> is always true. The <em>type</em> cannot be <code class="prettyprint">dynamic</code>.</p>

<p>The second form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <em>unbound_type_name</em>. An <em>unbound_type_name</em> is very similar to a <em>type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) except that an <em>unbound_type_name</em> contains <em>generic_dimension_specifier*s where a *type_name</em> contains <em>type_argument_list*s. When the operand of a *typeof_expression</em> is a sequence of tokens that satisfies the grammars of both <em>unbound_type_name</em> and <em>type_name</em>, namely when it contains neither a <em>generic_dimension_specifier</em> nor a <em>type_argument_list</em>, the sequence of tokens is considered to be a <em>type_name</em>. The meaning of an <em>unbound_type_name</em> is determined as follows:</p>

<ul>
<li> Convert the sequence of tokens to a <em>type_name</em> by replacing each <em>generic_dimension_specifier</em> with a <em>type_argument_list</em> having the same number of commas and the keyword <code class="prettyprint">object</code> as each <em>type_argument</em>.</li>
<li> Evaluate the resulting <em>type_name</em>, while ignoring all type parameter constraints.</li>
<li> The <em>unbound_type_name</em> resolves to the unbound generic type associated with the resulting constructed type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>).</li>
</ul>

<p>The result of the <em>typeof_expression</em> is the <code class="prettyprint">System.Type</code> object for the resulting unbound generic type.</p>

<p>The third form of <em>typeof_expression</em> consists of a <code class="prettyprint">typeof</code> keyword followed by a parenthesized <code class="prettyprint">void</code> keyword. The result of an expression of this form is the <code class="prettyprint">System.Type</code> object that represents the absence of a type. The type object returned by <code class="prettyprint">typeof(void)</code> is distinct from the type object returned for any type. This special type object is useful in class libraries that allow reflection onto methods in the language, where those methods wish to have a way to represent the return type of any method, including void methods, with an instance of <code class="prettyprint">System.Type</code>.</p>

<p>The <code class="prettyprint">typeof</code> operator can be used on a type parameter. The result is the <code class="prettyprint">System.Type</code> object for the run-time type that was bound to the type parameter. The <code class="prettyprint">typeof</code> operator can also be used on a constructed type or an unbound generic type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>). The <code class="prettyprint">System.Type</code> object for an unbound generic type is not the same as the <code class="prettyprint">System.Type</code> object of the instance type. The instance type is always a closed constructed type at run-time so its <code class="prettyprint">System.Type</code> object depends on the run-time type arguments in use, while the unbound generic type has no type arguments.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class X<T>
{
    public static void PrintTypes() {
        Type[] t = {
            typeof(int),
            typeof(System.Int32),
            typeof(string),
            typeof(double[]),
            typeof(void),
            typeof(T),
            typeof(X<T>),
            typeof(X<X<T>&gt;),
            typeof(X&lt;&gt;)
        };
        for (int i = 0; i &lt; t.Length; i++) {
            Console.WriteLine(t[i]);
        }
    }
}</p>

<p>class Test
{
    static void Main() {
        X<int>.PrintTypes();
    }
}
<code class="prettyprint">
produces the following output:
</code>bash
System.Int32
System.Int32
System.String
System.Double[]
System.Void
System.Int32
X<code class="prettyprint">1[System.Int32]
X</code>1[X<code class="prettyprint">1[System.Int32]]
X</code>1[T]
&ldquo;`</p>

<p>Note that <code class="prettyprint">int</code> and <code class="prettyprint">System.Int32</code> are the same type.</p>

<p>Also note that the result of <code class="prettyprint">typeof(X&lt;&gt;)</code> does not depend on the type argument but the result of <code class="prettyprint">typeof(X&lt;T&gt;)</code> does.</p>

<h3 id="the-checked-and-unchecked-operators">The checked and unchecked operators</h3>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators are used to control the <strong><em>overflow checking context</em></strong> for integral-type arithmetic operations and conversions.</p>
<pre class="highlight shell"><code>checked_expression
    : <span class="s1">'checked'</span> <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;

unchecked_expression
    : <span class="s1">'unchecked'</span> <span class="s1">'('</span> expression <span class="s1">')'</span>
    ;
</code></pre>
<p>The <code class="prettyprint">checked</code> operator evaluates the contained expression in a checked context, and the <code class="prettyprint">unchecked</code> operator evaluates the contained expression in an unchecked context. A <em>checked_expression</em> or <em>unchecked_expression</em> corresponds exactly to a <em>parenthesized_expression</em> (<a href="expressions.md#parenthesized-expressions">Parenthesized expressions</a>), except that the contained expression is evaluated in the given overflow checking context.</p>

<p>The overflow checking context can also be controlled through the <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> statements (<a href="statements.md#the-checked-and-unchecked-statements">The checked and unchecked statements</a>).</p>

<p>The following operations are affected by the overflow checking context established by the <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements:</p>

<ul>
<li> The predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> unary operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a> and <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>), when the operand is of an integral type.</li>
<li> The predefined <code class="prettyprint">-</code> unary operator (<a href="expressions.md#unary-minus-operator">Unary minus operator</a>), when the operand is of an integral type.</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, and <code class="prettyprint">/</code> binary operators (<a href="expressions.md#arithmetic-operators">Arithmetic operators</a>), when both operands are of integral types.</li>
<li> Explicit numeric conversions (<a href="conversions.md#explicit-numeric-conversions">Explicit numeric conversions</a>) from one integral type to another integral type, or from <code class="prettyprint">float</code> or <code class="prettyprint">double</code> to an integral type.</li>
</ul>

<p>When one of the above operations produce a result that is too large to represent in the destination type, the context in which the operation is performed controls the resulting behavior:</p>

<ul>
<li> In a <code class="prettyprint">checked</code> context, if the operation is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>), a compile-time error occurs. Otherwise, when the operation is performed at run-time, a <code class="prettyprint">System.OverflowException</code> is thrown.</li>
<li> In an <code class="prettyprint">unchecked</code> context, the result is truncated by discarding any high-order bits that do not fit in the destination type.</li>
</ul>

<p>For non-constant expressions (expressions that are evaluated at run-time) that are not enclosed by any <code class="prettyprint">checked</code> or <code class="prettyprint">unchecked</code> operators or statements, the default overflow checking context is <code class="prettyprint">unchecked</code> unless external factors (such as compiler switches and execution environment configuration) call for <code class="prettyprint">checked</code> evaluation.</p>

<p>For constant expressions (expressions that can be fully evaluated at compile-time), the default overflow checking context is always <code class="prettyprint">checked</code>. Unless a constant expression is explicitly placed in an <code class="prettyprint">unchecked</code> context, overflows that occur during the compile-time evaluation of the expression always cause compile-time errors.</p>

<p>The body of an anonymous function is not affected by <code class="prettyprint">checked</code> or <code class="prettyprint">unchecked</code> contexts in which the anonymous function occurs.</p>

<p>In the example
&rdquo;`csharp
class Test
{
    static readonly int x = 1000000;
    static readonly int y = 1000000;</p>

<p>static int F() {
        return checked(x * y);      // Throws OverflowException
    }</p>

<p>static int G() {
        return unchecked(x * y);    // Returns -727379968
    }</p>

<p>static int H() {
        return x * y;               // Depends on default
    }
}
&ldquo;<code class="prettyprint">
no compile-time errors are reported since neither of the expressions can be evaluated at compile-time. At run-time, the</code>F<code class="prettyprint">method throws a</code>System.OverflowException<code class="prettyprint">, and the</code>G<code class="prettyprint">method returns -727379968 (the lower 32 bits of the out-of-range result). The behavior of the</code>H<code class="prettyprint">method depends on the default overflow checking context for the compilation, but it is either the same as</code>F<code class="prettyprint">or the same as</code>G`.</p>

<p>In the example
&rdquo;`csharp
class Test
{
    const int x = 1000000;
    const int y = 1000000;</p>

<p>static int F() {
        return checked(x * y);      // Compile error, overflow
    }</p>

<p>static int G() {
        return unchecked(x * y);    // Returns -727379968
    }</p>

<p>static int H() {
        return x * y;               // Compile error, overflow
    }
}
&ldquo;<code class="prettyprint">
the overflows that occur when evaluating the constant expressions in</code>F<code class="prettyprint">and</code>H<code class="prettyprint">cause compile-time errors to be reported because the expressions are evaluated in a</code>checked<code class="prettyprint">context. An overflow also occurs when evaluating the constant expression in</code>G<code class="prettyprint">, but since the evaluation takes place in an</code>unchecked` context, the overflow is not reported.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators only affect the overflow checking context for those operations that are textually contained within the &rdquo;<code class="prettyprint">(</code>&ldquo; and &rdquo;<code class="prettyprint">)</code>&ldquo; tokens. The operators have no effect on function members that are invoked as a result of evaluating the contained expression. In the example
&rdquo;`csharp
class Test
{
    static int Multiply(int x, int y) {
        return x * y;
    }</p>

<p>static int F() {
        return checked(Multiply(1000000, 1000000));
    }
}
&ldquo;<code class="prettyprint">
the use of</code>checked<code class="prettyprint">in</code>F<code class="prettyprint">does not affect the evaluation of</code>x * y<code class="prettyprint">in</code>Multiply<code class="prettyprint">, so</code>x * y` is evaluated in the default overflow checking context.</p>

<p>The <code class="prettyprint">unchecked</code> operator is convenient when writing constants of the signed integral types in hexadecimal notation. For example:
&rdquo;`csharp
class Test
{
    public const int AllBits = unchecked((int)0xFFFFFFFF);</p>

<p>public const int HighBit = unchecked((int)0x80000000);
}
&ldquo;`</p>

<p>Both of the hexadecimal constants above are of type <code class="prettyprint">uint</code>. Because the constants are outside the <code class="prettyprint">int</code> range, without the <code class="prettyprint">unchecked</code> operator, the casts to <code class="prettyprint">int</code> would produce compile-time errors.</p>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements allow programmers to control certain aspects of some numeric calculations. However, the behavior of some numeric operators depends on their operands&rsquo; data types. For example, multiplying two decimals always results in an exception on overflow even within an explicitly <code class="prettyprint">unchecked</code> construct. Similarly, multiplying two floats never results in an exception on overflow even within an explicitly <code class="prettyprint">checked</code> construct. In addition, other operators are never affected by the mode of checking, whether default or explicit.</p>

<h3 id="default-value-expressions">Default value expressions</h3>

<p>A default value expression is used to obtain the default value (<a href="variables.md#default-values">Default values</a>) of a type. Typically a default value expression is used for type parameters, since it may not be known if the type parameter is a value type or a reference type. (No conversion exists from the <code class="prettyprint">null</code> literal to a type parameter unless the type parameter is known to be a reference type.)</p>
<pre class="highlight shell"><code>default_value_expression
    : <span class="s1">'default'</span> <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span>
    ;
</code></pre>
<p>If the <em>type</em> in a <em>default_value_expression</em> evaluates at run-time to a reference type, the result is <code class="prettyprint">null</code> converted to that type. If the <em>type</em> in a <em>default_value_expression</em> evaluates at run-time to a value type, the result is the <em>value_type</em>&lsquo;s default value (<a href="types.md#default-constructors">Default constructors</a>).</p>

<p>A <em>default_value_expression</em> is a constant expression (<a href="expressions.md#constant-expressions">Constant expressions</a>) if the type is a reference type or a type parameter that is known to be a reference type (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). In addition, a <em>default_value_expression</em> is a constant expression if the type is one of the following value types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, or any enumeration type.</p>

<h3 id="nameof-expressions">Nameof expressions</h3>

<p>A <em>nameof_expression</em> is used to obtain the name of a program entity as a constant string.</p>
<pre class="highlight shell"><code>nameof_expression
    : <span class="s1">'nameof'</span> <span class="s1">'('</span> named_entity <span class="s1">')'</span>
    ;

named_entity
    : simple_name
    | named_entity_target <span class="s1">'.'</span> identifier type_argument_list?
    ;

named_entity_target
    : <span class="s1">'this'</span>
    | <span class="s1">'base'</span>
    | named_entity 
    | predefined_type 
    | qualified_alias_member
    ;
</code></pre>
<p>Grammatically speaking, the <em>named_entity</em> operand is always an expression. Because <code class="prettyprint">nameof</code> is not a reserved keyword, a nameof expression is always syntactically ambiguous with an invocation of the simple name <code class="prettyprint">nameof</code>. For compatibility reasons, if a name lookup (<a href="expressions.md#simple-names">Simple names</a>) of the name <code class="prettyprint">nameof</code> succeeds, the expression is treated as an <em>invocation_expression</em> &ndash; regardless of whether the invocation is legal. Otherwise it is a <em>nameof_expression</em>.</p>

<p>The meaning of the <em>named_entity</em> of a <em>nameof_expression</em> is the meaning of it as an expression; that is, either as a <em>simple_name</em>, a <em>base_access</em> or a <em>member_access</em>. However, where the lookup described in <a href="expressions.md#simple-names">Simple names</a> and <a href="expressions.md#member-access">Member access</a> results in an error because an instance member was found in a static context, a <em>nameof_expression</em> produces no such error.</p>

<p>It is a compile-time error for a <em>named_entity</em> designating a method group to have a <em>type_argument_list</em>. It is a compile time error for a <em>named_entity_target</em> to have the type <code class="prettyprint">dynamic</code>.</p>

<p>A <em>nameof_expression</em> is a constant expression of type <code class="prettyprint">string</code>, and has no effect at runtime. Specifically, its <em>named_entity</em> is not evaluated, and is ignored for the purposes of definite assignment analysis (<a href="variables.md#general-rules-for-simple-expressions">General rules for simple expressions</a>). Its value is the last identifier of the <em>named_entity</em> before the optional final <em>type_argument_list</em>, transformed in the following way:</p>

<ul>
<li>The prefix &rdquo;<code class="prettyprint">@</code>&ldquo;, if used, is removed.</li>
<li>Each <em>unicode_escape_sequence</em> is transformed into its corresponding Unicode character.</li>
<li>Any <em>formatting_characters</em> are removed.</li>
</ul>

<p>These are the same transformations applied in <a href="lexical-structure.md#identifiers">Identifiers</a> when testing equality between identifiers.</p>

<p>TODO: examples</p>

<h3 id="anonymous-method-expressions">Anonymous method expressions</h3>

<p>An <em>anonymous_method_expression</em> is one of two ways of defining an anonymous function. These are further described in <a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>.</p>

<h2 id="unary-operators">Unary operators</h2>

<p>The <code class="prettyprint">?</code>, <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, cast, and <code class="prettyprint">await</code> operators are called the unary operators.</p>
<pre class="highlight shell"><code>unary_expression
    : primary_expression
    | null_conditional_expression
    | <span class="s1">'+'</span> unary_expression
    | <span class="s1">'-'</span> unary_expression
    | <span class="s1">'!'</span> unary_expression
    | <span class="s1">'~'</span> unary_expression
    | pre_increment_expression
    | pre_decrement_expression
    | cast_expression
    | await_expression
    | unary_expression_unsafe
    ;
</code></pre>
<p>If the operand of a <em>unary_expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, it is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the <em>unary_expression</em> is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of the operand.</p>

<h3 id="null-conditional-operator">Null-conditional operator</h3>

<p>The null-conditional operator applies a list of operations to its operand only if that operand is non-null. Otherwise the result of applying the operator is <code class="prettyprint">null</code>.</p>
<pre class="highlight shell"><code>null_conditional_expression
    : primary_expression null_conditional_operations
    ;

null_conditional_operations
    : null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'.'</span> identifier type_argument_list?
    | null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    | null_conditional_operations <span class="s1">'.'</span> identifier type_argument_list?
    | null_conditional_operations <span class="s1">'['</span> argument_list <span class="s1">']'</span>
    | null_conditional_operations <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>The list of operations can include member access and element access operations (which may themselves be null-conditional), as well as invocation.</p>

<p>For example, the expression <code class="prettyprint">a.b?[0]?.c()</code> is a <em>null_conditional_expression</em> with a <em>primary_expression</em> <code class="prettyprint">a.b</code> and <em>null_conditional_operations</em> <code class="prettyprint">?[0]</code> (null-conditional element access), <code class="prettyprint">?.c</code> (null-conditional member access) and <code class="prettyprint">()</code> (invocation).</p>

<p>For a <em>null_conditional_expression</em> <code class="prettyprint">E</code> with a <em>primary_expression</em> <code class="prettyprint">P</code>, let <code class="prettyprint">E0</code> be the expression obtained by textually removing the leading <code class="prettyprint">?</code> from each of the <em>null_conditional_operations</em> of <code class="prettyprint">E</code> that have one. Conceptually, <code class="prettyprint">E0</code> is the expression that will be evaluated if none of the null checks represented by the <code class="prettyprint">?</code>s do find a <code class="prettyprint">null</code>.</p>

<p>Also, let <code class="prettyprint">E1</code> be the expression obtained by textually removing the leading <code class="prettyprint">?</code> from just the first of the <em>null_conditional_operations</em> in <code class="prettyprint">E</code>. This may lead to a <em>primary-expression</em> (if there was just one <code class="prettyprint">?</code>) or to another <em>null_conditional_expression</em>.</p>

<p>For example, if <code class="prettyprint">E</code> is the expression <code class="prettyprint">a.b?[0]?.c()</code>, then <code class="prettyprint">E0</code> is the expression <code class="prettyprint">a.b[0].c()</code> and <code class="prettyprint">E1</code> is the expression <code class="prettyprint">a.b[0]?.c()</code>.</p>

<p>If <code class="prettyprint">E0</code> is classified as nothing, then <code class="prettyprint">E</code> is classified as nothing. Otherwise E is classified as a value.</p>

<p><code class="prettyprint">E0</code> and <code class="prettyprint">E1</code> are used to determine the meaning of <code class="prettyprint">E</code>:</p>

<ul>
<li> If <code class="prettyprint">E</code> occurs as a <em>statement_expression</em> the meaning of <code class="prettyprint">E</code> is the same as the statement</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">if</span> <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">E1</span><span class="p">;</span>
</code></pre>
<p>except that P is evaluated only once.</p>

<ul>
<li><p>Otherwise, if <code class="prettyprint">E0</code> is classified as nothing a compile-time error occurs.</p></li>
<li><p>Otherwise, let <code class="prettyprint">T0</code> be the type of <code class="prettyprint">E0</code>.</p>

<ul>
<li> If <code class="prettyprint">T0</code> is a type parameter that is not known to be a reference type or a non-nullable value type, a compile-time error occurs.</li>
<li> If <code class="prettyprint">T0</code> is a non-nullable value type, then the type of <code class="prettyprint">E</code> is <code class="prettyprint">T0?</code>, and the meaning of <code class="prettyprint">E</code> is the same as</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>  <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span><span class="n">T0</span><span class="p">?)</span><span class="k">null</span> <span class="p">:</span> <span class="n">E1</span>
</code></pre>
<p>except that <code class="prettyprint">P</code> is evaluated only once.
*  Otherwise the type of E is T0, and the meaning of E is the same as</p>
<pre class="highlight csharp tab-csharp"><code>  <span class="p">((</span><span class="kt">object</span><span class="p">)</span><span class="n">P</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">E1</span>
</code></pre>
<p>except that <code class="prettyprint">P</code> is evaluated only once.</p></li>
</ul>

<p>If <code class="prettyprint">E1</code> is itself a <em>null_conditional_expression</em>, then these rules are applied again, nesting the tests for <code class="prettyprint">null</code> until there are no further <code class="prettyprint">?</code>&rsquo;s, and the expression has been reduced all the way down to the primary-expression <code class="prettyprint">E0</code>.</p>

<p>For example, if the expression <code class="prettyprint">a.b?[0]?.c()</code> occurs as a statement-expression, as in the statement:
<code class="prettyprint">csharp
a.b?[0]?.c();
</code>
its meaning is equivalent to:
<code class="prettyprint">csharp
if (a.b != null) a.b[0]?.c();
</code>
which again is equivalent to:
<code class="prettyprint">csharp
if (a.b != null) if (a.b[0] != null) a.b[0].c();
</code>
Except that <code class="prettyprint">a.b</code> and <code class="prettyprint">a.b[0]</code> are evaluated only once.</p>

<p>If it occurs in a context where its value is used, as in:
<code class="prettyprint">csharp
var x = a.b?[0]?.c();
</code>
and assuming that the type of the final invocation is not a non-nullable value type, its meaning is equivalent to:
<code class="prettyprint">csharp
var x = (a.b == null) ? null : (a.b[0] == null) ? null : a.b[0].c();
</code>
except that <code class="prettyprint">a.b</code> and <code class="prettyprint">a.b[0]</code> are evaluated only once.</p>

<h4 id="null-conditional-expressions-as-projection-initializers">Null-conditional expressions as projection initializers</h4>

<p>A null-conditional expression is only allowed as a <em>member_declarator</em> in an <em>anonymous_object_creation_expression</em> (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) if it ends with an (optionally null-conditional) member access. Grammatically, this requirement can be expressed as:</p>
<pre class="highlight shell"><code>null_conditional_member_access
    : primary_expression null_conditional_operations? <span class="s1">'?'</span> <span class="s1">'.'</span> identifier type_argument_list?
    | primary_expression null_conditional_operations <span class="s1">'.'</span> identifier type_argument_list?
    ;
</code></pre>
<p>This is a special case of the grammar for <em>null_conditional_expression</em> above. The production for <em>member_declarator</em> in <a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a> then includes only <em>null_conditional_member_access</em>.</p>

<h4 id="null-conditional-expressions-as-statement-expressions">Null-conditional expressions as statement expressions</h4>

<p>A null-conditional expression is only allowed as a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>) if it ends with an invocation. Grammatically, this requirement can be expressed as:</p>
<pre class="highlight shell"><code>null_conditional_invocation_expression
    : primary_expression null_conditional_operations <span class="s1">'('</span> argument_list? <span class="s1">')'</span>
    ;
</code></pre>
<p>This is a special case of the grammar for <em>null_conditional_expression</em> above. The production for <em>statement_expression</em> in <a href="statements.md#expression-statements">Expression statements</a> then includes only <em>null_conditional_invocation_expression</em>.</p>

<h3 id="unary-plus-operator">Unary plus operator</h3>

<p>For an operation of the form <code class="prettyprint">+x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined unary plus operators are:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">uint</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">long</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">ulong</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">float</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">double</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
<span class="kt">decimal</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>For each of these operators, the result is simply the value of the operand.</p>

<h3 id="unary-minus-operator">Unary minus operator</h3>

<p>For an operation of the form <code class="prettyprint">-x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined negation operators are:</p>

<ul>
<li> Integer negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">long</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is computed by subtracting <code class="prettyprint">x</code> from zero. If the value of of <code class="prettyprint">x</code> is the smallest representable value of the operand type (-2^31 for <code class="prettyprint">int</code> or -2^63 for <code class="prettyprint">long</code>), then the mathematical negation of <code class="prettyprint">x</code> is not representable within the operand type. If this occurs within a <code class="prettyprint">checked</code> context, a <code class="prettyprint">System.OverflowException</code> is thrown; if it occurs within an <code class="prettyprint">unchecked</code> context, the result is the value of the operand and the overflow is not reported.</p>

<p>If the operand of the negation operator is of type <code class="prettyprint">uint</code>, it is converted to type <code class="prettyprint">long</code>, and the type of the result is <code class="prettyprint">long</code>. An exception is the rule that permits the <code class="prettyprint">int</code> value -2147483648 (-2^31) to be written as a decimal integer literal (<a href="lexical-structure.md#integer-literals">Integer literals</a>).</p>

<p>If the operand of the negation operator is of type <code class="prettyprint">ulong</code>, a compile-time error occurs. An exception is the rule that permits the <code class="prettyprint">long</code> value -9223372036854775808 (-2^63) to be written as a decimal integer literal (<a href="lexical-structure.md#integer-literals">Integer literals</a>).</p>

<ul>
<li> Floating-point negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is the value of <code class="prettyprint">x</code> with its sign inverted. If <code class="prettyprint">x</code> is NaN, the result is also NaN.</p>

<ul>
<li> Decimal negation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result is computed by subtracting <code class="prettyprint">x</code> from zero. Decimal negation is equivalent to using the unary minus operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="logical-negation-operator">Logical negation operator</h3>

<p>For an operation of the form <code class="prettyprint">!x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. Only one predefined logical negation operator exists:
<code class="prettyprint">csharp
bool operator !(bool x);
</code></p>

<p>This operator computes the logical negation of the operand: If the operand is <code class="prettyprint">true</code>, the result is <code class="prettyprint">false</code>. If the operand is <code class="prettyprint">false</code>, the result is <code class="prettyprint">true</code>.</p>

<h3 id="bitwise-complement-operator">Bitwise complement operator</h3>

<p>For an operation of the form <code class="prettyprint">~x</code>, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. The operand is converted to the parameter type of the selected operator, and the type of the result is the return type of the operator. The predefined bitwise complement operators are:
<code class="prettyprint">csharp
int operator ~(int x);
uint operator ~(uint x);
long operator ~(long x);
ulong operator ~(ulong x);
</code></p>

<p>For each of these operators, the result of the operation is the bitwise complement of <code class="prettyprint">x</code>.</p>

<p>Every enumeration type <code class="prettyprint">E</code> implicitly provides the following bitwise complement operator:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">E</span> <span class="k">operator</span> <span class="p">~(</span><span class="n">E</span> <span class="n">x</span><span class="p">);</span>
</code></pre>
<p>The result of evaluating <code class="prettyprint">~x</code>, where <code class="prettyprint">x</code> is an expression of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, is exactly the same as evaluating <code class="prettyprint">(E)(~(U)x)</code>, except that the conversion to <code class="prettyprint">E</code> is always performed as if in an <code class="prettyprint">unchecked</code> context (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>).</p>

<h3 id="prefix-increment-and-decrement-operators">Prefix increment and decrement operators</h3>
<pre class="highlight shell"><code>pre_increment_expression
    : <span class="s1">'++'</span> unary_expression
    ;

pre_decrement_expression
    : <span class="s1">'--'</span> unary_expression
    ;
</code></pre>
<p>The operand of a prefix increment or decrement operation must be an expression classified as a variable, a property access, or an indexer access. The result of the operation is a value of the same type as the operand.</p>

<p>If the operand of a prefix increment or decrement operation is a property or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>Unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is applied to select a specific operator implementation. Predefined <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators exist for the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, and any enum type. The predefined <code class="prettyprint">++</code> operators return the value produced by adding 1 to the operand, and the predefined <code class="prettyprint">--</code> operators return the value produced by subtracting 1 from the operand. In a <code class="prettyprint">checked</code> context, if the result of this addition or subtraction is outside the range of the result type and the result type is an integral type or enum type, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The run-time processing of a prefix increment or decrement operation of the form <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> consists of the following steps:</p>

<ul>
<li>  If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li>The selected operator is invoked with the value of <code class="prettyprint">x</code> as its argument.</li>
<li>The value returned by the operator is stored in the location given by the evaluation of <code class="prettyprint">x</code>.</li>
<li>The value returned by the operator becomes the result of the operation.</li>
</ul></li>
<li>  If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor invocations.</li>
<li>The <code class="prettyprint">get</code> accessor of <code class="prettyprint">x</code> is invoked.</li>
<li>The selected operator is invoked with the value returned by the <code class="prettyprint">get</code> accessor as its argument.</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value returned by the operator as its <code class="prettyprint">value</code> argument.</li>
<li>The value returned by the operator becomes the result of the operation.</li>
</ul></li>
</ul>

<p>The <code class="prettyprint">++</code> and <code class="prettyprint">--</code> operators also support postfix notation (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>). Typically, the result of <code class="prettyprint">x++</code> or <code class="prettyprint">x--</code> is the value of <code class="prettyprint">x</code> before the operation, whereas the result of <code class="prettyprint">++x</code> or <code class="prettyprint">--x</code> is the value of <code class="prettyprint">x</code> after the operation. In either case, <code class="prettyprint">x</code> itself has the same value after the operation.</p>

<p>An <code class="prettyprint">operator++</code> or <code class="prettyprint">operator--</code> implementation can be invoked using either postfix or prefix notation. It is not possible to have separate operator implementations for the two notations.</p>

<h3 id="cast-expressions">Cast expressions</h3>

<p>A <em>cast_expression</em> is used to explicitly convert an expression to a given type.</p>
<pre class="highlight shell"><code>cast_expression
    : <span class="s1">'('</span> <span class="nb">type</span> <span class="s1">')'</span> unary_expression
    ;
</code></pre>
<p>A <em>cast_expression</em> of the form <code class="prettyprint">(T)E</code>, where <code class="prettyprint">T</code> is a <em>type</em> and <code class="prettyprint">E</code> is a <em>unary_expression</em>, performs an explicit conversion (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) of the value of <code class="prettyprint">E</code> to type <code class="prettyprint">T</code>. If no explicit conversion exists from <code class="prettyprint">E</code> to <code class="prettyprint">T</code>, a binding-time error occurs. Otherwise, the result is the value produced by the explicit conversion. The result is always classified as a value, even if <code class="prettyprint">E</code> denotes a variable.</p>

<p>The grammar for a <em>cast_expression</em> leads to certain syntactic ambiguities. For example, the expression <code class="prettyprint">(x)-y</code> could either be interpreted as a <em>cast_expression</em> (a cast of <code class="prettyprint">-y</code> to type <code class="prettyprint">x</code>) or as an <em>additive_expression</em> combined with a <em>parenthesized_expression</em> (which computes the value <code class="prettyprint">x - y)</code>.</p>

<p>To resolve <em>cast_expression</em> ambiguities, the following rule exists: A sequence of one or more <em>token*s (<a href="lexical-structure.md#white-space">White space</a>) enclosed in parentheses is considered the start of a *cast_expression</em> only if at least one of the following are true:</p>

<ul>
<li> The sequence of tokens is correct grammar for a <em>type</em>, but not for an <em>expression</em>.</li>
<li> The sequence of tokens is correct grammar for a <em>type</em>, and the token immediately following the closing parentheses is the token &rdquo;<code class="prettyprint">~</code>&ldquo;, the token &rdquo;<code class="prettyprint">!</code>&ldquo;, the token &rdquo;<code class="prettyprint">(</code>&ldquo;, an <em>identifier</em> (<a href="lexical-structure.md#unicode-character-escape-sequences">Unicode character escape sequences</a>), a <em>literal</em> (<a href="lexical-structure.md#literals">Literals</a>), or any <em>keyword</em> (<a href="lexical-structure.md#keywords">Keywords</a>) except <code class="prettyprint">as</code> and <code class="prettyprint">is</code>.</li>
</ul>

<p>The term &quot;correct grammar&rdquo; above means only that the sequence of tokens must conform to the particular grammatical production. It specifically does not consider the actual meaning of any constituent identifiers. For example, if <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are identifiers, then <code class="prettyprint">x.y</code> is correct grammar for a type, even if <code class="prettyprint">x.y</code> doesn&rsquo;t actually denote a type.</p>

<p>From the disambiguation rule it follows that, if <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are identifiers, <code class="prettyprint">(x)y</code>, <code class="prettyprint">(x)(y)</code>, and <code class="prettyprint">(x)(-y)</code> are *cast_expression*s, but <code class="prettyprint">(x)-y</code> is not, even if <code class="prettyprint">x</code> identifies a type. However, if <code class="prettyprint">x</code> is a keyword that identifies a predefined type (such as <code class="prettyprint">int</code>), then all four forms are *cast_expression*s (because such a keyword could not possibly be an expression by itself).</p>

<h3 id="await-expressions">Await expressions</h3>

<p>The await operator is used to suspend evaluation of the enclosing async function until the asynchronous operation represented by the operand has completed.</p>
<pre class="highlight shell"><code>await_expression
    : <span class="s1">'await'</span> unary_expression
    ;
</code></pre>
<p>An <em>await_expression</em> is only allowed in the body of an async function (<a href="classes.md#iterators">Iterators</a>). Within the nearest enclosing async function, an <em>await_expression</em> may not occur in these places:</p>

<ul>
<li> Inside a nested (non-async) anonymous function</li>
<li> Inside the block of a <em>lock_statement</em></li>
<li> In an unsafe context</li>
</ul>

<p>Note that an <em>await_expression</em> cannot occur in most places within a <em>query_expression</em>, because those are syntactically transformed to use non-async lambda expressions.</p>

<p>Inside of an async function, <code class="prettyprint">await</code> cannot be used as an identifier. There is therefore no syntactic ambiguity between await-expressions and various expressions involving identifiers. Outside of async functions, <code class="prettyprint">await</code> acts as a normal identifier.</p>

<p>The operand of an <em>await_expression</em> is called the <strong><em>task</em></strong>. It represents an asynchronous operation that may or may not be complete at the time the <em>await_expression</em> is evaluated. The purpose of the await operator is to suspend execution of the enclosing async function until the awaited task is complete, and then obtain its outcome.</p>

<h4 id="awaitable-expressions">Awaitable expressions</h4>

<p>The task of an await expression is required to be <strong><em>awaitable</em></strong>. An expression <code class="prettyprint">t</code> is awaitable if one of the following holds:</p>

<ul>
<li> <code class="prettyprint">t</code> is of compile time type <code class="prettyprint">dynamic</code></li>
<li> <code class="prettyprint">t</code> has an accessible instance or extension method called <code class="prettyprint">GetAwaiter</code> with no parameters and no type parameters, and a return type <code class="prettyprint">A</code> for which all of the following hold:

<ul>
<li><code class="prettyprint">A</code> implements the interface <code class="prettyprint">System.Runtime.CompilerServices.INotifyCompletion</code> (hereafter known as <code class="prettyprint">INotifyCompletion</code> for brevity)</li>
<li><code class="prettyprint">A</code> has an accessible, readable instance property <code class="prettyprint">IsCompleted</code> of type <code class="prettyprint">bool</code></li>
<li><code class="prettyprint">A</code> has an accessible instance method <code class="prettyprint">GetResult</code> with no parameters and no type parameters</li>
</ul></li>
</ul>

<p>The purpose of the <code class="prettyprint">GetAwaiter</code> method is to obtain an <strong><em>awaiter</em></strong> for the task. The type <code class="prettyprint">A</code> is called the <strong><em>awaiter type</em></strong> for the await expression.</p>

<p>The purpose of the <code class="prettyprint">IsCompleted</code> property is to determine if the task is already complete. If so, there is no need to suspend evaluation.</p>

<p>The purpose of the <code class="prettyprint">INotifyCompletion.OnCompleted</code> method is to sign up a &ldquo;continuation&rdquo; to the task; i.e. a delegate (of type <code class="prettyprint">System.Action</code>) that will be invoked once the task is complete.</p>

<p>The purpose of the <code class="prettyprint">GetResult</code> method is to obtain the outcome of the task once it is complete. This outcome may be successful completion, possibly with a result value, or it may be an exception which is thrown by the <code class="prettyprint">GetResult</code> method.</p>

<h4 id="classification-of-await-expressions">Classification of await expressions</h4>

<p>The expression <code class="prettyprint">await t</code> is classified the same way as the expression <code class="prettyprint">(t).GetAwaiter().GetResult()</code>. Thus, if the return type of <code class="prettyprint">GetResult</code> is <code class="prettyprint">void</code>, the <em>await_expression</em> is classified as nothing. If it has a non-void return type <code class="prettyprint">T</code>, the <em>await_expression</em> is classified as a value of type <code class="prettyprint">T</code>.</p>

<h4 id="runtime-evaluation-of-await-expressions">Runtime evaluation of await expressions</h4>

<p>At runtime, the expression <code class="prettyprint">await t</code> is evaluated as follows:</p>

<ul>
<li> An awaiter <code class="prettyprint">a</code> is obtained by evaluating the expression <code class="prettyprint">(t).GetAwaiter()</code>.</li>
<li> A <code class="prettyprint">bool</code> <code class="prettyprint">b</code> is obtained by evaluating the expression <code class="prettyprint">(a).IsCompleted</code>.</li>
<li> If <code class="prettyprint">b</code> is <code class="prettyprint">false</code> then evaluation depends on whether <code class="prettyprint">a</code> implements the interface <code class="prettyprint">System.Runtime.CompilerServices.ICriticalNotifyCompletion</code> (hereafter known as <code class="prettyprint">ICriticalNotifyCompletion</code> for brevity). This check is done at binding time; i.e. at runtime if <code class="prettyprint">a</code> has the compile time type <code class="prettyprint">dynamic</code>, and at compile time otherwise. Let <code class="prettyprint">r</code> denote the resumption delegate (<a href="classes.md#iterators">Iterators</a>):

<ul>
<li>If <code class="prettyprint">a</code> does not implement <code class="prettyprint">ICriticalNotifyCompletion</code>, then the expression 
<code class="prettyprint">(a as (INotifyCompletion)).OnCompleted(r)</code> is evaluated.</li>
<li>If <code class="prettyprint">a</code> does implement <code class="prettyprint">ICriticalNotifyCompletion</code>, then the expression 
<code class="prettyprint">(a as (ICriticalNotifyCompletion)).UnsafeOnCompleted(r)</code> is evaluated.</li>
<li>Evaluation is then suspended, and control is returned to the current caller of the async function.</li>
</ul></li>
<li> Either immediately after (if <code class="prettyprint">b</code> was <code class="prettyprint">true</code>), or upon later invocation of the resumption delegate (if <code class="prettyprint">b</code> was <code class="prettyprint">false</code>), the expression <code class="prettyprint">(a).GetResult()</code> is evaluated. If it returns a value, that value is the result of the <em>await_expression</em>. Otherwise the result is nothing.</li>
</ul>

<p>An awaiter&rsquo;s implementation of the interface methods <code class="prettyprint">INotifyCompletion.OnCompleted</code> and <code class="prettyprint">ICriticalNotifyCompletion.UnsafeOnCompleted</code> should cause the delegate <code class="prettyprint">r</code> to be invoked at most once. Otherwise, the behavior of the enclosing async function is undefined.</p>

<h2 id="arithmetic-operators">Arithmetic operators</h2>

<p>The <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">+</code>, and <code class="prettyprint">-</code> operators are called the arithmetic operators.</p>
<pre class="highlight shell"><code>multiplicative_expression
    : unary_expression
    | multiplicative_expression <span class="s1">'*'</span> unary_expression
    | multiplicative_expression <span class="s1">'/'</span> unary_expression
    | multiplicative_expression <span class="s1">'%'</span> unary_expression
    ;

additive_expression
    : multiplicative_expression
    | additive_expression <span class="s1">'+'</span> multiplicative_expression
    | additive_expression <span class="s1">'-'</span> multiplicative_expression
    ;
</code></pre>
<p>If an operand of an arithmetic operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<h3 id="multiplication-operator">Multiplication operator</h3>

<p>For an operation of the form <code class="prettyprint">x * y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined multiplication operators are listed below. The operators all compute the product of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the product is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The product is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x * y</code>. If the result is too large for the destination type, <code class="prettyprint">z</code> is infinity. If the result is too small for the destination type, <code class="prettyprint">z</code> is zero.</p>

<p>|      |      |      |     |     |      |      |     |
   |:&mdash;-:|&mdash;&ndash;:|:&mdash;-:|:&mdash;:|:&mdash;:|:&mdash;-:|:&mdash;-:|:&mdash;-|
   |      | +y   | -y   | +0  | -0  | +inf | -inf | NaN | 
   | +x   | +z   | -z   | +0  | -0  | +inf | -inf | NaN | 
   | -x   | -z   | +z   | -0  | +0  | -inf | +inf | NaN | 
   | +0   | +0   | -0   | +0  | -0  | NaN  | NaN  | NaN | 
   | -0   | -0   | +0   | -0  | +0  | NaN  | NaN  | NaN | 
   | +inf | +inf | -inf | NaN | NaN | +inf | -inf | NaN | 
   | -inf | -inf | +inf | NaN | NaN | -inf | +inf | NaN | 
   | NaN  | NaN  | NaN  | NaN | NaN | NaN  | NaN  | NaN | </p>

<ul>
<li> Decimal multiplication:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">*(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. If the result value is too small to represent in the <code class="prettyprint">decimal</code> format, the result is zero. The scale of the result, before any rounding, is the sum of the scales of the two operands.</p>

<p>Decimal multiplication is equivalent to using the multiplication operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="division-operator">Division operator</h3>

<p>For an operation of the form <code class="prettyprint">x / y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined division operators are listed below. The operators all compute the quotient of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown.</p>

<p>The division rounds the result towards zero. Thus the absolute value of the result is the largest possible integer that is less than or equal to the absolute value of the quotient of the two operands. The result is zero or positive when the two operands have the same sign and zero or negative when the two operands have opposite signs.</p>

<p>If the left operand is the smallest representable <code class="prettyprint">int</code> or <code class="prettyprint">long</code> value and the right operand is <code class="prettyprint">-1</code>, an overflow occurs. In a <code class="prettyprint">checked</code> context, this causes a <code class="prettyprint">System.ArithmeticException</code> (or a subclass thereof) to be thrown. In an <code class="prettyprint">unchecked</code> context, it is implementation-defined as to whether a <code class="prettyprint">System.ArithmeticException</code> (or a subclass thereof) is thrown or the overflow goes unreported with the resulting value being that of the left operand.</p>

<ul>
<li> Floating-point division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The quotient is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x / y</code>. If the result is too large for the destination type, <code class="prettyprint">z</code> is infinity. If the result is too small for the destination type, <code class="prettyprint">z</code> is zero.</p>

<p>|      |      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | +y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | +z   | -z   | +inf | -inf | +0   | -0   | NaN  | 
   | -x   | -z   | +z   | -inf | +inf | -0   | +0   | NaN  | 
   | +0   | +0   | -0   | NaN  | NaN  | +0   | -0   | NaN  | 
   | -0   | -0   | +0   | NaN  | NaN  | -0   | +0   | NaN  | 
   | +inf | +inf | -inf | +inf | -inf | NaN  | NaN  | NaN  | 
   | -inf | -inf | +inf | -inf | +inf | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal division:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">/(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown. If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. If the result value is too small to represent in the <code class="prettyprint">decimal</code> format, the result is zero. The scale of the result is the smallest scale that will preserve a result equal to the nearest representantable decimal value to the true mathematical result.</p>

<p>Decimal division is equivalent to using the division operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="remainder-operator">Remainder operator</h3>

<p>For an operation of the form <code class="prettyprint">x % y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined remainder operators are listed below. The operators all compute the remainder of the division between <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<ul>
<li> Integer remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The result of <code class="prettyprint">x % y</code> is the value produced by <code class="prettyprint">x - (x / y) * y</code>. If <code class="prettyprint">y</code> is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown.</p>

<p>If the left operand is the smallest <code class="prettyprint">int</code> or <code class="prettyprint">long</code> value and the right operand is <code class="prettyprint">-1</code>, a <code class="prettyprint">System.OverflowException</code> is thrown. In no case does <code class="prettyprint">x % y</code> throw an exception where <code class="prettyprint">x / y</code> would not throw an exception.</p>

<ul>
<li> Floating-point remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are positive finite values. <code class="prettyprint">z</code> is the result of <code class="prettyprint">x % y</code> and is computed as <code class="prettyprint">x - n * y</code>, where <code class="prettyprint">n</code> is the largest possible integer that is less than or equal to <code class="prettyprint">x / y</code>. This method of computing the remainder is analogous to that used for integer operands, but differs from the IEEE 754 definition (in which <code class="prettyprint">n</code> is the integer closest to <code class="prettyprint">x / y</code>).</p>

<p>|      |      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | +y   | -y   | +0   | -0   | +inf | -inf | NaN  | 
   | +x   | +z   | +z   | NaN  | NaN  | x    | x    | NaN  | 
   | -x   | -z   | -z   | NaN  | NaN  | -x   | -x   | NaN  | 
   | +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  | 
   | -0   | -0   | -0   | NaN  | NaN  | -0   | -0   | NaN  | 
   | +inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | -inf | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal remainder:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">%(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the value of the right operand is zero, a <code class="prettyprint">System.DivideByZeroException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands, and the sign of the result, if non-zero, is the same as that of <code class="prettyprint">x</code>.</p>

<p>Decimal remainder is equivalent to using the remainder operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="addition-operator">Addition operator</h3>

<p>For an operation of the form <code class="prettyprint">x + y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined addition operators are listed below. For numeric and enumeration types, the predefined addition operators compute the sum of the two operands. When one or both operands are of type string, the predefined addition operators concatenate the string representation of the operands.</p>

<ul>
<li> Integer addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the sum is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The sum is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN&rsquo;s. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are nonzero finite values, and <code class="prettyprint">z</code> is the result of <code class="prettyprint">x + y</code>. If <code class="prettyprint">x</code> and <code class="prettyprint">y</code> have the same magnitude but opposite signs, <code class="prettyprint">z</code> is positive zero. If <code class="prettyprint">x + y</code> is too large to represent in the destination type, <code class="prettyprint">z</code> is an infinity with the same sign as <code class="prettyprint">x + y</code>.</p>

<p>|      |      |      |      |      |      |      |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|
   |      | y    | +0   | -0   | +inf | -inf | NaN  | 
   | x    | z    | x    | x    | +inf | -inf | NaN  | 
   | +0   | y    | +0   | +0   | +inf | -inf | NaN  | 
   | -0   | y    | +0   | -0   | +inf | -inf | NaN  | 
   | +inf | +inf | +inf | +inf | +inf | NaN  | NaN  | 
   | -inf | -inf | -inf | -inf | NaN  | -inf | NaN  | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | </p>

<ul>
<li> Decimal addition:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands.</p>

<p>Decimal addition is equivalent to using the addition operator of type <code class="prettyprint">System.Decimal</code>.</p>

<ul>
<li> Enumeration addition. Every enumeration type implicitly provides the following predefined operators, where <code class="prettyprint">E</code> is the enum type, and <code class="prettyprint">U</code> is the underlying type of <code class="prettyprint">E</code>:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">E</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">);</span>
   <span class="n">E</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">U</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>At run-time these operators are evaluated exactly as <code class="prettyprint">(E)((U)x + (U)y)</code>.</p>

<ul>
<li> String concatenation:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">object</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">string</span> <span class="k">operator</span> <span class="p">+(</span><span class="kt">object</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>These overloads of the binary <code class="prettyprint">+</code> operator perform string concatenation. If an operand of string concatenation is <code class="prettyprint">null</code>, an empty string is substituted. Otherwise, any non-string argument is converted to its string representation by invoking the virtual <code class="prettyprint">ToString</code> method inherited from type <code class="prettyprint">object</code>. If <code class="prettyprint">ToString</code> returns <code class="prettyprint">null</code>, an empty string is substituted.</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

   <span class="k">class</span> <span class="nc">Test</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
           <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"s = &gt;"</span> <span class="p">+</span> <span class="n">s</span> <span class="p">+</span> <span class="s">"&lt;"</span><span class="p">);</span>        <span class="c1">// displays s = &gt;&lt;</span>
           <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"i = "</span> <span class="p">+</span> <span class="n">i</span><span class="p">);</span>               <span class="c1">// displays i = 1</span>
           <span class="kt">float</span> <span class="n">f</span> <span class="p">=</span> <span class="m">1.2300E+15F</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"f = "</span> <span class="p">+</span> <span class="n">f</span><span class="p">);</span>               <span class="c1">// displays f = 1.23E+15</span>
           <span class="kt">decimal</span> <span class="n">d</span> <span class="p">=</span> <span class="m">2.900</span><span class="n">m</span><span class="p">;</span>
           <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"d = "</span> <span class="p">+</span> <span class="n">d</span><span class="p">);</span>               <span class="c1">// displays d = 2.900</span>
       <span class="p">}</span>
   <span class="p">}</span>
</code></pre>
<p>The result of the string concatenation operator is a string that consists of the characters of the left operand followed by the characters of the right operand. The string concatenation operator never returns a <code class="prettyprint">null</code> value. A <code class="prettyprint">System.OutOfMemoryException</code> may be thrown if there is not enough memory available to allocate the resulting string.</p>

<ul>
<li> Delegate combination. Every delegate type implicitly provides the following predefined operator, where <code class="prettyprint">D</code> is the delegate type:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">D</span> <span class="k">operator</span> <span class="p">+(</span><span class="n">D</span> <span class="n">x</span><span class="p">,</span> <span class="n">D</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The binary <code class="prettyprint">+</code> operator performs delegate combination when both operands are of some delegate type <code class="prettyprint">D</code>. (If the operands have different delegate types, a binding-time error occurs.) If the first operand is <code class="prettyprint">null</code>, the result of the operation is the value of the second operand (even if that is also <code class="prettyprint">null</code>). Otherwise, if the second operand is <code class="prettyprint">null</code>, then the result of the operation is the value of the first operand. Otherwise, the result of the operation is a new delegate instance that, when invoked, invokes the first operand and then invokes the second operand. For examples of delegate combination, see <a href="expressions.md#subtraction-operator">Subtraction operator</a> and <a href="delegates.md#delegate-invocation">Delegate invocation</a>. Since <code class="prettyprint">System.Delegate</code> is not a delegate type, <code class="prettyprint">operator</code> <code class="prettyprint">+</code> is not defined for it.</p>

<h3 id="subtraction-operator">Subtraction operator</h3>

<p>For an operation of the form <code class="prettyprint">x - y</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined subtraction operators are listed below. The operators all subtract <code class="prettyprint">y</code> from <code class="prettyprint">x</code>.</p>

<ul>
<li> Integer subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">long</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">ulong</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>In a <code class="prettyprint">checked</code> context, if the difference is outside the range of the result type, a <code class="prettyprint">System.OverflowException</code> is thrown. In an <code class="prettyprint">unchecked</code> context, overflows are not reported and any significant high-order bits outside the range of the result type are discarded.</p>

<ul>
<li> Floating-point subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">float</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
   <span class="kt">double</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The difference is computed according to the rules of IEEE 754 arithmetic. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaNs. In the table, <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are nonzero finite values, and <code class="prettyprint">z</code> is the result of <code class="prettyprint">x - y</code>. If <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are equal, <code class="prettyprint">z</code> is positive zero. If <code class="prettyprint">x - y</code> is too large to represent in the destination type, <code class="prettyprint">z</code> is an infinity with the same sign as <code class="prettyprint">x - y</code>.</p>

<p>|      |      |      |      |      |      |     |
   |:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;-:|:&mdash;:|
   | NaN  | y    | +0   | -0   | +inf | -inf | NaN | 
   | x    | z    | x    | x    | -inf | +inf | NaN | 
   | +0   | -y   | +0   | +0   | -inf | +inf | NaN | 
   | -0   | -y   | -0   | +0   | -inf | +inf | NaN | 
   | +inf | +inf | +inf | +inf | NaN  | +inf | NaN | 
   | -inf | -inf | -inf | -inf | -inf | NaN  | NaN | 
   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN | </p>

<ul>
<li> Decimal subtraction:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">decimal</span> <span class="k">operator</span> <span class="p">-(</span><span class="kt">decimal</span> <span class="n">x</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>If the resulting value is too large to represent in the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown. The scale of the result, before any rounding, is the larger of the scales of the two operands.</p>

<p>Decimal subtraction is equivalent to using the subtraction operator of type <code class="prettyprint">System.Decimal</code>.</p>

<ul>
<li> Enumeration subtraction. Every enumeration type implicitly provides the following predefined operator, where <code class="prettyprint">E</code> is the enum type, and <code class="prettyprint">U</code> is the underlying type of <code class="prettyprint">E</code>:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">U</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>This operator is evaluated exactly as <code class="prettyprint">(U)((U)x - (U)y)</code>. In other words, the operator computes the difference between the ordinal values of <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, and the type of the result is the underlying type of the enumeration.</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">E</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>This operator is evaluated exactly as <code class="prettyprint">(E)((U)x - y)</code>. In other words, the operator subtracts a value from the underlying type of the enumeration, yielding a value of the enumeration.</p>

<ul>
<li> Delegate removal. Every delegate type implicitly provides the following predefined operator, where <code class="prettyprint">D</code> is the delegate type:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="n">D</span> <span class="k">operator</span> <span class="p">-(</span><span class="n">D</span> <span class="n">x</span><span class="p">,</span> <span class="n">D</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The binary <code class="prettyprint">-</code> operator performs delegate removal when both operands are of some delegate type <code class="prettyprint">D</code>. If the operands have different delegate types, a binding-time error occurs. If the first operand is <code class="prettyprint">null</code>, the result of the operation is <code class="prettyprint">null</code>. Otherwise, if the second operand is <code class="prettyprint">null</code>, then the result of the operation is the value of the first operand. Otherwise, both operands represent invocation lists (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) having one or more entries, and the result is a new invocation list consisting of the first operand&rsquo;s list with the second operand&rsquo;s entries removed from it, provided the second operand&rsquo;s list is a proper contiguous sublist of the first&rsquo;s.     (To determine sublist equality, corresponding entries are compared as for the delegate equality operator (<a href="expressions.md#delegate-equality-operators">Delegate equality operators</a>).) Otherwise, the result is the value of the left operand. Neither of the operands&rsquo; lists is changed in the process. If the second operand&rsquo;s list matches multiple sublists of contiguous entries in the first operand&rsquo;s list, the right-most matching sublist of contiguous entries is removed. If removal results in an empty list, the result is <code class="prettyprint">null</code>. For example:</p>
<pre class="highlight csharp tab-csharp"><code>   <span class="k">delegate</span> <span class="k">void</span> <span class="nf">D</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

   <span class="k">class</span> <span class="nc">C</span>
   <span class="p">{</span>
       <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
       <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">M2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">class</span> <span class="nc">Test</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> 
           <span class="n">D</span> <span class="n">cd1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M1</span><span class="p">);</span>
           <span class="n">D</span> <span class="n">cd2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">D</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">M2</span><span class="p">);</span>
           <span class="n">D</span> <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>   <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span><span class="p">;</span>                      <span class="c1">// =&gt; M1 + M2 + M2</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>                <span class="c1">// =&gt; M2 + M1</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M1</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M2</span>

           <span class="n">cd3</span> <span class="p">=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd2</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>     <span class="c1">// M1 + M2 + M2 + M1</span>
           <span class="n">cd3</span> <span class="p">-=</span> <span class="n">cd1</span> <span class="p">+</span> <span class="n">cd1</span><span class="p">;</span>                <span class="c1">// =&gt; M1 + M2 + M2 + M1</span>
       <span class="p">}</span>
   <span class="p">}</span>
</code></pre>
<h2 id="shift-operators">Shift operators</h2>

<p>The <code class="prettyprint">&lt;&lt;</code> and <code class="prettyprint">&gt;&gt;</code> operators are used to perform bit shifting operations.</p>
<pre class="highlight shell"><code>shift_expression
    : additive_expression
    | shift_expression <span class="s1">'&lt;&lt;'</span> additive_expression
    | shift_expression right_shift additive_expression
    ;
</code></pre>
<p>If an operand of a <em>shift_expression</em> has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x &lt;&lt; count</code> or <code class="prettyprint">x &gt;&gt; count</code>, binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>When declaring an overloaded shift operator, the type of the first operand must always be the class or struct containing the operator declaration, and the type of the second operand must always be <code class="prettyprint">int</code>.</p>

<p>The predefined shift operators are listed below.</p>

<ul>
<li> Shift left:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">&lt;&lt;(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre>
<p>The <code class="prettyprint">&lt;&lt;</code> operator shifts <code class="prettyprint">x</code> left by a number of bits computed as described below.</p>

<p>The high-order bits outside the range of the result type of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted left, and the low-order empty bit positions are set to zero.</p>

<ul>
<li> Shift right:</li>
</ul>
<pre class="highlight csharp tab-csharp"><code>   <span class="kt">int</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">uint</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">long</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">long</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
   <span class="kt">ulong</span> <span class="k">operator</span> <span class="p">&gt;&gt;(</span><span class="kt">ulong</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre>
<p>The <code class="prettyprint">&gt;&gt;</code> operator shifts <code class="prettyprint">x</code> right by a number of bits computed as described below.</p>

<p>When <code class="prettyprint">x</code> is of type <code class="prettyprint">int</code> or <code class="prettyprint">long</code>, the low-order bits of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted right, and the high-order empty bit positions are set to zero if <code class="prettyprint">x</code> is non-negative and set to one if <code class="prettyprint">x</code> is negative.</p>

<p>When <code class="prettyprint">x</code> is of type <code class="prettyprint">uint</code> or <code class="prettyprint">ulong</code>, the low-order bits of <code class="prettyprint">x</code> are discarded, the remaining bits are shifted right, and the high-order empty bit positions are set to zero.</p>

<p>For the predefined operators, the number of bits to shift is computed as follows:</p>

<ul>
<li> When the type of <code class="prettyprint">x</code> is <code class="prettyprint">int</code> or <code class="prettyprint">uint</code>, the shift count is given by the low-order five bits of <code class="prettyprint">count</code>. In other words, the shift count is computed from <code class="prettyprint">count &amp; 0x1F</code>.</li>
<li> When the type of <code class="prettyprint">x</code> is <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code>, the shift count is given by the low-order six bits of <code class="prettyprint">count</code>. In other words, the shift count is computed from <code class="prettyprint">count &amp; 0x3F</code>.</li>
</ul>

<p>If the resulting shift count is zero, the shift operators simply return the value of <code class="prettyprint">x</code>.</p>

<p>Shift operations never cause overflows and produce the same results in <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> contexts.</p>

<p>When the left operand of the <code class="prettyprint">&gt;&gt;</code> operator is of a signed integral type, the operator performs an arithmetic shift right wherein the value of the most significant bit (the sign bit) of the operand is propagated to the high-order empty bit positions. When the left operand of the <code class="prettyprint">&gt;&gt;</code> operator is of an unsigned integral type, the operator performs a logical shift right wherein high-order empty bit positions are always set to zero. To perform the opposite operation of that inferred from the operand type, explicit casts can be used. For example, if <code class="prettyprint">x</code> is a variable of type <code class="prettyprint">int</code>, the operation <code class="prettyprint">unchecked((int)((uint)x &gt;&gt; y))</code> performs a logical shift right of <code class="prettyprint">x</code>.</p>

<h2 id="relational-and-type-testing-operators">Relational and type-testing operators</h2>

<p>The <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, <code class="prettyprint">&gt;=</code>, <code class="prettyprint">is</code> and <code class="prettyprint">as</code> operators are called the relational and type-testing operators.</p>
<pre class="highlight shell"><code>relational_expression
    : shift_expression
    | relational_expression <span class="s1">'&lt;'</span> shift_expression
    | relational_expression <span class="s1">'&gt;'</span> shift_expression
    | relational_expression <span class="s1">'&lt;='</span> shift_expression
    | relational_expression <span class="s1">'&gt;='</span> shift_expression
    | relational_expression <span class="s1">'is'</span> <span class="nb">type</span>
    | relational_expression <span class="s1">'as'</span> <span class="nb">type</span>
    ;

equality_expression
    : relational_expression
    | equality_expression <span class="s1">'=='</span> relational_expression
    | equality_expression <span class="s1">'!='</span> relational_expression
    ;
</code></pre>
<p>The <code class="prettyprint">is</code> operator is described in <a href="expressions.md#the-is-operator">The is operator</a> and the <code class="prettyprint">as</code> operator is described in <a href="expressions.md#the-as-operator">The as operator</a>.</p>

<p>The <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code> and <code class="prettyprint">&gt;=</code> operators are <strong><em>comparison operators</em></strong>.</p>

<p>If an operand of a comparison operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x</code> <em>op</em> <code class="prettyprint">y</code>, where <em>op</em> is a comparison operator, overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined comparison operators are described in the following sections. All predefined comparison operators return a result of type <code class="prettyprint">bool</code>, as described in the following table.</p>

<table><thead>
<tr>
<th><strong>Operation</strong></th>
<th><strong>Result</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">x == y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x != y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is not equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &lt; y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is less than <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &gt; y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is greater than <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &lt;= y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is less than or equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
<tr>
<td><code class="prettyprint">x &gt;= y</code></td>
<td><code class="prettyprint">true</code> if <code class="prettyprint">x</code> is greater than or equal to <code class="prettyprint">y</code>, <code class="prettyprint">false</code> otherwise</td>
</tr>
</tbody></table>

<h3 id="integer-comparison-operators">Integer comparison operators</h3>

<p>The predefined integer comparison operators are:
&ldquo;`csharp
bool operator ==(int x, int y);
bool operator ==(uint x, uint y);
bool operator ==(long x, long y);
bool operator ==(ulong x, ulong y);</p>

<p>bool operator !=(int x, int y);
bool operator !=(uint x, uint y);
bool operator !=(long x, long y);
bool operator !=(ulong x, ulong y);</p>

<p>bool operator &lt;(int x, int y);
bool operator &lt;(uint x, uint y);
bool operator &lt;(long x, long y);
bool operator &lt;(ulong x, ulong y);</p>

<p>bool operator &gt;(int x, int y);
bool operator &gt;(uint x, uint y);
bool operator &gt;(long x, long y);
bool operator &gt;(ulong x, ulong y);</p>

<p>bool operator &lt;=(int x, int y);
bool operator &lt;=(uint x, uint y);
bool operator &lt;=(long x, long y);
bool operator &lt;=(ulong x, ulong y);</p>

<p>bool operator &gt;=(int x, int y);
bool operator &gt;=(uint x, uint y);
bool operator &gt;=(long x, long y);
bool operator &gt;=(ulong x, ulong y);
&rdquo;`</p>

<p>Each of these operators compares the numeric values of the two integer operands and returns a <code class="prettyprint">bool</code> value that indicates whether the particular relation is <code class="prettyprint">true</code> or <code class="prettyprint">false</code>.</p>

<h3 id="floating-point-comparison-operators">Floating-point comparison operators</h3>

<p>The predefined floating-point comparison operators are:
&ldquo;`csharp
bool operator ==(float x, float y);
bool operator ==(double x, double y);</p>

<p>bool operator !=(float x, float y);
bool operator !=(double x, double y);</p>

<p>bool operator &lt;(float x, float y);
bool operator &lt;(double x, double y);</p>

<p>bool operator &gt;(float x, float y);
bool operator &gt;(double x, double y);</p>

<p>bool operator &lt;=(float x, float y);
bool operator &lt;=(double x, double y);</p>

<p>bool operator &gt;=(float x, float y);
bool operator &gt;=(double x, double y);
&rdquo;`</p>

<p>The operators compare the operands according to the rules of the IEEE 754 standard:</p>

<ul>
<li> If either operand is NaN, the result is <code class="prettyprint">false</code> for all operators except <code class="prettyprint">!=</code>, for which the result is <code class="prettyprint">true</code>. For any two operands, <code class="prettyprint">x != y</code> always produces the same result as <code class="prettyprint">!(x == y)</code>. However, when one or both operands are NaN, the <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">&gt;=</code> operators do not produce the same results as the logical negation of the opposite operator. For example, if either of <code class="prettyprint">x</code> and <code class="prettyprint">y</code> is NaN, then <code class="prettyprint">x &lt; y</code> is <code class="prettyprint">false</code>, but <code class="prettyprint">!(x &gt;= y)</code> is <code class="prettyprint">true</code>.</li>
<li> When neither operand is NaN, the operators compare the values of the two floating-point operands with respect to the ordering</li>
</ul>
<pre class="highlight shell"><code>   -inf &lt; -max &lt; ... &lt; -min &lt; -0.0 <span class="o">==</span> +0.0 &lt; +min &lt; ... &lt; +max &lt; +inf
</code></pre>
<p>where <code class="prettyprint">min</code> and <code class="prettyprint">max</code> are the smallest and largest positive finite values that can be represented in the given floating-point format. Notable effects of this ordering are:
   * Negative and positive zeros are considered equal.
   * A negative infinity is considered less than all other values, but equal to another negative infinity.
   * A positive infinity is considered greater than all other values, but equal to another positive infinity.</p>

<h3 id="decimal-comparison-operators">Decimal comparison operators</h3>

<p>The predefined decimal comparison operators are:
<code class="prettyprint">csharp
bool operator ==(decimal x, decimal y);
bool operator !=(decimal x, decimal y);
bool operator &lt;(decimal x, decimal y);
bool operator &gt;(decimal x, decimal y);
bool operator &lt;=(decimal x, decimal y);
bool operator &gt;=(decimal x, decimal y);
</code></p>

<p>Each of these operators compares the numeric values of the two decimal operands and returns a <code class="prettyprint">bool</code> value that indicates whether the particular relation is <code class="prettyprint">true</code> or <code class="prettyprint">false</code>. Each decimal comparison is equivalent to using the corresponding relational or equality operator of type <code class="prettyprint">System.Decimal</code>.</p>

<h3 id="boolean-equality-operators">Boolean equality operators</h3>

<p>The predefined boolean equality operators are:
<code class="prettyprint">csharp
bool operator ==(bool x, bool y);
bool operator !=(bool x, bool y);
</code></p>

<p>The result of <code class="prettyprint">==</code> is <code class="prettyprint">true</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code> or if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">false</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">!=</code> is <code class="prettyprint">false</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code> or if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">false</code>. Otherwise, the result is <code class="prettyprint">true</code>. When the operands are of type <code class="prettyprint">bool</code>, the <code class="prettyprint">!=</code> operator produces the same result as the <code class="prettyprint">^</code> operator.</p>

<h3 id="enumeration-comparison-operators">Enumeration comparison operators</h3>

<p>Every enumeration type implicitly provides the following predefined comparison operators:
<code class="prettyprint">csharp
bool operator ==(E x, E y);
bool operator !=(E x, E y);
bool operator &lt;(E x, E y);
bool operator &gt;(E x, E y);
bool operator &lt;=(E x, E y);
bool operator &gt;=(E x, E y);
</code></p>

<p>The result of evaluating <code class="prettyprint">x op y</code>, where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are expressions of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, and <code class="prettyprint">op</code> is one of the comparison operators, is exactly the same as evaluating <code class="prettyprint">((U)x) op ((U)y)</code>. In other words, the enumeration type comparison operators simply compare the underlying integral values of the two operands.</p>

<h3 id="reference-type-equality-operators">Reference type equality operators</h3>

<p>The predefined reference type equality operators are:
<code class="prettyprint">csharp
bool operator ==(object x, object y);
bool operator !=(object x, object y);
</code></p>

<p>The operators return the result of comparing the two references for equality or non-equality.</p>

<p>Since the predefined reference type equality operators accept operands of type <code class="prettyprint">object</code>, they apply to all types that do not declare applicable <code class="prettyprint">operator ==</code> and <code class="prettyprint">operator !=</code> members. Conversely, any applicable user-defined equality operators effectively hide the predefined reference type equality operators.</p>

<p>The predefined reference type equality operators require one of the following:</p>

<ul>
<li> Both operands are a value of a type known to be a <em>reference_type</em> or the literal <code class="prettyprint">null</code>. Furthermore, an explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from the type of either operand to the type of the other operand.</li>
<li> One operand is a value of type <code class="prettyprint">T</code> where <code class="prettyprint">T</code> is a <em>type_parameter</em> and the other operand is the literal <code class="prettyprint">null</code>. Furthermore <code class="prettyprint">T</code> does not have the value type constraint.</li>
</ul>

<p>Unless one of these conditions are true, a binding-time error occurs. Notable implications of these rules are:</p>

<ul>
<li> It is a binding-time error to use the predefined reference type equality operators to compare two references that are known to be different at binding-time. For example, if the binding-time types of the operands are two class types <code class="prettyprint">A</code> and <code class="prettyprint">B</code>, and if neither <code class="prettyprint">A</code> nor <code class="prettyprint">B</code> derives from the other, then it would be impossible for the two operands to reference the same object. Thus, the operation is considered a binding-time error.</li>
<li> The predefined reference type equality operators do not permit value type operands to be compared. Therefore, unless a struct type declares its own equality operators, it is not possible to compare values of that struct type.</li>
<li> The predefined reference type equality operators never cause boxing operations to occur for their operands. It would be meaningless to perform such boxing operations, since references to the newly allocated boxed instances would necessarily differ from all other references.</li>
<li> If an operand of a type parameter type <code class="prettyprint">T</code> is compared to <code class="prettyprint">null</code>, and the run-time type of <code class="prettyprint">T</code> is a value type, the result of the comparison is <code class="prettyprint">false</code>.</li>
</ul>

<p>The following example checks whether an argument of an unconstrained type parameter type is <code class="prettyprint">null</code>.
<code class="prettyprint">csharp
class C&lt;T&gt;
{
    void F(T x) {
        if (x == null) throw new ArgumentNullException();
        ...
    }
}
</code></p>

<p>The <code class="prettyprint">x == null</code> construct is permitted even though <code class="prettyprint">T</code> could represent a value type, and the result is simply defined to be <code class="prettyprint">false</code> when <code class="prettyprint">T</code> is a value type.</p>

<p>For an operation of the form <code class="prettyprint">x == y</code> or <code class="prettyprint">x != y</code>, if any applicable <code class="prettyprint">operator ==</code> or <code class="prettyprint">operator !=</code> exists, the operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) rules will select that operator instead of the predefined reference type equality operator. However, it is always possible to select the predefined reference type equality operator by explicitly casting one or both of the operands to type <code class="prettyprint">object</code>. The example
&ldquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        string s = &quot;Test&rdquo;;
        string t = string.Copy(s);
        Console.WriteLine(s == t);
        Console.WriteLine((object)s == t);
        Console.WriteLine(s == (object)t);
        Console.WriteLine((object)s == (object)t);
    }
}
<code class="prettyprint">
produces the output
</code>bash
True
False
False
False
&ldquo;`</p>

<p>The <code class="prettyprint">s</code> and <code class="prettyprint">t</code> variables refer to two distinct <code class="prettyprint">string</code> instances containing the same characters. The first comparison outputs <code class="prettyprint">True</code> because the predefined string equality operator (<a href="expressions.md#string-equality-operators">String equality operators</a>) is selected when both operands are of type <code class="prettyprint">string</code>. The remaining comparisons all output <code class="prettyprint">False</code> because the predefined reference type equality operator is selected when one or both of the operands are of type <code class="prettyprint">object</code>.</p>

<p>Note that the above technique is not meaningful for value types. The example
<code class="prettyprint">csharp
class Test
{
    static void Main() {
        int i = 123;
        int j = 123;
        System.Console.WriteLine((object)i == (object)j);
    }
}
</code>
outputs <code class="prettyprint">False</code> because the casts create references to two separate instances of boxed <code class="prettyprint">int</code> values.</p>

<h3 id="string-equality-operators">String equality operators</h3>

<p>The predefined string equality operators are:
<code class="prettyprint">csharp
bool operator ==(string x, string y);
bool operator !=(string x, string y);
</code></p>

<p>Two <code class="prettyprint">string</code> values are considered equal when one of the following is true:</p>

<ul>
<li> Both values are <code class="prettyprint">null</code>.</li>
<li> Both values are non-null references to string instances that have identical lengths and identical characters in each character position.</li>
</ul>

<p>The string equality operators compare string values rather than string references. When two separate string instances contain the exact same sequence of characters, the values of the strings are equal, but the references are different. As described in <a href="expressions.md#reference-type-equality-operators">Reference type equality operators</a>, the reference type equality operators can be used to compare string references instead of string values.</p>

<h3 id="delegate-equality-operators">Delegate equality operators</h3>

<p>Every delegate type implicitly provides the following predefined comparison operators:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">bool</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">x</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">x</span><span class="p">,</span> <span class="n">System</span><span class="p">.</span><span class="n">Delegate</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>Two delegate instances are considered equal as follows:</p>

<ul>
<li> If either of the delegate instances is <code class="prettyprint">null</code>, they are equal if and only if both are <code class="prettyprint">null</code>.</li>
<li> If the delegates have different run-time type they are never equal.</li>
<li> If both of the delegate instances have an invocation list (<a href="delegates.md#delegate-declarations">Delegate declarations</a>), those instances are equal if and only if their invocation lists are the same length, and each entry in one&rsquo;s invocation list is equal (as defined below) to the corresponding entry, in order, in the other&rsquo;s invocation list.</li>
</ul>

<p>The following rules govern the equality of invocation list entries:</p>

<ul>
<li> If two invocation list entries both refer to the same static method then the entries are equal.</li>
<li> If two invocation list entries both refer to the same non-static method on the same target object (as defined by the reference equality operators) then the entries are equal.</li>
<li> Invocation list entries produced from evaluation of semantically identical *anonymous_method_expression*s or *lambda_expression*s with the same (possibly empty) set of captured outer variable instances are permitted (but not required) to be equal.</li>
</ul>

<h3 id="equality-operators-and-null">Equality operators and null</h3>

<p>The <code class="prettyprint">==</code> and <code class="prettyprint">!=</code> operators permit one operand to be a value of a nullable type and the other to be the <code class="prettyprint">null</code> literal, even if no predefined or user-defined operator (in unlifted or lifted form) exists for the operation.</p>

<p>For an operation of one of the forms
<code class="prettyprint">csharp
x == null
null == x
x != null
null != x
</code>
where <code class="prettyprint">x</code> is an expression of a nullable type, if operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) fails to find an applicable operator, the result is instead computed from the <code class="prettyprint">HasValue</code> property of <code class="prettyprint">x</code>. Specifically, the first two forms are translated into <code class="prettyprint">!x.HasValue</code>, and last two forms are translated into <code class="prettyprint">x.HasValue</code>.</p>

<h3 id="the-is-operator">The is operator</h3>

<p>The <code class="prettyprint">is</code> operator is used to dynamically check if the run-time type of an object is compatible with a given type. The result of the operation <code class="prettyprint">E is T</code>, where <code class="prettyprint">E</code> is an expression and <code class="prettyprint">T</code> is a type, is a boolean value indicating whether <code class="prettyprint">E</code> can successfully be converted to type <code class="prettyprint">T</code> by a reference conversion, a boxing conversion, or an unboxing conversion. The operation is evaluated as follows, after type arguments have been substituted for all type parameters:</p>

<ul>
<li> If <code class="prettyprint">E</code> is an anonymous function, a compile-time error occurs</li>
<li> If <code class="prettyprint">E</code> is a method group or the <code class="prettyprint">null</code> literal, of if the type of <code class="prettyprint">E</code> is a reference type or a nullable type and the value of <code class="prettyprint">E</code> is null, the result is false.</li>
<li> Otherwise, let <code class="prettyprint">D</code> represent the dynamic type of <code class="prettyprint">E</code> as follows:

<ul>
<li>If the type of <code class="prettyprint">E</code> is a reference type, <code class="prettyprint">D</code> is the run-time type of the instance reference by <code class="prettyprint">E</code>.</li>
<li>If the type of <code class="prettyprint">E</code> is a nullable type, <code class="prettyprint">D</code> is the underlying type of that nullable type.</li>
<li>If the type of <code class="prettyprint">E</code> is a non-nullable value type, <code class="prettyprint">D</code> is the type of <code class="prettyprint">E</code>.</li>
</ul></li>
<li> The result of the operation depends on <code class="prettyprint">D</code> and <code class="prettyprint">T</code> as follows:

<ul>
<li>If <code class="prettyprint">T</code> is a reference type, the result is true if <code class="prettyprint">D</code> and <code class="prettyprint">T</code> are the same type, if <code class="prettyprint">D</code> is a reference type and an implicit reference conversion from <code class="prettyprint">D</code> to <code class="prettyprint">T</code> exists, or if <code class="prettyprint">D</code> is a value type and a boxing conversion from <code class="prettyprint">D</code> to <code class="prettyprint">T</code> exists.</li>
<li>If <code class="prettyprint">T</code> is a nullable type, the result is true if <code class="prettyprint">D</code> is the underlying type of <code class="prettyprint">T</code>.</li>
<li>If <code class="prettyprint">T</code> is a non-nullable value type, the result is true if <code class="prettyprint">D</code> and <code class="prettyprint">T</code> are the same type.</li>
<li>Otherwise, the result is false.</li>
</ul></li>
</ul>

<p>Note that user defined conversions, are not considered by the <code class="prettyprint">is</code> operator.</p>

<h3 id="the-as-operator">The as operator</h3>

<p>The <code class="prettyprint">as</code> operator is used to explicitly convert a value to a given reference type or nullable type. Unlike a cast expression (<a href="expressions.md#cast-expressions">Cast expressions</a>), the <code class="prettyprint">as</code> operator never throws an exception. Instead, if the indicated conversion is not possible, the resulting value is <code class="prettyprint">null</code>.</p>

<p>In an operation of the form <code class="prettyprint">E as T</code>, <code class="prettyprint">E</code> must be an expression and <code class="prettyprint">T</code> must be a reference type, a type parameter known to be a reference type, or a nullable type. Furthermore, at least one of the following must be true, or otherwise a compile-time error occurs:</p>

<ul>
<li> An identity (<a href="conversions.md#identity-conversion">Identity conversion</a>), implicit nullable (<a href="conversions.md#implicit-nullable-conversions">Implicit nullable conversions</a>), implicit reference (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>), boxing (<a href="conversions.md#boxing-conversions">Boxing conversions</a>), explicit nullable (<a href="conversions.md#explicit-nullable-conversions">Explicit nullable conversions</a>), explicit reference (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>), or unboxing (<a href="conversions.md#unboxing-conversions">Unboxing conversions</a>) conversion exists from <code class="prettyprint">E</code> to <code class="prettyprint">T</code>.</li>
<li> The type of <code class="prettyprint">E</code> or <code class="prettyprint">T</code> is an open type.</li>
<li> <code class="prettyprint">E</code> is the <code class="prettyprint">null</code> literal.</li>
</ul>

<p>If the compile-time type of <code class="prettyprint">E</code> is not <code class="prettyprint">dynamic</code>, the operation <code class="prettyprint">E as T</code> produces the same result as
<code class="prettyprint">csharp
E is T ? (T)(E) : (T)null
</code>
except that <code class="prettyprint">E</code> is only evaluated once. The compiler can be expected to optimize <code class="prettyprint">E as T</code> to perform at most one dynamic type check as opposed to the two dynamic type checks implied by the expansion above.</p>

<p>If the compile-time type of <code class="prettyprint">E</code> is <code class="prettyprint">dynamic</code>, unlike the cast operator the <code class="prettyprint">as</code> operator is not dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). Therefore the expansion in this case is:
<code class="prettyprint">csharp
E is T ? (T)(object)(E) : (T)null
</code></p>

<p>Note that some conversions, such as user defined conversions, are not possible with the <code class="prettyprint">as</code> operator and should instead be performed using cast expressions.</p>

<p>In the example
&rdquo;`csharp
class X
{</p>

<p>public string F(object o) {
        return o as string;        // OK, string is a reference type
    }</p>

<p>public T G<T>(object o) where T: Attribute {
        return o as T;             // Ok, T has a class constraint
    }</p>

<p>public U H<U>(object o) {
        return o as U;             // Error, U is unconstrained 
    }
}
&ldquo;<code class="prettyprint">
the type parameter</code>T<code class="prettyprint">of</code>G<code class="prettyprint">is known to be a reference type, because it has the class constraint. The type parameter</code>U<code class="prettyprint">of</code>H<code class="prettyprint">is not however; hence the use of the</code>as<code class="prettyprint">operator in</code>H` is disallowed.</p>

<h2 id="logical-operators">Logical operators</h2>

<p>The <code class="prettyprint">&amp;</code>, <code class="prettyprint">^</code>, and <code class="prettyprint">|</code> operators are called the logical operators.</p>
<pre class="highlight shell"><code>and_expression
    : equality_expression
    | and_expression <span class="s1">'&amp;'</span> equality_expression
    ;

exclusive_or_expression
    : and_expression
    | exclusive_or_expression <span class="s1">'^'</span> and_expression
    ;

inclusive_or_expression
    : exclusive_or_expression
    | inclusive_or_expression <span class="s1">'|'</span> exclusive_or_expression
    ;
</code></pre>
<p>If an operand of a logical operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>For an operation of the form <code class="prettyprint">x op y</code>, where <code class="prettyprint">op</code> is one of the logical operators, overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) is applied to select a specific operator implementation. The operands are converted to the parameter types of the selected operator, and the type of the result is the return type of the operator.</p>

<p>The predefined logical operators are described in the following sections.</p>

<h3 id="integer-logical-operators">Integer logical operators</h3>

<p>The predefined integer logical operators are:
&rdquo;`csharp
int operator &amp;(int x, int y);
uint operator &amp;(uint x, uint y);
long operator &amp;(long x, long y);
ulong operator &amp;(ulong x, ulong y);</p>

<p>int operator |(int x, int y);
uint operator |(uint x, uint y);
long operator |(long x, long y);
ulong operator |(ulong x, ulong y);</p>

<p>int operator ^(int x, int y);
uint operator ^(uint x, uint y);
long operator ^(long x, long y);
ulong operator ^(ulong x, ulong y);
&ldquo;`</p>

<p>The <code class="prettyprint">&amp;</code> operator computes the bitwise logical <code class="prettyprint">AND</code> of the two operands, the <code class="prettyprint">|</code> operator computes the bitwise logical <code class="prettyprint">OR</code> of the two operands, and the <code class="prettyprint">^</code> operator computes the bitwise logical exclusive <code class="prettyprint">OR</code> of the two operands. No overflows are possible from these operations.</p>

<h3 id="enumeration-logical-operators">Enumeration logical operators</h3>

<p>Every enumeration type <code class="prettyprint">E</code> implicitly provides the following predefined logical operators:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">E</span> <span class="k">operator</span> <span class="p">&amp;(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
<span class="n">E</span> <span class="k">operator</span> <span class="p">|(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
<span class="n">E</span> <span class="k">operator</span> <span class="p">^(</span><span class="n">E</span> <span class="n">x</span><span class="p">,</span> <span class="n">E</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The result of evaluating <code class="prettyprint">x op y</code>, where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are expressions of an enumeration type <code class="prettyprint">E</code> with an underlying type <code class="prettyprint">U</code>, and <code class="prettyprint">op</code> is one of the logical operators, is exactly the same as evaluating <code class="prettyprint">(E)((U)x op (U)y)</code>. In other words, the enumeration type logical operators simply perform the logical operation on the underlying type of the two operands.</p>

<h3 id="boolean-logical-operators">Boolean logical operators</h3>

<p>The predefined boolean logical operators are:
<code class="prettyprint">csharp
bool operator &amp;(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
</code></p>

<p>The result of <code class="prettyprint">x &amp; y</code> is <code class="prettyprint">true</code> if both <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">x | y</code> is <code class="prettyprint">true</code> if either <code class="prettyprint">x</code> or <code class="prettyprint">y</code> is <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>.</p>

<p>The result of <code class="prettyprint">x ^ y</code> is <code class="prettyprint">true</code> if <code class="prettyprint">x</code> is <code class="prettyprint">true</code> and <code class="prettyprint">y</code> is <code class="prettyprint">false</code>, or <code class="prettyprint">x</code> is <code class="prettyprint">false</code> and <code class="prettyprint">y</code> is <code class="prettyprint">true</code>. Otherwise, the result is <code class="prettyprint">false</code>. When the operands are of type <code class="prettyprint">bool</code>, the <code class="prettyprint">^</code> operator computes the same result as the <code class="prettyprint">!=</code> operator.</p>

<h3 id="nullable-boolean-logical-operators">Nullable boolean logical operators</h3>

<p>The nullable boolean type <code class="prettyprint">bool?</code> can represent three values, <code class="prettyprint">true</code>, <code class="prettyprint">false</code>, and <code class="prettyprint">null</code>, and is conceptually similar to the three-valued type used for boolean expressions in SQL. To ensure that the results produced by the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators for <code class="prettyprint">bool?</code> operands are consistent with SQL&rsquo;s three-valued logic, the following predefined operators are provided:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">bool</span><span class="p">?</span> <span class="k">operator</span> <span class="p">&amp;(</span><span class="kt">bool</span><span class="p">?</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span><span class="p">?</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">bool</span><span class="p">?</span> <span class="k">operator</span> <span class="p">|(</span><span class="kt">bool</span><span class="p">?</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span><span class="p">?</span> <span class="n">y</span><span class="p">);</span>
</code></pre>
<p>The following table lists the results produced by these operators for all combinations of the values <code class="prettyprint">true</code>, <code class="prettyprint">false</code>, and <code class="prettyprint">null</code>.</p>

<p>| <code class="prettyprint">x</code>     | <code class="prettyprint">y</code>     | <code class="prettyprint">x &amp; y</code> | <code class="prettyprint">x \| y</code>|
|:&mdash;&mdash;-:|:&mdash;&mdash;-:|:&mdash;&mdash;-:|:&mdash;&mdash;-:|
| <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">true</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">true</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | 
| <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">true</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">false</code> | <code class="prettyprint">false</code> | <code class="prettyprint">null</code>  | 
| <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | <code class="prettyprint">null</code>  | </p>

<h2 id="conditional-logical-operators">Conditional logical operators</h2>

<p>The <code class="prettyprint">&amp;&amp;</code> and <code class="prettyprint">||</code> operators are called the conditional logical operators. They are also called the &quot;short-circuiting&rdquo; logical operators.</p>
<pre class="highlight shell"><code>conditional_and_expression
    : inclusive_or_expression
    | conditional_and_expression <span class="s1">'&amp;&amp;'</span> inclusive_or_expression
    ;

conditional_or_expression
    : conditional_and_expression
    | conditional_or_expression <span class="s1">'||'</span> conditional_and_expression
    ;
</code></pre>
<p>The <code class="prettyprint">&amp;&amp;</code> and <code class="prettyprint">||</code> operators are conditional versions of the <code class="prettyprint">&amp;</code> and <code class="prettyprint">|</code> operators:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> corresponds to the operation <code class="prettyprint">x &amp; y</code>, except that <code class="prettyprint">y</code> is evaluated only if <code class="prettyprint">x</code> is not <code class="prettyprint">false</code>.</li>
<li> The operation <code class="prettyprint">x || y</code> corresponds to the operation <code class="prettyprint">x | y</code>, except that <code class="prettyprint">y</code> is evaluated only if <code class="prettyprint">x</code> is not <code class="prettyprint">true</code>.</li>
</ul>

<p>If an operand of a conditional logical operator has the compile-time type <code class="prettyprint">dynamic</code>, then the expression is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time using the run-time type of those operands that have the compile-time type <code class="prettyprint">dynamic</code>.</p>

<p>An operation of the form <code class="prettyprint">x &amp;&amp; y</code> or <code class="prettyprint">x || y</code> is processed by applying overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) as if the operation was written <code class="prettyprint">x &amp; y</code> or <code class="prettyprint">x | y</code>. Then,</p>

<ul>
<li> If overload resolution fails to find a single best operator, or if overload resolution selects one of the predefined integer logical operators, a binding-time error occurs.</li>
<li> Otherwise, if the selected operator is one of the predefined boolean logical operators (<a href="expressions.md#boolean-logical-operators">Boolean logical operators</a>) or nullable boolean logical operators (<a href="expressions.md#nullable-boolean-logical-operators">Nullable boolean logical operators</a>), the operation is processed as described in <a href="expressions.md#boolean-conditional-logical-operators">Boolean conditional logical operators</a>.</li>
<li> Otherwise, the selected operator is a user-defined operator, and the operation is processed as described in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a>.</li>
</ul>

<p>It is not possible to directly overload the conditional logical operators. However, because the conditional logical operators are evaluated in terms of the regular logical operators, overloads of the regular logical operators are, with certain restrictions, also considered overloads of the conditional logical operators. This is described further in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a>.</p>

<h3 id="boolean-conditional-logical-operators">Boolean conditional logical operators</h3>

<p>When the operands of <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> are of type <code class="prettyprint">bool</code>, or when the operands are of types that do not define an applicable <code class="prettyprint">operator &amp;</code> or <code class="prettyprint">operator |</code>, but do define implicit conversions to <code class="prettyprint">bool</code>, the operation is processed as follows:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> is evaluated as <code class="prettyprint">x ? y : false</code>. In other words, <code class="prettyprint">x</code> is first evaluated and converted to type <code class="prettyprint">bool</code>. Then, if <code class="prettyprint">x</code> is <code class="prettyprint">true</code>, <code class="prettyprint">y</code> is evaluated and converted to type <code class="prettyprint">bool</code>, and this becomes the result of the operation. Otherwise, the result of the operation is <code class="prettyprint">false</code>.</li>
<li> The operation <code class="prettyprint">x || y</code> is evaluated as <code class="prettyprint">x ? true : y</code>. In other words, <code class="prettyprint">x</code> is first evaluated and converted to type <code class="prettyprint">bool</code>. Then, if <code class="prettyprint">x</code> is <code class="prettyprint">true</code>, the result of the operation is <code class="prettyprint">true</code>. Otherwise, <code class="prettyprint">y</code> is evaluated and converted to type <code class="prettyprint">bool</code>, and this becomes the result of the operation.</li>
</ul>

<h3 id="user-defined-conditional-logical-operators">User-defined conditional logical operators</h3>

<p>When the operands of <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> are of types that declare an applicable user-defined <code class="prettyprint">operator &amp;</code> or <code class="prettyprint">operator |</code>, both of the following must be true, where <code class="prettyprint">T</code> is the type in which the selected operator is declared:</p>

<ul>
<li> The return type and the type of each parameter of the selected operator must be <code class="prettyprint">T</code>. In other words, the operator must compute the logical <code class="prettyprint">AND</code> or the logical <code class="prettyprint">OR</code> of two operands of type <code class="prettyprint">T</code>, and must return a result of type <code class="prettyprint">T</code>.</li>
<li> <code class="prettyprint">T</code> must contain declarations of <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>.</li>
</ul>

<p>A binding-time error occurs if either of these requirements is not satisfied. Otherwise, the <code class="prettyprint">&amp;&amp;</code> or <code class="prettyprint">||</code> operation is evaluated by combining the user-defined <code class="prettyprint">operator true</code> or <code class="prettyprint">operator false</code> with the selected user-defined operator:</p>

<ul>
<li> The operation <code class="prettyprint">x &amp;&amp; y</code> is evaluated as <code class="prettyprint">T.false(x) ? x : T.&amp;(x, y)</code>, where <code class="prettyprint">T.false(x)</code> is an invocation of the <code class="prettyprint">operator false</code> declared in <code class="prettyprint">T</code>, and <code class="prettyprint">T.&amp;(x, y)</code> is an invocation of the selected <code class="prettyprint">operator &amp;</code>. In other words, <code class="prettyprint">x</code> is first evaluated and <code class="prettyprint">operator false</code> is invoked on the result to determine if <code class="prettyprint">x</code> is definitely false. Then, if <code class="prettyprint">x</code> is definitely false, the result of the operation is the value previously computed for <code class="prettyprint">x</code>. Otherwise, <code class="prettyprint">y</code> is evaluated, and the selected <code class="prettyprint">operator &amp;</code> is invoked on the value previously computed for <code class="prettyprint">x</code> and the value computed for <code class="prettyprint">y</code> to produce the result of the operation.</li>
<li> The operation <code class="prettyprint">x || y</code> is evaluated as <code class="prettyprint">T.true(x) ? x : T.|(x, y)</code>, where <code class="prettyprint">T.true(x)</code> is an invocation of the <code class="prettyprint">operator true</code> declared in <code class="prettyprint">T</code>, and <code class="prettyprint">T.|(x,y)</code> is an invocation of the selected <code class="prettyprint">operator|</code>. In other words, <code class="prettyprint">x</code> is first evaluated and <code class="prettyprint">operator true</code> is invoked on the result to determine if <code class="prettyprint">x</code> is definitely true. Then, if <code class="prettyprint">x</code> is definitely true, the result of the operation is the value previously computed for <code class="prettyprint">x</code>. Otherwise, <code class="prettyprint">y</code> is evaluated, and the selected <code class="prettyprint">operator |</code> is invoked on the value previously computed for <code class="prettyprint">x</code> and the value computed for <code class="prettyprint">y</code> to produce the result of the operation.</li>
</ul>

<p>In either of these operations, the expression given by <code class="prettyprint">x</code> is only evaluated once, and the expression given by <code class="prettyprint">y</code> is either not evaluated or evaluated exactly once.</p>

<p>For an example of a type that implements <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>, see <a href="structs.md#database-boolean-type">Database boolean type</a>.</p>

<h2 id="the-null-coalescing-operator">The null coalescing operator</h2>

<p>The <code class="prettyprint">??</code> operator is called the null coalescing operator.</p>
<pre class="highlight shell"><code>null_coalescing_expression
    : conditional_or_expression
    | conditional_or_expression <span class="s1">'??'</span> null_coalescing_expression
    ;
</code></pre>
<p>A null coalescing expression of the form <code class="prettyprint">a ?? b</code> requires <code class="prettyprint">a</code> to be of a nullable type or reference type. If <code class="prettyprint">a</code> is non-null, the result of <code class="prettyprint">a ?? b</code> is <code class="prettyprint">a</code>; otherwise, the result is <code class="prettyprint">b</code>. The operation evaluates <code class="prettyprint">b</code> only if <code class="prettyprint">a</code> is null.</p>

<p>The null coalescing operator is right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a ?? b ?? c</code> is evaluated as <code class="prettyprint">a ?? (b ?? c)</code>. In general terms, an expression of the form <code class="prettyprint">E1 ?? E2 ?? ... ?? En</code> returns the first of the operands that is non-null, or null if all operands are null.</p>

<p>The type of the expression <code class="prettyprint">a ?? b</code> depends on which implicit conversions are available on the operands. In order of preference, the type of <code class="prettyprint">a ?? b</code> is <code class="prettyprint">A0</code>, <code class="prettyprint">A</code>, or <code class="prettyprint">B</code>, where <code class="prettyprint">A</code> is the type of <code class="prettyprint">a</code> (provided that <code class="prettyprint">a</code> has a type), <code class="prettyprint">B</code> is the type of <code class="prettyprint">b</code> (provided that <code class="prettyprint">b</code> has a type), and <code class="prettyprint">A0</code> is the underlying type of <code class="prettyprint">A</code> if <code class="prettyprint">A</code> is a nullable type, or <code class="prettyprint">A</code> otherwise. Specifically, <code class="prettyprint">a ?? b</code> is processed as follows:</p>

<ul>
<li> If <code class="prettyprint">A</code> exists and is not a nullable type or a reference type, a compile-time error occurs.</li>
<li> If <code class="prettyprint">b</code> is a dynamic expression, the result type is <code class="prettyprint">dynamic</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is converted to dynamic, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">A</code> exists and is a nullable type and an implicit conversion exists from <code class="prettyprint">b</code> to <code class="prettyprint">A0</code>, the result type is <code class="prettyprint">A0</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is unwrapped to type <code class="prettyprint">A0</code>, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and converted to type <code class="prettyprint">A0</code>, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">A</code> exists and an implicit conversion exists from <code class="prettyprint">b</code> to <code class="prettyprint">A</code>, the result type is <code class="prettyprint">A</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and converted to type <code class="prettyprint">A</code>, and this becomes the result.</li>
<li> Otherwise, if <code class="prettyprint">b</code> has a type <code class="prettyprint">B</code> and an implicit conversion exists from <code class="prettyprint">a</code> to <code class="prettyprint">B</code>, the result type is <code class="prettyprint">B</code>. At run-time, <code class="prettyprint">a</code> is first evaluated. If <code class="prettyprint">a</code> is not null, <code class="prettyprint">a</code> is unwrapped to type <code class="prettyprint">A0</code> (if <code class="prettyprint">A</code> exists and is nullable) and converted to type <code class="prettyprint">B</code>, and this becomes the result. Otherwise, <code class="prettyprint">b</code> is evaluated and becomes the result.</li>
<li> Otherwise, <code class="prettyprint">a</code> and <code class="prettyprint">b</code> are incompatible, and a compile-time error occurs.</li>
</ul>

<h2 id="conditional-operator">Conditional operator</h2>

<p>The <code class="prettyprint">?:</code> operator is called the conditional operator. It is at times also called the ternary operator.</p>
<pre class="highlight shell"><code>conditional_expression
    : null_coalescing_expression
    | null_coalescing_expression <span class="s1">'?'</span> expression <span class="s1">':'</span> expression
    ;
</code></pre>
<p>A conditional expression of the form <code class="prettyprint">b ? x : y</code> first evaluates the condition <code class="prettyprint">b</code>. Then, if <code class="prettyprint">b</code> is <code class="prettyprint">true</code>, <code class="prettyprint">x</code> is evaluated and becomes the result of the operation. Otherwise, <code class="prettyprint">y</code> is evaluated and becomes the result of the operation. A conditional expression never evaluates both <code class="prettyprint">x</code> and <code class="prettyprint">y</code>.</p>

<p>The conditional operator is right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a ? b : c ? d : e</code> is evaluated as <code class="prettyprint">a ? b : (c ? d : e)</code>.</p>

<p>The first operand of the <code class="prettyprint">?:</code> operator must be an expression that can be implicitly converted to <code class="prettyprint">bool</code>, or an expression of a type that implements <code class="prettyprint">operator true</code>. If neither of these requirements is satisfied, a compile-time error occurs.</p>

<p>The second and third operands, <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, of the <code class="prettyprint">?:</code> operator control the type of the conditional expression.</p>

<ul>
<li> If <code class="prettyprint">x</code> has type <code class="prettyprint">X</code> and <code class="prettyprint">y</code> has type <code class="prettyprint">Y</code> then

<ul>
<li>If an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from <code class="prettyprint">X</code> to <code class="prettyprint">Y</code>, but not from <code class="prettyprint">Y</code> to <code class="prettyprint">X</code>, then <code class="prettyprint">Y</code> is the type of the conditional expression.</li>
<li>If an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from <code class="prettyprint">Y</code> to <code class="prettyprint">X</code>, but not from <code class="prettyprint">X</code> to <code class="prettyprint">Y</code>, then <code class="prettyprint">X</code> is the type of the conditional expression.</li>
<li>Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul></li>
<li> If only one of <code class="prettyprint">x</code> and <code class="prettyprint">y</code> has a type, and both <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, of are implicitly convertible to that type, then that is the type of the conditional expression.</li>
<li> Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul>

<p>The run-time processing of a conditional expression of the form <code class="prettyprint">b ? x : y</code> consists of the following steps:</p>

<ul>
<li> First, <code class="prettyprint">b</code> is evaluated, and the <code class="prettyprint">bool</code> value of <code class="prettyprint">b</code> is determined:

<ul>
<li>If an implicit conversion from the type of <code class="prettyprint">b</code> to <code class="prettyprint">bool</code> exists, then this implicit conversion is performed to produce a <code class="prettyprint">bool</code> value.</li>
<li>Otherwise, the <code class="prettyprint">operator true</code> defined by the type of <code class="prettyprint">b</code> is invoked to produce a <code class="prettyprint">bool</code> value.</li>
</ul></li>
<li> If the <code class="prettyprint">bool</code> value produced by the step above is <code class="prettyprint">true</code>, then <code class="prettyprint">x</code> is evaluated and converted to the type of the conditional expression, and this becomes the result of the conditional expression.</li>
<li> Otherwise, <code class="prettyprint">y</code> is evaluated and converted to the type of the conditional expression, and this becomes the result of the conditional expression.</li>
</ul>

<h2 id="anonymous-function-expressions">Anonymous function expressions</h2>

<p>An <strong><em>anonymous function</em></strong> is an expression that represents an &ldquo;in-line&rdquo; method definition. An anonymous function does not have a value or type in and of itself, but is convertible to a compatible delegate or expression tree type. The evaluation of an anonymous function conversion depends on the target type of the conversion: If it is a delegate type, the conversion evaluates to a delegate value referencing the method which the anonymous function defines. If it is an expression tree type, the conversion evaluates to an expression tree which represents the structure of the method as an object structure.</p>

<p>For historical reasons there are two syntactic flavors of anonymous functions, namely *lambda_expression*s and *anonymous_method_expression*s. For almost all purposes, *lambda_expression*s are more concise and expressive than *anonymous_method_expression*s, which remain in the language for backwards compatibility.</p>
<pre class="highlight shell"><code>lambda_expression
    : anonymous_function_signature <span class="s1">'=&gt;'</span> anonymous_function_body
    ;

anonymous_method_expression
    : <span class="s1">'delegate'</span> explicit_anonymous_function_signature? block
    ;

anonymous_function_signature
    : explicit_anonymous_function_signature
    | implicit_anonymous_function_signature
    ;

explicit_anonymous_function_signature
    : <span class="s1">'('</span> explicit_anonymous_function_parameter_list? <span class="s1">')'</span>
    ;

explicit_anonymous_function_parameter_list
    : explicit_anonymous_function_parameter <span class="o">(</span><span class="s1">','</span> explicit_anonymous_function_parameter<span class="o">)</span><span class="k">*</span>
    ;

explicit_anonymous_function_parameter
    : anonymous_function_parameter_modifier? <span class="nb">type </span>identifier
    ;

anonymous_function_parameter_modifier
    : <span class="s1">'ref'</span>
    | <span class="s1">'out'</span>
    ;

implicit_anonymous_function_signature
    : <span class="s1">'('</span> implicit_anonymous_function_parameter_list? <span class="s1">')'</span>
    | implicit_anonymous_function_parameter
    ;

implicit_anonymous_function_parameter_list
    : implicit_anonymous_function_parameter <span class="o">(</span><span class="s1">','</span> implicit_anonymous_function_parameter<span class="o">)</span><span class="k">*</span>
    ;

implicit_anonymous_function_parameter
    : identifier
    ;

anonymous_function_body
    : expression
    | block
    ;
</code></pre>
<p>The <code class="prettyprint">=&gt;</code> operator has the same precedence as assignment (<code class="prettyprint">=</code>) and is right-associative.</p>

<p>An anonymous function with the <code class="prettyprint">async</code> modifier is an async function and follows the rules described in <a href="classes.md#iterators">Iterators</a>.</p>

<p>The parameters of an anonymous function in the form of a <em>lambda_expression</em> can be explicitly or implicitly typed. In an explicitly typed parameter list, the type of each parameter is explicitly stated. In an implicitly typed parameter list, the types of the parameters are inferred from the context in which the anonymous function occurs—specifically, when the anonymous function is converted to a compatible delegate type or expression tree type, that type provides the parameter types (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</p>

<p>In an anonymous function with a single, implicitly typed parameter, the parentheses may be omitted from the parameter list. In other words, an anonymous function of the form
<code class="prettyprint">csharp
( param ) =&gt; expr
</code>
can be abbreviated to
<code class="prettyprint">csharp
param =&gt; expr
</code></p>

<p>The parameter list of an anonymous function in the form of an <em>anonymous_method_expression</em> is optional. If given, the parameters must be explicitly typed. If not, the anonymous function is convertible to a delegate with any parameter list not containing <code class="prettyprint">out</code> parameters.</p>

<p>A <em>block</em> body of an anonymous function is reachable (<a href="statements.md#end-points-and-reachability">End points and reachability</a>) unless the anonymous function occurs inside an unreachable statement.</p>

<p>Some examples of anonymous functions follow below:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span>                              <span class="c1">// Implicitly typed, expression body</span>
<span class="n">x</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>                  <span class="c1">// Implicitly typed, statement body</span>
<span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span>                        <span class="c1">// Explicitly typed, expression body</span>
<span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>            <span class="c1">// Explicitly typed, statement body</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">*</span> <span class="n">y</span>                         <span class="c1">// Multiple parameters</span>
<span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">()</span>               <span class="c1">// No parameters</span>
<span class="k">async</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">await</span> <span class="n">t1</span> <span class="p">+</span> <span class="k">await</span> <span class="n">t2</span>    <span class="c1">// Async</span>
<span class="k">delegate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>      <span class="c1">// Anonymous method expression</span>
<span class="k">delegate</span> <span class="p">{</span> <span class="k">return</span> <span class="m">1</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="p">}</span>              <span class="c1">// Parameter list omitted</span>
</code></pre>
<p>The behavior of *lambda_expression*s and *anonymous_method_expression*s is the same except for the following points:</p>

<ul>
<li> *anonymous_method_expression*s permit the parameter list to be omitted entirely, yielding convertibility to delegate types of any list of value parameters.</li>
<li> *lambda_expression*s permit parameter types to be omitted and inferred whereas *anonymous_method_expression*s require parameter types to be explicitly stated.</li>
<li> The body of a <em>lambda_expression</em> can be an expression or a statement block whereas the body of an <em>anonymous_method_expression</em> must be a statement block.</li>
<li> Only *lambda_expression*s have conversions to compatible expression tree types (<a href="types.md#expression-tree-types">Expression tree types</a>).</li>
</ul>

<h3 id="anonymous-function-signatures">Anonymous function signatures</h3>

<p>The optional <em>anonymous_function_signature</em> of an anonymous function defines the names and optionally the types of the formal parameters for the anonymous function. The scope of the parameters of the anonymous function is the <em>anonymous_function_body</em>. (<a href="basic-concepts.md#scopes">Scopes</a>) Together with the parameter list (if given) the anonymous-method-body constitutes a declaration space (<a href="basic-concepts.md#declarations">Declarations</a>). It is thus a compile-time error for the name of a parameter of the anonymous function to match the name of a local variable, local constant or parameter whose scope includes the <em>anonymous_method_expression</em> or <em>lambda_expression</em>.</p>

<p>If an anonymous function has an <em>explicit_anonymous_function_signature</em>, then the set of compatible delegate types and expression tree types is restricted to those that have the same parameter types and modifiers in the same order. In contrast to method group conversions (<a href="conversions.md#method-group-conversions">Method group conversions</a>), contra-variance of anonymous function parameter types is not supported. If an anonymous function does not have an <em>anonymous_function_signature</em>, then the set of compatible delegate types and expression tree types is restricted to those that have no <code class="prettyprint">out</code> parameters.</p>

<p>Note that an <em>anonymous_function_signature</em> cannot include attributes or a parameter array. Nevertheless, an <em>anonymous_function_signature</em> may be compatible with a delegate type whose parameter list contains a parameter array.</p>

<p>Note also that conversion to an expression tree type, even if compatible, may still fail at compile-time (<a href="types.md#expression-tree-types">Expression tree types</a>).</p>

<h3 id="anonymous-function-bodies">Anonymous function bodies</h3>

<p>The body (<em>expression</em> or <em>block</em>) of an anonymous function is subject to the following rules:</p>

<ul>
<li> If the anonymous function includes a signature, the parameters specified in the signature are available in the body. If the anonymous function has no signature it can be converted to a delegate type or expression type having parameters (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>), but the parameters cannot be accessed in the body.</li>
<li> Except for <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters specified in the signature (if any) of the nearest enclosing anonymous function, it is a compile-time error for the body to access a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter.</li>
<li> When the type of <code class="prettyprint">this</code> is a struct type, it is a compile-time error for the body to access <code class="prettyprint">this</code>. This is true whether the access is explicit (as in <code class="prettyprint">this.x</code>) or implicit (as in <code class="prettyprint">x</code> where <code class="prettyprint">x</code> is an instance member of the struct). This rule simply prohibits such access and does not affect whether member lookup results in a member of the struct.</li>
<li> The body has access to the outer variables (<a href="expressions.md#outer-variables">Outer variables</a>) of the anonymous function. Access of an outer variable will reference the instance of the variable that is active at the time the <em>lambda_expression</em> or <em>anonymous_method_expression</em> is evaluated (<a href="expressions.md#evaluation-of-anonymous-function-expressions">Evaluation of anonymous function expressions</a>).</li>
<li> It is a compile-time error for the body to contain a <code class="prettyprint">goto</code> statement, <code class="prettyprint">break</code> statement, or <code class="prettyprint">continue</code> statement whose target is outside the body or within the body of a contained anonymous function.</li>
<li> A <code class="prettyprint">return</code> statement in the body returns control from an invocation of the nearest enclosing anonymous function, not from the enclosing function member. An expression specified in a <code class="prettyprint">return</code> statement must be implicitly convertible to the return type of the delegate type or expression tree type to which the nearest enclosing <em>lambda_expression</em> or <em>anonymous_method_expression</em> is converted (<a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>).</li>
</ul>

<p>It is explicitly unspecified whether there is any way to execute the block of an anonymous function other than through evaluation and invocation of the <em>lambda_expression</em> or <em>anonymous_method_expression</em>. In particular, the compiler may choose to implement an anonymous function by synthesizing one or more named methods or types. The names of any such synthesized elements must be of a form reserved for compiler use.</p>

<h3 id="overload-resolution-and-anonymous-functions">Overload resolution and anonymous functions</h3>

<p>Anonymous functions in an argument list participate in type inference and overload resolution. Please refer to <a href="expressions.md#type-inference">Type inference</a> and <a href="expressions.md#overload-resolution">Overload resolution</a> for the exact rules.</p>

<p>The following example illustrates the effect of anonymous functions on overload resolution.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">ItemList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="nf">Sum</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">item</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="n">sum</span> <span class="p">+=</span> <span class="nf">selector</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">double</span> <span class="nf">Sum</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">double</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">item</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="n">sum</span> <span class="p">+=</span> <span class="nf">selector</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">ItemList&lt;T&gt;</code> class has two <code class="prettyprint">Sum</code> methods. Each takes a <code class="prettyprint">selector</code> argument, which extracts the value to sum over from a list item. The extracted value can be either an <code class="prettyprint">int</code> or a <code class="prettyprint">double</code> and the resulting sum is likewise either an <code class="prettyprint">int</code> or a <code class="prettyprint">double</code>.</p>

<p>The <code class="prettyprint">Sum</code> methods could for example be used to compute sums from a list of detail lines in an order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Detail</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">UnitCount</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">UnitPrice</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">ComputeSums</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ItemList</span><span class="p">&lt;</span><span class="n">Detail</span><span class="p">&gt;</span> <span class="n">orderDetails</span> <span class="p">=</span> <span class="nf">GetOrderDetails</span><span class="p">(...);</span>
    <span class="kt">int</span> <span class="n">totalUnits</span> <span class="p">=</span> <span class="n">orderDetails</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitCount</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">orderTotal</span> <span class="p">=</span> <span class="n">orderDetails</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="n">d</span> <span class="p">=&gt;</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitPrice</span> <span class="p">*</span> <span class="n">d</span><span class="p">.</span><span class="n">UnitCount</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
<p>In the first invocation of <code class="prettyprint">orderDetails.Sum</code>, both <code class="prettyprint">Sum</code> methods are applicable because the anonymous function <code class="prettyprint">d =&gt; d. UnitCount</code> is compatible with both <code class="prettyprint">Func&lt;Detail,int&gt;</code> and <code class="prettyprint">Func&lt;Detail,double&gt;</code>. However, overload resolution picks the first <code class="prettyprint">Sum</code> method because the conversion to <code class="prettyprint">Func&lt;Detail,int&gt;</code> is better than the conversion to <code class="prettyprint">Func&lt;Detail,double&gt;</code>.</p>

<p>In the second invocation of <code class="prettyprint">orderDetails.Sum</code>, only the second <code class="prettyprint">Sum</code> method is applicable because the anonymous function <code class="prettyprint">d =&gt; d.UnitPrice * d.UnitCount</code> produces a value of type <code class="prettyprint">double</code>. Thus, overload resolution picks the second <code class="prettyprint">Sum</code> method for that invocation.</p>

<h3 id="anonymous-functions-and-dynamic-binding">Anonymous functions and dynamic binding</h3>

<p>An anonymous function cannot be a receiver, argument or operand of a dynamically bound operation.</p>

<h3 id="outer-variables">Outer variables</h3>

<p>Any local variable, value parameter, or parameter array whose scope includes the <em>lambda_expression</em> or <em>anonymous_method_expression</em> is called an <strong><em>outer variable</em></strong> of the anonymous function. In an instance function member of a class, the <code class="prettyprint">this</code> value is considered a value parameter and is an outer variable of any anonymous function contained within the function member.</p>

<h4 id="captured-outer-variables">Captured outer variables</h4>

<p>When an outer variable is referenced by an anonymous function, the outer variable is said to have been <strong><em>captured</em></strong> by the anonymous function. Ordinarily, the lifetime of a local variable is limited to execution of the block or statement with which it is associated (<a href="variables.md#local-variables">Local variables</a>). However, the lifetime of a captured outer variable is extended at least until the delegate or expression tree created from the anonymous function becomes eligible for garbage collection.</p>

<p>In the example
&ldquo;`csharp
using System;</p>

<p>delegate int D();</p>

<p>class Test
{
    static D F() {
        int x = 0;
        D result = () =&gt; ++x;
        return result;
    }</p>

<p>static void Main() {
        D d = F();
        Console.WriteLine(d());
        Console.WriteLine(d());
        Console.WriteLine(d());
    }
}
<code class="prettyprint">
the local variable `x` is captured by the anonymous function, and the lifetime of `x` is extended at least until the delegate returned from `F` becomes eligible for garbage collection (which doesn&#39;t happen until the very end of the program). Since each invocation of the anonymous function operates on the same instance of `x`, the output of the example is:
</code>bash
1
2
3
&rdquo;`</p>

<p>When a local variable or a value parameter is captured by an anonymous function, the local variable or parameter is no longer considered to be a fixed variable (<a href="unsafe-code.md#fixed-and-moveable-variables">Fixed and moveable variables</a>), but is instead considered to be a moveable variable. Thus any <code class="prettyprint">unsafe</code> code that takes the address of a captured outer variable must first use the <code class="prettyprint">fixed</code> statement to fix the variable.</p>

<p>Note that unlike an uncaptured variable, a captured local variable can be simultaneously exposed to multiple threads of execution.</p>

<h4 id="instantiation-of-local-variables">Instantiation of local variables</h4>

<p>A local variable is considered to be <strong><em>instantiated</em></strong> when execution enters the scope of the variable. For example, when the following method is invoked, the local variable <code class="prettyprint">x</code> is instantiated and initialized three times—once for each iteration of the loop.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="n">i</span> <span class="p">*</span> <span class="m">2</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>However, moving the declaration of <code class="prettyprint">x</code> outside the loop results in a single instantiation of <code class="prettyprint">x</code>:
<code class="prettyprint">csharp
static void F() {
    int x;
    for (int i = 0; i &lt; 3; i++) {
        x = i * 2 + 1;
        ...
    }
}
</code></p>

<p>When not captured, there is no way to observe exactly how often a local variable is instantiated—because the lifetimes of the instantiations are disjoint, it is possible for each instantation to simply use the same storage location. However, when an anonymous function captures a local variable, the effects of instantiation become apparent.</p>

<p>The example
&ldquo;`csharp
using System;</p>

<p>delegate void D();</p>

<p>class Test
{
    static D[] F() {
        D[] result = new D[3];
        for (int i = 0; i &lt; 3; i++) {
            int x = i * 2 + 1;
            result[i] = () =&gt; { Console.WriteLine(x); };
        }
        return result;
    }</p>

<p>static void Main() {
        foreach (D d in F()) d();
    }
}
<code class="prettyprint">
produces the output:
</code>bash
1
3
5
&rdquo;`</p>

<p>However, when the declaration of <code class="prettyprint">x</code> is moved outside the loop:
<code class="prettyprint">csharp
static D[] F() {
    D[] result = new D[3];
    int x;
    for (int i = 0; i &lt; 3; i++) {
        x = i * 2 + 1;
        result[i] = () =&gt; { Console.WriteLine(x); };
    }
    return result;
}
</code>
the output is:
<code class="prettyprint">bash
5
5
5
</code></p>

<p>If a for-loop declares an iteration variable, that variable itself is considered to be declared outside of the loop. Thus, if the example is changed to capture the iteration variable itself:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="n">D</span><span class="p">[]</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D</span><span class="p">[]</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>only one instance of the iteration variable is captured, which produces the output:
<code class="prettyprint">bash
3
3
3
</code></p>

<p>It is possible for anonymous function delegates to share some captured variables yet have separate instances of others. For example, if <code class="prettyprint">F</code> is changed to
<code class="prettyprint">csharp
static D[] F() {
    D[] result = new D[3];
    int x = 0;
    for (int i = 0; i &lt; 3; i++) {
        int y = 0;
        result[i] = () =&gt; { Console.WriteLine(&quot;{0} {1}&quot;, ++x, ++y); };
    }
    return result;
}
</code>
the three delegates capture the same instance of <code class="prettyprint">x</code> but separate instances of <code class="prettyprint">y</code>, and the output is:
<code class="prettyprint">bash
1 1
2 1
3 1
</code></p>

<p>Separate anonymous functions can capture the same instance of an outer variable. In the example:
&ldquo;`csharp
using System;</p>

<p>delegate void Setter(int value);</p>

<p>delegate int Getter();</p>

<p>class Test
{
    static void Main() {
        int x = 0;
        Setter s = (int value) =&gt; { x = value; };
        Getter g = () =&gt; { return x; };
        s(5);
        Console.WriteLine(g());
        s(10);
        Console.WriteLine(g());
    }
}
<code class="prettyprint">
the two anonymous functions capture the same instance of the local variable `x`, and they can thus &quot;communicate&quot; through that variable. The output of the example is:
</code>bash
5
10
&rdquo;`</p>

<h3 id="evaluation-of-anonymous-function-expressions">Evaluation of anonymous function expressions</h3>

<p>An anonymous function <code class="prettyprint">F</code> must always be converted to a delegate type <code class="prettyprint">D</code> or an expression tree type <code class="prettyprint">E</code>, either directly or through the execution of a delegate creation expression <code class="prettyprint">new D(F)</code>. This conversion determines the result of the anonymous function, as described in <a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>.</p>

<h2 id="query-expressions">Query expressions</h2>

<p><strong><em>Query expressions</em></strong> provide a language integrated syntax for queries that is similar to relational and hierarchical query languages such as SQL and XQuery.</p>
<pre class="highlight shell"><code>query_expression
    : from_clause query_body
    ;

from_clause
    : <span class="s1">'from'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression
    ;

query_body
    : query_body_clauses? select_or_group_clause query_continuation?
    ;

query_body_clauses
    : query_body_clause
    | query_body_clauses query_body_clause
    ;

query_body_clause
    : from_clause
    | let_clause
    | where_clause
    | join_clause
    | join_into_clause
    | orderby_clause
    ;

let_clause
    : <span class="s1">'let'</span> identifier <span class="s1">'='</span> expression
    ;

where_clause
    : <span class="s1">'where'</span> boolean_expression
    ;

join_clause
    : <span class="s1">'join'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression <span class="s1">'on'</span> expression <span class="s1">'equals'</span> expression
    ;

join_into_clause
    : <span class="s1">'join'</span> <span class="nb">type</span>? identifier <span class="s1">'in'</span> expression <span class="s1">'on'</span> expression <span class="s1">'equals'</span> expression <span class="s1">'into'</span> identifier
    ;

orderby_clause
    : <span class="s1">'orderby'</span> orderings
    ;

orderings
    : ordering <span class="o">(</span><span class="s1">','</span> ordering<span class="o">)</span><span class="k">*</span>
    ;

ordering
    : expression ordering_direction?
    ;

ordering_direction
    : <span class="s1">'ascending'</span>
    | <span class="s1">'descending'</span>
    ;

select_or_group_clause
    : select_clause
    | group_clause
    ;

select_clause
    : <span class="s1">'select'</span> expression
    ;

group_clause
    : <span class="s1">'group'</span> expression <span class="s1">'by'</span> expression
    ;

query_continuation
    : <span class="s1">'into'</span> identifier query_body
    ;
</code></pre>
<p>A query expression begins with a <code class="prettyprint">from</code> clause and ends with either a <code class="prettyprint">select</code> or <code class="prettyprint">group</code> clause. The initial <code class="prettyprint">from</code> clause can be followed by zero or more <code class="prettyprint">from</code>, <code class="prettyprint">let</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code> or <code class="prettyprint">orderby</code> clauses. Each <code class="prettyprint">from</code> clause is a generator introducing a <strong><em>range variable</em></strong> which ranges over the elements of a <strong><em>sequence</em></strong>. Each <code class="prettyprint">let</code> clause introduces a range variable representing a value computed by means of previous range variables. Each <code class="prettyprint">where</code> clause is a filter that excludes items from the result. Each <code class="prettyprint">join</code> clause compares specified keys of the source sequence with keys of another sequence, yielding matching pairs. Each <code class="prettyprint">orderby</code> clause reorders items according to specified criteria.The final <code class="prettyprint">select</code> or <code class="prettyprint">group</code> clause specifies the shape of the result in terms of the range variables. Finally, an <code class="prettyprint">into</code> clause can be used to &ldquo;splice&rdquo; queries by treating the results of one query as a generator in a subsequent query.</p>

<h3 id="ambiguities-in-query-expressions">Ambiguities in query expressions</h3>

<p>Query expressions contain a number of &ldquo;contextual keywords&rdquo;, i.e., identifiers that have special meaning in a given context. Specifically these are <code class="prettyprint">from</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code>, <code class="prettyprint">on</code>, <code class="prettyprint">equals</code>, <code class="prettyprint">into</code>, <code class="prettyprint">let</code>, <code class="prettyprint">orderby</code>, <code class="prettyprint">ascending</code>, <code class="prettyprint">descending</code>, <code class="prettyprint">select</code>, <code class="prettyprint">group</code> and <code class="prettyprint">by</code>. In order to avoid ambiguities in query expressions caused by mixed use of these identifiers as keywords or simple names, these identifiers are considered keywords when occurring anywhere within a query expression.</p>

<p>For this purpose, a query expression is any expression that starts with &ldquo;<code class="prettyprint">from dentifier</code>&rdquo; followed by any token except &ldquo;<code class="prettyprint">;</code>&rdquo;, &ldquo;<code class="prettyprint">=</code>&rdquo; or &ldquo;<code class="prettyprint">,</code>&rdquo;.</p>

<p>In order to use these words as identifiers within a query expression, they can be prefixed with &ldquo;<code class="prettyprint">@</code>&rdquo; (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<h3 id="query-expression-translation">Query expression translation</h3>

<p>The C# language does not specify the execution semantics of query expressions. Rather, query expressions are translated into invocations of methods that adhere to the <em>query expression pattern</em> (<a href="expressions.md#the-query-expression-pattern">The query expression pattern</a>). Specifically, query expressions are translated into invocations of methods named <code class="prettyprint">Where</code>, <code class="prettyprint">Select</code>, <code class="prettyprint">SelectMany</code>, <code class="prettyprint">Join</code>, <code class="prettyprint">GroupJoin</code>, <code class="prettyprint">OrderBy</code>, <code class="prettyprint">OrderByDescending</code>, <code class="prettyprint">ThenBy</code>, <code class="prettyprint">ThenByDescending</code>, <code class="prettyprint">GroupBy</code>, and <code class="prettyprint">Cast</code>.These methods are expected to have particular signatures and result types, as described in <a href="expressions.md#the-query-expression-pattern">The query expression pattern</a>. These methods can be instance methods of the object being queried or extension methods that are external to the object, and they implement the actual execution of the query.</p>

<p>The translation from query expressions to method invocations is a syntactic mapping that occurs before any type binding or overload resolution has been performed. The translation is guaranteed to be syntactically correct, but it is not guaranteed to produce semantically correct C# code. Following translation of query expressions, the resulting method invocations are processed as regular method invocations, and this may in turn uncover errors, for example if the methods do not exist, if arguments have wrong types, or if the methods are generic and type inference fails.</p>

<p>A query expression is processed by repeatedly applying the following translations until no further reductions are possible. The translations are listed in order of application: each section assumes that the translations in the preceding sections have been performed exhaustively, and once exhausted, a section will not later be revisited in the processing of the same query expression.</p>

<p>Assignment to range variables is not allowed in query expressions. However a C# implementation is permitted to not always enforce this restriction, since this may sometimes not be possible with the syntactic translation scheme presented here.</p>

<p>Certain translations inject range variables with transparent identifiers denoted by <code class="prettyprint">*</code>. The special properties of transparent identifiers are discussed further in <a href="expressions.md#transparent-identifiers">Transparent identifiers</a>.</p>

<h4 id="select-and-groupby-clauses-with-continuations">Select and groupby clauses with continuations</h4>

<p>A query expression with a continuation
<code class="prettyprint">csharp
from ... into x ...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( from ... ) ...
</code></p>

<p>The translations in the following sections assume that queries have no <code class="prettyprint">into</code> continuations.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
group c by c.Country into g
select new { Country = g.Key, CustCount = g.Count() }
</code>
is translated into
<code class="prettyprint">csharp
from g in
    from c in customers
    group c by c.Country
select new { Country = g.Key, CustCount = g.Count() }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
GroupBy(c =&gt; c.Country).
Select(g =&gt; new { Country = g.Key, CustCount = g.Count() })
</code></p>

<h4 id="explicit-range-variable-types">Explicit range variable types</h4>

<p>A <code class="prettyprint">from</code> clause that explicitly specifies a range variable type
<code class="prettyprint">csharp
from T x in e
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . Cast &lt; T &gt; ( )
</code></p>

<p>A <code class="prettyprint">join</code> clause that explicitly specifies a range variable type
<code class="prettyprint">bash
join T x in e on k1 equals k2
</code>
is translated into
<code class="prettyprint">bash
join x in ( e ) . Cast &lt; T &gt; ( ) on k1 equals k2
</code></p>

<p>The translations in the following sections assume that queries have no explicit range variable types.</p>

<p>The example
<code class="prettyprint">csharp
from Customer c in customers
where c.City == &quot;London&quot;
select c
</code>
is translated into
<code class="prettyprint">csharp
from c in customers.Cast&lt;Customer&gt;()
where c.City == &quot;London&quot;
select c
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
Cast&lt;Customer&gt;().
Where(c =&gt; c.City == &quot;London&quot;)
</code></p>

<p>Explicit range variable types are useful for querying collections that implement the non-generic <code class="prettyprint">IEnumerable</code> interface, but not the generic <code class="prettyprint">IEnumerable&lt;T&gt;</code> interface. In the example above, this would be the case if <code class="prettyprint">customers</code> were of type <code class="prettyprint">ArrayList</code>.</p>

<h4 id="degenerate-query-expressions">Degenerate query expressions</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e select x
</code>
is translated into
<code class="prettyprint">csharp
( e ) . Select ( x =&gt; x )
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
select c
</code>
is translated into
<code class="prettyprint">csharp
customers.Select(c =&gt; c)
</code></p>

<p>A degenerate query expression is one that trivially selects the elements of the source. A later phase of the translation removes degenerate queries introduced by other translation steps by replacing them with their source. It is important however to ensure that the result of a query expression is never the source object itself, as that would reveal the type and identity of the source to the client of the query. Therefore this step protects degenerate queries written directly in source code by explicitly calling <code class="prettyprint">Select</code> on the source. It is then up to the implementers of <code class="prettyprint">Select</code> and other query operators to ensure that these methods never return the source object itself.</p>

<h4 id="from-let-where-join-and-orderby-clauses">From, let, where, join and orderby clauses</h4>

<p>A query expression with a second <code class="prettyprint">from</code> clause followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
from x2 in e2
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . SelectMany( x1 =&gt; e2 , ( x1 , x2 ) =&gt; v )
</code></p>

<p>A query expression with a second <code class="prettyprint">from</code> clause followed by something other than a <code class="prettyprint">select</code> clause:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">from</span> <span class="n">x1</span> <span class="k">in</span> <span class="n">e1</span>
<span class="k">from</span> <span class="n">x2</span> <span class="k">in</span> <span class="n">e2</span>
<span class="p">...</span>
</code></pre>
<p>is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . SelectMany( x1 =&gt; e2 , ( x1 , x2 ) =&gt; new { x1 , x2 } )
...
</code></p>

<p>A query expression with a <code class="prettyprint">let</code> clause
<code class="prettyprint">csharp
from x in e
let y = f
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e ) . Select ( x =&gt; new { x , y = f } )
...
</code></p>

<p>A query expression with a <code class="prettyprint">where</code> clause
<code class="prettyprint">csharp
from x in e
where f
...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . Where ( x =&gt; f )
...
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause without an <code class="prettyprint">into</code> followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . Join( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , x2 ) =&gt; v )
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause without an <code class="prettyprint">into</code> followed by something other than a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . Join( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , x2 ) =&gt; new { x1 , x2 })
...
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause with an <code class="prettyprint">into</code> followed by a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
select v
</code>
is translated into
<code class="prettyprint">csharp
( e1 ) . GroupJoin( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , g ) =&gt; v )
</code></p>

<p>A query expression with a <code class="prettyprint">join</code> clause with an <code class="prettyprint">into</code> followed by something other than a <code class="prettyprint">select</code> clause
<code class="prettyprint">csharp
from x1 in e1
join x2 in e2 on k1 equals k2 into g
...
</code>
is translated into
<code class="prettyprint">csharp
from * in ( e1 ) . GroupJoin( e2 , x1 =&gt; k1 , x2 =&gt; k2 , ( x1 , g ) =&gt; new { x1 , g })
...
</code></p>

<p>A query expression with an <code class="prettyprint">orderby</code> clause
<code class="prettyprint">csharp
from x in e
orderby k1 , k2 , ..., kn
...
</code>
is translated into
<code class="prettyprint">csharp
from x in ( e ) . 
OrderBy ( x =&gt; k1 ) . 
ThenBy ( x =&gt; k2 ) .
... .
ThenBy ( x =&gt; kn )
...
</code></p>

<p>If an ordering clause specifies a <code class="prettyprint">descending</code> direction indicator, an invocation of <code class="prettyprint">OrderByDescending</code> or <code class="prettyprint">ThenByDescending</code> is produced instead.</p>

<p>The following translations assume that there are no <code class="prettyprint">let</code>, <code class="prettyprint">where</code>, <code class="prettyprint">join</code> or <code class="prettyprint">orderby</code> clauses, and no more than the one initial <code class="prettyprint">from</code> clause in each query expression.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
select new { c.Name, o.OrderID, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders,
     (c,o) =&gt; new { c.Name, o.OrderID, o.Total }
)
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.OrderID, o.Total }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(x =&gt; x.o.Total).
Select(x =&gt; new { x.c.Name, x.o.OrderID, x.o.Total })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from o in orders
let t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity)
where t &gt;= 1000
select new { o.OrderID, Total = t }
</code>
is translated into
<code class="prettyprint">csharp
from * in orders.
    Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) })
where t &gt;= 1000 
select new { o.OrderID, Total = t }
</code>
the final translation of which is
<code class="prettyprint">csharp
orders.
Select(o =&gt; new { o, t = o.Details.Sum(d =&gt; d.UnitPrice * d.Quantity) }).
Where(x =&gt; x.t &gt;= 1000).
Select(x =&gt; new { x.o.OrderID, Total = x.t })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
select new { c.Name, o.OrderDate, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
customers.Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, o) =&gt; new { c.Name, o.OrderDate, o.Total })
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID into co
let n = co.Count()
where n &gt;= 10
select new { c.Name, OrderCount = n }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    GroupJoin(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
        (c, co) =&gt; new { c, co })
let n = co.Count()
where n &gt;= 10 
select new { c.Name, OrderCount = n }
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
GroupJoin(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, co) =&gt; new { c, co }).
Select(x =&gt; new { x, n = x.co.Count() }).
Where(y =&gt; y.n &gt;= 10).
Select(y =&gt; new { y.x.c.Name, OrderCount = y.n)
</code>
where <code class="prettyprint">x</code> and <code class="prettyprint">y</code> are compiler generated identifiers that are otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from o in orders
orderby o.Customer.Name, o.Total descending
select o
</code>
has the final translation
<code class="prettyprint">csharp
orders.
OrderBy(o =&gt; o.Customer.Name).
ThenByDescending(o =&gt; o.Total)
</code></p>

<h4 id="select-clauses">Select clauses</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e select v
</code>
is translated into
<code class="prettyprint">csharp
( e ) . Select ( x =&gt; v )
</code>
except when v is the identifier x, the translation is simply
<code class="prettyprint">csharp
( e )
</code></p>

<p>For example
<code class="prettyprint">csharp
from c in customers.Where(c =&gt; c.City == &quot;London&quot;)
select c
</code>
is simply translated into
<code class="prettyprint">csharp
customers.Where(c =&gt; c.City == &quot;London&quot;)
</code></p>

<h4 id="groupby-clauses">Groupby clauses</h4>

<p>A query expression of the form
<code class="prettyprint">csharp
from x in e group v by k
</code>
is translated into
<code class="prettyprint">csharp
( e ) . GroupBy ( x =&gt; k , x =&gt; v )
</code>
except when v is the identifier x, the translation is
<code class="prettyprint">csharp
( e ) . GroupBy ( x =&gt; k )
</code></p>

<p>The example
<code class="prettyprint">csharp
from c in customers
group c.Name by c.Country
</code>
is translated into
<code class="prettyprint">csharp
customers.
GroupBy(c =&gt; c.Country, c =&gt; c.Name)
</code></p>

<h4 id="transparent-identifiers">Transparent identifiers</h4>

<p>Certain translations inject range variables with <strong><em>transparent identifiers</em></strong> denoted by <code class="prettyprint">*</code>. Transparent identifiers are not a proper language feature; they exist only as an intermediate step in the query expression translation process.</p>

<p>When a query translation injects a transparent identifier, further translation steps propagate the transparent identifier into anonymous functions and anonymous object initializers. In those contexts, transparent identifiers have the following behavior:</p>

<ul>
<li> When a transparent identifier occurs as a parameter in an anonymous function, the members of the associated anonymous type are automatically in scope in the body of the anonymous function.</li>
<li> When a member with a transparent identifier is in scope, the members of that member are in scope as well.</li>
<li> When a transparent identifier occurs as a member declarator in an anonymous object initializer, it introduces a member with a transparent identifier.</li>
<li> In the translation steps described above, transparent identifiers are always introduced together with anonymous types, with the intent of capturing multiple range variables as members of a single object. An implementation of C# is permitted to use a different mechanism than anonymous types to group together multiple range variables. The following translation examples assume that anonymous types are used, and show how transparent identifiers can be translated away.</li>
</ul>

<p>The example
<code class="prettyprint">csharp
from c in customers
from o in c.Orders
orderby o.Total descending
select new { c.Name, o.Total }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o })
orderby o.Total descending
select new { c.Name, o.Total }
</code></p>

<p>which is further translated into
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(* =&gt; o.Total).
Select(* =&gt; new { c.Name, o.Total })
</code>
which, when transparent identifiers are erased, is equivalent to
<code class="prettyprint">csharp
customers.
SelectMany(c =&gt; c.Orders, (c,o) =&gt; new { c, o }).
OrderByDescending(x =&gt; x.o.Total).
Select(x =&gt; new { x.c.Name, x.o.Total })
</code>
where <code class="prettyprint">x</code> is a compiler generated identifier that is otherwise invisible and inaccessible.</p>

<p>The example
<code class="prettyprint">csharp
from c in customers
join o in orders on c.CustomerID equals o.CustomerID
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
</code>
is translated into
<code class="prettyprint">csharp
from * in customers.
    Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID, 
        (c, o) =&gt; new { c, o })
join d in details on o.OrderID equals d.OrderID
join p in products on d.ProductID equals p.ProductID
select new { c.Name, o.OrderDate, p.ProductName }
</code>
which is further reduced to
<code class="prettyprint">csharp
customers.
Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID, (c, o) =&gt; new { c, o }).
Join(details, * =&gt; o.OrderID, d =&gt; d.OrderID, (*, d) =&gt; new { *, d }).
Join(products, * =&gt; d.ProductID, p =&gt; p.ProductID, (*, p) =&gt; new { *, p }).
Select(* =&gt; new { c.Name, o.OrderDate, p.ProductName })
</code>
the final translation of which is
<code class="prettyprint">csharp
customers.
Join(orders, c =&gt; c.CustomerID, o =&gt; o.CustomerID,
    (c, o) =&gt; new { c, o }).
Join(details, x =&gt; x.o.OrderID, d =&gt; d.OrderID,
    (x, d) =&gt; new { x, d }).
Join(products, y =&gt; y.d.ProductID, p =&gt; p.ProductID,
    (y, p) =&gt; new { y, p }).
Select(z =&gt; new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName })
</code>
where <code class="prettyprint">x</code>, <code class="prettyprint">y</code>, and <code class="prettyprint">z</code> are compiler generated identifiers that are otherwise invisible and inaccessible.</p>

<h3 id="the-query-expression-pattern">The query expression pattern</h3>

<p>The <strong><em>Query expression pattern</em></strong> establishes a pattern of methods that types can implement to support query expressions. Because query expressions are translated to method invocations by means of a syntactic mapping, types have considerable flexibility in how they implement the query expression pattern. For example, the methods of the pattern can be implemented as instance methods or as extension methods because the two have the same invocation syntax, and the methods can request delegates or expression trees because anonymous functions are convertible to both.</p>

<p>The recommended shape of a generic type <code class="prettyprint">C&lt;T&gt;</code> that supports the query expression pattern is shown below. A generic type is used in order to illustrate the proper relationships between parameter and result types, but it is possible to implement the pattern for non-generic types as well.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">delegate</span> <span class="n">R</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">arg1</span><span class="p">);</span>

<span class="k">delegate</span> <span class="n">R</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">,</span><span class="n">R</span><span class="p">&gt;(</span><span class="n">T1</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">arg2</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Cast</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">Where</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">predicate</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">Select</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">SelectMany</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;&gt;</span> <span class="n">selector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">Join</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">inner</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">outerKeySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">innerKeySelector</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">GroupJoin</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="p">&gt;(</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span> <span class="n">inner</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">outerKeySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">innerKeySelector</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">C</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;,</span><span class="n">V</span><span class="p">&gt;</span> <span class="n">resultSelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">OrderBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">OrderByDescending</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">GroupBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;&gt;</span> <span class="n">GroupBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">,</span>
        <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">E</span><span class="p">&gt;</span> <span class="n">elementSelector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ThenBy</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>

    <span class="k">public</span> <span class="n">O</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ThenByDescending</span><span class="p">&lt;</span><span class="n">K</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">K</span><span class="p">&gt;</span> <span class="n">keySelector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">G</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">C</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">K</span> <span class="n">Key</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The methods above use the generic delegate types <code class="prettyprint">Func&lt;T1,R&gt;</code> and <code class="prettyprint">Func&lt;T1,T2,R&gt;</code>, but they could equally well have used other delegate or expression tree types with the same relationships in parameter and result types.</p>

<p>Notice the recommended relationship between <code class="prettyprint">C&lt;T&gt;</code> and <code class="prettyprint">O&lt;T&gt;</code> which ensures that the <code class="prettyprint">ThenBy</code> and <code class="prettyprint">ThenByDescending</code> methods are available only on the result of an <code class="prettyprint">OrderBy</code> or <code class="prettyprint">OrderByDescending</code>. Also notice the recommended shape of the result of <code class="prettyprint">GroupBy</code> &ndash; a sequence of sequences, where each inner sequence has an additional <code class="prettyprint">Key</code> property.</p>

<p>The <code class="prettyprint">System.Linq</code> namespace provides an implementation of the query operator pattern for any type that implements the <code class="prettyprint">System.Collections.Generic.IEnumerable&lt;T&gt;</code> interface.</p>

<h2 id="assignment-operators">Assignment operators</h2>

<p>The assignment operators assign a new value to a variable, a property, an event, or an indexer element.</p>
<pre class="highlight shell"><code>assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : <span class="s1">'='</span>
    | <span class="s1">'+='</span>
    | <span class="s1">'-='</span>
    | <span class="s1">'*='</span>
    | <span class="s1">'/='</span>
    | <span class="s1">'%='</span>
    | <span class="s1">'&amp;='</span>
    | <span class="s1">'|='</span>
    | <span class="s1">'^='</span>
    | <span class="s1">'&lt;&lt;='</span>
    | right_shift_assignment
    ;
</code></pre>
<p>The left operand of an assignment must be an expression classified as a variable, a property access, an indexer access, or an event access.</p>

<p>The <code class="prettyprint">=</code> operator is called the <strong><em>simple assignment operator</em></strong>. It assigns the value of the right operand to the variable, property, or indexer element given by the left operand. The left operand of the simple assignment operator may not be an event access (except as described in <a href="classes.md#field-like-events">Field-like events</a>). The simple assignment operator is described in <a href="expressions.md#simple-assignment">Simple assignment</a>.</p>

<p>The assignment operators other than the <code class="prettyprint">=</code> operator are called the <strong><em>compound assignment operators</em></strong>. These operators perform the indicated operation on the two operands, and then assign the resulting value to the variable, property, or indexer element given by the left operand. The compound assignment operators are described in <a href="expressions.md#compound-assignment">Compound assignment</a>.</p>

<p>The <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators with an event access expression as the left operand are called the <em>event assignment operators</em>. No other assignment operator is valid with an event access as the left operand. The event assignment operators are described in <a href="expressions.md#event-assignment">Event assignment</a>.</p>

<p>The assignment operators are right-associative, meaning that operations are grouped from right to left. For example, an expression of the form <code class="prettyprint">a = b = c</code> is evaluated as <code class="prettyprint">a = (b = c)</code>.</p>

<h3 id="simple-assignment">Simple assignment</h3>

<p>The <code class="prettyprint">=</code> operator is called the simple assignment operator.</p>

<p>If the left operand of a simple assignment is of the form <code class="prettyprint">E.P</code> or <code class="prettyprint">E[Ei]</code> where <code class="prettyprint">E</code> has the compile-time type <code class="prettyprint">dynamic</code>, then the assignment is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the assignment expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time based on the run-time type of <code class="prettyprint">E</code>.</p>

<p>In a simple assignment, the right operand must be an expression that is implicitly convertible to the type of the left operand. The operation assigns the value of the right operand to the variable, property, or indexer element given by the left operand.</p>

<p>The result of a simple assignment expression is the value assigned to the left operand. The result has the same type as the left operand and is always classified as a value.</p>

<p>If the left operand is a property or indexer access, the property or indexer must have a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>The run-time processing of a simple assignment of the form <code class="prettyprint">x = y</code> consists of the following steps:</p>

<ul>
<li> If <code class="prettyprint">x</code> is classified as a variable:

<ul>
<li><code class="prettyprint">x</code> is evaluated to produce the variable.</li>
<li><code class="prettyprint">y</code> is evaluated and, if required, converted to the type of <code class="prettyprint">x</code> through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li>If the variable given by <code class="prettyprint">x</code> is an array element of a <em>reference_type</em>, a run-time check is performed to ensure that the value computed for <code class="prettyprint">y</code> is compatible with the array instance of which <code class="prettyprint">x</code> is an element. The check succeeds if <code class="prettyprint">y</code> is <code class="prettyprint">null</code>, or if an implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from the actual type of the instance referenced by <code class="prettyprint">y</code> to the actual element type of the array instance containing <code class="prettyprint">x</code>. Otherwise, a <code class="prettyprint">System.ArrayTypeMismatchException</code> is thrown.</li>
<li>The value resulting from the evaluation and conversion of <code class="prettyprint">y</code> is stored into the location given by the evaluation of <code class="prettyprint">x</code>.</li>
</ul></li>
<li> If <code class="prettyprint">x</code> is classified as a property or indexer access:

<ul>
<li>The instance expression (if <code class="prettyprint">x</code> is not <code class="prettyprint">static</code>) and the argument list (if <code class="prettyprint">x</code> is an indexer access) associated with <code class="prettyprint">x</code> are evaluated, and the results are used in the subsequent <code class="prettyprint">set</code> accessor invocation.</li>
<li><code class="prettyprint">y</code> is evaluated and, if required, converted to the type of <code class="prettyprint">x</code> through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li>The <code class="prettyprint">set</code> accessor of <code class="prettyprint">x</code> is invoked with the value computed for <code class="prettyprint">y</code> as its <code class="prettyprint">value</code> argument.</li>
</ul></li>
</ul>

<p>The array co-variance rules (<a href="arrays.md#array-covariance">Array covariance</a>) permit a value of an array type <code class="prettyprint">A[]</code> to be a reference to an instance of an array type <code class="prettyprint">B[]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>. Because of these rules, assignment to an array element of a <em>reference_type</em> requires a run-time check to ensure that the value being assigned is compatible with the array instance. In the example
&ldquo;`csharp
string[] sa = new string[10];
object[] oa = sa;</p>

<p>oa[0] = null;               // Ok
oa[1] = &quot;Hello&rdquo;;            // Ok
oa[2] = new ArrayList();    // ArrayTypeMismatchException
&ldquo;<code class="prettyprint">
the last assignment causes a</code>System.ArrayTypeMismatchException<code class="prettyprint">to be thrown because an instance of</code>ArrayList<code class="prettyprint">cannot be stored in an element of a</code>string[]`.</p>

<p>When a property or indexer declared in a <em>struct_type</em> is the target of an assignment, the instance expression associated with the property or indexer access must be classified as a variable. If the instance expression is classified as a value, a binding-time error occurs. Because of <a href="expressions.md#member-access">Member access</a>, the same rule also applies to fields.</p>

<p>Given the declarations:
&rdquo;`csharp
struct Point
{
    int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }</p>

<p>public int X {
        get { return x; }
        set { x = value; }
    }</p>

<p>public int Y {
        get { return y; }
        set { y = value; }
    }
}</p>

<p>struct Rectangle
{
    Point a, b;</p>

<p>public Rectangle(Point a, Point b) {
        this.a = a;
        this.b = b;
    }</p>

<p>public Point A {
        get { return a; }
        set { a = value; }
    }</p>

<p>public Point B {
        get { return b; }
        set { b = value; }
    }
}
<code class="prettyprint">
in the example
</code>csharp
Point p = new Point();
p.X = 100;
p.Y = 100;
Rectangle r = new Rectangle();
r.A = new Point(10, 10);
r.B = p;
<code class="prettyprint">
the assignments to `p.X`, `p.Y`, `r.A`, and `r.B` are permitted because `p` and `r` are variables. However, in the example
</code>csharp
Rectangle r = new Rectangle();
r.A.X = 10;
r.A.Y = 10;
r.B.X = 100;
r.B.Y = 100;
&ldquo;<code class="prettyprint">
the assignments are all invalid, since</code>r.A<code class="prettyprint">and</code>r.B` are not variables.</p>

<h3 id="compound-assignment">Compound assignment</h3>

<p>If the left operand of a compound assignment is of the form <code class="prettyprint">E.P</code> or <code class="prettyprint">E[Ei]</code> where <code class="prettyprint">E</code> has the compile-time type <code class="prettyprint">dynamic</code>, then the assignment is dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>). In this case the compile-time type of the assignment expression is <code class="prettyprint">dynamic</code>, and the resolution described below will take place at run-time based on the run-time type of <code class="prettyprint">E</code>.</p>

<p>An operation of the form <code class="prettyprint">x op= y</code> is processed by applying binary operator overload resolution (<a href="expressions.md#binary-operator-overload-resolution">Binary operator overload resolution</a>) as if the operation was written <code class="prettyprint">x op y</code>. Then,</p>

<ul>
<li> If the return type of the selected operator is implicitly convertible to the type of <code class="prettyprint">x</code>, the operation is evaluated as <code class="prettyprint">x = x op y</code>, except that <code class="prettyprint">x</code> is evaluated only once.</li>
<li> Otherwise, if the selected operator is a predefined operator, if the return type of the selected operator is explicitly convertible to the type of <code class="prettyprint">x</code>, and if <code class="prettyprint">y</code> is implicitly convertible to the type of <code class="prettyprint">x</code> or the operator is a shift operator, then the operation is evaluated as <code class="prettyprint">x = (T)(x op y)</code>, where <code class="prettyprint">T</code> is the type of <code class="prettyprint">x</code>, except that <code class="prettyprint">x</code> is evaluated only once.</li>
<li> Otherwise, the compound assignment is invalid, and a binding-time error occurs.</li>
</ul>

<p>The term &quot;evaluated only once&rdquo; means that in the evaluation of <code class="prettyprint">x op y</code>, the results of any constituent expressions of <code class="prettyprint">x</code> are temporarily saved and then reused when performing the assignment to <code class="prettyprint">x</code>. For example, in the assignment <code class="prettyprint">A()[B()] += C()</code>, where <code class="prettyprint">A</code> is a method returning <code class="prettyprint">int[]</code>, and <code class="prettyprint">B</code> and <code class="prettyprint">C</code> are methods returning <code class="prettyprint">int</code>, the methods are invoked only once, in the order <code class="prettyprint">A</code>, <code class="prettyprint">B</code>, <code class="prettyprint">C</code>.</p>

<p>When the left operand of a compound assignment is a property access or indexer access, the property or indexer must have both a <code class="prettyprint">get</code> accessor and a <code class="prettyprint">set</code> accessor. If this is not the case, a binding-time error occurs.</p>

<p>The second rule above permits <code class="prettyprint">x op= y</code> to be evaluated as <code class="prettyprint">x = (T)(x op y)</code> in certain contexts. The rule exists such that the predefined operators can be used as compound operators when the left operand is of type <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, or <code class="prettyprint">char</code>. Even when both arguments are of one of those types, the predefined operators produce a result of type <code class="prettyprint">int</code>, as described in <a href="expressions.md#binary-numeric-promotions">Binary numeric promotions</a>. Thus, without a cast it would not be possible to assign the result to the left operand.</p>

<p>The intuitive effect of the rule for predefined operators is simply that <code class="prettyprint">x op= y</code> is permitted if both of <code class="prettyprint">x op y</code> and <code class="prettyprint">x = y</code> are permitted. In the example
&ldquo;`csharp
byte b = 0;
char ch = &lsquo;\0&rsquo;;
int i = 0;</p>

<p>b += 1;             // Ok
b += 1000;          // Error, b = 1000 not permitted
b += i;             // Error, b = i not permitted
b += (byte)i;       // Ok</p>

<p>ch += 1;            // Error, ch = 1 not permitted
ch += (char)1;      // Ok
&rdquo;`
the intuitive reason for each error is that a corresponding simple assignment would also have been an error.</p>

<p>This also means that compound assignment operations support lifted operations. In the example
<code class="prettyprint">csharp
int? i = 0;
i += 1;             // Ok
</code>
the lifted operator <code class="prettyprint">+(int?,int?)</code> is used.</p>

<h3 id="event-assignment">Event assignment</h3>

<p>If the left operand of a <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator is classified as an event access, then the expression is evaluated as follows:</p>

<ul>
<li> The instance expression, if any, of the event access is evaluated.</li>
<li> The right operand of the <code class="prettyprint">+=</code> or <code class="prettyprint">-=</code> operator is evaluated, and, if required, converted to the type of the left operand through an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</li>
<li> An event accessor of the event is invoked, with argument list consisting of the right operand, after evaluation and, if necessary, conversion. If the operator was <code class="prettyprint">+=</code>, the <code class="prettyprint">add</code> accessor is invoked; if the operator was <code class="prettyprint">-=</code>, the <code class="prettyprint">remove</code> accessor is invoked.</li>
</ul>

<p>An event assignment expression does not yield a value. Thus, an event assignment expression is valid only in the context of a <em>statement_expression</em> (<a href="statements.md#expression-statements">Expression statements</a>).</p>

<h2 id="expression">Expression</h2>

<p>An <em>expression</em> is either a <em>non_assignment_expression</em> or an <em>assignment</em>.</p>
<pre class="highlight shell"><code>expression
    : non_assignment_expression
    | assignment
    ;

non_assignment_expression
    : conditional_expression
    | lambda_expression
    | query_expression
    ;
</code></pre>
<h2 id="constant-expressions">Constant expressions</h2>

<p>A <em>constant_expression</em> is an expression that can be fully evaluated at compile-time.</p>
<pre class="highlight shell"><code>constant_expression
    : expression
    ;
</code></pre>
<p>A constant expression must be the <code class="prettyprint">null</code> literal or a value with one of  the following types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">object</code>, <code class="prettyprint">string</code>, or any enumeration type. Only the following constructs are permitted in constant expressions:</p>

<ul>
<li> Literals (including the <code class="prettyprint">null</code> literal).</li>
<li> References to <code class="prettyprint">const</code> members of class and struct types.</li>
<li> References to members of enumeration types.</li>
<li> References to <code class="prettyprint">const</code> parameters or local variables</li>
<li> Parenthesized sub-expressions, which are themselves constant expressions.</li>
<li> Cast expressions, provided the target type is one of the types listed above.</li>
<li> <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> expressions</li>
<li> Default value expressions</li>
<li> Nameof expressions</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, and <code class="prettyprint">~</code> unary operators.</li>
<li> The predefined <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&amp;&amp;</code>, <code class="prettyprint">||</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;=</code>, and <code class="prettyprint">&gt;=</code> binary operators, provided each operand is of a type listed above.</li>
<li> The <code class="prettyprint">?:</code> conditional operator.</li>
</ul>

<p>The following conversions are permitted in constant expressions:</p>

<ul>
<li> Identity conversions</li>
<li> Numeric conversions</li>
<li> Enumeration conversions</li>
<li> Constant expression conversions</li>
<li> Implicit and explicit reference conversions, provided that the source of the conversions is a constant expression that evaluates to the null value.</li>
</ul>

<p>Other conversions including boxing, unboxing and implicit reference conversions of non-null values are not permitted in constant expressions. For example:
<code class="prettyprint">csharp
class C {
    const object i = 5;         // error: boxing conversion not permitted
    const object str = &quot;hello&quot;; // error: implicit reference conversion
}
</code>
the initialization of i is an error because a boxing conversion is required. The initialization of str is an error because an implicit reference conversion from a non-null value is required.</p>

<p>Whenever an expression fulfills the requirements listed above, the expression is evaluated at compile-time. This is true even if the expression is a sub-expression of a larger expression that contains non-constant constructs.</p>

<p>The compile-time evaluation of constant expressions uses the same rules as run-time evaluation of non-constant expressions, except that where run-time evaluation would have thrown an exception, compile-time evaluation causes a compile-time error to occur.</p>

<p>Unless a constant expression is explicitly placed in an <code class="prettyprint">unchecked</code> context, overflows that occur in integral-type arithmetic operations and conversions during the compile-time evaluation of the expression always cause compile-time errors (<a href="expressions.md#constant-expressions">Constant expressions</a>).</p>

<p>Constant expressions occur in the contexts listed below. In these contexts, a compile-time error occurs if an expression cannot be fully evaluated at compile-time.</p>

<ul>
<li> Constant declarations (<a href="classes.md#constants">Constants</a>).</li>
<li> Enumeration member declarations (<a href="enums.md#enum-members">Enum members</a>).</li>
<li> Default arguments of formal parameter lists (<a href="classes.md#method-parameters">Method parameters</a>)</li>
<li> <code class="prettyprint">case</code> labels of a <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>).</li>
<li> <code class="prettyprint">goto case</code> statements (<a href="statements.md#the-goto-statement">The goto statement</a>).</li>
<li> Dimension lengths in an array creation expression (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) that includes an initializer.</li>
<li> Attributes (<a href="attributes.md#attributes">Attributes</a>).</li>
</ul>

<p>An implicit constant expression conversion (<a href="conversions.md#implicit-constant-expression-conversions">Implicit constant expression conversions</a>) permits a constant expression of type <code class="prettyprint">int</code> to be converted to <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">uint</code>, or <code class="prettyprint">ulong</code>, provided the value of the constant expression is within the range of the destination type.</p>

<h2 id="boolean-expressions">Boolean expressions</h2>

<p>A <em>boolean_expression</em> is an expression that yields a result of type <code class="prettyprint">bool</code>; either directly or through application of <code class="prettyprint">operator true</code> in certain contexts as specified in the following.</p>
<pre class="highlight shell"><code>boolean_expression
    : expression
    ;
</code></pre>
<p>The controlling conditional expression of an <em>if_statement</em> (<a href="statements.md#the-if-statement">The if statement</a>), <em>while_statement</em> (<a href="statements.md#the-while-statement">The while statement</a>), <em>do_statement</em> (<a href="statements.md#the-do-statement">The do statement</a>), or <em>for_statement</em> (<a href="statements.md#the-for-statement">The for statement</a>) is a <em>boolean_expression</em>. The controlling conditional expression of the <code class="prettyprint">?:</code> operator (<a href="expressions.md#conditional-operator">Conditional operator</a>) follows the same rules as a <em>boolean_expression</em>, but for reasons of operator precedence is classified as a <em>conditional_or_expression</em>.</p>

<p>A <em>boolean_expression</em> <code class="prettyprint">E</code> is required to be able to produce a value of type <code class="prettyprint">bool</code>, as follows:</p>

<ul>
<li> If <code class="prettyprint">E</code> is implicitly convertible to <code class="prettyprint">bool</code> then at runtime that implicit conversion is applied.</li>
<li> Otherwise, unary operator overload resolution (<a href="expressions.md#unary-operator-overload-resolution">Unary operator overload resolution</a>) is used to find a unique best implementation of operator <code class="prettyprint">true</code> on <code class="prettyprint">E</code>, and that implementation is applied at runtime.</li>
<li> If no such operator is found, a binding-time error occurs.</li>
</ul>

<p>The <code class="prettyprint">DBBool</code> struct type in <a href="structs.md#database-boolean-type">Database boolean type</a> provides an example of a type that implements <code class="prettyprint">operator true</code> and <code class="prettyprint">operator false</code>.</p>
