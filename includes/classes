<h1 id="classes">Classes</h1>

<p>A class is a data structure that may contain data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types. Class types support inheritance, a mechanism whereby a derived class can extend and specialize a base class.</p>

<h2 id="class-declarations">Class declarations</h2>

<p>A <em>class_declaration</em> is a <em>type_declaration</em> (<a href="namespaces.md#type-declarations">Type declarations</a>) that declares a new class.</p>
<pre class="highlight plaintext"><code>class_declaration
    : attributes? class_modifier* 'partial'? 'class' identifier type_parameter_list?
      class_base? type_parameter_constraints_clause* class_body ';'?
    ;
</code></pre>
<p>A <em>class_declaration</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), followed by an optional set of <em>class_modifier*s (<a href="classes.md#class-modifiers">Class modifiers</a>), followed by an optional <code class="prettyprint">partial</code> modifier, followed by the keyword <code class="prettyprint">class</code> and an *identifier</em> that names the class, followed by an optional <em>type_parameter_list</em> (<a href="classes.md#type-parameters">Type parameters</a>), followed by an optional <em>class_base</em> specification (<a href="classes.md#class-base-specification">Class base specification</a>) , followed by an optional set of <em>type_parameter_constraints_clause*s (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), followed by a *class_body</em> (<a href="classes.md#class-body">Class body</a>), optionally followed by a semicolon.</p>

<p>A class declaration cannot supply <em>type_parameter_constraints_clause*s unless it also supplies a *type_parameter_list</em>.</p>

<p>A class declaration that supplies a <em>type_parameter_list</em> is a <strong><em>generic class declaration</em></strong>. Additionally, any class nested inside a generic class declaration or a generic struct declaration is itself a generic class declaration, since type parameters for the containing type must be supplied to create a constructed type.</p>

<h3 id="class-modifiers">Class modifiers</h3>

<p>A <em>class_declaration</em> may optionally include a sequence of class modifiers:</p>
<pre class="highlight plaintext"><code>class_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'abstract'
    | 'sealed'
    | 'static'
    | class_modifier_unsafe
    ;
</code></pre>
<p>It is a compile-time error for the same modifier to appear multiple times in a class declaration.</p>

<p>The <code class="prettyprint">new</code> modifier is permitted on nested classes. It specifies that the class hides an inherited member by the same name, as described in <a href="classes.md#the-new-modifier">The new modifier</a>. It is a compile-time error for the <code class="prettyprint">new</code> modifier to appear on a class declaration that is not a nested class declaration.</p>

<p>The <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers control the accessibility of the class. Depending on the context in which the class declaration occurs, some of these modifiers may not be permitted (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<p>The <code class="prettyprint">abstract</code>, <code class="prettyprint">sealed</code> and <code class="prettyprint">static</code> modifiers are discussed in the following sections.</p>

<h4 id="abstract-classes">Abstract classes</h4>

<p>The <code class="prettyprint">abstract</code> modifier is used to indicate that a class is incomplete and that it is intended to be used only as a base class. An abstract class differs from a non-abstract class in the following ways:</p>

<ul>
<li> An abstract class cannot be instantiated directly, and it is a compile-time error to use the <code class="prettyprint">new</code> operator on an abstract class. While it is possible to have variables and values whose compile-time types are abstract, such variables and values will necessarily either be <code class="prettyprint">null</code> or contain references to instances of non-abstract classes derived from the abstract types.</li>
<li> An abstract class is permitted (but not required) to contain abstract members.</li>
<li> An abstract class cannot be sealed.</li>
</ul>

<p>When a non-abstract class is derived from an abstract class, the non-abstract class must include actual implementations of all inherited abstract members, thereby overriding those abstract members. In the example
&ldquo;`csharp
abstract class A
{
    public abstract void F();
}</p>

<p>abstract class B: A
{
    public void G() {}
}</p>

<p>class C: B
{
    public override void F() {
        // actual implementation of F
    }
}
&rdquo;<code class="prettyprint">
the abstract class</code>A<code class="prettyprint">introduces an abstract method</code>F<code class="prettyprint">. Class</code>B<code class="prettyprint">introduces an additional method</code>G<code class="prettyprint">, but since it doesn&#39;t provide an implementation of</code>F<code class="prettyprint">,</code>B<code class="prettyprint">must also be declared abstract. Class</code>C<code class="prettyprint">overrides</code>F<code class="prettyprint">and provides an actual implementation. Since there are no abstract members in</code>C<code class="prettyprint">,</code>C` is permitted (but not required) to be non-abstract.</p>

<h4 id="sealed-classes">Sealed classes</h4>

<p>The <code class="prettyprint">sealed</code> modifier is used to prevent derivation from a class. A compile-time error occurs if a sealed class is specified as the base class of another class.</p>

<p>A sealed class cannot also be an abstract class.</p>

<p>The <code class="prettyprint">sealed</code> modifier is primarily used to prevent unintended derivation, but it also enables certain run-time optimizations. In particular, because a sealed class is known to never have any derived classes, it is possible to transform virtual function member invocations on sealed class instances into non-virtual invocations.</p>

<h4 id="static-classes">Static classes</h4>

<p>The <code class="prettyprint">static</code> modifier is used to mark the class being declared as a <strong><em>static class</em></strong>. A static class cannot be instantiated, cannot be used as a type and can contain only static members. Only a static class can contain declarations of extension methods (<a href="classes.md#extension-methods">Extension methods</a>).</p>

<p>A static class declaration is subject to the following restrictions:</p>

<ul>
<li> A static class may not include a <code class="prettyprint">sealed</code> or <code class="prettyprint">abstract</code> modifier. Note, however, that since a static class cannot be instantiated or derived from, it behaves as if it was both sealed and abstract.</li>
<li> A static class may not include a <em>class_base</em> specification (<a href="classes.md#class-base-specification">Class base specification</a>) and cannot explicitly specify a base class or a list of implemented interfaces. A static class implicitly inherits from type <code class="prettyprint">object</code>.</li>
<li> A static class can only contain static members (<a href="classes.md#static-and-instance-members">Static and instance members</a>). Note that constants and nested types are classified as static members.</li>
<li> A static class cannot have members with <code class="prettyprint">protected</code> or <code class="prettyprint">protected internal</code> declared accessibility.</li>
</ul>

<p>It is a compile-time error to violate any of these restrictions.</p>

<p>A static class has no instance constructors. It is not possible to declare an instance constructor in a static class, and no default instance constructor (<a href="classes.md#default-constructors">Default constructors</a>) is provided for a static class.</p>

<p>The members of a static class are not automatically static, and the member declarations must explicitly include a <code class="prettyprint">static</code> modifier (except for constants and nested types). When a class is nested within a static outer class, the nested class is not a static class unless it explicitly includes a <code class="prettyprint">static</code> modifier.</p>

<p><strong>Referencing static class types</strong></p>

<p>A <em>namespace_or_type_name</em> (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) is permitted to reference a static class if</p>

<ul>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>namespace_or_type_name</em> of the form <code class="prettyprint">T.I</code>, or</li>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>typeof_expression</em> (<a href="expressions.md#argument-lists">Argument lists</a>1) of the form <code class="prettyprint">typeof(T)</code>.</li>
</ul>

<p>A <em>primary_expression</em> (<a href="expressions.md#function-members">Function members</a>) is permitted to reference a static class if</p>

<ul>
<li> The <em>primary_expression</em> is the <code class="prettyprint">E</code> in a <em>member_access</em> (<a href="expressions.md#compile-time-checking-of-dynamic-overload-resolution">Compile-time checking of dynamic overload resolution</a>) of the form <code class="prettyprint">E.I</code>.</li>
</ul>

<p>In any other context it is a compile-time error to reference a static class. For example, it is an error for a static class to be used as a base class, a constituent type (<a href="classes.md#nested-types">Nested types</a>) of a member, a generic type argument, or a type parameter constraint. Likewise, a static class cannot be used in an array type, a pointer type, a <code class="prettyprint">new</code> expression, a cast expression, an <code class="prettyprint">is</code> expression, an <code class="prettyprint">as</code> expression, a <code class="prettyprint">sizeof</code> expression, or a default value expression.</p>

<h3 id="partial-modifier">Partial modifier</h3>

<p>The <code class="prettyprint">partial</code> modifier is used to indicate that this <em>class_declaration</em> is a partial type declaration. Multiple partial type declarations with the same name within an enclosing namespace or type declaration combine to form one type declaration, following the rules specified in <a href="classes.md#partial-types">Partial types</a>.</p>

<p>Having the declaration of a class distributed over separate segments of program text can be useful if these segments are produced or maintained in different contexts. For instance, one part of a class declaration may be machine generated, whereas the other is manually authored. Textual separation of the two prevents updates by one from conflicting with updates by the other.</p>

<h3 id="type-parameters">Type parameters</h3>

<p>A type parameter is a simple identifier that denotes a placeholder for a type argument supplied to create a constructed type. A type parameter is a formal placeholder for a type that will be supplied later. By constrast, a type argument (<a href="types.md#type-arguments">Type arguments</a>) is the actual type that is substituted for the type parameter when a constructed type is created.</p>
<pre class="highlight plaintext"><code>type_parameter_list
    : '&lt;' type_parameters '&gt;'
    ;

type_parameters
    : attributes? type_parameter
    | type_parameters ',' attributes? type_parameter
    ;

type_parameter
    : identifier
    ;
</code></pre>
<p>Each type parameter in a class declaration defines a name in the declaration space (<a href="basic-concepts.md#declarations">Declarations</a>) of that class. Thus, it cannot have the same name as another type parameter or a member declared in that class. A type parameter cannot have the same name as the type itself.</p>

<h3 id="class-base-specification">Class base specification</h3>

<p>A class declaration may include a <em>class_base</em> specification, which defines the direct base class of the class and the interfaces (<a href="interfaces.md#interfaces">Interfaces</a>) directly implemented by the class.</p>
<pre class="highlight plaintext"><code>class_base
    : ':' class_type
    | ':' interface_type_list
    | ':' class_type ',' interface_type_list
    ;

interface_type_list
    : interface_type (',' interface_type)*
    ;
</code></pre>
<p>The base class specified in a class declaration can be a constructed class type (<a href="types.md#constructed-types">Constructed types</a>). A base class cannot be a type parameter on its own, though it can involve the type parameters that are in scope.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Extend</span><span class="p">&lt;</span><span class="n">V</span><span class="p">&gt;:</span> <span class="n">V</span> <span class="p">{}</span>            <span class="c1">// Error, type parameter used as base class</span>
</code></pre>
<h4 id="base-classes">Base classes</h4>

<p>When a <em>class_type</em> is included in the <em>class_base</em>, it specifies the direct base class of the class being declared. If a class declaration has no <em>class_base</em>, or if the <em>class_base</em> lists only interface types, the direct base class is assumed to be <code class="prettyprint">object</code>. A class inherits members from its direct base class, as described in <a href="classes.md#inheritance">Inheritance</a>.</p>

<p>In the example
&ldquo;`csharp
class A {}</p>

<p>class B: A {}
&rdquo;<code class="prettyprint">
class</code>A<code class="prettyprint">is said to be the direct base class of</code>B<code class="prettyprint">, and</code>B<code class="prettyprint">is said to be derived from</code>A<code class="prettyprint">. Since</code>A<code class="prettyprint">does not explicitly specify a direct base class, its direct base class is implicitly</code>object`.</p>

<p>For a constructed class type, if a base class is specified in the generic class declaration, the base class of the constructed type is obtained by substituting, for each <em>type_parameter</em> in the base class declaration, the corresponding <em>type_argument</em> of the constructed type. Given the generic class declarations
&ldquo;`csharp
class B<U,V> {&hellip;}</p>

<p>class G<T>: B<string,T[]> {&hellip;}
&rdquo;<code class="prettyprint">
the base class of the constructed type</code>G<int><code class="prettyprint">would be</code>B<string,int[]>`.</p>

<p>The direct base class of a class type must be at least as accessible as the class type itself (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>). For example, it is a compile-time error for a <code class="prettyprint">public</code> class to derive from a <code class="prettyprint">private</code> or <code class="prettyprint">internal</code> class.</p>

<p>The direct base class of a class type must not be any of the following types: <code class="prettyprint">System.Array</code>, <code class="prettyprint">System.Delegate</code>, <code class="prettyprint">System.MulticastDelegate</code>, <code class="prettyprint">System.Enum</code>, or <code class="prettyprint">System.ValueType</code>. Furthermore, a generic class declaration cannot use <code class="prettyprint">System.Attribute</code> as a direct or indirect base class.</p>

<p>While determining the meaning of the direct base class specification <code class="prettyprint">A</code> of a class <code class="prettyprint">B</code>, the direct base class of <code class="prettyprint">B</code> is temporarily assumed to be <code class="prettyprint">object</code>. Intuitively this ensures that the meaning of a base class specification cannot recursively depend on itself. The example:
&ldquo;`csharp
class A<T> {
   public class B {}
}</p>

<p>class C : A<C.B> {}
&rdquo;<code class="prettyprint">
is in error since in the base class specification</code>A<C.B><code class="prettyprint">the direct base class of</code>C<code class="prettyprint">is considered to be</code>object<code class="prettyprint">, and hence (by the rules of [Namespace and type names](basic-concepts.md#namespace-and-type-names))</code>C<code class="prettyprint">is not considered to have a member</code>B`.</p>

<p>The base classes of a class type are the direct base class and its base classes. In other words, the set of base classes is the transitive closure of the direct base class relationship. Referring to the example above, the base classes of <code class="prettyprint">B</code> are <code class="prettyprint">A</code> and <code class="prettyprint">object</code>. In the example
&ldquo;`csharp
class A {&hellip;}</p>

<p>class B<T>: A {&hellip;}</p>

<p>class C<T>: B<IComparable<T>&gt; {&hellip;}</p>

<p>class D<T>: C<T[]> {&hellip;}
&rdquo;<code class="prettyprint">
the base classes of</code>D<int><code class="prettyprint">are</code>C<int[]><code class="prettyprint">,</code>B<IComparable<int[]>&gt;<code class="prettyprint">,</code>A<code class="prettyprint">, and</code>object`.</p>

<p>Except for class <code class="prettyprint">object</code>, every class type has exactly one direct base class. The <code class="prettyprint">object</code> class has no direct base class and is the ultimate base class of all other classes.</p>

<p>When a class <code class="prettyprint">B</code> derives from a class <code class="prettyprint">A</code>, it is a compile-time error for <code class="prettyprint">A</code> to depend on <code class="prettyprint">B</code>. A class <strong><em>directly depends on</em></strong> its direct base class (if any) and <strong><em>directly depends on</em></strong> the class within which it is immediately nested (if any). Given this definition, the complete set of classes upon which a class depends is the reflexive and transitive closure of the <strong><em>directly depends on</em></strong> relationship.</p>

<p>The example
<code class="prettyprint">csharp
class A: A {}
</code>
is erroneous because the class depends on itself. Likewise, the example
<code class="prettyprint">csharp
class A: B {}
class B: C {}
class C: A {}
</code>
is in error because the classes circularly depend on themselves. Finally, the example
&ldquo;`csharp
class A: B.C {}</p>

<p>class B: A
{
    public class C {}
}
&rdquo;<code class="prettyprint">
results in a compile-time error because</code>A<code class="prettyprint">depends on</code>B.C<code class="prettyprint">(its direct base class), which depends on</code>B<code class="prettyprint">(its immediately enclosing class), which circularly depends on</code>A`.</p>

<p>Note that a class does not depend on the classes that are nested within it. In the example
<code class="prettyprint">csharp
class A
{
    class B: A {}
}
</code>
<code class="prettyprint">B</code> depends on <code class="prettyprint">A</code> (because <code class="prettyprint">A</code> is both its direct base class and its immediately enclosing class), but <code class="prettyprint">A</code> does not depend on <code class="prettyprint">B</code> (since <code class="prettyprint">B</code> is neither a base class nor an enclosing class of <code class="prettyprint">A</code>). Thus, the example is valid.</p>

<p>It is not possible to derive from a <code class="prettyprint">sealed</code> class. In the example
&ldquo;`csharp
sealed class A {}</p>

<p>class B: A {}            // Error, cannot derive from a sealed class
&rdquo;<code class="prettyprint">
class</code>B<code class="prettyprint">is in error because it attempts to derive from the</code>sealed<code class="prettyprint">class</code>A`.</p>

<h4 id="interface-implementations">Interface implementations</h4>

<p>A <em>class_base</em> specification may include a list of interface types, in which case the class is said to directly implement the given interface types. Interface implementations are discussed further in <a href="interfaces.md#interface-implementations">Interface implementations</a>.</p>

<h3 id="type-parameter-constraints">Type parameter constraints</h3>

<p>Generic type and method declarations can optionally specify type parameter constraints by including *type_parameter_constraints_clause*s.</p>
<pre class="highlight plaintext"><code>type_parameter_constraints_clause
    : 'where' type_parameter ':' type_parameter_constraints
    ;

type_parameter_constraints
    : primary_constraint
    | secondary_constraints
    | constructor_constraint
    | primary_constraint ',' secondary_constraints
    | primary_constraint ',' constructor_constraint
    | secondary_constraints ',' constructor_constraint
    | primary_constraint ',' secondary_constraints ',' constructor_constraint
    ;

primary_constraint
    : class_type
    | 'class'
    | 'struct'
    ;

secondary_constraints
    : interface_type
    | type_parameter
    | secondary_constraints ',' interface_type
    | secondary_constraints ',' type_parameter
    ;

constructor_constraint
    : 'new' '(' ')'
    ;
</code></pre>
<p>Each <em>type_parameter_constraints_clause</em> consists of the token <code class="prettyprint">where</code>, followed by the name of a type parameter, followed by a colon and the list of constraints for that type parameter. There can be at most one <code class="prettyprint">where</code> clause for each type parameter, and the <code class="prettyprint">where</code> clauses can be listed in any order. Like the <code class="prettyprint">get</code> and <code class="prettyprint">set</code> tokens in a property accessor, the <code class="prettyprint">where</code> token is not a keyword.</p>

<p>The list of constraints given in a <code class="prettyprint">where</code> clause can include any of the following components, in this order: a single primary constraint, one or more secondary constraints, and the constructor constraint, <code class="prettyprint">new()</code>.</p>

<p>A primary constraint can be a class type or the <strong><em>reference type constraint</em></strong> <code class="prettyprint">class</code> or the <strong><em>value type constraint</em></strong> <code class="prettyprint">struct</code>. A secondary constraint can be a <em>type_parameter</em> or <em>interface_type</em>.</p>

<p>The reference type constraint specifies that a type argument used for the type parameter must be a reference type. All class types, interface types, delegate types, array types, and type parameters known to be a reference type (as defined below) satisfy this constraint.</p>

<p>The value type constraint specifies that a type argument used for the type parameter must be a non-nullable value type. All non-nullable struct types, enum types, and type parameters having the value type constraint satisfy this constraint. Note that although classified as a value type, a nullable type (<a href="types.md#nullable-types">Nullable types</a>) does not satisfy the value type constraint. A type parameter having the value type constraint cannot also have the <em>constructor_constraint</em>.</p>

<p>Pointer types are never allowed to be type arguments and are not considered to satisfy either the reference type or value type constraints.</p>

<p>If a constraint is a class type, an interface type, or a type parameter, that type specifies a minimal &ldquo;base type&rdquo; that every type argument used for that type parameter must support. Whenever a constructed type or generic method is used, the type argument is checked against the constraints on the type parameter at compile-time. The type argument supplied must satisfy the conditions described in <a href="types.md#satisfying-constraints">Satisfying constraints</a>.</p>

<p>A <em>class_type</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be a class type.</li>
<li> The type must not be <code class="prettyprint">sealed</code>.</li>
<li> The type must not be one of the following types: <code class="prettyprint">System.Array</code>, <code class="prettyprint">System.Delegate</code>, <code class="prettyprint">System.Enum</code>, or <code class="prettyprint">System.ValueType</code>.</li>
<li> The type must not be <code class="prettyprint">object</code>. Because all types derive from <code class="prettyprint">object</code>, such a constraint would have no effect if it were permitted.</li>
<li> At most one constraint for a given type parameter can be a class type.</li>
</ul>

<p>A type specified as an <em>interface_type</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be an interface type.</li>
<li> A type must not be specified more than once in a given <code class="prettyprint">where</code> clause.</li>
</ul>

<p>In either case, the constraint can involve any of the type parameters of the associated type or method declaration as part of a constructed type, and can involve the type being declared.</p>

<p>Any class or interface type specified as a type parameter constraint must be at least as accessible (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>) as the generic type or method being declared.</p>

<p>A type specified as a <em>type_parameter</em> constraint must satisfy the following rules:</p>

<ul>
<li> The type must be a type parameter.</li>
<li> A type must not be specified more than once in a given <code class="prettyprint">where</code> clause.</li>
</ul>

<p>In addition there must be no cycles in the dependency graph of type parameters, where dependency is a transitive relation defined by:</p>

<ul>
<li> If a type parameter <code class="prettyprint">T</code> is used as a constraint for type parameter <code class="prettyprint">S</code> then <code class="prettyprint">S</code> <strong><em>depends on</em></strong> <code class="prettyprint">T</code>.</li>
<li> If a type parameter <code class="prettyprint">S</code> depends on a type parameter <code class="prettyprint">T</code> and <code class="prettyprint">T</code> depends on a type parameter <code class="prettyprint">U</code> then <code class="prettyprint">S</code> <strong><em>depends on</em></strong> <code class="prettyprint">U</code>.</li>
</ul>

<p>Given this relation, it is a compile-time error for a type parameter to depend on itself (directly or indirectly).</p>

<p>Any constraints must be consistent among dependent type parameters. If type parameter <code class="prettyprint">S</code> depends on type parameter <code class="prettyprint">T</code> then:</p>

<ul>
<li> <code class="prettyprint">T</code> must not have the value type constraint. Otherwise, <code class="prettyprint">T</code> is effectively sealed so <code class="prettyprint">S</code> would be forced to be the same type as <code class="prettyprint">T</code>, eliminating the need for two type parameters.</li>
<li> If <code class="prettyprint">S</code> has the value type constraint then <code class="prettyprint">T</code> must not have a <em>class_type</em> constraint.</li>
<li> If <code class="prettyprint">S</code> has a <em>class_type</em> constraint <code class="prettyprint">A</code> and <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">B</code> then there must be an identity conversion or implicit reference conversion from <code class="prettyprint">A</code> to <code class="prettyprint">B</code> or an implicit reference conversion from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</li>
<li> If <code class="prettyprint">S</code> also depends on type parameter <code class="prettyprint">U</code> and <code class="prettyprint">U</code> has a <em>class_type</em> constraint <code class="prettyprint">A</code> and <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">B</code> then there must be an identity conversion or implicit reference conversion from <code class="prettyprint">A</code> to <code class="prettyprint">B</code> or an implicit reference conversion from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</li>
</ul>

<p>It is valid for <code class="prettyprint">S</code> to have the value type constraint and <code class="prettyprint">T</code> to have the reference type constraint. Effectively this limits <code class="prettyprint">T</code> to the types <code class="prettyprint">System.Object</code>, <code class="prettyprint">System.ValueType</code>, <code class="prettyprint">System.Enum</code>, and any interface type.</p>

<p>If the <code class="prettyprint">where</code> clause for a type parameter includes a constructor constraint (which has the form <code class="prettyprint">new()</code>), it is possible to use the <code class="prettyprint">new</code> operator to create instances of the type (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>). Any type argument used for a type parameter with a constructor constraint must have a public parameterless constructor (this constructor implicitly exists for any value type) or be a type parameter having the value type constraint or constructor constraint (see <a href="classes.md#type-parameter-constraints">Type parameter constraints</a> for details).</p>

<p>The following are examples of constraints:
&ldquo;`csharp
interface IPrintable
{
    void Print();
}</p>

<p>interface IComparable<T>
{
    int CompareTo(T value);
}</p>

<p>interface IKeyProvider<T>
{
    T GetKey();
}</p>

<p>class Printer<T> where T: IPrintable {&hellip;}</p>

<p>class SortedList<T> where T: IComparable<T> {&hellip;}</p>

<p>class Dictionary<K,V>
    where K: IComparable<K>
    where V: IPrintable, IKeyProvider<K>, new()
{
    &hellip;
}
&rdquo;`</p>

<p>The following example is in error because it causes a circularity in the dependency graph of the type parameters:
<code class="prettyprint">csharp
class Circular&lt;S,T&gt;
    where S: T
    where T: S                // Error, circularity in dependency graph
{
    ...
}
</code></p>

<p>The following examples illustrate additional invalid situations:
&ldquo;`csharp
class Sealed<S,T>
    where S: T
    where T: struct        // Error, T is sealed
{
    &hellip;
}</p>

<p>class A {&hellip;}</p>

<p>class B {&hellip;}</p>

<p>class Incompat<S,T>
    where S: A, T
    where T: B                // Error, incompatible class-type constraints
{
    &hellip;
}</p>

<p>class StructWithClass<S,T,U>
    where S: struct, T
    where T: U
    where U: A                // Error, A incompatible with struct
{
    &hellip;
}
&rdquo;`</p>

<p>The <strong><em>effective base class</em></strong> of a type parameter <code class="prettyprint">T</code> is defined as follows:</p>

<ul>
<li> If <code class="prettyprint">T</code> has no primary constraints or type parameter constraints, its effective base class is <code class="prettyprint">object</code>.</li>
<li> If <code class="prettyprint">T</code> has the value type constraint, its effective base class is <code class="prettyprint">System.ValueType</code>.</li>
<li> If <code class="prettyprint">T</code> has a <em>class_type</em> constraint <code class="prettyprint">C</code> but no <em>type_parameter</em> constraints, its effective base class is <code class="prettyprint">C</code>.</li>
<li> If <code class="prettyprint">T</code> has no <em>class_type</em> constraint but has one or more <em>type_parameter</em> constraints, its effective base class is the most encompassed type (<a href="conversions.md#lifted-conversion-operators">Lifted conversion operators</a>) in the set of effective base classes of its <em>type_parameter</em> constraints. The consistency rules ensure that such a most encompassed type exists.</li>
<li> If <code class="prettyprint">T</code> has both a <em>class_type</em> constraint and one or more <em>type_parameter</em> constraints, its effective base class is the most encompassed type (<a href="conversions.md#lifted-conversion-operators">Lifted conversion operators</a>) in the set consisting of the <em>class_type</em> constraint of <code class="prettyprint">T</code> and the effective base classes of its <em>type_parameter</em> constraints. The consistency rules ensure that such a most encompassed type exists.</li>
<li> If <code class="prettyprint">T</code> has the reference type constraint but no <em>class_type</em> constraints, its effective base class is <code class="prettyprint">object</code>.</li>
</ul>

<p>For the purpose of these rules, if T has a constraint <code class="prettyprint">V</code> that is a <em>value_type</em>, use instead the most specific base type of <code class="prettyprint">V</code> that is a <em>class_type</em>. This can never happen in an explicitly given constraint, but may occur when the constraints of a generic method are implicitly inherited by an overriding method declaration or an explicit implementation of an interface method.</p>

<p>These rules ensure that the effective base class is always a <em>class_type</em>.</p>

<p>The <strong><em>effective interface set</em></strong> of a type parameter <code class="prettyprint">T</code> is defined as follows:</p>

<ul>
<li> If <code class="prettyprint">T</code> has no <em>secondary_constraints</em>, its effective interface set is empty.</li>
<li> If <code class="prettyprint">T</code> has <em>interface_type</em> constraints but no <em>type_parameter</em> constraints, its effective interface set is its set of <em>interface_type</em> constraints.</li>
<li> If <code class="prettyprint">T</code> has no <em>interface_type</em> constraints but has <em>type_parameter</em> constraints, its effective interface set is the union of the effective interface sets of its <em>type_parameter</em> constraints.</li>
<li> If <code class="prettyprint">T</code> has both <em>interface_type</em> constraints and <em>type_parameter</em> constraints, its effective interface set is the union of its set of <em>interface_type</em> constraints and the effective interface sets of its <em>type_parameter</em> constraints.</li>
</ul>

<p>A type parameter is <strong><em>known to be a reference type</em></strong> if it has the reference type constraint or its effective base class is not <code class="prettyprint">object</code> or <code class="prettyprint">System.ValueType</code>.</p>

<p>Values of a constrained type parameter type can be used to access the instance members implied by the constraints. In the example
&ldquo;`csharp
interface IPrintable
{
    void Print();
}</p>

<p>class Printer<T> where T: IPrintable
{
    void PrintOne(T x) {
        x.Print();
    }
}
&rdquo;<code class="prettyprint">
the methods of</code>IPrintable<code class="prettyprint">can be invoked directly on</code>x<code class="prettyprint">because</code>T<code class="prettyprint">is constrained to always implement</code>IPrintable`.</p>

<h3 id="class-body">Class body</h3>

<p>The <em>class_body</em> of a class defines the members of that class.</p>
<pre class="highlight plaintext"><code>class_body
    : '{' class_member_declaration* '}'
    ;
</code></pre>
<h2 id="partial-types">Partial types</h2>

<p>A type declaration can be split across multiple <strong><em>partial type declarations</em></strong>. The type declaration is constructed from its parts by following the rules in this section, whereupon it is treated as a single declaration during the remainder of the compile-time and run-time processing of the program.</p>

<p>A <em>class_declaration</em>, <em>struct_declaration</em> or <em>interface_declaration</em> represents a partial type declaration if it includes a <code class="prettyprint">partial</code> modifier. <code class="prettyprint">partial</code> is not a keyword, and only acts as a modifier if it appears immediately before one of the keywords <code class="prettyprint">class</code>, <code class="prettyprint">struct</code> or <code class="prettyprint">interface</code> in a type declaration, or before the type <code class="prettyprint">void</code> in a method declaration. In other contexts it can be used as a normal identifier.</p>

<p>Each part of a partial type declaration must include a <code class="prettyprint">partial</code> modifier. It must have the same name  and be declared in the same namespace or type declaration as the other parts. The <code class="prettyprint">partial</code> modifier indicates that additional parts of the type declaration may exist elsewhere, but the existence of such additional parts is not a requirement; it is valid for a type with a single declaration to include the <code class="prettyprint">partial</code> modifier.</p>

<p>All parts of a partial type must be compiled together such that the parts can be merged at compile-time into a single type declaration. Partial types specifically do not allow already compiled types to be extended.</p>

<p>Nested types may be declared in multiple parts by using the <code class="prettyprint">partial</code> modifier. Typically, the containing type is declared using <code class="prettyprint">partial</code> as well, and each part of the nested type is declared in a different part of the containing type.</p>

<p>The <code class="prettyprint">partial</code> modifier is not permitted on delegate or enum declarations.</p>

<h3 id="attributes">Attributes</h3>

<p>The attributes of a partial type are determined by combining, in an unspecified order, the attributes of each of the parts. If an attribute is placed on multiple parts, it is equivalent to specifying the attribute multiple times on the type. For example, the two parts:</p>
<pre class="highlight csharp tab-csharp"><code><span class="na">[Attr1, Attr2("hello")]</span>
<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>

<span class="na">[Attr3, Attr2("goodbye")]</span>
<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{}</span>
</code></pre>
<p>are equivalent to a declaration such as:
<code class="prettyprint">csharp
[Attr1, Attr2(&quot;hello&quot;), Attr3, Attr2(&quot;goodbye&quot;)]
class A {}
</code></p>

<p>Attributes on type parameters combine in a similar fashion.</p>

<h3 id="modifiers">Modifiers</h3>

<p>When a partial type declaration includes an accessibility specification (the <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, and <code class="prettyprint">private</code> modifiers) it must agree with all other parts that include an accessibility specification. If no part of a partial type includes an accessibility specification, the type is given the appropriate default accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>).</p>

<p>If one or more partial declarations of a nested type include a <code class="prettyprint">new</code> modifier, no warning is reported if the nested type hides an inherited member (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>).</p>

<p>If one or more partial declarations of a class include an <code class="prettyprint">abstract</code> modifier, the class is considered abstract (<a href="classes.md#abstract-classes">Abstract classes</a>). Otherwise, the class is considered non-abstract.</p>

<p>If one or more partial declarations of a class include a <code class="prettyprint">sealed</code> modifier, the class is considered sealed (<a href="classes.md#sealed-classes">Sealed classes</a>). Otherwise, the class is considered unsealed.</p>

<p>Note that a class cannot be both abstract and sealed.</p>

<p>When the <code class="prettyprint">unsafe</code> modifier is used on a partial type declaration, only that particular part is considered an unsafe context (<a href="unsafe-code.md#unsafe-contexts">Unsafe contexts</a>).</p>

<h3 id="type-parameters-and-constraints">Type parameters and constraints</h3>

<p>If a generic type is declared in multiple parts, each part must state the type parameters. Each part must have the same number of type parameters, and the same name for each type parameter, in order.</p>

<p>When a partial generic type declaration includes constraints (<code class="prettyprint">where</code> clauses), the constraints must agree with all other parts that include constraints. Specifically, each part that includes constraints must have constraints for the same set of type parameters, and for each type parameter the sets of primary, secondary, and constructor constraints must be equivalent. Two sets of constraints are equivalent if they contain the same members. If no part of a partial generic type specifies type parameter constraints, the type parameters are considered unconstrained.</p>

<p>The example
&ldquo;`csharp
partial class Dictionary<K,V>
    where K: IComparable<K>
    where V: IKeyProvider<K>, IPersistable
{
    &hellip;
}</p>

<p>partial class Dictionary<K,V>
    where V: IPersistable, IKeyProvider<K>
    where K: IComparable<K>
{
    &hellip;
}</p>

<p>partial class Dictionary<K,V>
{
    &hellip;
}
&rdquo;`
is correct because those parts that include constraints (the first two) effectively specify the same set of primary, secondary, and constructor constraints for the same set of type parameters, respectively.</p>

<h3 id="base-class">Base class</h3>

<p>When a partial class declaration includes a base class specification it must agree with all other parts that include a base class specification. If no part of a partial class includes a base class specification, the base class becomes <code class="prettyprint">System.Object</code> (<a href="classes.md#base-classes">Base classes</a>).</p>

<h3 id="base-interfaces">Base interfaces</h3>

<p>The set of base interfaces for a type declared in multiple parts is the union of the base interfaces specified on each part. A particular base interface may only be named once on each part, but it is permitted for multiple parts to name the same base interface(s). There must only be one implementation of the members of any given base interface.</p>

<p>In the example
&ldquo;`csharp
partial class C: IA, IB {&hellip;}</p>

<p>partial class C: IC {&hellip;}</p>

<p>partial class C: IA, IB {&hellip;}
&rdquo;<code class="prettyprint">
the set of base interfaces for class</code>C<code class="prettyprint">is</code>IA<code class="prettyprint">,</code>IB<code class="prettyprint">, and</code>IC`.</p>

<p>Typically, each part provides an implementation of the interface(s) declared on that part; however, this is not a requirement. A part may provide the implementation for an interface declared on a different part:
&ldquo;`csharp
partial class X
{
    int IComparable.CompareTo(object o) {&hellip;}
}</p>

<p>partial class X: IComparable
{
    &hellip;
}
&rdquo;`</p>

<h3 id="members">Members</h3>

<p>With the exception of partial methods (<a href="classes.md#partial-methods">Partial methods</a>), the set of members of a type declared in multiple parts is simply the union of the set of members declared in each part. The bodies of all parts of the type declaration share the same declaration space (<a href="basic-concepts.md#declarations">Declarations</a>), and the scope of each member (<a href="basic-concepts.md#scopes">Scopes</a>) extends to the bodies of all the parts. The accessibility domain of any member always includes all the parts of the enclosing type; a <code class="prettyprint">private</code> member declared in one part is freely accessible from another part. It is a compile-time error to declare the same member in more than one part of the type, unless that member is a type with the <code class="prettyprint">partial</code> modifier.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                     <span class="c1">// Error, cannot declare x more than once</span>

    <span class="k">partial</span> <span class="k">class</span> <span class="nc">Inner</span>        <span class="c1">// Ok, Inner is a partial type</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">partial</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>                     <span class="c1">// Error, cannot declare x more than once</span>

    <span class="k">partial</span> <span class="k">class</span> <span class="nc">Inner</span>        <span class="c1">// Ok, Inner is a partial type</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The ordering of members within a type is rarely significant to C# code, but may be significant when interfacing with other languages and environments. In these cases, the ordering of members within a type declared in multiple parts is undefined.</p>

<h3 id="partial-methods">Partial methods</h3>

<p>Partial methods can be defined in one part of a type declaration and implemented in another. The implementation is optional; if no part implements the partial method, the partial method declaration and all calls to it are removed from the type declaration resulting from the combination of the parts.</p>

<p>Partial methods cannot define access modifiers, but are implicitly <code class="prettyprint">private</code>. Their return type must be <code class="prettyprint">void</code>, and their parameters cannot have the <code class="prettyprint">out</code> modifier. The identifier <code class="prettyprint">partial</code> is recognized as a special keyword in a method declaration only if it appears right before the <code class="prettyprint">void</code> type; otherwise it can be used as a normal identifier. A partial method cannot explicitly implement interface methods.</p>

<p>There are two kinds of partial method declarations: If the body of the method declaration is a semicolon, the declaration is said to be a <strong><em>defining partial method declaration</em></strong>. If the body is given as a <em>block</em>, the declaration is said to be an <strong><em>implementing partial method declaration</em></strong>. Across the parts of a type declaration there can be only one defining partial method declaration with a given signature, and there can be only one implementing partial method declaration with a given signature. If an implementing partial method declaration is given, a corresponding defining partial method declaration must exist, and the declarations must match as specified in the following:</p>

<ul>
<li>The declarations must have the same modifiers (although not necessarily in the same order), method name, number of type parameters and number of parameters.</li>
<li>Corresponding parameters in the declarations must have the same modifiers (although not necessarily in the same order) and the same types (modulo differences in type parameter names).</li>
<li>Corresponding type parameters in the declarations must have the same constraints (modulo differences in type parameter names).</li>
</ul>

<p>An implementing partial method declaration can appear in the same part as the corresponding defining partial method declaration.</p>

<p>Only a defining partial method participates in overload resolution. Thus, whether or not an implementing declaration is given, invocation expressions may resolve to invocations of the partial method. Because a partial method always returns <code class="prettyprint">void</code>, such invocation expressions will always be expression statements. Furthermore, because a partial method is implicitly <code class="prettyprint">private</code>, such statements will always occur within one of the parts of the type declaration within which the partial method is declared.</p>

<p>If no part of a partial type declaration contains an implementing declaration for a given partial method, any expression statement invoking it is simply removed from the combined type declaration. Thus the invocation expression, including any constituent expressions, has no effect at run-time. The partial method itself is also removed and will not be a member of the combined type declaration.</p>

<p>If an implementing declaration exist for a given partial method, the invocations of the partial methods are retained. The partial method gives rise to a method declaration similar to the implementing partial method declaration except for the following:</p>

<ul>
<li>The <code class="prettyprint">partial</code> modifier is not included</li>
<li>The attributes in the resulting method declaration are the combined attributes of the defining and the implementing partial method declaration in unspecified order. Duplicates are not removed.</li>
<li>The attributes on the parameters of the resulting method declaration are the combined attributes of the corresponding parameters of the defining and the implementing partial method declaration in unspecified order. Duplicates are not removed.</li>
</ul>

<p>If a defining declaration but not an implementing declaration is given for a partial method M, the following restrictions apply:</p>

<ul>
<li>It is a compile-time error to create a delegate to method (<a href="expressions.md#delegate-creation-expressions">Delegate creation expressions</a>).</li>
<li>It is a compile-time error to refer to <code class="prettyprint">M</code> inside an anonymous function that is converted to an expression tree type (<a href="conversions.md#evaluation-of-anonymous-function-conversions-to-expression-tree-types">Evaluation of anonymous function conversions to expression tree types</a>).</li>
<li>Expressions occurring as part of an invocation of <code class="prettyprint">M</code> do not affect the definite assignment state (<a href="variables.md#definite-assignment">Definite assignment</a>), which can potentially lead to compile-time errors.</li>
<li><code class="prettyprint">M</code> cannot be the entry point for an application (<a href="basic-concepts.md#application-startup">Application Startup</a>).</li>
</ul>

<p>Partial methods are useful for allowing one part of a type declaration to customize the behavior of another part, e.g., one that is generated by a tool. Consider the following partial class declaration:
&ldquo;`csharp
partial class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }</p>

<p>}</p>

<p>partial void OnNameChanging(string newName);</p>

<p>partial void OnNameChanged();
}
&rdquo;`</p>

<p>If this class is compiled without any other parts, the defining partial method declarations and their invocations will be removed, and the resulting combined class declaration will be equivalent to the following:
&ldquo;`csharp
class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set { name = value; }
    }
}
&rdquo;`</p>

<p>Assume that another part is given, however, which provides implementing declarations of the partial methods:
&ldquo;`csharp
partial class Customer
{
    partial void OnNameChanging(string newName)
    {
        Console.WriteLine(&quot;Changing &rdquo; + name + &ldquo; to &rdquo; + newName);
    }</p>

<p>partial void OnNameChanged()
    {
        Console.WriteLine(&ldquo;Changed to &rdquo; + name);
    }
}
&ldquo;`</p>

<p>Then the resulting combined class declaration will be equivalent to the following:
&rdquo;`csharp
class Customer
{
    string name;</p>

<p>public string Name {
        get { return name; }
        set {
            OnNameChanging(value);
            name = value;
            OnNameChanged();
        }</p>

<p>}</p>

<p>void OnNameChanging(string newName)
    {
        Console.WriteLine(&ldquo;Changing &rdquo; + name + &ldquo; to &rdquo; + newName);
    }</p>

<p>void OnNameChanged()
    {
        Console.WriteLine(&ldquo;Changed to &rdquo; + name);
    }
}
&ldquo;`</p>

<h3 id="name-binding">Name binding</h3>

<p>Although each part of an extensible type must be declared within the same namespace, the parts are typically written within different namespace declarations. Thus, different <code class="prettyprint">using</code> directives (<a href="namespaces.md#using-directives">Using directives</a>) may be present for each part. When interpreting simple names (<a href="expressions.md#type-inference">Type inference</a>) within one part, only the <code class="prettyprint">using</code> directives of the namespace declaration(s) enclosing that part are considered. This may result in the same identifier having different meanings in different parts:
&rdquo;`csharp
namespace N
{
    using List = System.Collections.ArrayList;</p>

<p>partial class A
    {
        List x;                // x has type System.Collections.ArrayList
    }
}</p>

<p>namespace N
{
    using List = Widgets.LinkedList;</p>

<p>partial class A
    {
        List y;                // y has type Widgets.LinkedList
    }
}
&ldquo;`</p>

<h2 id="class-members">Class members</h2>

<p>The members of a class consist of the members introduced by its *class_member_declaration*s and the members inherited from the direct base class.</p>
<pre class="highlight plaintext"><code>class_member_declaration
    : constant_declaration
    | field_declaration
    | method_declaration
    | property_declaration
    | event_declaration
    | indexer_declaration
    | operator_declaration
    | constructor_declaration
    | destructor_declaration
    | static_constructor_declaration
    | type_declaration
    ;
</code></pre>
<p>The members of a class type are divided into the following categories:</p>

<ul>
<li> Constants, which represent constant values associated with the class (<a href="classes.md#constants">Constants</a>).</li>
<li> Fields, which are the variables of the class (<a href="classes.md#fields">Fields</a>).</li>
<li> Methods, which implement the computations and actions that can be performed by the class (<a href="classes.md#methods">Methods</a>).</li>
<li> Properties, which define named characteristics and the actions associated with reading and writing those characteristics (<a href="classes.md#properties">Properties</a>).</li>
<li> Events, which define notifications that can be generated by the class (<a href="classes.md#events">Events</a>).</li>
<li> Indexers, which permit instances of the class to be indexed in the same way (syntactically) as arrays (<a href="classes.md#indexers">Indexers</a>).</li>
<li> Operators, which define the expression operators that can be applied to instances of the class (<a href="classes.md#operators">Operators</a>).</li>
<li> Instance constructors, which implement the actions required to initialize instances of the class (<a href="classes.md#instance-constructors">Instance constructors</a>)</li>
<li> Destructors, which implement the actions to be performed before instances of the class are permanently discarded (<a href="classes.md#destructors">Destructors</a>).</li>
<li> Static constructors, which implement the actions required to initialize the class itself (<a href="classes.md#static-constructors">Static constructors</a>).</li>
<li> Types, which represent the types that are local to the class (<a href="classes.md#nested-types">Nested types</a>).</li>
</ul>

<p>Members that can contain executable code are collectively known as the <em>function members</em> of the class type. The function members of a class type are the methods, properties, events, indexers, operators, instance constructors,  destructors, and static constructors of that class type.</p>

<p>A <em>class_declaration</em> creates a new declaration space (<a href="basic-concepts.md#declarations">Declarations</a>), and the <em>class_member_declaration*s immediately contained by the *class_declaration</em> introduce new members into this declaration space. The following rules apply to *class_member_declaration*s:</p>

<ul>
<li> Instance constructors, destructors and static constructors must have the same name as the immediately enclosing class. All other members must have names that differ from the name of the immediately enclosing class.</li>
<li> The name of a constant, field, property, event, or type must differ from the names of all other members declared in the same class.</li>
<li> The name of a method must differ from the names of all other non-methods declared in the same class. In addition, the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of a method must differ from the signatures of all other methods declared in the same class, and two methods declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</li>
<li> The signature of an instance constructor must differ from the signatures of all other instance constructors declared in the same class, and two constructors declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</li>
<li> The signature of an indexer must differ from the signatures of all other indexers declared in the same class.</li>
<li> The signature of an operator must differ from the signatures of all other operators declared in the same class.</li>
</ul>

<p>The inherited members of a class type (<a href="classes.md#inheritance">Inheritance</a>) are not part of the declaration space of a class. Thus, a derived class is allowed to declare a member with the same name or signature as an inherited member (which in effect hides the inherited member).</p>

<h3 id="the-instance-type">The instance type</h3>

<p>Each class declaration has an associated bound type (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>), the <strong><em>instance type</em></strong>. For a generic class declaration, the instance type is formed by creating a constructed type (<a href="types.md#constructed-types">Constructed types</a>) from the type declaration, with each of the supplied type arguments being the corresponding type parameter. Since the instance type uses the type parameters, it can only be used where the type parameters are in scope; that is, inside the class declaration. The instance type is the type of <code class="prettyprint">this</code> for code written inside the class declaration. For non-generic classes, the instance type is simply the declared class. The following shows several class declarations along with their instance types: 
&rdquo;`csharp
class A<T>                           // instance type: A<T>
{
    class B {}                       // instance type: A<T>.B
    class C<U> {}                    // instance type: A<T>.C<U>
}</p>

<p>class D {}                           // instance type: D
&ldquo;`</p>

<h3 id="members-of-constructed-types">Members of constructed types</h3>

<p>The non-inherited members of a constructed type are obtained by substituting, for each <em>type_parameter</em> in the member declaration, the corresponding <em>type_argument</em> of the constructed type. The substitution process is based on the semantic meaning of type declarations, and is not simply textual substitution.</p>

<p>For example, given the generic class declaration
<code class="prettyprint">csharp
class Gen&lt;T,U&gt;
{
    public T[,] a;
    public void G(int i, T t, Gen&lt;U,T&gt; gt) {...}
    public U Prop { get {...} set {...} }
    public int H(double d) {...}
}
</code>
the constructed type <code class="prettyprint">Gen&lt;int[],IComparable&lt;string&gt;&gt;</code> has the following members:
<code class="prettyprint">csharp
public int[,][] a;
public void G(int i, int[] t, Gen&lt;IComparable&lt;string&gt;,int[]&gt; gt) {...}
public IComparable&lt;string&gt; Prop { get {...} set {...} }
public int H(double d) {...}
</code></p>

<p>The type of the member <code class="prettyprint">a</code> in the generic class declaration <code class="prettyprint">Gen</code> is &quot;two-dimensional array of <code class="prettyprint">T</code>&rdquo;, so the type of the member <code class="prettyprint">a</code> in the constructed type above is &ldquo;two-dimensional array of one-dimensional array of <code class="prettyprint">int</code>&rdquo;, or <code class="prettyprint">int[,][]</code>.</p>

<p>Within instance function members, the type of <code class="prettyprint">this</code> is the instance type (<a href="classes.md#the-instance-type">The instance type</a>) of the containing declaration.</p>

<p>All members of a generic class can use type parameters from any enclosing class, either directly or as part of a constructed type. When a particular closed constructed type (<a href="types.md#open-and-closed-types">Open and closed types</a>) is used at run-time, each use of a type parameter is replaced with the actual type argument supplied to the constructed type. For example:
&ldquo;`csharp
class C<V>
{
    public V f1;
    public C<V> f2 = null;</p>

<p>public C(V x) {
        this.f1 = x;
        this.f2 = this;
    }
}</p>

<p>class Application
{
    static void Main() {
        C<int> x1 = new C<int>(1);
        Console.WriteLine(x1.f1);        // Prints 1</p>

<p>C<double> x2 = new C<double>(3.1415);
        Console.WriteLine(x2.f1);        // Prints 3.1415
    }
}
&rdquo;`</p>

<h3 id="inheritance">Inheritance</h3>

<p>A class <strong><em>inherits</em></strong> the members of its direct base class type. Inheritance means that a class implicitly contains all members of its direct base class type, except for the instance constructors, destructors and static constructors of the base class. Some important aspects of inheritance are:</p>

<ul>
<li> Inheritance is transitive. If <code class="prettyprint">C</code> is derived from <code class="prettyprint">B</code>, and <code class="prettyprint">B</code> is derived from <code class="prettyprint">A</code>, then <code class="prettyprint">C</code> inherits the members declared in <code class="prettyprint">B</code> as well as the members declared in <code class="prettyprint">A</code>.</li>
<li> A derived class extends its direct base class. A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</li>
<li> Instance constructors, destructors, and static constructors are not inherited, but all other members are, regardless of their declared accessibility (<a href="basic-concepts.md#member-access">Member access</a>). However, depending on their declared accessibility, inherited members might not be accessible in a derived class.</li>
<li> A derived class can <strong><em>hide</em></strong> (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>) inherited members by declaring new members with the same name or signature. Note however that hiding an inherited member does not remove that member—it merely makes that member inaccessible directly through the derived class.</li>
<li> An instance of a class contains a set of all instance fields declared in the class and its base classes, and an implicit conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from a derived class type to any of its base class types. Thus, a reference to an instance of some derived class can be treated as a reference to an instance of any of its base classes.</li>
<li> A class can declare virtual methods, properties, and indexers, and derived classes can override the implementation of these function members. This enables classes to exhibit polymorphic behavior wherein the actions performed by a function member invocation varies depending on the run-time type of the instance through which that function member is invoked.</li>
</ul>

<p>The inherited member of a constructed class type are the members of the immediate base class type (<a href="classes.md#base-classes">Base classes</a>), which is found by substituting the type arguments of the constructed type for each occurrence of the corresponding type parameters in the <em>class_base</em> specification. These members, in turn, are transformed by substituting, for each <em>type_parameter</em> in the member declaration, the corresponding <em>type_argument</em> of the <em>class_base</em> specification.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">B</span><span class="p">&lt;</span><span class="n">U</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">U</span> <span class="nf">F</span><span class="p">(</span><span class="kt">long</span> <span class="n">index</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">[</span><span class="k">]&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="nf">G</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre>
<p>In the above example, the constructed type <code class="prettyprint">D&lt;int&gt;</code> has a non-inherited member <code class="prettyprint">public int G(string s)</code> obtained by substituting the type argument <code class="prettyprint">int</code> for the type parameter <code class="prettyprint">T</code>. <code class="prettyprint">D&lt;int&gt;</code> also has an inherited member from the class declaration <code class="prettyprint">B</code>. This inherited member is determined by first determining the base class type <code class="prettyprint">B&lt;int[]&gt;</code> of <code class="prettyprint">D&lt;int&gt;</code> by substituting <code class="prettyprint">int</code> for <code class="prettyprint">T</code> in the base class specification <code class="prettyprint">B&lt;T[]&gt;</code>. Then, as a type argument to <code class="prettyprint">B</code>, <code class="prettyprint">int[]</code> is substituted for <code class="prettyprint">U</code> in <code class="prettyprint">public U F(long index)</code>, yielding the inherited member <code class="prettyprint">public int[] F(long index)</code>.</p>

<h3 id="the-new-modifier">The new modifier</h3>

<p>A <em>class_member_declaration</em> is permitted to declare a member with the same name or signature as an inherited member. When this occurs, the derived class member is said to <strong><em>hide</em></strong> the base class member. Hiding an inherited member is not considered an error, but it does cause the compiler to issue a warning. To suppress the warning, the declaration of the derived class member can include a <code class="prettyprint">new</code> modifier to indicate that the derived member is intended to hide the base member. This topic is discussed further in <a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>.</p>

<p>If a <code class="prettyprint">new</code> modifier is included in a declaration that doesn&rsquo;t hide an inherited member, a warning to that effect is issued. This warning is suppressed by removing the <code class="prettyprint">new</code> modifier.</p>

<h3 id="access-modifiers">Access modifiers</h3>

<p>A <em>class_member_declaration</em> can have any one of the five possible kinds of declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>): <code class="prettyprint">public</code>, <code class="prettyprint">protected internal</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>. Except for the <code class="prettyprint">protected internal</code> combination, it is a compile-time error to specify more than one access modifier. When a <em>class_member_declaration</em> does not include any access modifiers, <code class="prettyprint">private</code> is assumed.</p>

<h3 id="constituent-types">Constituent types</h3>

<p>Types that are used in the declaration of a member are called the constituent types of that member. Possible constituent types are the type of a constant, field, property, event, or indexer, the return type of a method or operator, and the parameter types of a method, indexer, operator, or instance constructor. The constituent types of a member must be at least as accessible as that member itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<h3 id="static-and-instance-members">Static and instance members</h3>

<p>Members of a class are either <strong><em>static members</em></strong> or <strong><em>instance members</em></strong>. Generally speaking, it is useful to think of static members as belonging to class types and instance members as belonging to objects (instances of class types).</p>

<p>When a field, method, property, event, operator, or constructor declaration includes a <code class="prettyprint">static</code> modifier, it declares a static member. In addition, a constant or type declaration implicitly declares a static member. Static members have the following characteristics:</p>

<ul>
<li> When a static member <code class="prettyprint">M</code> is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>. It is a compile-time error for <code class="prettyprint">E</code> to denote an instance.</li>
<li> A static field identifies exactly one storage location to be shared by all instances of a given closed class type. No matter how many instances of a given closed class type are created, there is only ever one copy of a static field.</li>
<li> A static function member (method, property, event, operator, or constructor) does not operate on a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in such a function member.</li>
</ul>

<p>When a field, method, property, event, indexer, constructor, or destructor declaration does not include a <code class="prettyprint">static</code> modifier, it declares an instance member. (An instance member is sometimes called a non-static member.) Instance members have the following characteristics:</p>

<ul>
<li> When an instance member <code class="prettyprint">M</code> is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, <code class="prettyprint">E</code> must denote an instance of a type containing <code class="prettyprint">M</code>. It is a binding-time error for <code class="prettyprint">E</code> to denote a type.</li>
<li> Every instance of a class contains a separate set of all instance fields of the class.</li>
<li> An instance function member (method, property, indexer, instance constructor, or destructor) operates on a given instance of the class, and this instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</li>
</ul>

<p>The following example illustrates the rules for accessing static and instance members:
&ldquo;`csharp
class Test
{
    int x;
    static int y;</p>

<p>void F() {
        x = 1;            // Ok, same as this.x = 1
        y = 1;            // Ok, same as Test.y = 1
    }</p>

<p>static void G() {
        x = 1;            // Error, cannot access this.x
        y = 1;            // Ok, same as Test.y = 1
    }</p>

<p>static void Main() {
        Test t = new Test();
        t.x = 1;          // Ok
        t.y = 1;          // Error, cannot access static member through instance
        Test.x = 1;       // Error, cannot access instance member through type
        Test.y = 1;       // Ok
    }
}
&rdquo;`</p>

<p>The <code class="prettyprint">F</code> method shows that in an instance function member, a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) can be used to access both instance members and static members. The <code class="prettyprint">G</code> method shows that in a static function member, it is a compile-time error to access an instance member through a <em>simple_name</em>. The <code class="prettyprint">Main</code> method shows that in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), instance members must be accessed through instances, and static members must be accessed through types.</p>

<h3 id="nested-types">Nested types</h3>

<p>A type declared within a class or struct declaration is called a <strong><em>nested type</em></strong>. A type that is declared within a compilation unit or namespace is called a <strong><em>non-nested type</em></strong>.</p>

<p>In the example
&ldquo;`csharp
using System;</p>

<p>class A
{
    class B
    {
        static void F() {
            Console.WriteLine(&quot;A.B.F&rdquo;);
        }
    }
}
&ldquo;<code class="prettyprint">
class</code>B<code class="prettyprint">is a nested type because it is declared within class</code>A<code class="prettyprint">, and class</code>A` is a non-nested type because it is declared within a compilation unit.</p>

<h4 id="fully-qualified-name">Fully qualified name</h4>

<p>The fully qualified name (<a href="basic-concepts.md#fully-qualified-names">Fully qualified names</a>) for a nested type is <code class="prettyprint">S.N</code> where <code class="prettyprint">S</code> is the fully qualified name of the type in which type <code class="prettyprint">N</code> is declared.</p>

<h4 id="declared-accessibility">Declared accessibility</h4>

<p>Non-nested types can have <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility and have <code class="prettyprint">internal</code> declared accessibility by default. Nested types can have these forms of declared accessibility too, plus one or more additional forms of declared accessibility, depending on whether the containing type is a class or struct:</p>

<ul>
<li> A nested type that is declared in a class can have any of five forms of declared accessibility (<code class="prettyprint">public</code>, <code class="prettyprint">protected internal</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>) and, like other class members, defaults to <code class="prettyprint">private</code> declared accessibility.</li>
<li> A nested type that is declared in a struct can have any of three forms of declared accessibility (<code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code>) and, like other struct members, defaults to <code class="prettyprint">private</code> declared accessibility.</li>
</ul>

<p>The example
&rdquo;`csharp
public class List
{
    // Private data structure
    private class Node
    { 
        public object Data;
        public Node Next;</p>

<p>public Node(object data, Node next) {
            this.Data = data;
            this.Next = next;
        }
    }</p>

<p>private Node first = null;
    private Node last = null;</p>

<p>// Public interface
    public void AddToFront(object o) {&hellip;}
    public void AddToBack(object o) {&hellip;}
    public object RemoveFromFront() {&hellip;}
    public object RemoveFromBack() {&hellip;}
    public int Count { get {&hellip;} }
}
&ldquo;<code class="prettyprint">
declares a private nested class</code>Node`.</p>

<h4 id="hiding">Hiding</h4>

<p>A nested type may hide (<a href="basic-concepts.md#name-hiding">Name hiding</a>) a base member. The <code class="prettyprint">new</code> modifier is permitted on nested type declarations so that hiding can be expressed explicitly. The example
&rdquo;`csharp
using System;</p>

<p>class Base
{
    public static void M() {
        Console.WriteLine(&ldquo;Base.M&rdquo;);
    }
}</p>

<p>class Derived: Base 
{
    new public class M 
    {
        public static void F() {
            Console.WriteLine(&ldquo;Derived.M.F&rdquo;);
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        Derived.M.F();
    }
}
&ldquo;<code class="prettyprint">
shows a nested class</code>M<code class="prettyprint">that hides the method</code>M<code class="prettyprint">defined in</code>Base`.</p>

<h4 id="this-access">this access</h4>

<p>A nested type and its containing type do not have a special relationship with regard to <em>this_access</em> (<a href="expressions.md#this-access">This access</a>). Specifically, <code class="prettyprint">this</code> within a nested type cannot be used to refer to instance members of the containing type. In cases where a nested type needs access to the instance members of its containing type, access can be provided by providing the <code class="prettyprint">this</code> for the instance of the containing type as a constructor argument for the nested type. The following example
&rdquo;`csharp
using System;</p>

<p>class C
{
    int i = 123;</p>

<p>public void F() {
        Nested n = new Nested(this);
        n.G();
    }</p>

<p>public class Nested
    {
        C this_c;</p>

<p>public Nested(C c) {
            this_c = c;
        }</p>

<p>public void G() {
            Console.WriteLine(this_c.i);
        }
    }
}</p>

<p>class Test
{
    static void Main() {
        C c = new C();
        c.F();
    }
}
&ldquo;<code class="prettyprint">
shows this technique. An instance of</code>C<code class="prettyprint">creates an instance of</code>Nested<code class="prettyprint">and passes its own</code>this<code class="prettyprint">to</code>Nested<code class="prettyprint">&#39;s constructor in order to provide subsequent access to</code>C`&lsquo;s instance members.</p>

<h4 id="access-to-private-and-protected-members-of-the-containing-type">Access to private and protected members of the containing type</h4>

<p>A nested type has access to all of the members that are accessible to its containing type, including members of the containing type that have <code class="prettyprint">private</code> and <code class="prettyprint">protected</code> declared accessibility. The example
&rdquo;`csharp
using System;</p>

<p>class C 
{
    private static void F() {
        Console.WriteLine(&ldquo;C.F&rdquo;);
    }</p>

<p>public class Nested 
    {
        public static void G() {
            F();
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        C.Nested.G();
    }
}
&ldquo;<code class="prettyprint">
shows a class</code>C<code class="prettyprint">that contains a nested class</code>Nested<code class="prettyprint">. Within</code>Nested<code class="prettyprint">, the method</code>G<code class="prettyprint">calls the static method</code>F<code class="prettyprint">defined in</code>C<code class="prettyprint">, and</code>F` has private declared accessibility.</p>

<p>A nested type also may access protected members defined in a base type of its containing type. In the example
&rdquo;`csharp
using System;</p>

<p>class Base 
{
    protected void F() {
        Console.WriteLine(&ldquo;Base.F&rdquo;);
    }
}</p>

<p>class Derived: Base 
{
    public class Nested 
    {
        public void G() {
            Derived d = new Derived();
            d.F();        // ok
        }
    }
}</p>

<p>class Test 
{
    static void Main() {
        Derived.Nested n = new Derived.Nested();
        n.G();
    }
}
&ldquo;<code class="prettyprint">
the nested class</code>Derived.Nested<code class="prettyprint">accesses the protected method</code>F<code class="prettyprint">defined in</code>Derived<code class="prettyprint">&#39;s base class,</code>Base<code class="prettyprint">, by calling through an instance of</code>Derived`.</p>

<h4 id="nested-types-in-generic-classes">Nested types in generic classes</h4>

<p>A generic class declaration can contain nested type declarations. The type parameters of the enclosing class can be used within the nested types. A nested type declaration can contain additional type parameters that apply only to the nested type.</p>

<p>Every type declaration contained within a generic class declaration is implicitly a generic type declaration. When writing a reference to a type nested within a generic type, the containing constructed type, including its type arguments, must be named. However, from within the outer class, the nested type can be used without qualification; the instance type of the outer class can be implicitly used when constructing the nested type. The following example shows three different correct ways to refer to a constructed type created from <code class="prettyprint">Inner</code>; the first two are equivalent:
&rdquo;`csharp
class Outer<T>
{
    class Inner<U>
    {
        public static void F(T t, U u) {&hellip;}
    }</p>

<p>static void F(T t) {
        Outer<T>.Inner<string>.F(t, &ldquo;abc&rdquo;);      // These two statements have
        Inner<string>.F(t, &ldquo;abc&rdquo;);               // the same effect</p>

<p>Outer<int>.Inner<string>.F(3, &ldquo;abc&rdquo;);    // This type is different</p>

<p>Outer.Inner<string>.F(t, &ldquo;abc&rdquo;);         // Error, Outer needs type arg
    }
}
&ldquo;`</p>

<p>Although it is bad programming style, a type parameter in a nested type can hide a member or type parameter declared in the outer type:
<code class="prettyprint">csharp
class Outer&lt;T&gt;
{
    class Inner&lt;T&gt;        // Valid, hides Outer&#39;s T
    {
        public T t;       // Refers to Inner&#39;s T
    }
}
</code></p>

<h3 id="reserved-member-names">Reserved member names</h3>

<p>To facilitate the underlying C# run-time implementation, for each source member declaration that is a property, event, or indexer, the implementation must reserve two method signatures based on the kind of the member declaration, its name, and its type. It is a compile-time error for a program to declare a member whose signature matches one of these reserved signatures, even if the underlying run-time implementation does not make use of these reservations.</p>

<p>The reserved names do not introduce declarations, thus they do not participate in member lookup. However, a declaration&rsquo;s associated reserved method signatures do participate in inheritance (<a href="classes.md#inheritance">Inheritance</a>), and can be hidden with the <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>).</p>

<p>The reservation of these names serves three purposes:</p>

<ul>
<li> To allow the underlying implementation to use an ordinary identifier as a method name for get or set access to the C# language feature.</li>
<li> To allow other languages to interoperate using an ordinary identifier as a method name for get or set access to the C# language feature.</li>
<li> To help ensure that the source accepted by one conforming compiler is accepted by another, by making the specifics of reserved member names consistent across all C# implementations.</li>
</ul>

<p>The declaration of a destructor (<a href="classes.md#destructors">Destructors</a>) also causes a signature to be reserved (<a href="classes.md#member-names-reserved-for-destructors">Member names reserved for destructors</a>).</p>

<h4 id="member-names-reserved-for-properties">Member names reserved for properties</h4>

<p>For a property <code class="prettyprint">P</code> (<a href="classes.md#properties">Properties</a>) of type <code class="prettyprint">T</code>, the following signatures are reserved:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">T</span> <span class="nf">get_P</span><span class="p">();</span>
<span class="k">void</span> <span class="nf">set_P</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">);</span>
</code></pre>
<p>Both signatures are reserved, even if the property is read-only or write-only.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public int P {
        get { return 123; }
    }
}</p>

<p>class B: A
{
    new public int get_P() {
        return 456;
    }</p>

<p>new public void set_P(int value) {
    }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        Console.WriteLine(a.P);
        Console.WriteLine(b.P);
        Console.WriteLine(b.get_P());
    }
}
<code class="prettyprint">
a class `A` defines a read-only property `P`, thus reserving signatures for `get_P` and `set_P` methods. A class `B` derives from `A` and hides both of these reserved signatures. The example produces the output:
</code>
123
123
456
&ldquo;`</p>

<h4 id="member-names-reserved-for-events">Member names reserved for events</h4>

<p>For an event <code class="prettyprint">E</code> (<a href="classes.md#events">Events</a>) of delegate type <code class="prettyprint">T</code>, the following signatures are reserved:
<code class="prettyprint">csharp
void add_E(T handler);
void remove_E(T handler);
</code></p>

<h4 id="member-names-reserved-for-indexers">Member names reserved for indexers</h4>

<p>For an indexer (<a href="classes.md#indexers">Indexers</a>) of type <code class="prettyprint">T</code> with parameter-list <code class="prettyprint">L</code>, the following signatures are reserved:
<code class="prettyprint">csharp
T get_Item(L);
void set_Item(L, T value);
</code></p>

<p>Both signatures are reserved, even if the indexer is read-only or write-only.</p>

<p>Furthermore the member name <code class="prettyprint">Item</code> is reserved.</p>

<h4 id="member-names-reserved-for-destructors">Member names reserved for destructors</h4>

<p>For a class containing a destructor (<a href="classes.md#destructors">Destructors</a>), the following signature is reserved:
<code class="prettyprint">csharp
void Finalize();
</code></p>

<h2 id="constants">Constants</h2>

<p>A <strong><em>constant</em></strong> is a class member that represents a constant value: a value that can be computed at compile-time. A <em>constant_declaration</em> introduces one or more constants of a given type.</p>
<pre class="highlight plaintext"><code>constant_declaration
    : attributes? constant_modifier* 'const' type constant_declarators ';'
    ;

constant_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    ;

constant_declarators
    : constant_declarator (',' constant_declarator)*
    ;

constant_declarator
    : identifier '=' constant_expression
    ;
</code></pre>
<p>A <em>constant_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>), and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>). The attributes and modifiers apply to all of the members declared by the <em>constant_declaration</em>. Even though constants are considered static members, a <em>constant_declaration</em> neither requires nor allows a <code class="prettyprint">static</code> modifier. It is an error for the same modifier to appear multiple times in a constant declaration.</p>

<p>The <em>type</em> of a <em>constant_declaration</em> specifies the type of the members introduced by the declaration. The type is followed by a list of <em>constant_declarator*s, each of which introduces a new member. A *constant_declarator</em> consists of an <em>identifier</em> that names the member, followed by an &rdquo;<code class="prettyprint">=</code>&ldquo; token, followed by a <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>) that gives the value of the member.</p>

<p>The <em>type</em> specified in a constant declaration must be <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">double</code>, <code class="prettyprint">decimal</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">string</code>, an <em>enum_type</em>, or a <em>reference_type</em>. Each <em>constant_expression</em> must yield a value of the target type or of a type that can be converted to the target type by an implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>).</p>

<p>The <em>type</em> of a constant must be at least as accessible as the constant itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The value of a constant is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>).</p>

<p>A constant can itself participate in a <em>constant_expression</em>. Thus, a constant may be used in any construct that requires a <em>constant_expression</em>. Examples of such constructs include <code class="prettyprint">case</code> labels, <code class="prettyprint">goto case</code> statements, <code class="prettyprint">enum</code> member declarations, attributes, and other constant declarations.</p>

<p>As described in <a href="expressions.md#constant-expressions">Constant expressions</a>, a <em>constant_expression</em> is an expression that can be fully evaluated at compile-time. Since the only way to create a non-null value of a <em>reference_type</em> other than <code class="prettyprint">string</code> is to apply the <code class="prettyprint">new</code> operator, and since the <code class="prettyprint">new</code> operator is not permitted in a <em>constant_expression</em>, the only possible value for constants of *reference_type*s other than <code class="prettyprint">string</code> is <code class="prettyprint">null</code>.</p>

<p>When a symbolic name for a constant value is desired, but when the type of that value is not permitted in a constant declaration, or when the value cannot be computed at compile-time by a <em>constant_expression</em>, a <code class="prettyprint">readonly</code> field (<a href="classes.md#readonly-fields">Readonly fields</a>) may be used instead.</p>

<p>A constant declaration that declares multiple constants is equivalent to multiple declarations of single constants with the same attributes, modifiers, and type. For example
<code class="prettyprint">csharp
class A
{
    public const double X = 1.0, Y = 2.0, Z = 3.0;
}
</code>
is equivalent to
<code class="prettyprint">csharp
class A
{
    public const double X = 1.0;
    public const double Y = 2.0;
    public const double Z = 3.0;
}
</code></p>

<p>Constants are permitted to depend on other constants within the same program as long as the dependencies are not of a circular nature. The compiler automatically arranges to evaluate the constant declarations in the appropriate order. In the example
&rdquo;`csharp
class A
{
    public const int X = B.Z + 1;
    public const int Y = 10;
}</p>

<p>class B
{
    public const int Z = A.Y + 1;
}
&ldquo;<code class="prettyprint">
the compiler first evaluates</code>A.Y<code class="prettyprint">, then evaluates</code>B.Z<code class="prettyprint">, and finally evaluates</code>A.X<code class="prettyprint">, producing the values</code>10<code class="prettyprint">,</code>11<code class="prettyprint">, and</code>12<code class="prettyprint">. Constant declarations may depend on constants from other programs, but such dependencies are only possible in one direction. Referring to the example above, if</code>A<code class="prettyprint">and</code>B<code class="prettyprint">were declared in separate programs, it would be possible for</code>A.X<code class="prettyprint">to depend on</code>B.Z<code class="prettyprint">, but</code>B.Z<code class="prettyprint">could then not simultaneously depend on</code>A.Y`.</p>

<h2 id="fields">Fields</h2>

<p>A <strong><em>field</em></strong> is a member that represents a variable associated with an object or class. A <em>field_declaration</em> introduces one or more fields of a given type.</p>
<pre class="highlight plaintext"><code>field_declaration
    : attributes? field_modifier* type variable_declarators ';'
    ;

field_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'readonly'
    | 'volatile'
    | field_modifier_unsafe
    ;

variable_declarators
    : variable_declarator (',' variable_declarator)*
    ;

variable_declarator
    : identifier ('=' variable_initializer)?
    ;

variable_initializer
    : expression
    | array_initializer
    ;
</code></pre>
<p>A <em>field_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">new</code> modifier (<a href="classes.md#the-new-modifier">The new modifier</a>), a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), and a <code class="prettyprint">static</code> modifier (<a href="classes.md#static-and-instance-fields">Static and instance fields</a>). In addition, a <em>field_declaration</em> may include a <code class="prettyprint">readonly</code> modifier (<a href="classes.md#readonly-fields">Readonly fields</a>) or a <code class="prettyprint">volatile</code> modifier (<a href="classes.md#volatile-fields">Volatile fields</a>) but not both. The attributes and modifiers apply to all of the members declared by the <em>field_declaration</em>. It is an error for the same modifier to appear multiple times in a field declaration.</p>

<p>The <em>type</em> of a <em>field_declaration</em> specifies the type of the members introduced by the declaration. The type is followed by a list of <em>variable_declarator*s, each of which introduces a new member. A *variable_declarator</em> consists of an <em>identifier</em> that names that member, optionally followed by an &rdquo;<code class="prettyprint">=</code>&ldquo; token and a <em>variable_initializer</em> (<a href="classes.md#variable-initializers">Variable initializers</a>) that gives the initial value of that member.</p>

<p>The <em>type</em> of a field must be at least as accessible as the field itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The value of a field is obtained in an expression using a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>). The value of a non-readonly field is modified using an <em>assignment</em> (<a href="expressions.md#assignment-operators">Assignment operators</a>). The value of a non-readonly field can be both obtained and modified using postfix increment and decrement operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>) and prefix increment and decrement operators (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>).</p>

<p>A field declaration that declares multiple fields is equivalent to multiple declarations of single fields with the same attributes, modifiers, and type. For example
<code class="prettyprint">csharp
class A
{
    public static int X = 1, Y, Z = 100;
}
</code>
is equivalent to
<code class="prettyprint">csharp
class A
{
    public static int X = 1;
    public static int Y;
    public static int Z = 100;
}
</code></p>

<h3 id="static-and-instance-fields">Static and instance fields</h3>

<p>When a field declaration includes a <code class="prettyprint">static</code> modifier, the fields introduced by the declaration are <strong><em>static fields</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the fields introduced by the declaration are <strong><em>instance fields</em></strong>. Static fields and instance fields are two of the several kinds of variables (<a href="variables.md#variables">Variables</a>) supported by C#, and at times they are referred to as <strong><em>static variables</em></strong> and <strong><em>instance variables</em></strong>, respectively.</p>

<p>A static field is not part of a specific instance; instead, it is shared amongst all instances of a closed type (<a href="types.md#open-and-closed-types">Open and closed types</a>). No matter how many instances of a closed class type are created, there is only ever one copy of a static field for the associated application domain.</p>

<p>For example:
&rdquo;`csharp
class C<V>
{
    static int count = 0;</p>

<p>public C() {
        count++;
    }</p>

<p>public static int Count {
        get { return count; }
    }
}</p>

<p>class Application
{
    static void Main() {
        C<int> x1 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 1</p>

<p>C<double> x2 = new C<double>();
        Console.WriteLine(C<int>.Count);        // Prints 1</p>

<p>C<int> x3 = new C<int>();
        Console.WriteLine(C<int>.Count);        // Prints 2
    }
}
&ldquo;`</p>

<p>An instance field belongs to an instance. Specifically, every instance of a class contains a separate set of all the instance fields of that class.</p>

<p>When a field is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static field, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance field, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="readonly-fields">Readonly fields</h3>

<p>When a <em>field_declaration</em> includes a <code class="prettyprint">readonly</code> modifier, the fields introduced by the declaration are <strong><em>readonly fields</em></strong>. Direct assignments to readonly fields can only occur as part of that declaration or in an instance constructor or static constructor in the same class. (A readonly field can be assigned to multiple times in these contexts.) Specifically, direct assignments to a <code class="prettyprint">readonly</code> field are permitted only in the following contexts:</p>

<ul>
<li> In the <em>variable_declarator</em> that introduces the field (by including a <em>variable_initializer</em> in the declaration).</li>
<li> For an instance field, in the instance constructors of the class that contains the field declaration; for a static field, in the static constructor of the class that contains the field declaration. These are also the only contexts in which it is valid to pass a <code class="prettyprint">readonly</code> field as an <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> parameter.</li>
</ul>

<p>Attempting to assign to a <code class="prettyprint">readonly</code> field or pass it as an <code class="prettyprint">out</code> or <code class="prettyprint">ref</code> parameter in any other context is a compile-time error.</p>

<h4 id="using-static-readonly-fields-for-constants">Using static readonly fields for constants</h4>

<p>A <code class="prettyprint">static readonly</code> field is useful when a symbolic name for a constant value is desired, but when the type of the value is not permitted in a <code class="prettyprint">const</code> declaration, or when the value cannot be computed at compile-time. In the example
&rdquo;`csharp
public class Color
{
    public static readonly Color Black = new Color(0, 0, 0);
    public static readonly Color White = new Color(255, 255, 255);
    public static readonly Color Red = new Color(255, 0, 0);
    public static readonly Color Green = new Color(0, 255, 0);
    public static readonly Color Blue = new Color(0, 0, 255);</p>

<p>private byte red, green, blue;</p>

<p>public Color(byte r, byte g, byte b) {
        red = r;
        green = g;
        blue = b;
    }
}
&ldquo;<code class="prettyprint">
the</code>Black<code class="prettyprint">,</code>White<code class="prettyprint">,</code>Red<code class="prettyprint">,</code>Green<code class="prettyprint">, and</code>Blue<code class="prettyprint">members cannot be declared as</code>const<code class="prettyprint">members because their values cannot be computed at compile-time. However, declaring them</code>static readonly` instead has much the same effect.</p>

<h4 id="versioning-of-constants-and-static-readonly-fields">Versioning of constants and static readonly fields</h4>

<p>Constants and readonly fields have different binary versioning semantics. When an expression references a constant, the value of the constant is obtained at compile-time, but when an expression references a readonly field, the value of the field is not obtained until run-time. Consider an application that consists of two separate programs:
&rdquo;`csharp
using System;</p>

<p>namespace Program1
{
    public class Utils
    {
        public static readonly int X = 1;
    }
}</p>

<p>namespace Program2
{
    class Test
    {
        static void Main() {
            Console.WriteLine(Program1.Utils.X);
        }
    }
}
&ldquo;`</p>

<p>The <code class="prettyprint">Program1</code> and <code class="prettyprint">Program2</code> namespaces denote two programs that are compiled separately. Because <code class="prettyprint">Program1.Utils.X</code> is declared as a static readonly field, the value output by the <code class="prettyprint">Console.WriteLine</code> statement is not known at compile-time, but rather is obtained at run-time. Thus, if the value of <code class="prettyprint">X</code> is changed and <code class="prettyprint">Program1</code> is recompiled, the <code class="prettyprint">Console.WriteLine</code> statement will output the new value even if <code class="prettyprint">Program2</code> isn&rsquo;t recompiled. However, had <code class="prettyprint">X</code> been a constant, the value of <code class="prettyprint">X</code> would have been obtained at the time <code class="prettyprint">Program2</code> was compiled, and would remain unaffected by changes in <code class="prettyprint">Program1</code> until <code class="prettyprint">Program2</code> is recompiled.</p>

<h3 id="volatile-fields">Volatile fields</h3>

<p>When a <em>field_declaration</em> includes a <code class="prettyprint">volatile</code> modifier, the fields introduced by that declaration are <strong><em>volatile fields</em></strong>.</p>

<p>For non-volatile fields, optimization techniques that reorder instructions can lead to unexpected and unpredictable results in multi-threaded programs that access fields without synchronization such as that provided by the <em>lock_statement</em> (<a href="statements.md#the-lock-statement">The lock statement</a>). These optimizations can be performed by the compiler, by the run-time system, or by hardware. For volatile fields, such reordering optimizations are restricted:</p>

<ul>
<li> A read of a volatile field is called a <strong><em>volatile read</em></strong>. A volatile read has &quot;acquire semantics&rdquo;; that is, it is guaranteed to occur prior to any references to memory that occur after it in the instruction sequence.</li>
<li> A write of a volatile field is called a <strong><em>volatile write</em></strong>. A volatile write has &ldquo;release semantics&rdquo;; that is, it is guaranteed to happen after any memory references prior to the write instruction in the instruction sequence.</li>
</ul>

<p>These restrictions ensure that all threads will observe volatile writes performed by any other thread in the order in which they were performed. A conforming implementation is not required to provide a single total ordering of volatile writes as seen from all threads of execution. The type of a volatile field must be one of the following:</p>

<ul>
<li> A <em>reference_type</em>.</li>
<li> The type <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">char</code>, <code class="prettyprint">float</code>, <code class="prettyprint">bool</code>, <code class="prettyprint">System.IntPtr</code>, or<code class="prettyprint">System.UIntPtr</code>.</li>
<li> An <em>enum_type</em> having an enum base type of <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">uint</code>.</li>
</ul>

<p>The example
&ldquo;`csharp
using System;
using System.Threading;</p>

<p>class Test
{
    public static int result;<br>
    public static volatile bool finished;</p>

<p>static void Thread2() {
        result = 143;<br>
        finished = true; 
    }</p>

<p>static void Main() {
        finished = false;</p>

<p>// Run Thread2() in a new thread
        new Thread(new ThreadStart(Thread2)).Start();</p>

<p>// Wait for Thread2 to signal that it has a result by setting
        // finished to true.
        for (;;) {
            if (finished) {
                Console.WriteLine(&quot;result = {0}&rdquo;, result);
                return;
            }
        }
    }
}
<code class="prettyprint">
produces the output:
</code>
result = 143
&ldquo;`</p>

<p>In this example, the method <code class="prettyprint">Main</code> starts a new thread that runs the method <code class="prettyprint">Thread2</code>. This method stores a value into a non-volatile field called <code class="prettyprint">result</code>, then stores <code class="prettyprint">true</code> in the volatile field <code class="prettyprint">finished</code>. The main thread waits for the field <code class="prettyprint">finished</code> to be set to <code class="prettyprint">true</code>, then reads the field <code class="prettyprint">result</code>. Since <code class="prettyprint">finished</code> has been declared <code class="prettyprint">volatile</code>, the main thread must read the value <code class="prettyprint">143</code> from the field <code class="prettyprint">result</code>. If the field <code class="prettyprint">finished</code> had not been declared <code class="prettyprint">volatile</code>, then it would be permissible for the store to <code class="prettyprint">result</code> to be visible to the main thread after the store to <code class="prettyprint">finished</code>, and hence for the main thread to read the value <code class="prettyprint">0</code> from the field <code class="prettyprint">result</code>. Declaring <code class="prettyprint">finished</code> as a <code class="prettyprint">volatile</code> field prevents any such inconsistency.</p>

<h3 id="field-initialization">Field initialization</h3>

<p>The initial value of a field, whether it be a static field or an instance field, is the default value (<a href="variables.md#default-values">Default values</a>) of the field&rsquo;s type. It is not possible to observe the value of a field before this default initialization has occurred, and a field is thus never &quot;uninitialized&rdquo;. The example
&ldquo;`csharp
using System;</p>

<p>class Test
{
    static bool b;
    int i;</p>

<p>static void Main() {
        Test t = new Test();
        Console.WriteLine(&quot;b = {0}, i = {1}&rdquo;, b, t.i);
    }
}
<code class="prettyprint">
produces the output
</code>
b = False, i = 0
&ldquo;<code class="prettyprint">
because</code>b<code class="prettyprint">and</code>i` are both automatically initialized to default values.</p>

<h3 id="variable-initializers">Variable initializers</h3>

<p>Field declarations may include *variable_initializer*s. For static fields, variable initializers correspond to assignment statements that are executed during class initialization. For instance fields, variable initializers correspond to assignment statements that are executed when an instance of the class is created.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static double x = Math.Sqrt(2.0);
    int i = 100;
    string s = &ldquo;Hello&rdquo;;</p>

<p>static void Main() {
        Test a = new Test();
        Console.WriteLine(&ldquo;x = {0}, i = {1}, s = {2}&rdquo;, x, a.i, a.s);
    }
}
<code class="prettyprint">
produces the output
</code>
x = 1.4142135623731, i = 100, s = Hello
&ldquo;<code class="prettyprint">
because an assignment to</code>x<code class="prettyprint">occurs when static field initializers execute and assignments to</code>i<code class="prettyprint">and</code>s` occur when the instance field initializers execute.</p>

<p>The default value initialization described in <a href="classes.md#field-initialization">Field initialization</a> occurs for all fields, including fields that have variable initializers. Thus, when a class is initialized, all static fields in that class are first initialized to their default values, and then the static field initializers are executed in textual order. Likewise, when an instance of a class is created, all instance fields in that instance are first initialized to their default values, and then the instance field initializers are executed in textual order.</p>

<p>It is possible for static fields with variable initializers to be observed in their default value state. However, this is strongly discouraged as a matter of style. The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static int a = b + 1;
    static int b = a + 1;</p>

<p>static void Main() {
        Console.WriteLine(&ldquo;a = {0}, b = {1}&rdquo;, a, b);
    }
}
<code class="prettyprint">
exhibits this behavior. Despite the circular definitions of a and b, the program is valid. It results in the output
</code>
a = 1, b = 2
&ldquo;<code class="prettyprint">
because the static fields</code>a<code class="prettyprint">and</code>b<code class="prettyprint">are initialized to</code>0<code class="prettyprint">(the default value for</code>int<code class="prettyprint">) before their initializers are executed. When the initializer for</code>a<code class="prettyprint">runs, the value of</code>b<code class="prettyprint">is zero, and so</code>a<code class="prettyprint">is initialized to</code>1<code class="prettyprint">. When the initializer for</code>b<code class="prettyprint">runs, the value of</code>a<code class="prettyprint">is already</code>1<code class="prettyprint">, and so</code>b<code class="prettyprint">is initialized to</code>2`.</p>

<h4 id="static-field-initialization">Static field initialization</h4>

<p>The static field variable initializers of a class correspond to a sequence of assignments that are executed in the textual order in which they appear in the class declaration. If a static constructor (<a href="classes.md#static-constructors">Static constructors</a>) exists in the class, execution of the static field initializers occurs immediately prior to executing that static constructor. Otherwise, the static field initializers are executed at an implementation-dependent time prior to the first use of a static field of that class. The example
&rdquo;`csharp
using System;</p>

<p>class Test 
{ 
    static void Main() {
        Console.WriteLine(&ldquo;{0} {1}&rdquo;, B.Y, A.X);
    }</p>

<p>public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}</p>

<p>class A
{
    public static int X = Test.F(&ldquo;Init A&rdquo;);
}</p>

<p>class B
{
    public static int Y = Test.F(&ldquo;Init B&rdquo;);
}
<code class="prettyprint">
might produce either the output:
</code>
Init A
Init B
1 1
<code class="prettyprint">
or the output:
</code>
Init B
Init A
1 1
<code class="prettyprint">
because the execution of `X`&#39;s initializer and `Y`&#39;s initializer could occur in either order; they are only constrained to occur before the references to those fields. However, in the example:
</code>csharp
using System;</p>

<p>class Test
{
    static void Main() {
        Console.WriteLine(&ldquo;{0} {1}&rdquo;, B.Y, A.X);
    }</p>

<p>public static int F(string s) {
        Console.WriteLine(s);
        return 1;
    }
}</p>

<p>class A
{
    static A() {}</p>

<p>public static int X = Test.F(&ldquo;Init A&rdquo;);
}</p>

<p>class B
{
    static B() {}</p>

<p>public static int Y = Test.F(&ldquo;Init B&rdquo;);
}
<code class="prettyprint">
the output must be:
</code>
Init B
Init A
1 1
&ldquo;<code class="prettyprint">
because the rules for when static constructors execute (as defined in [Static constructors](classes.md#static-constructors)) provide that</code>B<code class="prettyprint">&#39;s static constructor (and hence</code>B<code class="prettyprint">&#39;s static field initializers) must run before</code>A`&rsquo;s static constructor and field initializers.</p>

<h4 id="instance-field-initialization">Instance field initialization</h4>

<p>The instance field variable initializers of a class correspond to a sequence of assignments that are executed immediately upon entry to any one of the instance constructors (<a href="classes.md#constructor-initializers">Constructor initializers</a>) of that class. The variable initializers are executed in the textual order in which they appear in the class declaration. The class instance creation and initialization process is described further in <a href="classes.md#instance-constructors">Instance constructors</a>.</p>

<p>A variable initializer for an instance field cannot reference the instance being created. Thus, it is a compile-time error to reference <code class="prettyprint">this</code> in a variable initializer, as it is a compile-time error for a variable initializer to reference any instance member through a <em>simple_name</em>. In the example
<code class="prettyprint">csharp
class A
{
    int x = 1;
    int y = x + 1;        // Error, reference to instance member of this
}
</code>
the variable initializer for <code class="prettyprint">y</code> results in a compile-time error because it references a member of the instance being created.</p>

<h2 id="methods">Methods</h2>

<p>A <strong><em>method</em></strong> is a member that implements a computation or action that can be performed by an object or class. Methods are declared using *method_declaration*s:</p>
<pre class="highlight plaintext"><code>method_declaration
    : method_header method_body
    ;

method_header
    : attributes? method_modifier* 'partial'? return_type member_name type_parameter_list?
      '(' formal_parameter_list? ')' type_parameter_constraints_clause*
    ;

method_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | method_modifier_unsafe
    ;

return_type
    : type
    | 'void'
    ;

member_name
    : identifier
    | interface_type '.' identifier
    ;

method_body
    : block
    | '=&gt;' expression ';'
    | ';'
    ;
</code></pre>
<p>A <em>method_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>A declaration has a valid combination of modifiers if all of the following are true:</p>

<ul>
<li> The declaration includes a valid combination of access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>).</li>
<li> The declaration does not include the same modifier multiple times.</li>
<li> The declaration includes at most one of the following modifiers: <code class="prettyprint">static</code>, <code class="prettyprint">virtual</code>, and <code class="prettyprint">override</code>.</li>
<li> The declaration includes at most one of the following modifiers: <code class="prettyprint">new</code> and <code class="prettyprint">override</code>.</li>
<li> If the declaration includes the <code class="prettyprint">abstract</code> modifier, then the declaration does not include any of the following modifiers: <code class="prettyprint">static</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">sealed</code> or <code class="prettyprint">extern</code>.</li>
<li> If the declaration includes the <code class="prettyprint">private</code> modifier, then the declaration does not include any of the following modifiers: <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, or <code class="prettyprint">abstract</code>.</li>
<li> If the declaration includes the <code class="prettyprint">sealed</code> modifier, then the declaration also includes the <code class="prettyprint">override</code> modifier.</li>
<li> If the declaration includes the <code class="prettyprint">partial</code> modifier, then it does not include any of the following modifiers: <code class="prettyprint">new</code>, <code class="prettyprint">public</code>, <code class="prettyprint">protected</code>, <code class="prettyprint">internal</code>, <code class="prettyprint">private</code>, <code class="prettyprint">virtual</code>, <code class="prettyprint">sealed</code>, <code class="prettyprint">override</code>, <code class="prettyprint">abstract</code>, or <code class="prettyprint">extern</code>.</li>
</ul>

<p>A method that has the async modifier is an async function and follows the rules described in <a href="classes.md#iterators">Iterators</a>.</p>

<p>The <em>return_type</em> of a method declaration specifies the type of the value computed and returned by the method. The <em>return_type</em> is <code class="prettyprint">void</code> if the method does not return a value. If the declaration includes the <code class="prettyprint">partial</code> modifier, then the return type must be <code class="prettyprint">void</code>.</p>

<p>The <em>member_name</em> specifies the name of the method. Unless the method is an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>), the <em>member_name</em> is simply an <em>identifier</em>. For an explicit interface member implementation, the <em>member_name</em> consists of an <em>interface_type</em> followed by a &rdquo;<code class="prettyprint">.</code>&ldquo; and an <em>identifier</em>.</p>

<p>The optional <em>type_parameter_list</em> specifies the type parameters of the method (<a href="classes.md#type-parameters">Type parameters</a>). If a <em>type_parameter_list</em> is specified the method is a <strong><em>generic method</em></strong>. If the method has an <code class="prettyprint">extern</code> modifier, a <em>type_parameter_list</em> cannot be specified.</p>

<p>The optional <em>formal_parameter_list</em> specifies the parameters of the method (<a href="classes.md#method-parameters">Method parameters</a>).</p>

<p>The optional <em>type_parameter_constraints_clause*s specify constraints on individual type parameters (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>) and may only be specified if a *type_parameter_list</em> is also supplied, and the method does not have an <code class="prettyprint">override</code> modifier.</p>

<p>The <em>return_type</em> and each of the types referenced in the <em>formal_parameter_list</em> of a method must be at least as accessible as the method itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The <em>method_body</em> is either a semicolon, a <strong><em>statement body</em></strong> or an <strong><em>expression body</em></strong>. A statement body consists of a <em>block</em>, which specifies the statements to execute when the method is invoked. An expression body consists of <code class="prettyprint">=&gt;</code> followed by an <em>expression</em> and a semicolon, and denotes a single expression to perform when the method is invoked. </p>

<p>For <code class="prettyprint">abstract</code> and <code class="prettyprint">extern</code> methods, the <em>method_body</em> consists simply of a semicolon. For <code class="prettyprint">partial</code> methods the <em>method_body</em> may consist of either a semicolon, a block body or an expression body. For all other methods, the <em>method_body</em> is either a block body or an expression body.</p>

<p>If the <em>method_body</em> consists of a semicolon, then the declaration may not include the <code class="prettyprint">async</code> modifier.</p>

<p>The name, the type parameter list and the formal parameter list of a method define the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of the method. Specifically, the signature of a method consists of its name, the number of type parameters and the number, modifiers, and types of its formal parameters. For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.The return type is not part of a method&rsquo;s signature, nor are the names of the type parameters or the formal parameters.</p>

<p>The name of a method must differ from the names of all other non-methods declared in the same class. In addition, the signature of a method must differ from the signatures of all other methods declared in the same class, and two methods declared in the same class may not have signatures that differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</p>

<p>The method&rsquo;s <em>type_parameter*s are in scope throughout the *method_declaration</em>, and can be used to form types throughout that scope in <em>return_type</em>, <em>method_body</em>, and <em>type_parameter_constraints_clause*s but not in *attributes</em>.</p>

<p>All formal parameters and type parameters must have different names.</p>

<h3 id="method-parameters">Method parameters</h3>

<p>The parameters of a method, if any, are declared by the method&rsquo;s <em>formal_parameter_list</em>.</p>
<pre class="highlight plaintext"><code>formal_parameter_list
    : fixed_parameters
    | fixed_parameters ',' parameter_array
    | parameter_array
    ;

fixed_parameters
    : fixed_parameter (',' fixed_parameter)*
    ;

fixed_parameter
    : attributes? parameter_modifier? type identifier default_argument?
    ;

default_argument
    : '=' expression
    ;

parameter_modifier
    : 'ref'
    | 'out'
    | 'this'
    ;

parameter_array
    : attributes? 'params' array_type identifier
    ;
</code></pre>
<p>The formal parameter list consists of one or more comma-separated parameters of which only the last may be a <em>parameter_array</em>.</p>

<p>A <em>fixed_parameter</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), an optional <code class="prettyprint">ref</code>, <code class="prettyprint">out</code> or <code class="prettyprint">this</code> modifier, a <em>type</em>, an <em>identifier</em> and an optional <em>default_argument</em>. Each <em>fixed_parameter</em> declares a parameter of the given type with the given name. The <code class="prettyprint">this</code> modifier designates the method as an extension method and is only allowed on the first parameter of a static method. Extension methods are further described in <a href="classes.md#extension-methods">Extension methods</a>.</p>

<p>A <em>fixed_parameter</em> with a <em>default_argument</em> is known as an <strong><em>optional parameter</em></strong>, whereas a <em>fixed_parameter</em> without a <em>default_argument</em> is a <strong><em>required parameter</em></strong>. A required parameter may not appear after an optional parameter in a <em>formal_parameter_list</em>.</p>

<p>A <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameter cannot have a <em>default_argument</em>. The <em>expression</em> in a <em>default_argument</em> must be one of the following:</p>

<ul>
<li> a <em>constant_expression</em></li>
<li> an expression of the form <code class="prettyprint">new S()</code> where <code class="prettyprint">S</code> is a value type</li>
<li> an expression of the form <code class="prettyprint">default(S)</code> where <code class="prettyprint">S</code> is a value type</li>
</ul>

<p>The <em>expression</em> must be implicitly convertible by an identity or nullable conversion to the type of the parameter.</p>

<p>If optional parameters occur in an implementing partial method declaration (<a href="classes.md#partial-methods">Partial methods</a>) , an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>) or in a single-parameter indexer declaration (<a href="classes.md#indexers">Indexers</a>) the compiler should give a warning, since these members can never be invoked in a way that permits arguments to be omitted.</p>

<p>A <em>parameter_array</em> consists of an optional set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a <code class="prettyprint">params</code> modifier, an <em>array_type</em>, and an <em>identifier</em>. A parameter array declares a single parameter of the given array type with the given name. The <em>array_type</em> of a parameter array must be a single-dimensional array type (<a href="arrays.md#array-types">Array types</a>). In a method invocation, a parameter array permits either a single argument of the given array type to be specified, or it permits zero or more arguments of the array element type to be specified. Parameter arrays are described further in <a href="classes.md#parameter-arrays">Parameter arrays</a>.</p>

<p>A <em>parameter_array</em> may occur after an optional parameter, but cannot have a default value &ndash; the omission of arguments for a <em>parameter_array</em> would instead result in the creation of an empty array.</p>

<p>The following example illustrates different kinds of parameters:
<code class="prettyprint">csharp
public void M(
    ref int      i,
    decimal      d,
    bool         b = false,
    bool?        n = false,
    string       s = &quot;Hello&quot;,
    object       o = null,
    T            t = default(T),
    params int[] a
) { }
</code></p>

<p>In the <em>formal_parameter_list</em> for <code class="prettyprint">M</code>, <code class="prettyprint">i</code> is a required ref parameter, <code class="prettyprint">d</code> is a required value parameter, <code class="prettyprint">b</code>, <code class="prettyprint">s</code>, <code class="prettyprint">o</code> and <code class="prettyprint">t</code> are optional value parameters and <code class="prettyprint">a</code> is a parameter array.</p>

<p>A method declaration creates a separate declaration space for parameters, type parameters and local variables. Names are introduced into this declaration space by the type parameter list and the formal parameter list of the method and by local variable declarations in the <em>block</em> of the method. It is an error for two members of a method declaration space to have the same name. It is an error for the method declaration space and the local variable declaration space of a nested declaration space to contain elements with the same name.</p>

<p>A method invocation (<a href="expressions.md#method-invocations">Method invocations</a>) creates a copy, specific to that invocation, of the formal parameters and local variables of the method, and the argument list of the invocation assigns values or variable references to the newly created formal parameters. Within the <em>block</em> of a method, formal parameters can be referenced by their identifiers in <em>simple_name</em> expressions (<a href="expressions.md#simple-names">Simple names</a>).</p>

<p>There are four kinds of formal parameters:</p>

<ul>
<li> Value parameters, which are declared without any modifiers.</li>
<li> Reference parameters, which are declared with the <code class="prettyprint">ref</code> modifier.</li>
<li> Output parameters, which are declared with the <code class="prettyprint">out</code> modifier.</li>
<li> Parameter arrays, which are declared with the <code class="prettyprint">params</code> modifier.</li>
</ul>

<p>As described in <a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>, the <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> modifiers are part of a method&rsquo;s signature, but the <code class="prettyprint">params</code> modifier is not.</p>

<h4 id="value-parameters">Value parameters</h4>

<p>A parameter declared with no modifiers is a value parameter. A value parameter corresponds to a local variable that gets its initial value from the corresponding argument supplied in the method invocation.</p>

<p>When a formal parameter is a value parameter, the corresponding argument in a method invocation must be an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the formal parameter type.</p>

<p>A method is permitted to assign new values to a value parameter. Such assignments only affect the local storage location represented by the value parameter—they have no effect on the actual argument given in the method invocation.</p>

<h4 id="reference-parameters">Reference parameters</h4>

<p>A parameter declared with a <code class="prettyprint">ref</code> modifier is a reference parameter. Unlike a value parameter, a reference parameter does not create a new storage location. Instead, a reference parameter represents the same storage location as the variable given as the argument in the method invocation.</p>

<p>When a formal parameter is a reference parameter, the corresponding argument in a method invocation must consist of the keyword <code class="prettyprint">ref</code> followed by a <em>variable_reference</em> (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>) of the same type as the formal parameter. A variable must be definitely assigned before it can be passed as a reference parameter.</p>

<p>Within a method, a reference parameter is always considered definitely assigned.</p>

<p>A method declared as an iterator (<a href="classes.md#iterators">Iterators</a>) cannot have reference parameters.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Swap(ref int x, ref int y) {
        int temp = x;
        x = y;
        y = temp;
    }</p>

<p>static void Main() {
        int i = 1, j = 2;
        Swap(ref i, ref j);
        Console.WriteLine(&ldquo;i = {0}, j = {1}&rdquo;, i, j);
    }
}
<code class="prettyprint">
produces the output
</code>
i = 2, j = 1
&ldquo;`</p>

<p>For the invocation of <code class="prettyprint">Swap</code> in <code class="prettyprint">Main</code>, <code class="prettyprint">x</code> represents <code class="prettyprint">i</code> and <code class="prettyprint">y</code> represents <code class="prettyprint">j</code>. Thus, the invocation has the effect of swapping the values of <code class="prettyprint">i</code> and <code class="prettyprint">j</code>.</p>

<p>In a method that takes reference parameters it is possible for multiple names to represent the same storage location. In the example
&rdquo;`csharp
class A
{
    string s;</p>

<p>void F(ref string a, ref string b) {
        s = &ldquo;One&rdquo;;
        a = &ldquo;Two&rdquo;;
        b = &ldquo;Three&rdquo;;
    }</p>

<p>void G() {
        F(ref s, ref s);
    }
}
&ldquo;<code class="prettyprint">
the invocation of</code>F<code class="prettyprint">in</code>G<code class="prettyprint">passes a reference to</code>s<code class="prettyprint">for both</code>a<code class="prettyprint">and</code>b<code class="prettyprint">. Thus, for that invocation, the names</code>s<code class="prettyprint">,</code>a<code class="prettyprint">, and</code>b<code class="prettyprint">all refer to the same storage location, and the three assignments all modify the instance field</code>s`.</p>

<h4 id="output-parameters">Output parameters</h4>

<p>A parameter declared with an <code class="prettyprint">out</code> modifier is an output parameter. Similar to a reference parameter, an output parameter does not create a new storage location. Instead, an output parameter represents the same storage location as the variable given as the argument in the method invocation.</p>

<p>When a formal parameter is an output parameter, the corresponding argument in a method invocation must consist of the keyword <code class="prettyprint">out</code> followed by a <em>variable_reference</em> (<a href="variables.md#precise-rules-for-determining-definite-assignment">Precise rules for determining definite assignment</a>) of the same type as the formal parameter. A variable need not be definitely assigned before it can be passed as an output parameter, but following an invocation where a variable was passed as an output parameter, the variable is considered definitely assigned.</p>

<p>Within a method, just like a local variable, an output parameter is initially considered unassigned and must be definitely assigned before its value is used.</p>

<p>Every output parameter of a method must be definitely assigned before the method returns.</p>

<p>A method declared as a partial method (<a href="classes.md#partial-methods">Partial methods</a>) or an iterator (<a href="classes.md#iterators">Iterators</a>) cannot have output parameters.</p>

<p>Output parameters are typically used in methods that produce multiple return values. For example:
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void SplitPath(string path, out string dir, out string name) {
        int i = path.Length;
        while (i &gt; 0) {
            char ch = path[i - 1];
            if (ch == &rsquo;\&lsquo; || ch == &rsquo;/&lsquo; || ch == &rsquo;:&lsquo;) break;
            i&ndash;;
        }
        dir = path.Substring(0, i);
        name = path.Substring(i);
    }</p>

<p>static void Main() {
        string dir, name;
        SplitPath(&ldquo;c:\Windows\System\hello.txt&rdquo;, out dir, out name);
        Console.WriteLine(dir);
        Console.WriteLine(name);
    }
}
&ldquo;`</p>

<p>The example produces the output:
<code class="prettyprint">
c:\Windows\System\
hello.txt
</code></p>

<p>Note that the <code class="prettyprint">dir</code> and <code class="prettyprint">name</code> variables can be unassigned before they are passed to <code class="prettyprint">SplitPath</code>, and that they are considered definitely assigned following the call.</p>

<h4 id="parameter-arrays">Parameter arrays</h4>

<p>A parameter declared with a <code class="prettyprint">params</code> modifier is a parameter array. If a formal parameter list includes a parameter array, it must be the last parameter in the list and it must be of a single-dimensional array type. For example, the types <code class="prettyprint">string[]</code> and <code class="prettyprint">string[][]</code> can be used as the type of a parameter array, but the type <code class="prettyprint">string[,]</code> can not. It is not possible to combine the <code class="prettyprint">params</code> modifier with the modifiers <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.</p>

<p>A parameter array permits arguments to be specified in one of two ways in a method invocation:</p>

<ul>
<li> The argument given for a parameter array can be a single expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the parameter array type. In this case, the parameter array acts precisely like a value parameter.</li>
<li> Alternatively, the invocation can specify zero or more arguments for the parameter array, where each argument is an expression that is implicitly convertible (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) to the element type of the parameter array. In this case, the invocation creates an instance of the parameter array type with a length corresponding to the number of arguments, initializes the elements of the array instance with the given argument values, and uses the newly created array instance as the actual argument.</li>
</ul>

<p>Except for allowing a variable number of arguments in an invocation, a parameter array is precisely equivalent to a value parameter (<a href="classes.md#value-parameters">Value parameters</a>) of the same type.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params int[] args) {
        Console.Write(&ldquo;Array contains {0} elements:&rdquo;, args.Length);
        foreach (int i in args) 
            Console.Write(&ldquo; {0}&rdquo;, i);
        Console.WriteLine();
    }</p>

<p>static void Main() {
        int[] arr = {1, 2, 3};
        F(arr);
        F(10, 20, 30, 40);
        F();
    }
}
<code class="prettyprint">
produces the output
</code>
Array contains 3 elements: 1 2 3
Array contains 4 elements: 10 20 30 40
Array contains 0 elements:
&ldquo;`</p>

<p>The first invocation of <code class="prettyprint">F</code> simply passes the array <code class="prettyprint">a</code> as a value parameter. The second invocation of <code class="prettyprint">F</code> automatically creates a four-element <code class="prettyprint">int[]</code> with the given element values and passes that array instance as a value parameter. Likewise, the third invocation of <code class="prettyprint">F</code> creates a zero-element <code class="prettyprint">int[]</code> and passes that instance as a value parameter. The second and third invocations are precisely equivalent to writing:
<code class="prettyprint">csharp
F(new int[] {10, 20, 30, 40});
F(new int[] {});
</code></p>

<p>When performing overload resolution, a method with a parameter array may be applicable either in its normal form or in its expanded form (<a href="expressions.md#applicable-function-member">Applicable function member</a>). The expanded form of a method is available only if the normal form of the method is not applicable and only if an applicable method with the same signature as the expanded form is not already declared in the same type.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params object[] a) {
        Console.WriteLine(&ldquo;F(object[])&rdquo;);
    }</p>

<p>static void F() {
        Console.WriteLine(&ldquo;F()&rdquo;);
    }</p>

<p>static void F(object a0, object a1) {
        Console.WriteLine(&ldquo;F(object,object)&rdquo;);
    }</p>

<p>static void Main() {
        F();
        F(1);
        F(1, 2);
        F(1, 2, 3);
        F(1, 2, 3, 4);
    }
}
<code class="prettyprint">
produces the output
</code>
F();
F(object[]);
F(object,object);
F(object[]);
F(object[]);
&ldquo;`</p>

<p>In the example, two of the possible expanded forms of the method with a parameter array are already included in the class as regular methods. These expanded forms are therefore not considered when performing overload resolution, and the first and third method invocations thus select the regular methods. When a class declares a method with a parameter array, it is not uncommon to also include some of the expanded forms as regular methods. By doing so it is possible to avoid the allocation of an array instance that occurs when an expanded form of a method with a parameter array is invoked.</p>

<p>When the type of a parameter array is <code class="prettyprint">object[]</code>, a potential ambiguity arises between the normal form of the method and the expended form for a single <code class="prettyprint">object</code> parameter. The reason for the ambiguity is that an <code class="prettyprint">object[]</code> is itself implicitly convertible to type <code class="prettyprint">object</code>. The ambiguity presents no problem, however, since it can be resolved by inserting a cast if needed.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void F(params object[] args) {
        foreach (object o in args) {
            Console.Write(o.GetType().FullName);
            Console.Write(&ldquo; &rdquo;);
        }
        Console.WriteLine();
    }</p>

<p>static void Main() {
        object[] a = {1, &ldquo;Hello&rdquo;, 123.456};
        object o = a;
        F(a);
        F((object)a);
        F(o);
        F((object[])o);
    }
}
<code class="prettyprint">
produces the output
</code>
System.Int32 System.String System.Double
System.Object[]
System.Object[]
System.Int32 System.String System.Double
&ldquo;`</p>

<p>In the first and last invocations of <code class="prettyprint">F</code>, the normal form of <code class="prettyprint">F</code> is applicable because an implicit conversion exists from the argument type to the parameter type (both are of type <code class="prettyprint">object[]</code>). Thus, overload resolution selects the normal form of <code class="prettyprint">F</code>, and the argument is passed as a regular value parameter. In the second and third invocations, the normal form of <code class="prettyprint">F</code> is not applicable because no implicit conversion exists from the argument type to the parameter type (type <code class="prettyprint">object</code> cannot be implicitly converted to type <code class="prettyprint">object[]</code>). However, the expanded form of <code class="prettyprint">F</code> is applicable, so it is selected by overload resolution. As a result, a one-element <code class="prettyprint">object[]</code> is created by the invocation, and the single element of the array is initialized with the given argument value (which itself is a reference to an <code class="prettyprint">object[]</code>).</p>

<h3 id="static-and-instance-methods">Static and instance methods</h3>

<p>When a method declaration includes a <code class="prettyprint">static</code> modifier, that method is said to be a static method. When no <code class="prettyprint">static</code> modifier is present, the method is said to be an instance method.</p>

<p>A static method does not operate on a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in a static method.</p>

<p>An instance method operates on a given instance of a class, and that instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>).</p>

<p>When a method is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static method, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance method, <code class="prettyprint">E</code> must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="virtual-methods">Virtual methods</h3>

<p>When an instance method declaration includes a <code class="prettyprint">virtual</code> modifier, that method is said to be a virtual method. When no <code class="prettyprint">virtual</code> modifier is present, the method is said to be a non-virtual method.</p>

<p>The implementation of a non-virtual method is invariant: The implementation is the same whether the method is invoked on an instance of the class in which it is declared or an instance of a derived class. In contrast, the implementation of a virtual method can be superseded by derived classes. The process of superseding the implementation of an inherited virtual method is known as <strong><em>overriding</em></strong> that method (<a href="classes.md#override-methods">Override methods</a>).</p>

<p>In a virtual method invocation, the <strong><em>run-time type</em></strong> of the instance for which that invocation takes place determines the actual method implementation to invoke. In a non-virtual method invocation, the <strong><em>compile-time type</em></strong> of the instance is the determining factor. In precise terms, when a method named <code class="prettyprint">N</code> is invoked with an argument list <code class="prettyprint">A</code> on an instance with a compile-time type <code class="prettyprint">C</code> and a run-time type <code class="prettyprint">R</code> (where <code class="prettyprint">R</code> is either <code class="prettyprint">C</code> or a class derived from <code class="prettyprint">C</code>), the invocation is processed as follows:</p>

<ul>
<li> First, overload resolution is applied to <code class="prettyprint">C</code>, <code class="prettyprint">N</code>, and <code class="prettyprint">A</code>, to select a specific method <code class="prettyprint">M</code> from the set of methods declared in and inherited by <code class="prettyprint">C</code>. This is described in <a href="expressions.md#method-invocations">Method invocations</a>.</li>
<li> Then, if <code class="prettyprint">M</code> is a non-virtual method, <code class="prettyprint">M</code> is invoked.</li>
<li> Otherwise, <code class="prettyprint">M</code> is a virtual method, and the most derived implementation of <code class="prettyprint">M</code> with respect to <code class="prettyprint">R</code> is invoked.</li>
</ul>

<p>For every virtual method declared in or inherited by a class, there exists a <strong><em>most derived implementation</em></strong> of the method with respect to that class. The most derived implementation of a virtual method <code class="prettyprint">M</code> with respect to a class <code class="prettyprint">R</code> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">R</code> contains the introducing <code class="prettyprint">virtual</code> declaration of <code class="prettyprint">M</code>, then this is the most derived implementation of <code class="prettyprint">M</code>.</li>
<li> Otherwise, if <code class="prettyprint">R</code> contains an <code class="prettyprint">override</code> of <code class="prettyprint">M</code>, then this is the most derived implementation of <code class="prettyprint">M</code>.</li>
<li> Otherwise, the most derived implementation of <code class="prettyprint">M</code> with respect to <code class="prettyprint">R</code> is the same as the most derived implementation of <code class="prettyprint">M</code> with respect to the direct base class of <code class="prettyprint">R</code>.</li>
</ul>

<p>The following example illustrates the differences between virtual and non-virtual methods:
&rdquo;`csharp
using System;</p>

<p>class A
{
    public void F() { Console.WriteLine(&ldquo;A.F&rdquo;); }</p>

<p>public virtual void G() { Console.WriteLine(&ldquo;A.G&rdquo;); }
}</p>

<p>class B: A
{
    new public void F() { Console.WriteLine(&ldquo;B.F&rdquo;); }</p>

<p>public override void G() { Console.WriteLine(&ldquo;B.G&rdquo;); }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B();
        A a = b;
        a.F();
        b.F();
        a.G();
        b.G();
    }
}
&ldquo;`</p>

<p>In the example, <code class="prettyprint">A</code> introduces a non-virtual method <code class="prettyprint">F</code> and a virtual method <code class="prettyprint">G</code>. The class <code class="prettyprint">B</code> introduces a new non-virtual method <code class="prettyprint">F</code>, thus hiding the inherited <code class="prettyprint">F</code>, and also overrides the inherited method <code class="prettyprint">G</code>. The example produces the output:
<code class="prettyprint">
A.F
B.F
B.G
B.G
</code></p>

<p>Notice that the statement <code class="prettyprint">a.G()</code> invokes <code class="prettyprint">B.G</code>, not <code class="prettyprint">A.G</code>. This is because the run-time type of the instance (which is <code class="prettyprint">B</code>), not the compile-time type of the instance (which is <code class="prettyprint">A</code>), determines the actual method implementation to invoke.</p>

<p>Because methods are allowed to hide inherited methods, it is possible for a class to contain several virtual methods with the same signature. This does not present an ambiguity problem, since all but the most derived method are hidden. In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() { Console.WriteLine(&ldquo;A.F&rdquo;); }
}</p>

<p>class B: A
{
    public override void F() { Console.WriteLine(&ldquo;B.F&rdquo;); }
}</p>

<p>class C: B
{
    new public virtual void F() { Console.WriteLine(&ldquo;C.F&rdquo;); }
}</p>

<p>class D: C
{
    public override void F() { Console.WriteLine(&ldquo;D.F&rdquo;); }
}</p>

<p>class Test
{
    static void Main() {
        D d = new D();
        A a = d;
        B b = d;
        C c = d;
        a.F();
        b.F();
        c.F();
        d.F();
    }
}
<code class="prettyprint">
the `C` and `D` classes contain two virtual methods with the same signature: The one introduced by `A` and the one introduced by `C`. The method introduced by `C` hides the method inherited from `A`. Thus, the override declaration in `D` overrides the method introduced by `C`, and it is not possible for `D` to override the method introduced by `A`. The example produces the output:
</code>
B.F
B.F
D.F
D.F
&ldquo;`</p>

<p>Note that it is possible to invoke the hidden virtual method by accessing an instance of <code class="prettyprint">D</code> through a less derived type in which the method is not hidden.</p>

<h3 id="override-methods">Override methods</h3>

<p>When an instance method declaration includes an <code class="prettyprint">override</code> modifier, the method is said to be an <strong><em>override method</em></strong>. An override method overrides an inherited virtual method with the same signature. Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</p>

<p>The method overridden by an <code class="prettyprint">override</code> declaration is known as the <strong><em>overridden base method</em></strong>. For an override method <code class="prettyprint">M</code> declared in a class <code class="prettyprint">C</code>, the overridden base method is determined by examining each base class type of <code class="prettyprint">C</code>, starting with the direct base class type of <code class="prettyprint">C</code> and continuing with each successive direct base class type, until in a given base class type at least one accessible method is located which has the same signature as <code class="prettyprint">M</code> after substitution of type arguments. For the purposes of locating the overridden base method, a method is considered accessible if it is <code class="prettyprint">public</code>, if it is <code class="prettyprint">protected</code>, if it is <code class="prettyprint">protected internal</code>, or if it is <code class="prettyprint">internal</code> and declared in the same program as <code class="prettyprint">C</code>.</p>

<p>A compile-time error occurs unless all of the following are true for an override declaration:</p>

<ul>
<li> An overridden base method can be located as described above.</li>
<li> There is exactly one such overridden base method. This restriction has effect only if the base class type is a constructed type where the substitution of type arguments makes the signature of two methods the same.</li>
<li> The overridden base method is a virtual, abstract, or override method. In other words, the overridden base method cannot be static or non-virtual.</li>
<li> The overridden base method is not a sealed method.</li>
<li> The override method and the overridden base method have the same return type.</li>
<li> The override declaration and the overridden base method have the same declared accessibility. In other words, an override declaration cannot change the accessibility of the virtual method. However, if the overridden base method is protected internal and it is declared in a different assembly than the assembly containing the override method then the override method&rsquo;s declared accessibility must be protected.</li>
<li> The override declaration does not specify type-parameter-constraints-clauses. Instead the constraints are inherited from the overridden base method. Note that constraints that are type parameters in the overridden method may be replaced by type arguments in the inherited constraint. This can lead to constraints that are not legal when explicitly specified, such as value types or sealed types.</li>
</ul>

<p>The following example demonstrates how the overriding rules work for generic classes:
&rdquo;`csharp
abstract class C<T>
{
    public virtual T F() {&hellip;}
    public virtual C<T> G() {&hellip;}
    public virtual void H(C<T> x) {&hellip;}
}</p>

<p>class D: C<string>
{
    public override string F() {&hellip;}            // Ok
    public override C<string> G() {&hellip;}         // Ok
    public override void H(C<T> x) {&hellip;}        // Error, should be C<string>
}</p>

<p>class E<T,U>: C<U>
{
    public override U F() {&hellip;}                 // Ok
    public override C<U> G() {&hellip;}              // Ok
    public override void H(C<T> x) {&hellip;}        // Error, should be C<U>
}
&ldquo;`</p>

<p>An override declaration can access the overridden base method using a <em>base_access</em> (<a href="expressions.md#base-access">Base access</a>). In the example
&rdquo;`csharp
class A
{
    int x;</p>

<p>public virtual void PrintFields() {
        Console.WriteLine(&ldquo;x = {0}&rdquo;, x);
    }
}</p>

<p>class B: A
{
    int y;</p>

<p>public override void PrintFields() {
        base.PrintFields();
        Console.WriteLine(&ldquo;y = {0}&rdquo;, y);
    }
}
&ldquo;<code class="prettyprint">
the</code>base.PrintFields()<code class="prettyprint">invocation in</code>B<code class="prettyprint">invokes the</code>PrintFields<code class="prettyprint">method declared in</code>A<code class="prettyprint">. A *base_access* disables the virtual invocation mechanism and simply treats the base method as a non-virtual method. Had the invocation in</code>B<code class="prettyprint">been written</code>((A)this).PrintFields()<code class="prettyprint">, it would recursively invoke the</code>PrintFields<code class="prettyprint">method declared in</code>B<code class="prettyprint">, not the one declared in</code>A<code class="prettyprint">, since</code>PrintFields<code class="prettyprint">is virtual and the run-time type of</code>((A)this)<code class="prettyprint">is</code>B`.</p>

<p>Only by including an <code class="prettyprint">override</code> modifier can a method override another method. In all other cases, a method with the same signature as an inherited method simply hides the inherited method. In the example
&rdquo;`csharp
class A
{
    public virtual void F() {}
}</p>

<p>class B: A
{
    public virtual void F() {}        // Warning, hiding inherited F()
}
&ldquo;<code class="prettyprint">
the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">does not include an</code>override<code class="prettyprint">modifier and therefore does not override the</code>F<code class="prettyprint">method in</code>A<code class="prettyprint">. Rather, the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">hides the method in</code>A<code class="prettyprint">, and a warning is reported because the declaration does not include a</code>new` modifier.</p>

<p>In the example
&rdquo;`csharp
class A
{
    public virtual void F() {}
}</p>

<p>class B: A
{
    new private void F() {}        // Hides A.F within body of B
}</p>

<p>class C: B
{
    public override void F() {}    // Ok, overrides A.F
}
&ldquo;<code class="prettyprint">
the</code>F<code class="prettyprint">method in</code>B<code class="prettyprint">hides the virtual</code>F<code class="prettyprint">method inherited from</code>A<code class="prettyprint">. Since the new</code>F<code class="prettyprint">in</code>B<code class="prettyprint">has private access, its scope only includes the class body of</code>B<code class="prettyprint">and does not extend to</code>C<code class="prettyprint">. Therefore, the declaration of</code>F<code class="prettyprint">in</code>C<code class="prettyprint">is permitted to override the</code>F<code class="prettyprint">inherited from</code>A`.</p>

<h3 id="sealed-methods">Sealed methods</h3>

<p>When an instance method declaration includes a <code class="prettyprint">sealed</code> modifier, that method is said to be a <strong><em>sealed method</em></strong>. If an instance method declaration includes the  <code class="prettyprint">sealed</code> modifier, it must also include the <code class="prettyprint">override</code> modifier. Use of the <code class="prettyprint">sealed</code> modifier prevents a derived class from further overriding the method.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }</p>

<p>public virtual void G() {
        Console.WriteLine(&ldquo;A.G&rdquo;);
    }
}</p>

<p>class B: A
{
    sealed override public void F() {
        Console.WriteLine(&ldquo;B.F&rdquo;);
    } </p>

<p>override public void G() {
        Console.WriteLine(&ldquo;B.G&rdquo;);
    } 
}</p>

<p>class C: B
{
    override public void G() {
        Console.WriteLine(&ldquo;C.G&rdquo;);
    } 
}
&ldquo;<code class="prettyprint">
the class</code>B<code class="prettyprint">provides two override methods: an</code>F<code class="prettyprint">method that has the</code>sealed<code class="prettyprint">modifier and a</code>G<code class="prettyprint">method that does not.</code>B<code class="prettyprint">&#39;s use of the sealed</code>modifier<code class="prettyprint">prevents</code>C<code class="prettyprint">from further overriding</code>F`.</p>

<h3 id="abstract-methods">Abstract methods</h3>

<p>When an instance method declaration includes an <code class="prettyprint">abstract</code> modifier, that method is said to be an <strong><em>abstract method</em></strong>. Although an abstract method is implicitly also a virtual method, it cannot have the modifier <code class="prettyprint">virtual</code>.</p>

<p>An abstract method declaration introduces a new virtual method but does not provide an implementation of that method. Instead, non-abstract derived classes are required to provide their own implementation by overriding that method. Because an abstract method provides no actual implementation, the <em>method_body</em> of an abstract method simply consists of a semicolon.</p>

<p>Abstract method declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).</p>

<p>In the example
&rdquo;`csharp
public abstract class Shape
{
    public abstract void Paint(Graphics g, Rectangle r);
}</p>

<p>public class Ellipse: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawEllipse&reg;;
    }
}</p>

<p>public class Box: Shape
{
    public override void Paint(Graphics g, Rectangle r) {
        g.DrawRect&reg;;
    }
}
&ldquo;<code class="prettyprint">
the</code>Shape<code class="prettyprint">class defines the abstract notion of a geometrical shape object that can paint itself. The</code>Paint<code class="prettyprint">method is abstract because there is no meaningful default implementation. The</code>Ellipse<code class="prettyprint">and</code>Box<code class="prettyprint">classes are concrete</code>Shape<code class="prettyprint">implementations. Because these classes are non-abstract, they are required to override the</code>Paint` method and provide an actual implementation.</p>

<p>It is a compile-time error for a <em>base_access</em> (<a href="expressions.md#base-access">Base access</a>) to reference an abstract method. In the example
&rdquo;`csharp
abstract class A
{
    public abstract void F();
}</p>

<p>class B: A
{
    public override void F() {
        base.F();                        // Error, base.F is abstract
    }
}
&ldquo;<code class="prettyprint">
a compile-time error is reported for the</code>base.F()` invocation because it references an abstract method.</p>

<p>An abstract method declaration is permitted to override a virtual method. This allows an abstract class to force re-implementation of the method in derived classes, and makes the original implementation of the method unavailable. In the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public virtual void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }
}</p>

<p>abstract class B: A
{
    public abstract override void F();
}</p>

<p>class C: B
{
    public override void F() {
        Console.WriteLine(&ldquo;C.F&rdquo;);
    }
}
&ldquo;<code class="prettyprint">
class</code>A<code class="prettyprint">declares a virtual method, class</code>B<code class="prettyprint">overrides this method with an abstract method, and class</code>C` overrides the abstract method to provide its own implementation.</p>

<h3 id="external-methods">External methods</h3>

<p>When a method declaration includes an <code class="prettyprint">extern</code> modifier, that method is said to be an <strong><em>external method</em></strong>. External methods are implemented externally, typically using a language other than C#. Because an external method declaration provides no actual implementation, the <em>method_body</em> of an external method simply consists of a semicolon. An external method may not be generic.</p>

<p>The <code class="prettyprint">extern</code> modifier is typically used in conjunction with a <code class="prettyprint">DllImport</code> attribute (<a href="attributes.md#interoperation-with-com-and-win32-components">Interoperation with COM and Win32 components</a>), allowing external methods to be implemented by DLLs (Dynamic Link Libraries). The execution environment may support other mechanisms whereby implementations of external methods can be provided.</p>

<p>When an external method includes a <code class="prettyprint">DllImport</code> attribute, the method declaration must also include a <code class="prettyprint">static</code> modifier. This example demonstrates the use of the <code class="prettyprint">extern</code> modifier and the <code class="prettyprint">DllImport</code> attribute:
&rdquo;`csharp
using System.Text;
using System.Security.Permissions;
using System.Runtime.InteropServices;</p>

<p>class Path
{
    [DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool CreateDirectory(string name, SecurityAttribute sa);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool RemoveDirectory(string name);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern int GetCurrentDirectory(int bufSize, StringBuilder buf);</p>

<p>[DllImport(&ldquo;kernel32&rdquo;, SetLastError=true)]
    static extern bool SetCurrentDirectory(string name);
}
&ldquo;`</p>

<h3 id="partial-methods-recap">Partial methods (recap)</h3>

<p>When a method declaration includes a <code class="prettyprint">partial</code> modifier, that method is said to be a <strong><em>partial method</em></strong>. Partial methods can only be declared as members of partial types (<a href="classes.md#partial-types">Partial types</a>), and are subject to a number of restrictions. Partial methods are further described in <a href="classes.md#partial-methods">Partial methods</a>.</p>

<h3 id="extension-methods">Extension methods</h3>

<p>When the first parameter of a method includes the <code class="prettyprint">this</code> modifier, that method is said to be an <strong><em>extension method</em></strong>. Extension methods can only be declared in non-generic, non-nested static classes. The first parameter of an extension method can have no modifiers other than <code class="prettyprint">this</code>, and the parameter type cannot be a pointer type.</p>

<p>The following is an example of a static class that declares two extension methods:
&rdquo;`csharp
public static class Extensions
{
    public static int ToInt32(this string s) {
        return Int32.Parse(s);
    }</p>

<p>public static T[] Slice<T>(this T[] source, int index, int count) {
        if (index &lt; 0 || count &lt; 0 || source.Length - index &lt; count)
            throw new ArgumentException();
        T[] result = new T[count];
        Array.Copy(source, index, result, 0, count);
        return result;
    }
}
&ldquo;`</p>

<p>An extension method is a regular static method. In addition, where its enclosing static class is in scope, an extension method can be invoked using instance method invocation syntax (<a href="expressions.md#extension-method-invocations">Extension method invocations</a>), using the receiver expression as the first argument.</p>

<p>The following program uses the extension methods declared above:
<code class="prettyprint">csharp
static class Program
{
    static void Main() {
        string[] strings = { &quot;1&quot;, &quot;22&quot;, &quot;333&quot;, &quot;4444&quot; };
        foreach (string s in strings.Slice(1, 2)) {
            Console.WriteLine(s.ToInt32());
        }
    }
}
</code></p>

<p>The <code class="prettyprint">Slice</code> method is available on the <code class="prettyprint">string[]</code>, and the <code class="prettyprint">ToInt32</code> method is available on <code class="prettyprint">string</code>, because they have been declared as extension methods. The meaning of the program is the same as the following, using ordinary static method calls:
<code class="prettyprint">csharp
static class Program
{
    static void Main() {
        string[] strings = { &quot;1&quot;, &quot;22&quot;, &quot;333&quot;, &quot;4444&quot; };
        foreach (string s in Extensions.Slice(strings, 1, 2)) {
            Console.WriteLine(Extensions.ToInt32(s));
        }
    }
}
</code></p>

<h3 id="method-body">Method body</h3>

<p>The <em>method_body</em> of a method declaration consists of either a block body, an expression body or a semicolon.</p>

<p>The <strong><em>result type</em></strong> of a method is <code class="prettyprint">void</code> if the return type is <code class="prettyprint">void</code>, or if the method is async and the return type is <code class="prettyprint">System.Threading.Tasks.Task</code>. Otherwise, the result type of a non-async method is its return type, and the result type of an async method with return type <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code> is <code class="prettyprint">T</code>.</p>

<p>When a method has a <code class="prettyprint">void</code> result type and a block body, <code class="prettyprint">return</code> statements (<a href="statements.md#the-return-statement">The return statement</a>) in the block are not permitted to specify an expression. If execution of the block of a void method completes normally (that is, control flows off the end of the method body), that method simply returns to its current caller.</p>

<p>When a method has a <code class="prettyprint">void</code> result and an expression body, the expression <code class="prettyprint">E</code> must be a <em>statement_expression</em>, and the body is exactly equivalent to a block body of the form <code class="prettyprint">{ E; }</code>.</p>

<p>When a method has a non-void result type and a block body, each <code class="prettyprint">return</code> statement in the block must specify an expression that is implicitly convertible to the result type. The endpoint of a block body of a value-returning method must not be reachable. In other words, in a value-returning method with a block body, control is not permitted to flow off the end of the method body.</p>

<p>When a method has a non-void result type and an expression body, the expression must be implicitly convertible to the result type, and the body is exactly equivalent to a block body of the form <code class="prettyprint">{ return E; }</code>.</p>

<p>In the example
&rdquo;`csharp
class A
{
    public int F() {}            // Error, return value required</p>

<p>public int G() {
        return 1;
    }</p>

<p>public int H(bool b) {
        if (b) {
            return 1;
        }
        else {
            return 0;
        }
    }</p>

<p>public int I(bool b) =&gt; b ? 1 : 0;
}
&ldquo;<code class="prettyprint">
the value-returning</code>F<code class="prettyprint">method results in a compile-time error because control can flow off the end of the method body. The</code>G<code class="prettyprint">and</code>H<code class="prettyprint">methods are correct because all possible execution paths end in a return statement that specifies a return value. The</code>I` method is correct, because its body is equivalent to a statement block with just a single return statement in it.</p>

<h3 id="method-overloading">Method overloading</h3>

<p>The method overload resolution rules are described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<h2 id="properties">Properties</h2>

<p>A <strong><em>property</em></strong> is a member that provides access to a characteristic of an object or a class. Examples of properties include the length of a string, the size of a font, the caption of a window, the name of a customer, and so on. Properties are a natural extension of fields—both are named members with associated types, and the syntax for accessing fields and properties is the same. However, unlike fields, properties do not denote storage locations. Instead, properties have <strong><em>accessors</em></strong> that specify the statements to be executed when their values are read or written. Properties thus provide a mechanism for associating actions with the reading and writing of an object&rsquo;s attributes; furthermore, they permit such attributes to be computed.</p>

<p>Properties are declared using *property_declaration*s:</p>
<pre class="highlight plaintext"><code>property_declaration
    : attributes? property_modifier* type member_name property_body
    ;

property_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | property_modifier_unsafe
    ;

property_body
    : '{' accessor_declarations '}' property_initializer?
    | '=&gt;' expression ';'
    ;

property_initializer
    : '=' variable_initializer
    ;
</code></pre>
<p>A <em>property_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Property declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers.</p>

<p>The <em>type</em> of a property declaration specifies the type of the property introduced by the declaration, and the <em>member_name</em> specifies the name of the property. Unless the property is an explicit interface member implementation, the <em>member_name</em> is simply an <em>identifier</em>. For an explicit interface member implementation (<a href="interfaces.md#explicit-interface-member-implementations">Explicit interface member implementations</a>), the <em>member_name</em> consists of an <em>interface_type</em> followed by a &rdquo;<code class="prettyprint">.</code>&ldquo; and an <em>identifier</em>.</p>

<p>The <em>type</em> of a property must be at least as accessible as the property itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>A <em>property_body</em> may either consist of an <strong><em>accessor body</em></strong> or an <strong><em>expression body</em></strong>. In an accessor body,  <em>accessor_declarations</em>, which must be enclosed in &rdquo;<code class="prettyprint">{</code>&ldquo; and &rdquo;<code class="prettyprint">}</code>&ldquo; tokens, declare the accessors (<a href="classes.md#accessors">Accessors</a>) of the property. The accessors specify the executable statements associated with reading and writing the property.</p>

<p>An expression body consisting of <code class="prettyprint">=&gt;</code> followed by an <em>expression</em> <code class="prettyprint">E</code> and a semicolon is exactly equivalent to the statement body <code class="prettyprint">{ get { return E; } }</code>, and can therefore only be used to specify getter-only properties where the result of the getter is given by a single expression.</p>

<p>A <em>property_initializer</em> may only be given for an automatically implemented property (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>), and causes the initialization of the underlying field of such properties with the value given by the <em>expression</em>.</p>

<p>Even though the syntax for accessing a property is the same as that for a field, a property is not classified as a variable. Thus, it is not possible to pass a property as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> argument.</p>

<p>When a property declaration includes an <code class="prettyprint">extern</code> modifier, the property is said to be an <strong><em>external property</em></strong>. Because an external property declaration provides no actual implementation, each of its <em>accessor_declarations</em> consists of a semicolon.</p>

<h3 id="static-and-instance-properties">Static and instance properties</h3>

<p>When a property declaration includes a <code class="prettyprint">static</code> modifier, the property is said to be a <strong><em>static property</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the property is said to be an <strong><em>instance property</em></strong>.</p>

<p>A static property is not associated with a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in the accessors of a static property.</p>

<p>An instance property is associated with a given instance of a class, and that instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>) in the accessors of that property.</p>

<p>When a property is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static property, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance property, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="accessors">Accessors</h3>

<p>The <em>accessor_declarations</em> of a property specify the executable statements associated with reading and writing that property.</p>
<pre class="highlight plaintext"><code>accessor_declarations
    : get_accessor_declaration set_accessor_declaration?
    | set_accessor_declaration get_accessor_declaration?
    ;

get_accessor_declaration
    : attributes? accessor_modifier? 'get' accessor_body
    ;

set_accessor_declaration
    : attributes? accessor_modifier? 'set' accessor_body
    ;

accessor_modifier
    : 'protected'
    | 'internal'
    | 'private'
    | 'protected' 'internal'
    | 'internal' 'protected'
    ;

accessor_body
    : block
    | ';'
    ;
</code></pre>
<p>The accessor declarations consist of a <em>get_accessor_declaration</em>, a <em>set_accessor_declaration</em>, or both. Each accessor declaration consists of the token <code class="prettyprint">get</code> or <code class="prettyprint">set</code> followed by an optional <em>accessor_modifier</em> and an <em>accessor_body</em>.</p>

<p>The use of *accessor_modifier*s is governed by the following restrictions:</p>

<ul>
<li> An <em>accessor_modifier</em> may not be used in an interface or in an explicit interface member implementation.</li>
<li> For a property or indexer that has no <code class="prettyprint">override</code> modifer, an <em>accessor_modifier</em> is permitted only if the property or indexer has both a <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessor, and then is permitted only on one of those accessors.</li>
<li> For a property or indexer that includes an <code class="prettyprint">override</code> modifer, an accessor must match the <em>accessor_modifier</em>, if any, of the accessor being overridden.</li>
<li> The <em>accessor_modifier</em> must declare an accessibility that is strictly more restrictive than the declared accessibility of the property or indexer itself. To be precise:

<ul>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">public</code>, the <em>accessor_modifier</em> may be either <code class="prettyprint">protected internal</code>, <code class="prettyprint">internal</code>, <code class="prettyprint">protected</code>, or <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">protected internal</code>, the <em>accessor_modifier</em> may be either <code class="prettyprint">internal</code>, <code class="prettyprint">protected</code>, or <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">internal</code> or <code class="prettyprint">protected</code>, the <em>accessor_modifier</em> must be <code class="prettyprint">private</code>.</li>
<li>If the property or indexer has a declared accessibility of <code class="prettyprint">private</code>, no <em>accessor_modifier</em> may be used.</li>
</ul></li>
</ul>

<p>For <code class="prettyprint">abstract</code> and <code class="prettyprint">extern</code> properties, the <em>accessor_body</em> for each accessor specified is simply a semicolon. A non-abstract, non-extern property may have each <em>accessor_body</em> be a semicolon, in which case it is an <strong><em>automatically implemented property</em></strong> (<a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a>). An automatically implemented property must have at least a get accessor. For the accessors of any other non-abstract, non-extern property, the <em>accessor_body</em> is a <em>block</em> which specifies the statements to be executed when the corresponding accessor is invoked.</p>

<p>A <code class="prettyprint">get</code> accessor corresponds to a parameterless method with a return value of the property type. Except as the target of an assignment, when a property is referenced in an expression, the <code class="prettyprint">get</code> accessor of the property is invoked to compute the value of the property (<a href="expressions.md#values-of-expressions">Values of expressions</a>). The body of a <code class="prettyprint">get</code> accessor must conform to the rules for value-returning methods described in <a href="classes.md#method-body">Method body</a>. In particular, all <code class="prettyprint">return</code> statements in the body of a <code class="prettyprint">get</code> accessor must specify an expression that is implicitly convertible to the property type. Furthermore, the endpoint of a <code class="prettyprint">get</code> accessor must not be reachable.</p>

<p>A <code class="prettyprint">set</code> accessor corresponds to a method with a single value parameter of the property type and a <code class="prettyprint">void</code> return type. The implicit parameter of a <code class="prettyprint">set</code> accessor is always named <code class="prettyprint">value</code>. When a property is referenced as the target of an assignment (<a href="expressions.md#assignment-operators">Assignment operators</a>), or as the operand of <code class="prettyprint">++</code> or <code class="prettyprint">--</code> (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>, <a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>), the <code class="prettyprint">set</code> accessor is invoked with an argument (whose value is that of the right-hand side of the assignment or the operand of the <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operator) that provides the new value (<a href="expressions.md#simple-assignment">Simple assignment</a>). The body of a <code class="prettyprint">set</code> accessor must conform to the rules for <code class="prettyprint">void</code> methods described in <a href="classes.md#method-body">Method body</a>. In particular, <code class="prettyprint">return</code> statements in the <code class="prettyprint">set</code> accessor body are not permitted to specify an expression. Since a <code class="prettyprint">set</code> accessor implicitly has a parameter named <code class="prettyprint">value</code>, it is a compile-time error for a local variable or constant declaration in a <code class="prettyprint">set</code> accessor to have that name.</p>

<p>Based on the presence or absence of the <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessors, a property is classified as follows:</p>

<ul>
<li> A property that includes both a <code class="prettyprint">get</code> accessor and a <code class="prettyprint">set</code> accessor is said to be a <strong><em>read-write</em></strong> property.</li>
<li> A property that has only a <code class="prettyprint">get</code> accessor is said to be a <strong><em>read-only</em></strong> property. It is a compile-time error for a read-only property to be the target of an assignment.</li>
<li> A property that has only a <code class="prettyprint">set</code> accessor is said to be a <strong><em>write-only</em></strong> property. Except as the target of an assignment, it is a compile-time error to reference a write-only property in an expression.</li>
</ul>

<p>In the example
&rdquo;`csharp
public class Button: Control
{
    private string caption;</p>

<p>public string Caption {
        get {
            return caption;
        }
        set {
            if (caption != value) {
                caption = value;
                Repaint();
            }
        }
    }</p>

<p>public override void Paint(Graphics g, Rectangle r) {
        // Painting code goes here
    }
}
&ldquo;<code class="prettyprint">
the</code>Button<code class="prettyprint">control declares a public</code>Caption<code class="prettyprint">property. The</code>get<code class="prettyprint">accessor of the</code>Caption<code class="prettyprint">property returns the string stored in the private</code>caption<code class="prettyprint">field. The</code>set<code class="prettyprint">accessor checks if the new value is different from the current value, and if so, it stores the new value and repaints the control. Properties often follow the pattern shown above: The</code>get<code class="prettyprint">accessor simply returns a value stored in a private field, and the</code>set` accessor modifies that private field and then performs any additional actions required to fully update the state of the object.</p>

<p>Given the <code class="prettyprint">Button</code> class above, the following is an example of use of the <code class="prettyprint">Caption</code> property:
<code class="prettyprint">csharp
Button okButton = new Button();
okButton.Caption = &quot;OK&quot;;            // Invokes set accessor
string s = okButton.Caption;        // Invokes get accessor
</code></p>

<p>Here, the <code class="prettyprint">set</code> accessor is invoked by assigning a value to the property, and the <code class="prettyprint">get</code> accessor is invoked by referencing the property in an expression.</p>

<p>The <code class="prettyprint">get</code> and <code class="prettyprint">set</code> accessors of a property are not distinct members, and it is not possible to declare the accessors of a property separately. As such, it is not possible for the two accessors of a read-write property to have different accessibility. The example
&rdquo;`csharp
class A
{
    private string name;</p>

<p>public string Name {                // Error, duplicate member name
        get { return name; }
    }</p>

<p>public string Name {                // Error, duplicate member name
        set { name = value; }
    }
}
&ldquo;`
does not declare a single read-write property. Rather, it declares two properties with the same name, one read-only and one write-only. Since two members declared in the same class cannot have the same name, the example causes a compile-time error to occur.</p>

<p>When a derived class declares a property by the same name as an inherited property, the derived property hides the inherited property with respect to both reading and writing. In the example
&rdquo;`csharp
class A
{
    public int P {
        set {&hellip;}
    }
}</p>

<p>class B: A
{
    new public int P {
        get {&hellip;}
    }
}
<code class="prettyprint">
the `P` property in `B` hides the `P` property in `A` with respect to both reading and writing. Thus, in the statements
</code>csharp
B b = new B();
b.P = 1;          // Error, B.P is read-only
((A)b).P = 1;     // Ok, reference to A.P
&ldquo;<code class="prettyprint">
the assignment to</code>b.P<code class="prettyprint">causes a compile-time error to be reported, since the read-only</code>P<code class="prettyprint">property in</code>B<code class="prettyprint">hides the write-only</code>P<code class="prettyprint">property in</code>A<code class="prettyprint">. Note, however, that a cast can be used to access the hidden</code>P` property.</p>

<p>Unlike public fields, properties provide a separation between an object&rsquo;s internal state and its public interface. Consider the example:
&rdquo;`csharp
class Label
{
    private int x, y;
    private string caption;</p>

<p>public Label(int x, int y, string caption) {
        this.x = x;
        this.y = y;
        this.caption = caption;
    }</p>

<p>public int X {
        get { return x; }
    }</p>

<p>public int Y {
        get { return y; }
    }</p>

<p>public Point Location {
        get { return new Point(x, y); }
    }</p>

<p>public string Caption {
        get { return caption; }
    }
}
&ldquo;`</p>

<p>Here, the <code class="prettyprint">Label</code> class uses two <code class="prettyprint">int</code> fields, <code class="prettyprint">x</code> and <code class="prettyprint">y</code>, to store its location. The location is publicly exposed both as an <code class="prettyprint">X</code> and a <code class="prettyprint">Y</code> property and as a <code class="prettyprint">Location</code> property of type <code class="prettyprint">Point</code>. If, in a future version of <code class="prettyprint">Label</code>, it becomes more convenient to store the location as a <code class="prettyprint">Point</code> internally, the change can be made without affecting the public interface of the class:
&rdquo;`csharp
class Label
{
    private Point location;
    private string caption;</p>

<p>public Label(int x, int y, string caption) {
        this.location = new Point(x, y);
        this.caption = caption;
    }</p>

<p>public int X {
        get { return location.x; }
    }</p>

<p>public int Y {
        get { return location.y; }
    }</p>

<p>public Point Location {
        get { return location; }
    }</p>

<p>public string Caption {
        get { return caption; }
    }
}
&ldquo;`</p>

<p>Had <code class="prettyprint">x</code> and <code class="prettyprint">y</code> instead been <code class="prettyprint">public readonly</code> fields, it would have been impossible to make such a change to the <code class="prettyprint">Label</code> class.</p>

<p>Exposing state through properties is not necessarily any less efficient than exposing fields directly. In particular, when a property is non-virtual and contains only a small amount of code, the execution environment may replace calls to accessors with the actual code of the accessors. This process is known as <strong><em>inlining</em></strong>, and it makes property access as efficient as field access, yet preserves the increased flexibility of properties.</p>

<p>Since invoking a <code class="prettyprint">get</code> accessor is conceptually equivalent to reading the value of a field, it is considered bad programming style for <code class="prettyprint">get</code> accessors to have observable side-effects. In the example
&rdquo;`csharp
class Counter
{
    private int next;</p>

<p>public int Next {
        get { return next++; }
    }
}
&ldquo;<code class="prettyprint">
the value of the</code>Next` property depends on the number of times the property has previously been accessed. Thus, accessing the property produces an observable side-effect, and the property should be implemented as a method instead.</p>

<p>The &quot;no side-effects&rdquo; convention for <code class="prettyprint">get</code> accessors doesn&rsquo;t mean that <code class="prettyprint">get</code> accessors should always be written to simply return values stored in fields. Indeed, <code class="prettyprint">get</code> accessors often compute the value of a property by accessing multiple fields or invoking methods. However, a properly designed <code class="prettyprint">get</code> accessor performs no actions that cause observable changes in the state of the object.</p>

<p>Properties can be used to delay initialization of a resource until the moment it is first referenced. For example:
&ldquo;`csharp
using System.IO;</p>

<p>public class Console
{
    private static TextReader reader;
    private static TextWriter writer;
    private static TextWriter error;</p>

<p>public static TextReader In {
        get {
            if (reader == null) {
                reader = new StreamReader(Console.OpenStandardInput());
            }
            return reader;
        }
    }</p>

<p>public static TextWriter Out {
        get {
            if (writer == null) {
                writer = new StreamWriter(Console.OpenStandardOutput());
            }
            return writer;
        }
    }</p>

<p>public static TextWriter Error {
        get {
            if (error == null) {
                error = new StreamWriter(Console.OpenStandardError());
            }
            return error;
        }
    }
}
&rdquo;`</p>

<p>The <code class="prettyprint">Console</code> class contains three properties, <code class="prettyprint">In</code>, <code class="prettyprint">Out</code>, and <code class="prettyprint">Error</code>, that represent the standard input, output, and error devices, respectively. By exposing these members as properties, the <code class="prettyprint">Console</code> class can delay their initialization until they are actually used. For example, upon first referencing the <code class="prettyprint">Out</code> property, as in
<code class="prettyprint">csharp
Console.Out.WriteLine(&quot;hello, world&quot;);
</code>
the underlying <code class="prettyprint">TextWriter</code> for the output device is created. But if the application makes no reference to the <code class="prettyprint">In</code> and <code class="prettyprint">Error</code> properties, then no objects are created for those devices.</p>

<h3 id="automatically-implemented-properties">Automatically implemented properties</h3>

<p>An automatically implemented property (or <strong><em>auto-property</em></strong> for short), is a non-abstract non-extern property with semicolon-only accessor bodies. Auto-properties must have a get accessor and can optionally have a set accessor.</p>

<p>When a property is specified as an automatically implemented property, a hidden backing field is automatically available for the property, and the accessors are implemented to read from and write to that backing field. If the auto-property has no set accessor, the backing field is considered <code class="prettyprint">readonly</code> (<a href="classes.md#readonly-fields">Readonly fields</a>). Just like a <code class="prettyprint">readonly</code> field, a getter-only auto-property can also be assigned to in the body of a constructor of the enclosing class. Such an assignment assigns directly to the readonly backing field of the property.</p>

<p>An auto-property may optionally have a <em>property_initializer</em>, which is applied directly to the backing field as a <em>variable_initializer</em> (<a href="classes.md#variable-initializers">Variable initializers</a>).</p>

<p>The following example:
<code class="prettyprint">csharp
public class Point {
    public int X { get; set; } = 0;
    public int Y { get; set; } = 0;
}
</code>
is equivalent to the following declaration:
<code class="prettyprint">csharp
public class Point {
    private int __x = 0;
    private int __y = 0;
    public int X { get { return __x; } set { __x = value; } }
    public int Y { get { return __y; } set { __y = value; } }
}
</code></p>

<p>The following example:
<code class="prettyprint">csharp
public class ReadOnlyPoint
{
    public int X { get; }
    public int Y { get; }
    public ReadOnlyPoint(int x, int y) { X = x; Y = y; }
}
</code>
is equivalent to the following declaration:
<code class="prettyprint">csharp
public class ReadOnlyPoint
{
    private readonly int __x;
    private readonly int __y;
    public int X { get { return __x; } }
    public int Y { get { return __y; } }
    public ReadOnlyPoint(int x, int y) { __x = x; __y = y; }
}
</code></p>

<p>Notice that the assignments to the readonly field are legal, because they occur within the constructor.</p>

<h3 id="accessibility">Accessibility</h3>

<p>If an accessor has an <em>accessor_modifier</em>, the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the accessor is determined using the declared accessibility of the <em>accessor_modifier</em>. If an accessor does not have an <em>accessor_modifier</em>, the accessibility domain of the accessor is determined from the declared accessibility of the property or indexer.</p>

<p>The presence of an <em>accessor_modifier</em> never affects member lookup (<a href="expressions.md#operators">Operators</a>) or overload resolution (<a href="expressions.md#overload-resolution">Overload resolution</a>). The modifiers on the property or indexer always determine which property or indexer is bound to, regardless of the context of the access.</p>

<p>Once a particular property or indexer has been selected, the accessibility domains of the specific accessors involved are used to determine if that usage is valid:</p>

<ul>
<li> If the usage is as a value (<a href="expressions.md#values-of-expressions">Values of expressions</a>), the <code class="prettyprint">get</code> accessor must exist and be accessible.</li>
<li> If the usage is as the target of a simple assignment (<a href="expressions.md#simple-assignment">Simple assignment</a>), the <code class="prettyprint">set</code> accessor must exist and be accessible.</li>
<li> If the usage is as the target of compound assignment (<a href="expressions.md#compound-assignment">Compound assignment</a>), or as the target of the <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operators (<a href="expressions.md#function-members">Function members</a>.9, <a href="expressions.md#invocation-expressions">Invocation expressions</a>), both the <code class="prettyprint">get</code> accessors and the <code class="prettyprint">set</code> accessor must exist and be accessible.</li>
</ul>

<p>In the following example, the property <code class="prettyprint">A.Text</code> is hidden by the property <code class="prettyprint">B.Text</code>, even in contexts where only the <code class="prettyprint">set</code> accessor is called. In contrast, the property <code class="prettyprint">B.Count</code> is not accessible to class <code class="prettyprint">M</code>, so the accessible property <code class="prettyprint">A.Count</code> is used instead.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Text</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"hello"</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="m">5</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">string</span> <span class="n">text</span> <span class="p">=</span> <span class="s">"goodbye"</span><span class="p">;</span> 
    <span class="k">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">new</span> <span class="k">public</span> <span class="kt">string</span> <span class="n">Text</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">protected</span> <span class="k">set</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">new</span> <span class="k">protected</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> 
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">count</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">M</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">B</span> <span class="n">b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">B</span><span class="p">();</span>
        <span class="n">b</span><span class="p">.</span><span class="n">Count</span> <span class="p">=</span> <span class="m">12</span><span class="p">;</span>             <span class="c1">// Calls A.Count set accessor</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>          <span class="c1">// Calls A.Count get accessor</span>
        <span class="n">b</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">"howdy"</span><span class="p">;</span>         <span class="c1">// Error, B.Text set accessor not accessible</span>
        <span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Text</span><span class="p">;</span>        <span class="c1">// Calls B.Text get accessor</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An accessor that is used to implement an interface may not have an <em>accessor_modifier</em>. If only one accessor is used to implement an interface, the other accessor may be declared with an <em>accessor_modifier</em>:
&ldquo;`csharp
public interface I
{
    string Prop { get; }
}</p>

<p>public class C: I
{
    public Prop {
        get { return &quot;April&rdquo;; }       // Must not have a modifier here
        internal set {&hellip;}            // Ok, because I.Prop has no set accessor
    }
}
&ldquo;`</p>

<h3 id="virtual-sealed-override-and-abstract-property-accessors">Virtual, sealed, override, and abstract property accessors</h3>

<p>A <code class="prettyprint">virtual</code> property declaration specifies that the accessors of the property are virtual. The <code class="prettyprint">virtual</code> modifier applies to both accessors of a read-write property—it is not possible for only one accessor of a read-write property to be virtual.</p>

<p>An <code class="prettyprint">abstract</code> property declaration specifies that the accessors of the property are virtual, but does not provide an actual implementation of the accessors. Instead, non-abstract derived classes are required to provide their own implementation for the accessors by overriding the property. Because an accessor for an abstract property declaration provides no actual implementation, its <em>accessor_body</em> simply consists of a semicolon.</p>

<p>A property declaration that includes both the <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers specifies that the property is abstract and overrides a base property. The accessors of such a property are also abstract.</p>

<p>Abstract property declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).The accessors of an inherited virtual property can be overridden in a derived class by including a property declaration that specifies an <code class="prettyprint">override</code> directive. This is known as an <strong><em>overriding property declaration</em></strong>. An overriding property declaration does not declare a new property. Instead, it simply specializes the implementations of the accessors of an existing virtual property.</p>

<p>An overriding property declaration must specify the exact same accessibility modifiers, type, and name as the inherited property. If the inherited property has only a single accessor (i.e., if the inherited property is read-only or write-only), the overriding property must include only that accessor. If the inherited property includes both accessors (i.e., if the inherited property is read-write), the overriding property can include either a single accessor or both accessors.</p>

<p>An overriding property declaration may include the <code class="prettyprint">sealed</code> modifier. Use of this modifier prevents a derived class from further overriding the property. The accessors of a sealed property are also sealed.</p>

<p>Except for differences in declaration and invocation syntax, virtual, sealed, override, and abstract accessors behave exactly like virtual, sealed, override and abstract methods. Specifically, the rules described in <a href="classes.md#virtual-methods">Virtual methods</a>, <a href="classes.md#override-methods">Override methods</a>, <a href="classes.md#sealed-methods">Sealed methods</a>, and <a href="classes.md#abstract-methods">Abstract methods</a> apply as if accessors were methods of a corresponding form:</p>

<ul>
<li> A <code class="prettyprint">get</code> accessor corresponds to a parameterless method with a return value of the property type and the same modifiers as the containing property.</li>
<li> A <code class="prettyprint">set</code> accessor corresponds to a method with a single value parameter of the property type, a <code class="prettyprint">void</code> return type, and the same modifiers as the containing property.</li>
</ul>

<p>In the example
&rdquo;`csharp
abstract class A
{
    int y;</p>

<p>public virtual int X {
        get { return 0; }
    }</p>

<p>public virtual int Y {
        get { return y; }
        set { y = value; }
    }</p>

<p>public abstract int Z { get; set; }
}
&ldquo;<code class="prettyprint">
</code>X<code class="prettyprint">is a virtual read-only property,</code>Y<code class="prettyprint">is a virtual read-write property, and</code>Z<code class="prettyprint">is an abstract read-write property. Because</code>Z<code class="prettyprint">is abstract, the containing class</code>A` must also be declared abstract.</p>

<p>A class that derives from <code class="prettyprint">A</code> is show below:
&rdquo;`csharp
class B: A
{
    int z;</p>

<p>public override int X {
        get { return base.X + 1; }
    }</p>

<p>public override int Y {
        set { base.Y = value &lt; 0? 0: value; }
    }</p>

<p>public override int Z {
        get { return z; }
        set { z = value; }
    }
}
&ldquo;`</p>

<p>Here, the declarations of <code class="prettyprint">X</code>, <code class="prettyprint">Y</code>, and <code class="prettyprint">Z</code> are overriding property declarations. Each property declaration exactly matches the accessibility modifiers, type, and name of the corresponding inherited property. The <code class="prettyprint">get</code> accessor of <code class="prettyprint">X</code> and the <code class="prettyprint">set</code> accessor of <code class="prettyprint">Y</code> use the <code class="prettyprint">base</code> keyword to access the inherited accessors. The declaration of <code class="prettyprint">Z</code> overrides both abstract accessors—thus, there are no outstanding abstract function members in <code class="prettyprint">B</code>, and <code class="prettyprint">B</code> is permitted to be a non-abstract class.</p>

<p>When a property is declared as an <code class="prettyprint">override</code>, any overridden accessors must be accessible to the overriding code. In addition, the declared accessibility of both the property or indexer itself, and of the accessors, must match that of the overridden member and accessors. For example:
&rdquo;`csharp
public class B
{
    public virtual int P {
        protected set {&hellip;}
        get {&hellip;}
    }
}</p>

<p>public class D: B
{
    public override int P {
        protected set {&hellip;}            // Must specify protected here
        get {&hellip;}                      // Must not have a modifier here
    }
}
&ldquo;`</p>

<h2 id="events">Events</h2>

<p>An <strong><em>event</em></strong> is a member that enables an object or class to provide notifications. Clients can attach executable code for events by supplying <strong><em>event handlers</em></strong>.</p>

<p>Events are declared using *event_declaration*s:</p>
<pre class="highlight plaintext"><code>event_declaration
    : attributes? event_modifier* 'event' type variable_declarators ';'
    | attributes? event_modifier* 'event' type member_name '{' event_accessor_declarations '}'
    ;

event_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'static'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | event_modifier_unsafe
    ;

event_accessor_declarations
    : add_accessor_declaration remove_accessor_declaration
    | remove_accessor_declaration add_accessor_declaration
    ;

add_accessor_declaration
    : attributes? 'add' block
    ;

remove_accessor_declaration
    : attributes? 'remove' block
    ;
</code></pre>
<p>An <em>event_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>),  <code class="prettyprint">static</code> (<a href="classes.md#static-and-instance-methods">Static and instance methods</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Event declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers.</p>

<p>The <em>type</em> of an event declaration must be a <em>delegate_type</em> (<a href="types.md#reference-types">Reference types</a>), and that <em>delegate_type</em> must be at least as accessible as the event itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>An event declaration may include <em>event_accessor_declarations</em>. However, if it does not, for non-extern, non-abstract events, the compiler supplies them automatically (<a href="classes.md#field-like-events">Field-like events</a>); for extern events, the accessors are provided externally.</p>

<p>An event declaration that omits <em>event_accessor_declarations</em> defines one or more events—one for each of the <em>variable_declarator*s. The attributes and modifiers apply to all of the members declared by such an *event_declaration</em>.</p>

<p>It is a compile-time error for an <em>event_declaration</em> to include both the <code class="prettyprint">abstract</code> modifier and brace-delimited <em>event_accessor_declarations</em>.</p>

<p>When an event declaration includes an <code class="prettyprint">extern</code> modifier, the event is said to be an <strong><em>external event</em></strong>. Because an external event declaration provides no actual implementation, it is an error for it to include both the <code class="prettyprint">extern</code> modifier and <em>event_accessor_declarations</em>.</p>

<p>It is a compile-time error for a <em>variable_declarator</em> of an event declaration with an <code class="prettyprint">abstract</code> or <code class="prettyprint">external</code> modifier to include a <em>variable_initializer</em>.</p>

<p>An event can be used as the left-hand operand of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators (<a href="expressions.md#event-assignment">Event assignment</a>). These operators are used, respectively, to attach event handlers to or to remove event handlers from an event, and the access modifiers of the event control the contexts in which such operations are permitted.</p>

<p>Since <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> are the only operations that are permitted on an event outside the type that declares the event, external code can add and remove handlers for an event, but cannot in any other way obtain or modify the underlying list of event handlers.</p>

<p>In an operation of the form <code class="prettyprint">x += y</code> or <code class="prettyprint">x -= y</code>, when <code class="prettyprint">x</code> is an event and the reference takes place outside the type that contains the declaration of <code class="prettyprint">x</code>, the result of the operation has type <code class="prettyprint">void</code> (as opposed to having the type of <code class="prettyprint">x</code>, with the value of <code class="prettyprint">x</code> after the assignment). This rule prohibits external code from indirectly examining the underlying delegate of an event.</p>

<p>The following example shows how event handlers are attached to instances of the <code class="prettyprint">Button</code> class:
&rdquo;`csharp
public delegate void EventHandler(object sender, EventArgs e);</p>

<p>public class Button: Control
{
    public event EventHandler Click;
}</p>

<p>public class LoginDialog: Form
{
    Button OkButton;
    Button CancelButton;</p>

<p>public LoginDialog() {
        OkButton = new Button(&hellip;);
        OkButton.Click += new EventHandler(OkButtonClick);
        CancelButton = new Button(&hellip;);
        CancelButton.Click += new EventHandler(CancelButtonClick);
    }</p>

<p>void OkButtonClick(object sender, EventArgs e) {
        // Handle OkButton.Click event
    }</p>

<p>void CancelButtonClick(object sender, EventArgs e) {
        // Handle CancelButton.Click event
    }
}
&ldquo;`</p>

<p>Here, the <code class="prettyprint">LoginDialog</code> instance constructor creates two <code class="prettyprint">Button</code> instances and attaches event handlers to the <code class="prettyprint">Click</code> events.</p>

<h3 id="field-like-events">Field-like events</h3>

<p>Within the program text of the class or struct that contains the declaration of an event, certain events can be used like fields. To be used in this way, an event must not be <code class="prettyprint">abstract</code> or <code class="prettyprint">extern</code>, and must not explicitly include <em>event_accessor_declarations</em>. Such an event can be used in any context that permits a field. The field contains a delegate (<a href="delegates.md#delegates">Delegates</a>) which refers to the list of event handlers that have been added to the event. If no event handlers have been added, the field contains <code class="prettyprint">null</code>.</p>

<p>In the example
&rdquo;`csharp
public delegate void EventHandler(object sender, EventArgs e);</p>

<p>public class Button: Control
{
    public event EventHandler Click;</p>

<p>protected void OnClick(EventArgs e) {
        if (Click != null) Click(this, e);
    }</p>

<p>public void Reset() {
        Click = null;
    }
}
&ldquo;<code class="prettyprint">
</code>Click<code class="prettyprint">is used as a field within the</code>Button<code class="prettyprint">class. As the example demonstrates, the field can be examined, modified, and used in delegate invocation expressions. The</code>OnClick<code class="prettyprint">method in the</code>Button<code class="prettyprint">class &quot;raises&quot; the</code>Click` event. The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events. Note that the delegate invocation is preceded by a check that ensures the delegate is non-null.</p>

<p>Outside the declaration of the <code class="prettyprint">Button</code> class, the <code class="prettyprint">Click</code> member can only be used on the left-hand side of the <code class="prettyprint">+=</code> and <code class="prettyprint">-=</code> operators, as in
<code class="prettyprint">csharp
b.Click += new EventHandler(...);
</code>
which appends a delegate to the invocation list of the <code class="prettyprint">Click</code> event, and
<code class="prettyprint">csharp
b.Click -= new EventHandler(...);
</code>
which removes a delegate from the invocation list of the <code class="prettyprint">Click</code> event.</p>

<p>When compiling a field-like event, the compiler automatically creates storage to hold the delegate, and creates accessors for the event that add or remove event handlers to the delegate field. The addition and removal operations are thread safe, and may (but are not required to) be done while holding the lock (<a href="statements.md#the-lock-statement">The lock statement</a>) on the containing object for an instance event, or the type object (<a href="expressions.md#anonymous-object-creation-expressions">Anonymous object creation expressions</a>) for a static event.</p>

<p>Thus, an instance event declaration of the form:
<code class="prettyprint">csharp
class X
{
    public event D Ev;
}
</code>
will be compiled to something equivalent to:
&rdquo;`csharp
class X
{
    private D __Ev;  // field to hold the delegate</p>

<p>public event D Ev {
        add {
            /* add the delegate in a thread safe way */
        }</p>

<p>remove {
            /* remove the delegate in a thread safe way */
        }
    }
}
&ldquo;<code class="prettyprint">
Within the class</code>X<code class="prettyprint">, references to</code>Ev<code class="prettyprint">on the left-hand side of the</code>+=<code class="prettyprint">and</code>-=<code class="prettyprint">operators cause the add and remove accessors to be invoked. All other references to</code>Ev<code class="prettyprint">are compiled to reference the hidden field</code><strong>Ev<code class="prettyprint">instead ([Member access](expressions.md#member-access)). The name &quot;</code></strong>Ev`&rdquo; is arbitrary; the hidden field could have any name or no name at all.</p>

<h3 id="event-accessors">Event accessors</h3>

<p>Event declarations typically omit <em>event_accessor_declarations</em>, as in the <code class="prettyprint">Button</code> example above. One situation for doing so involves the case in which the storage cost of one field per event is not acceptable. In such cases, a class can include <em>event_accessor_declarations</em> and use a private mechanism for storing the list of event handlers.</p>

<p>The <em>event_accessor_declarations</em> of an event specify the executable statements associated with adding and removing event handlers.</p>

<p>The accessor declarations consist of an <em>add_accessor_declaration</em> and a <em>remove_accessor_declaration</em>. Each accessor declaration consists of the token <code class="prettyprint">add</code> or <code class="prettyprint">remove</code> followed by a <em>block</em>. The <em>block</em> associated with an <em>add_accessor_declaration</em> specifies the statements to execute when an event handler is added, and the <em>block</em> associated with a <em>remove_accessor_declaration</em> specifies the statements to execute when an event handler is removed.</p>

<p>Each <em>add_accessor_declaration</em> and <em>remove_accessor_declaration</em> corresponds to a method with a single value parameter of the event type and a <code class="prettyprint">void</code> return type. The implicit parameter of an event accessor is named <code class="prettyprint">value</code>. When an event is used in an event assignment, the appropriate event accessor is used. Specifically, if the assignment operator is <code class="prettyprint">+=</code> then the add accessor is used, and if the assignment operator is <code class="prettyprint">-=</code> then the remove accessor is used. In either case, the right-hand operand of the assignment operator is used as the argument to the event accessor. The block of an <em>add_accessor_declaration</em> or a <em>remove_accessor_declaration</em> must conform to the rules for <code class="prettyprint">void</code> methods described in <a href="classes.md#method-body">Method body</a>. In particular, <code class="prettyprint">return</code> statements in such a block are not permitted to specify an expression.</p>

<p>Since an event accessor implicitly has a parameter named <code class="prettyprint">value</code>, it is a compile-time error for a local variable or constant declared in an event accessor to have that name.</p>

<p>In the example
&ldquo;`csharp
class Control: Component
{
    // Unique keys for events
    static readonly object mouseDownEventKey = new object();
    static readonly object mouseUpEventKey = new object();</p>

<p>// Return event handler associated with key
    protected Delegate GetEventHandler(object key) {&hellip;}</p>

<p>// Add event handler associated with key
    protected void AddEventHandler(object key, Delegate handler) {&hellip;}</p>

<p>// Remove event handler associated with key
    protected void RemoveEventHandler(object key, Delegate handler) {&hellip;}</p>

<p>// MouseDown event
    public event MouseEventHandler MouseDown {
        add { AddEventHandler(mouseDownEventKey, value); }
        remove { RemoveEventHandler(mouseDownEventKey, value); }
    }</p>

<p>// MouseUp event
    public event MouseEventHandler MouseUp {
        add { AddEventHandler(mouseUpEventKey, value); }
        remove { RemoveEventHandler(mouseUpEventKey, value); }
    }</p>

<p>// Invoke the MouseUp event
    protected void OnMouseUp(MouseEventArgs args) {
        MouseEventHandler handler; 
        handler = (MouseEventHandler)GetEventHandler(mouseUpEventKey);
        if (handler != null)
            handler(this, args);
    }
}
&rdquo;<code class="prettyprint">
the</code>Control<code class="prettyprint">class implements an internal storage mechanism for events. The</code>AddEventHandler<code class="prettyprint">method associates a delegate value with a key, the</code>GetEventHandler<code class="prettyprint">method returns the delegate currently associated with a key, and the</code>RemoveEventHandler<code class="prettyprint">method removes a delegate as an event handler for the specified event. Presumably, the underlying storage mechanism is designed such that there is no cost for associating a</code>null` delegate value with a key, and thus unhandled events consume no storage.</p>

<h3 id="static-and-instance-events">Static and instance events</h3>

<p>When an event declaration includes a <code class="prettyprint">static</code> modifier, the event is said to be a <strong><em>static event</em></strong>. When no <code class="prettyprint">static</code> modifier is present, the event is said to be an <strong><em>instance event</em></strong>.</p>

<p>A static event is not associated with a specific instance, and it is a compile-time error to refer to <code class="prettyprint">this</code> in the accessors of a static event.</p>

<p>An instance event is associated with a given instance of a class, and this instance can be accessed as <code class="prettyprint">this</code> (<a href="expressions.md#this-access">This access</a>) in the accessors of that event.</p>

<p>When an event is referenced in a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>) of the form <code class="prettyprint">E.M</code>, if <code class="prettyprint">M</code> is a static event, <code class="prettyprint">E</code> must denote a type containing <code class="prettyprint">M</code>, and if <code class="prettyprint">M</code> is an instance event, E must denote an instance of a type containing <code class="prettyprint">M</code>.</p>

<p>The differences between static and instance members are discussed further in <a href="classes.md#static-and-instance-members">Static and instance members</a>.</p>

<h3 id="virtual-sealed-override-and-abstract-event-accessors">Virtual, sealed, override, and abstract event accessors</h3>

<p>A <code class="prettyprint">virtual</code> event declaration specifies that the accessors of that event are virtual. The <code class="prettyprint">virtual</code> modifier applies to both accessors of an event.</p>

<p>An <code class="prettyprint">abstract</code> event declaration specifies that the accessors of the event are virtual, but does not provide an actual implementation of the accessors. Instead, non-abstract derived classes are required to provide their own implementation for the accessors by overriding the event. Because an abstract event declaration provides no actual implementation, it cannot provide brace-delimited <em>event_accessor_declarations</em>.</p>

<p>An event declaration that includes both the <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers specifies that the event is abstract and overrides a base event. The accessors of such an event are also abstract.</p>

<p>Abstract event declarations are only permitted in abstract classes (<a href="classes.md#abstract-classes">Abstract classes</a>).</p>

<p>The accessors of an inherited virtual event can be overridden in a derived class by including an event declaration that specifies an <code class="prettyprint">override</code> modifier. This is known as an <strong><em>overriding event declaration</em></strong>. An overriding event declaration does not declare a new event. Instead, it simply specializes the implementations of the accessors of an existing virtual event.</p>

<p>An overriding event declaration must specify the exact same accessibility modifiers, type, and name as the overridden event.</p>

<p>An overriding event declaration may include the <code class="prettyprint">sealed</code> modifier. Use of this modifier prevents a derived class from further overriding the event. The accessors of a sealed event are also sealed.</p>

<p>It is a compile-time error for an overriding event declaration to include a <code class="prettyprint">new</code> modifier.</p>

<p>Except for differences in declaration and invocation syntax, virtual, sealed, override, and abstract accessors behave exactly like virtual, sealed, override and abstract methods. Specifically, the rules described in <a href="classes.md#virtual-methods">Virtual methods</a>, <a href="classes.md#override-methods">Override methods</a>, <a href="classes.md#sealed-methods">Sealed methods</a>, and <a href="classes.md#abstract-methods">Abstract methods</a> apply as if accessors were methods of a corresponding form. Each accessor corresponds to a method with a single value parameter of the event type, a <code class="prettyprint">void</code> return type, and the same modifiers as the containing event.</p>

<h2 id="indexers">Indexers</h2>

<p>An <strong><em>indexer</em></strong> is a member that enables an object to be indexed in the same way as an array. Indexers are declared using *indexer_declaration*s:</p>
<pre class="highlight plaintext"><code>indexer_declaration
    : attributes? indexer_modifier* indexer_declarator indexer_body
    ;

indexer_modifier
    : 'new'
    | 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'virtual'
    | 'sealed'
    | 'override'
    | 'abstract'
    | 'extern'
    | indexer_modifier_unsafe
    ;

indexer_declarator
    : type 'this' '[' formal_parameter_list ']'
    | type interface_type '.' 'this' '[' formal_parameter_list ']'
    ;

indexer_body
    : '{' accessor_declarations '}' 
    | '=&gt;' expression ';'
    ;
</code></pre>
<p>An <em>indexer_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), the <code class="prettyprint">new</code> (<a href="classes.md#the-new-modifier">The new modifier</a>), <code class="prettyprint">virtual</code> (<a href="classes.md#virtual-methods">Virtual methods</a>), <code class="prettyprint">override</code> (<a href="classes.md#override-methods">Override methods</a>), <code class="prettyprint">sealed</code> (<a href="classes.md#sealed-methods">Sealed methods</a>), <code class="prettyprint">abstract</code> (<a href="classes.md#abstract-methods">Abstract methods</a>), and <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifiers.</p>

<p>Indexer declarations are subject to the same rules as method declarations (<a href="classes.md#methods">Methods</a>) with regard to valid combinations of modifiers, with the one exception being that the static modifier is not permitted on an indexer declaration.</p>

<p>The modifiers <code class="prettyprint">virtual</code>, <code class="prettyprint">override</code>, and <code class="prettyprint">abstract</code> are mutually exclusive except in one case. The <code class="prettyprint">abstract</code> and <code class="prettyprint">override</code> modifiers may be used together so that an abstract indexer can override a virtual one.</p>

<p>The <em>type</em> of an indexer declaration specifies the element type of the indexer introduced by the declaration. Unless the indexer is an explicit interface member implementation, the <em>type</em> is followed by the keyword <code class="prettyprint">this</code>. For an explicit interface member implementation, the <em>type</em> is followed by an <em>interface_type</em>, a &ldquo;<code class="prettyprint">.</code>&rdquo;, and the keyword <code class="prettyprint">this</code>. Unlike other members, indexers do not have user-defined names.</p>

<p>The <em>formal_parameter_list</em> specifies the parameters of the indexer. The formal parameter list of an indexer corresponds to that of a method (<a href="classes.md#method-parameters">Method parameters</a>), except that at least one parameter must be specified, and that the <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter modifiers are not permitted.</p>

<p>The <em>type</em> of an indexer and each of the types referenced in the <em>formal_parameter_list</em> must be at least as accessible as the indexer itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>An <em>indexer_body</em> may either consist of an <strong><em>accessor body</em></strong> or an <strong><em>expression body</em></strong>. In an accessor body, <em>accessor_declarations</em>, which must be enclosed in &ldquo;<code class="prettyprint">{</code>&rdquo; and &ldquo;<code class="prettyprint">}</code>&rdquo; tokens, declare the accessors (<a href="classes.md#accessors">Accessors</a>) of the property. The accessors specify the executable statements associated with reading and writing the property.</p>

<p>An expression body consisting of &ldquo;<code class="prettyprint">=&gt;</code>&rdquo; followed by an expression <code class="prettyprint">E</code> and a semicolon is exactly equivalent to the statement body <code class="prettyprint">{ get { return E; } }</code>, and can therefore only be used to specify getter-only indexers where the result of the getter is given by a single expression.</p>

<p>Even though the syntax for accessing an indexer element is the same as that for an array element, an indexer element is not classified as a variable. Thus, it is not possible to pass an indexer element as a <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> argument.</p>

<p>The formal parameter list of an indexer defines the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of the indexer. Specifically, the signature of an indexer consists of the number and types of its formal parameters. The element type and names of the formal parameters are not part of an indexer&rsquo;s signature.</p>

<p>The signature of an indexer must differ from the signatures of all other indexers declared in the same class.</p>

<p>Indexers and properties are very similar in concept, but differ in the following ways:</p>

<ul>
<li> A property is identified by its name, whereas an indexer is identified by its signature.</li>
<li> A property is accessed through a <em>simple_name</em> (<a href="expressions.md#simple-names">Simple names</a>) or a <em>member_access</em> (<a href="expressions.md#member-access">Member access</a>), whereas an indexer element is accessed through an <em>element_access</em> (<a href="expressions.md#indexer-access">Indexer access</a>).</li>
<li> A property can be a <code class="prettyprint">static</code> member, whereas an indexer is always an instance member.</li>
<li> A <code class="prettyprint">get</code> accessor of a property corresponds to a method with no parameters, whereas a <code class="prettyprint">get</code> accessor of an indexer corresponds to a method with the same formal parameter list as the indexer.</li>
<li> A <code class="prettyprint">set</code> accessor of a property corresponds to a method with a single parameter named <code class="prettyprint">value</code>, whereas a <code class="prettyprint">set</code> accessor of an indexer corresponds to a method with the same formal parameter list as the indexer, plus an additional parameter named <code class="prettyprint">value</code>.</li>
<li> It is a compile-time error for an indexer accessor to declare a local variable with the same name as an indexer parameter.</li>
<li> In an overriding property declaration, the inherited property is accessed using the syntax <code class="prettyprint">base.P</code>, where <code class="prettyprint">P</code> is the property name. In an overriding indexer declaration, the inherited indexer is accessed using the syntax <code class="prettyprint">base[E]</code>, where <code class="prettyprint">E</code> is a comma separated list of expressions.</li>
<li> There is no concept of an &ldquo;automatically implemented indexer&rdquo;. It is an error to have a non-abstract, non-external indexer with semicolon accessors.</li>
</ul>

<p>Aside from these differences, all rules defined in <a href="classes.md#accessors">Accessors</a> and <a href="classes.md#automatically-implemented-properties">Automatically implemented properties</a> apply to indexer accessors as well as to property accessors.</p>

<p>When an indexer declaration includes an <code class="prettyprint">extern</code> modifier, the indexer is said to be an <strong><em>external indexer</em></strong>. Because an external indexer declaration provides no actual implementation, each of its <em>accessor_declarations</em> consists of a semicolon.</p>

<p>The example below declares a <code class="prettyprint">BitArray</code> class that implements an indexer for accessing the individual bits in the bit array.
&ldquo;`csharp
using System;</p>

<p>class BitArray
{
    int[] bits;
    int length;</p>

<p>public BitArray(int length) {
        if (length &lt; 0) throw new ArgumentException();
        bits = new int[((length - 1) &gt;&gt; 5) + 1];
        this.length = length;
    }</p>

<p>public int Length {
        get { return length; }
    }</p>

<p>public bool this[int index] {
        get {
            if (index &lt; 0 || index &gt;= length) {
                throw new IndexOutOfRangeException();
            }
            return (bits[index &gt;&gt; 5] &amp; 1 &lt;&lt; index) != 0;
        }
        set {
            if (index &lt; 0 || index &gt;= length) {
                throw new IndexOutOfRangeException();
            }
            if (value) {
                bits[index &gt;&gt; 5] |= 1 &lt;&lt; index;
            }
            else {
                bits[index &gt;&gt; 5] &amp;= ~(1 &lt;&lt; index);
            }
        }
    }
}
&rdquo;`</p>

<p>An instance of the <code class="prettyprint">BitArray</code> class consumes substantially less memory than a corresponding <code class="prettyprint">bool[]</code> (since each value of the former occupies only one bit instead of the latter&rsquo;s one byte), but it permits the same operations as a <code class="prettyprint">bool[]</code>.</p>

<p>The following <code class="prettyprint">CountPrimes</code> class uses a <code class="prettyprint">BitArray</code> and the classical &ldquo;sieve&rdquo; algorithm to compute the number of primes between 1 and a given maximum:
&ldquo;`csharp
class CountPrimes
{
    static int Count(int max) {
        BitArray flags = new BitArray(max + 1);
        int count = 1;
        for (int i = 2; i &lt;= max; i++) {
            if (!flags[i]) {
                for (int j = i * 2; j &lt;= max; j += i) flags[j] = true;
                count++;
            }
        }
        return count;
    }</p>

<p>static void Main(string[] args) {
        int max = int.Parse(args[0]);
        int count = Count(max);
        Console.WriteLine(&quot;Found {0} primes between 1 and {1}&rdquo;, count, max);
    }
}
&ldquo;`</p>

<p>Note that the syntax for accessing elements of the <code class="prettyprint">BitArray</code> is precisely the same as for a <code class="prettyprint">bool[]</code>.</p>

<p>The following example shows a 26 * 10 grid class that has an indexer with two parameters. The first parameter is required to be an upper- or lowercase letter in the range A-Z, and the second is required to be an integer in the range 0-9.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Grid</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NumRows</span> <span class="p">=</span> <span class="m">26</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NumCols</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>

    <span class="kt">int</span><span class="p">[,]</span> <span class="n">cells</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">NumRows</span><span class="p">,</span> <span class="n">NumCols</span><span class="p">];</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="k">this</span><span class="p">[</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="n">c</span> <span class="p">=</span> <span class="n">Char</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">&lt;</span> <span class="sc">'A'</span> <span class="p">||</span> <span class="n">c</span> <span class="p">&gt;</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">col</span> <span class="p">&gt;=</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">cells</span><span class="p">[</span><span class="n">c</span> <span class="p">-</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">col</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">set</span> <span class="p">{</span>
            <span class="n">c</span> <span class="p">=</span> <span class="n">Char</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">&lt;</span> <span class="sc">'A'</span> <span class="p">||</span> <span class="n">c</span> <span class="p">&gt;</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">col</span> <span class="p">&gt;=</span> <span class="n">NumCols</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">cells</span><span class="p">[</span><span class="n">c</span> <span class="p">-</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="indexer-overloading">Indexer overloading</h3>

<p>The indexer overload resolution rules are described in <a href="expressions.md#type-inference">Type inference</a>.</p>

<h2 id="operators">Operators</h2>

<p>An <strong><em>operator</em></strong> is a member that defines the meaning of an expression operator that can be applied to instances of the class. Operators are declared using *operator_declaration*s:</p>
<pre class="highlight plaintext"><code>operator_declaration
    : attributes? operator_modifier+ operator_declarator operator_body
    ;

operator_modifier
    : 'public'
    | 'static'
    | 'extern'
    | operator_modifier_unsafe
    ;

operator_declarator
    : unary_operator_declarator
    | binary_operator_declarator
    | conversion_operator_declarator
    ;

unary_operator_declarator
    : type 'operator' overloadable_unary_operator '(' type identifier ')'
    ;

overloadable_unary_operator
    : '+' | '-' | '!' | '~' | '++' | '--' | 'true' | 'false'
    ;

binary_operator_declarator
    : type 'operator' overloadable_binary_operator '(' type identifier ',' type identifier ')'
    ;

overloadable_binary_operator
    : '+'   | '-'   | '*'   | '/'   | '%'   | '&amp;'   | '|'   | '^'   | '&lt;&lt;'
    | 'right_shift' | '=='  | '!='  | '&gt;'   | '&lt;'   | '&gt;='  | '&lt;='
    ;

conversion_operator_declarator
    : 'implicit' 'operator' type '(' type identifier ')'
    | 'explicit' 'operator' type '(' type identifier ')'
    ;

operator_body
    : block
    | '=&gt;' expression ';'
    | ';'
    ;
</code></pre>
<p>There are three categories of overloadable operators: Unary operators (<a href="classes.md#unary-operators">Unary operators</a>), binary operators (<a href="classes.md#binary-operators">Binary operators</a>), and conversion operators (<a href="classes.md#conversion-operators">Conversion operators</a>).</p>

<p>The <em>operator_body</em> is either a semicolon, a <strong><em>statement body</em></strong> or an <strong><em>expression body</em></strong>. A statement body consists of a <em>block</em>, which specifies the statements to execute when the operator is invoked. The <em>block</em> must conform to the rules for value-returning methods described in <a href="classes.md#method-body">Method body</a>. An expression body consists of <code class="prettyprint">=&gt;</code> followed by an expression and a semicolon, and denotes a single expression to perform when the operator is invoked.</p>

<p>For <code class="prettyprint">extern</code> operators, the <em>operator_body</em> consists simply of a semicolon. For all other operators, the <em>operator_body</em> is either a block body or an expression body.</p>

<p>The following rules apply to all operator declarations:</p>

<ul>
<li> An operator declaration must include both a <code class="prettyprint">public</code> and a <code class="prettyprint">static</code> modifier.</li>
<li> The parameter(s) of an operator must be value parameters (<a href="variables.md#value-parameters">Value parameters</a>). It is a compile-time error for an operator declaration to specify <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</li>
<li> The signature of an operator (<a href="classes.md#unary-operators">Unary operators</a>, <a href="classes.md#binary-operators">Binary operators</a>, <a href="classes.md#conversion-operators">Conversion operators</a>) must differ from the signatures of all other operators declared in the same class.</li>
<li> All types referenced in an operator declaration must be at least as accessible as the operator itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</li>
<li> It is an error for the same modifier to appear multiple times in an operator declaration.</li>
</ul>

<p>Each operator category imposes additional restrictions, as described in the following sections.</p>

<p>Like other members, operators declared in a base class are inherited by derived classes. Because operator declarations always require the class or struct in which the operator is declared to participate in the signature of the operator, it is not possible for an operator declared in a derived class to hide an operator declared in a base class. Thus, the <code class="prettyprint">new</code> modifier is never required, and therefore never permitted, in an operator declaration.</p>

<p>Additional information on unary and binary operators can be found in <a href="expressions.md#operators">Operators</a>.</p>

<p>Additional information on conversion operators can be found in <a href="conversions.md#user-defined-conversions">User-defined conversions</a>.</p>

<h3 id="unary-operators">Unary operators</h3>

<p>The following rules apply to unary operator declarations, where <code class="prettyprint">T</code> denotes the instance type of the class or struct that contains the operator declaration:</p>

<ul>
<li> A unary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, or <code class="prettyprint">~</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and can return any type.</li>
<li> A unary <code class="prettyprint">++</code> or <code class="prettyprint">--</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and must return that same type or a type derived from it.</li>
<li> A unary <code class="prettyprint">true</code> or <code class="prettyprint">false</code> operator must take a single parameter of type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and must return type <code class="prettyprint">bool</code>.</li>
</ul>

<p>The signature of a unary operator consists of the operator token (<code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">!</code>, <code class="prettyprint">~</code>, <code class="prettyprint">++</code>, <code class="prettyprint">--</code>, <code class="prettyprint">true</code>, or <code class="prettyprint">false</code>) and the type of the single formal parameter. The return type is not part of a unary operator&rsquo;s signature, nor is the name of the formal parameter.</p>

<p>The <code class="prettyprint">true</code> and <code class="prettyprint">false</code> unary operators require pair-wise declaration. A compile-time error occurs if a class declares one of these operators without also declaring the other. The <code class="prettyprint">true</code> and <code class="prettyprint">false</code> operators are described further in <a href="expressions.md#user-defined-conditional-logical-operators">User-defined conditional logical operators</a> and <a href="expressions.md#boolean-expressions">Boolean expressions</a>.</p>

<p>The following example shows an implementation and subsequent usage of <code class="prettyprint">operator ++</code> for an integer vector class:
&rdquo;`csharp
public class IntVector
{
    public IntVector(int length) {&hellip;}</p>

<p>public int Length {&hellip;}                 // read-only property</p>

<p>public int this[int index] {&hellip;}        // read-write indexer</p>

<p>public static IntVector operator ++(IntVector iv) {
        IntVector temp = new IntVector(iv.Length);
        for (int i = 0; i &lt; iv.Length; i++)
            temp[i] = iv[i] + 1;
        return temp;
    }
}</p>

<p>class Test
{
    static void Main() {
        IntVector iv1 = new IntVector(4);    // vector of 4 x 0
        IntVector iv2;</p>

<p>iv2 = iv1++;    // iv2 contains 4 x 0, iv1 contains 4 x 1
        iv2 = ++iv1;    // iv2 contains 4 x 2, iv1 contains 4 x 2
    }
}
&ldquo;`</p>

<p>Note how the operator method returns the value produced by adding 1 to the operand, just like the  postfix increment and decrement operators (<a href="expressions.md#postfix-increment-and-decrement-operators">Postfix increment and decrement operators</a>), and the prefix increment and decrement operators (<a href="expressions.md#prefix-increment-and-decrement-operators">Prefix increment and decrement operators</a>). Unlike in C++, this method need not modify the value of its operand directly. In fact, modifying the operand value would violate the standard semantics of the postfix increment operator.</p>

<h3 id="binary-operators">Binary operators</h3>

<p>The following rules apply to binary operator declarations, where <code class="prettyprint">T</code> denotes the instance type of the class or struct that contains the operator declaration:</p>

<ul>
<li> A binary non-shift operator must take two parameters, at least one of which must have type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code>, and can return any type.</li>
<li> A binary <code class="prettyprint">&lt;&lt;</code> or <code class="prettyprint">&gt;&gt;</code> operator must take two parameters, the first of which must have type <code class="prettyprint">T</code> or <code class="prettyprint">T?</code> and the second of which must have type <code class="prettyprint">int</code> or <code class="prettyprint">int?</code>, and can return any type.</li>
</ul>

<p>The signature of a binary operator consists of the operator token (<code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">|</code>, <code class="prettyprint">^</code>, <code class="prettyprint">&lt;&lt;</code>, <code class="prettyprint">&gt;&gt;</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, or <code class="prettyprint">&lt;=</code>) and the types of the two formal parameters. The return type and the names of the formal parameters are not part of a binary operator&rsquo;s signature.</p>

<p>Certain binary operators require pair-wise declaration. For every declaration of either operator of a pair, there must be a matching declaration of the other operator of the pair. Two operator declarations match when they have the same return type and the same type for each parameter. The following operators require pair-wise declaration:</p>

<ul>
<li> <code class="prettyprint">operator ==</code> and <code class="prettyprint">operator !=</code></li>
<li> <code class="prettyprint">operator &gt;</code> and <code class="prettyprint">operator &lt;</code></li>
<li> <code class="prettyprint">operator &gt;=</code> and <code class="prettyprint">operator &lt;=</code></li>
</ul>

<h3 id="conversion-operators">Conversion operators</h3>

<p>A conversion operator declaration introduces a <strong><em>user-defined conversion</em></strong> (<a href="conversions.md#user-defined-conversions">User-defined conversions</a>) which augments the pre-defined implicit and explicit conversions.</p>

<p>A conversion operator declaration that includes the <code class="prettyprint">implicit</code> keyword introduces a user-defined implicit conversion. Implicit conversions can occur in a variety of situations, including function member invocations, cast expressions, and assignments. This is described further in <a href="conversions.md#implicit-conversions">Implicit conversions</a>.</p>

<p>A conversion operator declaration that includes the <code class="prettyprint">explicit</code> keyword introduces a user-defined explicit conversion. Explicit conversions can occur in cast expressions, and are described further in <a href="conversions.md#explicit-conversions">Explicit conversions</a>.</p>

<p>A conversion operator converts from a source type, indicated by the parameter type of the conversion operator, to a target type, indicated by the return type of the conversion operator.</p>

<p>For a given source type <code class="prettyprint">S</code> and target type <code class="prettyprint">T</code>, if <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are nullable types, let <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> refer to their underlying types, otherwise <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are equal to <code class="prettyprint">S</code> and <code class="prettyprint">T</code> respectively. A class or struct is permitted to declare a conversion from a source type <code class="prettyprint">S</code> to a target type <code class="prettyprint">T</code> only if all of the following are true:</p>

<ul>
<li> <code class="prettyprint">S0</code> and <code class="prettyprint">T0</code> are different types.</li>
<li> Either <code class="prettyprint">S0</code> or <code class="prettyprint">T0</code> is the class or struct type in which the operator declaration takes place.</li>
<li> Neither <code class="prettyprint">S0</code> nor <code class="prettyprint">T0</code> is an <em>interface_type</em>.</li>
<li> Excluding user-defined conversions, a conversion does not exist from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> or from <code class="prettyprint">T</code> to <code class="prettyprint">S</code>.</li>
</ul>

<p>For the purposes of these rules, any type parameters associated with <code class="prettyprint">S</code> or <code class="prettyprint">T</code> are considered to be unique types that have no inheritance relationship with other types, and any constraints on those type parameters are ignored.</p>

<p>In the example
&rdquo;`csharp
class C<T> {&hellip;}</p>

<p>class D<T>: C<T>
{
    public static implicit operator C<int>(D<T> value) {&hellip;}      // Ok
    public static implicit operator C<string>(D<T> value) {&hellip;}   // Ok
    public static implicit operator C<T>(D<T> value) {&hellip;}        // Error
}
&ldquo;<code class="prettyprint">
the first two operator declarations are permitted because, for the purposes of [Indexers](classes.md#indexers).3,</code>T<code class="prettyprint">and</code>int<code class="prettyprint">and</code>string<code class="prettyprint">respectively are considered unique types with no relationship. However, the third operator is an error because</code>C<T><code class="prettyprint">is the base class of</code>D<T>`.</p>

<p>From the second rule it follows that a conversion operator must convert either to or from the class or struct type in which the operator is declared. For example, it is possible for a class or struct type <code class="prettyprint">C</code> to define a conversion from <code class="prettyprint">C</code> to <code class="prettyprint">int</code> and from <code class="prettyprint">int</code> to <code class="prettyprint">C</code>, but not from <code class="prettyprint">int</code> to <code class="prettyprint">bool</code>.</p>

<p>It is not possible to directly redefine a pre-defined conversion. Thus, conversion operators are not allowed to convert from or to <code class="prettyprint">object</code> because implicit and explicit conversions already exist between <code class="prettyprint">object</code> and all other types. Likewise, neither the source nor the target types of a conversion can be a base type of the other, since a conversion would then already exist.</p>

<p>However, it is possible to declare operators on generic types that, for particular type arguments, specify conversions that already exist as pre-defined conversions. In the example
<code class="prettyprint">csharp
struct Convertible&lt;T&gt;
{
    public static implicit operator Convertible&lt;T&gt;(T value) {...}
    public static explicit operator T(Convertible&lt;T&gt; value) {...}
}
</code>
when type <code class="prettyprint">object</code> is specified as a type argument for <code class="prettyprint">T</code>, the second operator declares a conversion that already exists (an implicit, and therefore also an explicit, conversion exists from any type to type <code class="prettyprint">object</code>).</p>

<p>In cases where a pre-defined conversion exists between two types, any user-defined conversions between those types are ignored. Specifically:</p>

<ul>
<li> If a pre-defined implicit conversion (<a href="conversions.md#implicit-conversions">Implicit conversions</a>) exists from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code>, all user-defined conversions (implicit or explicit) from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored.</li>
<li> If a pre-defined explicit conversion (<a href="conversions.md#explicit-conversions">Explicit conversions</a>) exists from type <code class="prettyprint">S</code> to type <code class="prettyprint">T</code>, any user-defined explicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored. Furthermore:</li>
</ul>

<p>If <code class="prettyprint">T</code> is an interface type, user-defined implicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are ignored.</p>

<p>Otherwise, user-defined implicit conversions from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> are still considered.</p>

<p>For all types but <code class="prettyprint">object</code>, the operators declared by the <code class="prettyprint">Convertible&lt;T&gt;</code> type above do not conflict with pre-defined conversions. For example:
<code class="prettyprint">csharp
void F(int i, Convertible&lt;int&gt; n) {
    i = n;                          // Error
    i = (int)n;                     // User-defined explicit conversion
    n = i;                          // User-defined implicit conversion
    n = (Convertible&lt;int&gt;)i;        // User-defined implicit conversion
}
</code></p>

<p>However, for type <code class="prettyprint">object</code>, pre-defined conversions hide the user-defined conversions in all cases but one:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">object</span> <span class="n">o</span><span class="p">,</span> <span class="n">Convertible</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">o</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>                         <span class="c1">// Pre-defined boxing conversion</span>
    <span class="n">o</span> <span class="p">=</span> <span class="p">(</span><span class="kt">object</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>                 <span class="c1">// Pre-defined boxing conversion</span>
    <span class="n">n</span> <span class="p">=</span> <span class="n">o</span><span class="p">;</span>                         <span class="c1">// User-defined implicit conversion</span>
    <span class="n">n</span> <span class="p">=</span> <span class="p">(</span><span class="n">Convertible</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">o</span><span class="p">;</span>    <span class="c1">// Pre-defined unboxing conversion</span>
<span class="p">}</span>
</code></pre>
<p>User-defined conversions are not allowed to convert from or to <em>interface_type*s. In particular, this restriction ensures that no user-defined transformations occur when converting to an *interface_type</em>, and that a conversion to an <em>interface_type</em> succeeds only if the object being converted actually implements the specified <em>interface_type</em>.</p>

<p>The signature of a conversion operator consists of the source type and the target type. (Note that this is the only form of member for which the return type participates in the signature.) The <code class="prettyprint">implicit</code> or <code class="prettyprint">explicit</code> classification of a conversion operator is not part of the operator&rsquo;s signature. Thus, a class or struct cannot declare both an <code class="prettyprint">implicit</code> and an <code class="prettyprint">explicit</code> conversion operator with the same source and target types.</p>

<p>In general, user-defined implicit conversions should be designed to never throw exceptions and never lose information. If a user-defined conversion can give rise to exceptions (for example, because the source argument is out of range) or loss of information (such as discarding high-order bits), then that conversion should be defined as an explicit conversion.</p>

<p>In the example
&rdquo;`csharp
using System;</p>

<p>public struct Digit
{
    byte value;</p>

<p>public Digit(byte value) {
        if (value &lt; 0 || value &gt; 9) throw new ArgumentException();
        this.value = value;
    }</p>

<p>public static implicit operator byte(Digit d) {
        return d.value;
    }</p>

<p>public static explicit operator Digit(byte b) {
        return new Digit(b);
    }
}
&ldquo;<code class="prettyprint">
the conversion from</code>Digit<code class="prettyprint">to</code>byte<code class="prettyprint">is implicit because it never throws exceptions or loses information, but the conversion from</code>byte<code class="prettyprint">to</code>Digit<code class="prettyprint">is explicit since</code>Digit<code class="prettyprint">can only represent a subset of the possible values of a</code>byte`.</p>

<h2 id="instance-constructors">Instance constructors</h2>

<p>An <strong><em>instance constructor</em></strong> is a member that implements the actions required to initialize an instance of a class. Instance constructors are declared using *constructor_declaration*s:</p>
<pre class="highlight plaintext"><code>constructor_declaration
    : attributes? constructor_modifier* constructor_declarator constructor_body
    ;

constructor_modifier
    : 'public'
    | 'protected'
    | 'internal'
    | 'private'
    | 'extern'
    | constructor_modifier_unsafe
    ;

constructor_declarator
    : identifier '(' formal_parameter_list? ')' constructor_initializer?
    ;

constructor_initializer
    : ':' 'base' '(' argument_list? ')'
    | ':' 'this' '(' argument_list? ')'
    ;

constructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>constructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>), a valid combination of the four access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>), and an <code class="prettyprint">extern</code> (<a href="classes.md#external-methods">External methods</a>) modifier. A constructor declaration is not permitted to include the same modifier multiple times.</p>

<p>The <em>identifier</em> of a <em>constructor_declarator</em> must name the class in which the instance constructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>The optional <em>formal_parameter_list</em> of an instance constructor is subject to the same rules as the <em>formal_parameter_list</em> of a method (<a href="classes.md#methods">Methods</a>). The formal parameter list defines the signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>) of an instance constructor and governs the process whereby overload resolution (<a href="expressions.md#type-inference">Type inference</a>) selects a particular instance constructor in an invocation.</p>

<p>Each of the types referenced in the <em>formal_parameter_list</em> of an instance constructor must be at least as accessible as the constructor itself (<a href="basic-concepts.md#accessibility-constraints">Accessibility constraints</a>).</p>

<p>The optional <em>constructor_initializer</em> specifies another instance constructor to invoke before executing the statements given in the <em>constructor_body</em> of this instance constructor. This is described further in <a href="classes.md#constructor-initializers">Constructor initializers</a>.</p>

<p>When a constructor declaration includes an <code class="prettyprint">extern</code> modifier, the constructor is said to be an <strong><em>external constructor</em></strong>. Because an external constructor declaration provides no actual implementation, its <em>constructor_body</em> consists of a semicolon. For all other constructors, the <em>constructor_body</em> consists of a <em>block</em> which specifies the statements to initialize a new instance of the class. This corresponds exactly to the <em>block</em> of an instance method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Instance constructors are not inherited. Thus, a class has no instance constructors other than those actually declared in the class. If a class contains no instance constructor declarations, a default instance constructor is automatically provided (<a href="classes.md#default-constructors">Default constructors</a>).</p>

<p>Instance constructors are invoked by *object_creation_expression*s (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>) and through *constructor_initializer*s.</p>

<h3 id="constructor-initializers">Constructor initializers</h3>

<p>All instance constructors (except those for class <code class="prettyprint">object</code>) implicitly include an invocation of another instance constructor immediately before the <em>constructor_body</em>. The constructor to implicitly invoke is determined by the <em>constructor_initializer</em>:</p>

<ul>
<li> An instance constructor initializer of the form <code class="prettyprint">base(argument_list)</code> or <code class="prettyprint">base()</code> causes an instance constructor from the direct base class to be invoked. That constructor is selected using <em>argument_list</em> if present and the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors contained in the direct base class, or the default constructor (<a href="classes.md#default-constructors">Default constructors</a>), if no instance constructors are declared in the direct base class. If this set is empty, or if a single best instance constructor cannot be identified, a compile-time error occurs.</li>
<li> An instance constructor initializer of the form <code class="prettyprint">this(argument-list)</code> or <code class="prettyprint">this()</code> causes an instance constructor from the class itself to be invoked. The constructor is selected using <em>argument_list</em> if present and the overload resolution rules of <a href="expressions.md#overload-resolution">Overload resolution</a>. The set of candidate instance constructors consists of all accessible instance constructors declared in the class itself. If this set is empty, or if a single best instance constructor cannot be identified, a compile-time error occurs. If an instance constructor declaration includes a constructor initializer that invokes the constructor itself, a compile-time error occurs.</li>
</ul>

<p>If an instance constructor has no constructor initializer, a constructor initializer of the form <code class="prettyprint">base()</code> is implicitly provided. Thus, an instance constructor declaration of the form
<code class="prettyprint">csharp
C(...) {...}
</code>
is exactly equivalent to
<code class="prettyprint">csharp
C(...): base() {...}
</code></p>

<p>The scope of the parameters given by the <em>formal_parameter_list</em> of an instance constructor declaration includes the constructor initializer of that declaration. Thus, a constructor initializer is permitted to access the parameters of the constructor. For example:
&rdquo;`csharp
class A
{
    public A(int x, int y) {}
}</p>

<p>class B: A
{
    public B(int x, int y): base(x + y, x - y) {}
}
&ldquo;`</p>

<p>An instance constructor initializer cannot access the instance being created. Therefore it is a compile-time error to reference <code class="prettyprint">this</code> in an argument expression of the constructor initializer, as is it a compile-time error for an argument expression to reference any instance member through a <em>simple_name</em>.</p>

<h3 id="instance-variable-initializers">Instance variable initializers</h3>

<p>When an instance constructor has no constructor initializer, or it has a constructor initializer of the form <code class="prettyprint">base(...)</code>, that constructor implicitly performs the initializations specified by the *variable_initializer*s of the instance fields declared in its class. This corresponds to a sequence of assignments that are executed immediately upon entry to the constructor and before the implicit invocation of the direct base class constructor. The variable initializers are executed in the textual order in which they appear in the class declaration.</p>

<h3 id="constructor-execution">Constructor execution</h3>

<p>Variable initializers are transformed into assignment statements, and these assignment statements are executed before the invocation of the base class instance constructor. This ordering ensures that all instance fields are initialized by their variable initializers before any statements that have access to that instance are executed.</p>

<p>Given the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public A() {
        PrintFields();
    }</p>

<p>public virtual void PrintFields() {}
}</p>

<p>class B: A
{
    int x = 1;
    int y;</p>

<p>public B() {
        y = -1;
    }</p>

<p>public override void PrintFields() {
        Console.WriteLine(&ldquo;x = {0}, y = {1}&rdquo;, x, y);
    }
}
<code class="prettyprint">
when `new B()` is used to create an instance of `B`, the following output is produced:
</code>
x = 1, y = 0
&ldquo;`</p>

<p>The value of <code class="prettyprint">x</code> is 1 because the variable initializer is executed before the base class instance constructor is invoked. However, the value of <code class="prettyprint">y</code> is 0 (the default value of an <code class="prettyprint">int</code>) because the assignment to <code class="prettyprint">y</code> is not executed until after the base class constructor returns.</p>

<p>It is useful to think of instance variable initializers and constructor initializers as statements that are automatically inserted before the <em>constructor_body</em>. The example
&rdquo;`csharp
using System;
using System.Collections;</p>

<p>class A
{
    int x = 1, y = -1, count;</p>

<p>public A() {
        count = 0;
    }</p>

<p>public A(int n) {
        count = n;
    }
}</p>

<p>class B: A
{
    double sqrt2 = Math.Sqrt(2.0);
    ArrayList items = new ArrayList(100);
    int max;</p>

<p>public B(): this(100) {
        items.Add(&ldquo;default&rdquo;);
    }</p>

<p>public B(int n): base(n - 1) {
        max = n;
    }
}
&ldquo;<code class="prettyprint">
contains several variable initializers; it also contains constructor initializers of both forms (</code>base<code class="prettyprint">and</code>this`). The example corresponds to the code shown below, where each comment indicates an automatically inserted statement (the syntax used for the automatically inserted constructor invocations isn&rsquo;t valid, but merely serves to illustrate the mechanism).</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                       <span class="c1">// Variable initializer</span>
        <span class="n">y</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>                      <span class="c1">// Variable initializer</span>
        <span class="kt">object</span><span class="p">();</span>                    <span class="c1">// Invoke object() constructor</span>
        <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                       <span class="c1">// Variable initializer</span>
        <span class="n">y</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>                      <span class="c1">// Variable initializer</span>
        <span class="kt">object</span><span class="p">();</span>                    <span class="c1">// Invoke object() constructor</span>
        <span class="n">count</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">sqrt2</span><span class="p">;</span>
    <span class="n">ArrayList</span> <span class="n">items</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">B</span><span class="p">():</span> <span class="k">this</span><span class="p">(</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">B</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>                      <span class="c1">// Invoke B(int) constructor</span>
        <span class="n">items</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">"default"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">):</span> <span class="k">base</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sqrt2</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="m">2.0</span><span class="p">);</span>      <span class="c1">// Variable initializer</span>
        <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>  <span class="c1">// Variable initializer</span>
        <span class="nf">A</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>                    <span class="c1">// Invoke A(int) constructor</span>
        <span class="n">max</span> <span class="p">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h3 id="default-constructors">Default constructors</h3>

<p>If a class contains no instance constructor declarations, a default instance constructor is automatically provided. That default constructor simply invokes the parameterless constructor of the direct base class. If the class is abstract then the declared accessibility for the default constructor is protected. Otherwise, the declared accessibility for the default constructor is public. Thus, the default constructor is always of the form</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">protected</span> <span class="nf">C</span><span class="p">():</span> <span class="k">base</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
<p>or
<code class="prettyprint">csharp
public C(): base() {}
</code>
where <code class="prettyprint">C</code> is the name of the class. If overload resolution is unable to determine a unique best candidate for the base class constructor initializer then a compile-time error occurs.</p>

<p>In the example
<code class="prettyprint">csharp
class Message
{
    object sender;
    string text;
}
</code>
a default constructor is provided because the class contains no instance constructor declarations. Thus, the example is precisely equivalent to
&rdquo;`csharp
class Message
{
    object sender;
    string text;</p>

<p>public Message(): base() {}
}
&ldquo;`</p>

<h3 id="private-constructors">Private constructors</h3>

<p>When a class <code class="prettyprint">T</code> declares only private instance constructors, it is not possible for classes outside the program text of <code class="prettyprint">T</code> to derive from <code class="prettyprint">T</code> or to directly create instances of <code class="prettyprint">T</code>. Thus, if a class contains only static members and isn&rsquo;t intended to be instantiated, adding an empty private instance constructor will prevent instantiation. For example:
&rdquo;`csharp
public class Trig
{
    private Trig() {}        // Prevent instantiation</p>

<p>public const double PI = 3.14159265358979323846;</p>

<p>public static double Sin(double x) {&hellip;}
    public static double Cos(double x) {&hellip;}
    public static double Tan(double x) {&hellip;}
}
&ldquo;`</p>

<p>The <code class="prettyprint">Trig</code> class groups related methods and constants, but is not intended to be instantiated. Therefore it declares a single empty private instance constructor. At least one instance constructor must be declared to suppress the automatic generation of a default constructor.</p>

<h3 id="optional-instance-constructor-parameters">Optional instance constructor parameters</h3>

<p>The <code class="prettyprint">this(...)</code> form of constructor initializer is commonly used in conjunction with overloading to implement optional instance constructor parameters. In the example
&rdquo;`csharp
class Text
{
    public Text(): this(0, 0, null) {}</p>

<p>public Text(int x, int y): this(x, y, null) {}</p>

<p>public Text(int x, int y, string s) {
        // Actual constructor implementation
    }
}
<code class="prettyprint">
the first two instance constructors merely provide the default values for the missing arguments. Both use a `this(...)` constructor initializer to invoke the third instance constructor, which actually does the work of initializing the new instance. The effect is that of optional constructor parameters:
</code>csharp
Text t1 = new Text();                    // Same as Text(0, 0, null)
Text t2 = new Text(5, 10);               // Same as Text(5, 10, null)
Text t3 = new Text(5, 20, &ldquo;Hello&rdquo;);
&ldquo;`</p>

<h2 id="static-constructors">Static constructors</h2>

<p>A <strong><em>static constructor</em></strong> is a member that implements the actions required to initialize a closed class type. Static constructors are declared using *static_constructor_declaration*s:</p>
<pre class="highlight plaintext"><code>static_constructor_declaration
    : attributes? static_constructor_modifiers identifier '(' ')' static_constructor_body
    ;

static_constructor_modifiers
    : 'extern'? 'static'
    | 'static' 'extern'?
    | static_constructor_modifiers_unsafe
    ;

static_constructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>static_constructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>) and an <code class="prettyprint">extern</code> modifier (<a href="classes.md#external-methods">External methods</a>).</p>

<p>The <em>identifier</em> of a <em>static_constructor_declaration</em> must name the class in which the static constructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>When a static constructor declaration includes an <code class="prettyprint">extern</code> modifier, the static constructor is said to be an <strong><em>external static constructor</em></strong>. Because an external static constructor declaration provides no actual implementation, its <em>static_constructor_body</em> consists of a semicolon. For all other static constructor declarations, the <em>static_constructor_body</em> consists of a <em>block</em> which specifies the statements to execute in order to initialize the class. This corresponds exactly to the <em>method_body</em> of a static method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Static constructors are not inherited, and cannot be called directly.</p>

<p>The static constructor for a closed class type executes at most once in a given application domain. The execution of a static constructor is triggered by the first of the following events to occur within an application domain:</p>

<ul>
<li> An instance of the class type is created.</li>
<li> Any of the static members of the class type are referenced.</li>
</ul>

<p>If a class contains the <code class="prettyprint">Main</code> method (<a href="basic-concepts.md#application-startup">Application Startup</a>) in which execution begins, the static constructor for that class executes before the <code class="prettyprint">Main</code> method is called.</p>

<p>To initialize a new closed class type, first a new set of static fields (<a href="classes.md#static-and-instance-fields">Static and instance fields</a>) for that particular closed type is created. Each of the static fields is initialized to its default value (<a href="variables.md#default-values">Default values</a>). Next, the static field initializers (<a href="classes.md#static-field-initialization">Static field initialization</a>) are executed for those static fields. Finally, the static constructor is executed.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class Test
{
    static void Main() {
        A.F();
        B.F();
    }
}</p>

<p>class A
{
    static A() {
        Console.WriteLine(&ldquo;Init A&rdquo;);
    }
    public static void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
    }
}</p>

<p>class B
{
    static B() {
        Console.WriteLine(&ldquo;Init B&rdquo;);
    }
    public static void F() {
        Console.WriteLine(&ldquo;B.F&rdquo;);
    }
}
<code class="prettyprint">
must produce the output:
</code>
Init A
A.F
Init B
B.F
&ldquo;<code class="prettyprint">
because the execution of</code>A<code class="prettyprint">&#39;s static constructor is triggered by the call to</code>A.F<code class="prettyprint">, and the execution of</code>B<code class="prettyprint">&#39;s static constructor is triggered by the call to</code>B.F`.</p>

<p>It is possible to construct circular dependencies that allow static fields with variable initializers to be observed in their default value state.</p>

<p>The example
&rdquo;`csharp
using System;</p>

<p>class A
{
    public static int X;</p>

<p>static A() {
        X = B.Y + 1;
    }
}</p>

<p>class B
{
    public static int Y = A.X + 1;</p>

<p>static B() {}</p>

<p>static void Main() {
        Console.WriteLine(&ldquo;X = {0}, Y = {1}&rdquo;, A.X, B.Y);
    }
}
<code class="prettyprint">
produces the output
</code>
X = 1, Y = 2
&ldquo;`</p>

<p>To execute the <code class="prettyprint">Main</code> method, the system first runs the initializer for <code class="prettyprint">B.Y</code>, prior to class <code class="prettyprint">B</code>&rsquo;s static constructor. <code class="prettyprint">Y</code>&rsquo;s initializer causes <code class="prettyprint">A</code>&rsquo;s static constructor to be run because the value of <code class="prettyprint">A.X</code> is referenced. The static constructor of <code class="prettyprint">A</code> in turn proceeds to compute the value of <code class="prettyprint">X</code>, and in doing so fetches the default value of <code class="prettyprint">Y</code>, which is zero. <code class="prettyprint">A.X</code> is thus initialized to 1. The process of running <code class="prettyprint">A</code>&rsquo;s static field initializers and static constructor then completes, returning to the calculation of the initial value of <code class="prettyprint">Y</code>, the result of which becomes 2.</p>

<p>Because the static constructor is executed exactly once for each closed constructed class type, it is a convenient place to enforce run-time checks on the type parameter that cannot be checked at compile-time via constraints (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For example, the following type uses a static constructor to enforce that the type argument is an enum:
<code class="prettyprint">csharp
class Gen&lt;T&gt; where T: struct
{
    static Gen() {
        if (!typeof(T).IsEnum) {
            throw new ArgumentException(&quot;T must be an enum&quot;);
        }
    }
}
</code></p>

<h2 id="destructors">Destructors</h2>

<p>A <strong><em>destructor</em></strong> is a member that implements the actions required to destruct an instance of a class. A destructor is declared using a <em>destructor_declaration</em>:</p>
<pre class="highlight plaintext"><code>destructor_declaration
    : attributes? 'extern'? '~' identifier '(' ')' destructor_body
    | destructor_declaration_unsafe
    ;

destructor_body
    : block
    | ';'
    ;
</code></pre>
<p>A <em>destructor_declaration</em> may include a set of <em>attributes</em> (<a href="attributes.md#attributes">Attributes</a>).</p>

<p>The <em>identifier</em> of a <em>destructor_declaration</em> must name the class in which the destructor is declared. If any other name is specified, a compile-time error occurs.</p>

<p>When a destructor declaration includes an <code class="prettyprint">extern</code> modifier, the destructor is said to be an <strong><em>external destructor</em></strong>. Because an external destructor declaration provides no actual implementation, its <em>destructor_body</em> consists of a semicolon. For all other destructors, the <em>destructor_body</em> consists of a <em>block</em> which specifies the statements to execute in order to destruct an instance of the class. A <em>destructor_body</em> corresponds exactly to the <em>method_body</em> of an instance method with a <code class="prettyprint">void</code> return type (<a href="classes.md#method-body">Method body</a>).</p>

<p>Destructors are not inherited. Thus, a class has no destructors other than the one which may be declared in that class.</p>

<p>Since a destructor is required to have no parameters, it cannot be overloaded, so a class can have, at most, one destructor.</p>

<p>Destructors are invoked automatically, and cannot be invoked explicitly. An instance becomes eligible for destruction when it is no longer possible for any code to use that instance. Execution of the destructor for the instance may occur at any time after the instance becomes eligible for destruction. When an instance is destructed, the destructors in that instance&rsquo;s inheritance chain are called, in order, from most derived to least derived. A destructor may be executed on any thread. For further discussion of the rules that govern when and how a destructor is executed, see <a href="basic-concepts.md#automatic-memory-management">Automatic memory management</a>.</p>

<p>The output of the example
&rdquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&ldquo;A&rsquo;s destructor&rdquo;);
    }
}</p>

<p>class B: A
{
    ~B() {
        Console.WriteLine(&ldquo;B&rsquo;s destructor&rdquo;);
    }
}</p>

<p>class Test
{
   static void Main() {
        B b = new B();
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
   }
}
<code class="prettyprint">
is
</code>
B&rsquo;s destructor
A&rsquo;s destructor
&ldquo;`
since destructors in an inheritance chain are called in order, from most derived to least derived.</p>

<p>Destructors are implemented by overriding the virtual method <code class="prettyprint">Finalize</code> on <code class="prettyprint">System.Object</code>. C# programs are not permitted to override this method or call it (or overrides of it) directly. For instance, the program
&rdquo;`csharp
class A 
{
    override protected void Finalize() {}    // error</p>

<p>public void F() {
        this.Finalize();                     // error
    }
}
&ldquo;`
contains two errors.</p>

<p>The compiler behaves as if this method, and overrides of it, do not exist at all. Thus, this program:
<code class="prettyprint">csharp
class A 
{
    void Finalize() {}                            // permitted
}
</code>
is valid, and the method shown hides <code class="prettyprint">System.Object</code>&rsquo;s <code class="prettyprint">Finalize</code> method.</p>

<p>For a discussion of the behavior when an exception is thrown from a destructor, see <a href="exceptions.md#how-exceptions-are-handled">How exceptions are handled</a>.</p>

<h2 id="iterators">Iterators</h2>

<p>A function member (<a href="expressions.md#function-members">Function members</a>) implemented using an iterator block (<a href="statements.md#blocks">Blocks</a>) is called an <strong><em>iterator</em></strong>.</p>

<p>An iterator block may be used as the body of a function member as long as the return type of the corresponding function member is one of the enumerator interfaces (<a href="classes.md#enumerator-interfaces">Enumerator interfaces</a>) or one of the enumerable interfaces (<a href="classes.md#enumerable-interfaces">Enumerable interfaces</a>). It can occur as a <em>method_body</em>, <em>operator_body</em> or <em>accessor_body</em>, whereas events, instance constructors, static constructors and destructors cannot be implemented as iterators.</p>

<p>When a function member is implemented using an iterator block, it is a compile-time error for the formal parameter list of the function member to specify any <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</p>

<h3 id="enumerator-interfaces">Enumerator interfaces</h3>

<p>The <strong><em>enumerator interfaces</em></strong> are the non-generic interface <code class="prettyprint">System.Collections.IEnumerator</code> and all instantiations of the generic interface <code class="prettyprint">System.Collections.Generic.IEnumerator&lt;T&gt;</code>. For the sake of brevity, in this chapter these interfaces are referenced as <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, respectively.</p>

<h3 id="enumerable-interfaces">Enumerable interfaces</h3>

<p>The <strong><em>enumerable interfaces</em></strong> are the non-generic interface <code class="prettyprint">System.Collections.IEnumerable</code> and all instantiations of the generic interface <code class="prettyprint">System.Collections.Generic.IEnumerable&lt;T&gt;</code>. For the sake of brevity, in this chapter these interfaces are referenced as <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code>, respectively.</p>

<h3 id="yield-type">Yield type</h3>

<p>An iterator produces a sequence of values, all of the same type. This type is called the <strong><em>yield type</em></strong> of the iterator.</p>

<ul>
<li> The yield type of an iterator that returns <code class="prettyprint">IEnumerator</code> or <code class="prettyprint">IEnumerable</code> is <code class="prettyprint">object</code>.</li>
<li> The yield type of an iterator that returns <code class="prettyprint">IEnumerator&lt;T&gt;</code> or <code class="prettyprint">IEnumerable&lt;T&gt;</code> is <code class="prettyprint">T</code>.</li>
</ul>

<h3 id="enumerator-objects">Enumerator objects</h3>

<p>When a function member returning an enumerator interface type is implemented using an iterator block, invoking the function member does not immediately execute the code in the iterator block. Instead, an <strong><em>enumerator object</em></strong> is created and returned. This object encapsulates the code specified in the iterator block, and execution of the code in the iterator block occurs when the enumerator object&rsquo;s <code class="prettyprint">MoveNext</code> method is invoked. An enumerator object has the following characteristics:</p>

<ul>
<li> It implements <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, where <code class="prettyprint">T</code> is the yield type of the iterator.</li>
<li> It implements <code class="prettyprint">System.IDisposable</code>.</li>
<li> It is initialized with a copy of the argument values (if any) and instance value passed to the function member.</li>
<li> It has four potential states, <strong><em>before</em></strong>, <strong><em>running</em></strong>, <strong><em>suspended</em></strong>, and <strong><em>after</em></strong>, and is initially in the <strong><em>before</em></strong> state.</li>
</ul>

<p>An enumerator object is typically an instance of a compiler-generated enumerator class that encapsulates the code in the iterator block and implements the enumerator interfaces, but other methods of implementation are possible. If an enumerator class is generated by the compiler, that class will be nested, directly or indirectly, in the class containing the function member, it will have private accessibility, and it will have a name reserved for compiler use (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<p>An enumerator object may implement more interfaces than those specified above.</p>

<p>The following sections describe the exact behavior of the <code class="prettyprint">MoveNext</code>, <code class="prettyprint">Current</code>, and <code class="prettyprint">Dispose</code> members of the <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code> interface implementations provided by an enumerator object.</p>

<p>Note that enumerator objects do not support the <code class="prettyprint">IEnumerator.Reset</code> method. Invoking this method causes a <code class="prettyprint">System.NotSupportedException</code> to be thrown.</p>

<h4 id="the-movenext-method">The MoveNext method</h4>

<p>The <code class="prettyprint">MoveNext</code> method of an enumerator object encapsulates the code of an iterator block. Invoking the <code class="prettyprint">MoveNext</code> method executes code in the iterator block and sets the <code class="prettyprint">Current</code> property of the enumerator object as appropriate. The precise action performed by <code class="prettyprint">MoveNext</code> depends on the state of the enumerator object when <code class="prettyprint">MoveNext</code> is invoked:</p>

<ul>
<li> If the state of the enumerator object is <strong><em>before</em></strong>, invoking <code class="prettyprint">MoveNext</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Initializes the parameters (including <code class="prettyprint">this</code>) of the iterator block to the argument values and instance value saved when the enumerator object was initialized.</li>
<li>Executes the iterator block from the beginning until execution is interrupted (as described below).</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>running</em></strong>, the result of invoking <code class="prettyprint">MoveNext</code> is unspecified.</li>
<li> If the state of the enumerator object is <strong><em>suspended</em></strong>, invoking <code class="prettyprint">MoveNext</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Restores the values of all local variables and parameters (including this) to the values saved when execution of the iterator block was last suspended. Note that the contents of any objects referenced by these variables may have changed since the previous call to MoveNext.</li>
<li>Resumes execution of the iterator block immediately following the <code class="prettyprint">yield return</code> statement that caused the suspension of execution and continues until execution is interrupted (as described below).</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>after</em></strong>, invoking <code class="prettyprint">MoveNext</code> returns <code class="prettyprint">false</code>.</li>
</ul>

<p>When <code class="prettyprint">MoveNext</code> executes the iterator block, execution can be interrupted in four ways: By a <code class="prettyprint">yield return</code> statement, by a <code class="prettyprint">yield break</code> statement, by encountering the end of the iterator block, and by an exception being thrown and propagated out of the iterator block.</p>

<ul>
<li> When a <code class="prettyprint">yield return</code> statement is encountered (<a href="statements.md#the-yield-statement">The yield statement</a>):

<ul>
<li>The expression given in the statement is evaluated, implicitly converted to the yield type, and assigned to the <code class="prettyprint">Current</code> property of the enumerator object.</li>
<li>Execution of the iterator body is suspended. The values of all local variables and parameters (including <code class="prettyprint">this</code>) are saved, as is the location of this <code class="prettyprint">yield return</code> statement. If the <code class="prettyprint">yield return</code> statement is within one or more <code class="prettyprint">try</code> blocks, the associated <code class="prettyprint">finally</code> blocks are not executed at this time.</li>
<li>The state of the enumerator object is changed to <strong><em>suspended</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">true</code> to its caller, indicating that the iteration successfully advanced to the next value.</li>
</ul></li>
<li> When a <code class="prettyprint">yield break</code> statement is encountered (<a href="statements.md#the-yield-statement">The yield statement</a>):

<ul>
<li>If the <code class="prettyprint">yield break</code> statement is within one or more <code class="prettyprint">try</code> blocks, the associated <code class="prettyprint">finally</code> blocks are executed.</li>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">false</code> to its caller, indicating that the iteration is complete.</li>
</ul></li>
<li> When the end of the iterator body is encountered:

<ul>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The <code class="prettyprint">MoveNext</code> method returns <code class="prettyprint">false</code> to its caller, indicating that the iteration is complete.</li>
</ul></li>
<li> When an exception is thrown and propagated out of the iterator block:

<ul>
<li>Appropriate <code class="prettyprint">finally</code> blocks in the iterator body will have been executed by the exception propagation.</li>
<li>The state of the enumerator object is changed to <strong><em>after</em></strong>.</li>
<li>The exception propagation continues to the caller of the <code class="prettyprint">MoveNext</code> method.</li>
</ul></li>
</ul>

<h4 id="the-current-property">The Current property</h4>

<p>An enumerator object&rsquo;s <code class="prettyprint">Current</code> property is affected by <code class="prettyprint">yield return</code> statements in the iterator block.</p>

<p>When an enumerator object is in the <strong><em>suspended</em></strong> state, the value of <code class="prettyprint">Current</code> is the value set by the previous call to <code class="prettyprint">MoveNext</code>. When an enumerator object is in the <strong><em>before</em></strong>, <strong><em>running</em></strong>, or <strong><em>after</em></strong> states, the result of accessing <code class="prettyprint">Current</code> is unspecified.</p>

<p>For an iterator with a yield type other than <code class="prettyprint">object</code>, the result of accessing <code class="prettyprint">Current</code> through the enumerator object&rsquo;s <code class="prettyprint">IEnumerable</code> implementation corresponds to accessing <code class="prettyprint">Current</code> through the enumerator object&rsquo;s <code class="prettyprint">IEnumerator&lt;T&gt;</code> implementation and casting the result to <code class="prettyprint">object</code>.</p>

<h4 id="the-dispose-method">The Dispose method</h4>

<p>The <code class="prettyprint">Dispose</code> method is used to clean up the iteration by bringing the enumerator object to the <strong><em>after</em></strong> state.</p>

<ul>
<li> If the state of the enumerator object is <strong><em>before</em></strong>, invoking <code class="prettyprint">Dispose</code> changes the state to <strong><em>after</em></strong>.</li>
<li> If the state of the enumerator object is <strong><em>running</em></strong>, the result of invoking <code class="prettyprint">Dispose</code> is unspecified.</li>
<li> If the state of the enumerator object is <strong><em>suspended</em></strong>, invoking <code class="prettyprint">Dispose</code>:

<ul>
<li>Changes the state to <strong><em>running</em></strong>.</li>
<li>Executes any finally blocks as if the last executed <code class="prettyprint">yield return</code> statement were a <code class="prettyprint">yield break</code> statement. If this causes an exception to be thrown and propagated out of the iterator body, the state of the enumerator object is set to <strong><em>after</em></strong> and the exception is propagated to the caller of the <code class="prettyprint">Dispose</code> method.</li>
<li>Changes the state to <strong><em>after</em></strong>.</li>
</ul></li>
<li> If the state of the enumerator object is <strong><em>after</em></strong>, invoking <code class="prettyprint">Dispose</code> has no affect.</li>
</ul>

<h3 id="enumerable-objects">Enumerable objects</h3>

<p>When a function member returning an enumerable interface type is implemented using an iterator block, invoking the function member does not immediately execute the code in the iterator block. Instead, an <strong><em>enumerable object</em></strong> is created and returned. The enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code> method returns an enumerator object that encapsulates the code specified in the iterator block, and execution of the code in the iterator block occurs when the enumerator object&rsquo;s <code class="prettyprint">MoveNext</code> method is invoked. An enumerable object has the following characteristics:</p>

<ul>
<li> It implements <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code>, where <code class="prettyprint">T</code> is the yield type of the iterator.</li>
<li> It is initialized with a copy of the argument values (if any) and instance value passed to the function member.</li>
</ul>

<p>An enumerable object is typically an instance of a compiler-generated enumerable class that encapsulates the code in the iterator block and implements the enumerable interfaces, but other methods of implementation are possible. If an enumerable class is generated by the compiler, that class will be nested, directly or indirectly, in the class containing the function member, it will have private accessibility, and it will have a name reserved for compiler use (<a href="lexical-structure.md#identifiers">Identifiers</a>).</p>

<p>An enumerable object may implement more interfaces than those specified above. In particular, an enumerable object may also implement <code class="prettyprint">IEnumerator</code> and <code class="prettyprint">IEnumerator&lt;T&gt;</code>, enabling it to serve as both an enumerable and an enumerator. In that type of implementation, the first time an enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code> method is invoked, the enumerable object itself is returned. Subsequent invocations of the enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code>, if any, return a copy of the enumerable object. Thus, each returned enumerator has its own state and changes in one enumerator will not affect another.</p>

<h4 id="the-getenumerator-method">The GetEnumerator method</h4>

<p>An enumerable object provides an implementation of the <code class="prettyprint">GetEnumerator</code> methods of the <code class="prettyprint">IEnumerable</code> and <code class="prettyprint">IEnumerable&lt;T&gt;</code> interfaces. The two <code class="prettyprint">GetEnumerator</code> methods share a common implementation that acquires and returns an available enumerator object. The enumerator object is initialized with the argument values and instance value saved when the enumerable object was initialized, but otherwise the enumerator object functions as described in <a href="classes.md#enumerator-objects">Enumerator objects</a>.</p>

<h3 id="implementation-example">Implementation example</h3>

<p>This section describes a possible implementation of iterators in terms of standard C# constructs. The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation or the only one possible.</p>

<p>The following <code class="prettyprint">Stack&lt;T&gt;</code> class implements its <code class="prettyprint">GetEnumerator</code> method using an iterator. The iterator enumerates the elements of the stack in top to bottom order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">items</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="m">4</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">T</span><span class="p">[]</span> <span class="n">newItems</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">count</span> <span class="p">*</span> <span class="m">2</span><span class="p">];</span>
            <span class="n">Array</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">newItems</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
            <span class="n">items</span> <span class="p">=</span> <span class="n">newItems</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">items</span><span class="p">[</span><span class="n">count</span><span class="p">++]</span> <span class="p">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">T</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">result</span> <span class="p">=</span> <span class="n">items</span><span class="p">[--</span><span class="n">count</span><span class="p">];</span>
        <span class="n">items</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="p">--</span><span class="n">i</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">GetEnumerator</code> method can be translated into an instantiation of a compiler-generated enumerator class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerator1</span><span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">__current</span><span class="p">;</span>
        <span class="n">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="n">Stack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__this</span> <span class="p">=</span> <span class="n">__this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="m">1</span><span class="p">:</span> <span class="k">goto</span> <span class="n">__state1</span><span class="p">;</span>
                <span class="k">case</span> <span class="m">2</span><span class="p">:</span> <span class="k">goto</span> <span class="n">__state2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">i</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
        <span class="n">__loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__state2</span><span class="p">;</span>
            <span class="n">__current</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">__state1</span><span class="p">:</span>
            <span class="p">--</span><span class="n">i</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">__loop</span><span class="p">;</span>
        <span class="n">__state2</span><span class="p">:</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In the preceding translation, the code in the iterator block is turned into a state machine and placed in the <code class="prettyprint">MoveNext</code> method of the enumerator class. Furthermore, the local variable <code class="prettyprint">i</code> is turned into a field in the enumerator object so it can continue to exist across invocations of <code class="prettyprint">MoveNext</code>.</p>

<p>The following example prints a simple multiplication table of the integers 1 through 10. The <code class="prettyprint">FromTo</code> method in the example returns an enumerable object and is implemented using an iterator.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">FromTo</span><span class="p">(</span><span class="kt">int</span> <span class="k">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">from</span> <span class="p">&lt;=</span> <span class="n">to</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="k">from</span><span class="p">++;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">e</span> <span class="p">=</span> <span class="nf">FromTo</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="k">in</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="k">in</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0,3} "</span><span class="p">,</span> <span class="n">x</span> <span class="p">*</span> <span class="n">y</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">FromTo</code> method can be translated into an instantiation of a compiler-generated enumerable class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Test</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">FromTo</span><span class="p">(</span><span class="kt">int</span> <span class="k">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerable1</span><span class="p">:</span>
        <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> <span class="n">IEnumerable</span><span class="p">,</span>
        <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__current</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__from</span><span class="p">;</span>
        <span class="kt">int</span> <span class="k">from</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="kt">int</span> <span class="n">__from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__from</span> <span class="p">=</span> <span class="n">__from</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">to</span> <span class="p">=</span> <span class="n">to</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__Enumerable1</span> <span class="n">result</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">__state</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">__Enumerable1</span><span class="p">(</span><span class="n">__from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
                <span class="n">result</span><span class="p">.</span><span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="p">.</span><span class="k">from</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">__from</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">IEnumerator</span><span class="p">)</span><span class="nf">GetEnumerator</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">from</span> <span class="p">&gt;</span> <span class="n">to</span><span class="p">)</span> <span class="k">goto</span> <span class="k">case</span> <span class="m">2</span><span class="p">;</span>
                <span class="n">__current</span> <span class="p">=</span> <span class="k">from</span><span class="p">++;</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="k">case</span> <span class="m">2</span><span class="p">:</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The enumerable class implements both the enumerable interfaces and the enumerator interfaces, enabling it to serve as both an enumerable and an enumerator. The first time the <code class="prettyprint">GetEnumerator</code> method is invoked, the enumerable object itself is returned. Subsequent invocations of the enumerable object&rsquo;s <code class="prettyprint">GetEnumerator</code>, if any, return a copy of the enumerable object. Thus, each returned enumerator has its own state and changes in one enumerator will not affect another. The <code class="prettyprint">Interlocked.CompareExchange</code> method is used to ensure thread-safe operation.</p>

<p>The <code class="prettyprint">from</code> and <code class="prettyprint">to</code> parameters are turned into fields in the enumerable class. Because <code class="prettyprint">from</code> is modified in the iterator block, an additional <code class="prettyprint">__from</code> field is introduced to hold the initial value given to <code class="prettyprint">from</code> in each enumerator.</p>

<p>The <code class="prettyprint">MoveNext</code> method throws an <code class="prettyprint">InvalidOperationException</code> if it is called when <code class="prettyprint">__state</code> is <code class="prettyprint">0</code>. This protects against use of the enumerable object as an enumerator object without first calling <code class="prettyprint">GetEnumerator</code>.</p>

<p>The following example shows a simple tree class. The <code class="prettyprint">Tree&lt;T&gt;</code> class implements its <code class="prettyprint">GetEnumerator</code> method using an iterator. The iterator enumerates the elements of the tree in infix order.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="k">value</span><span class="p">;</span>
    <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Tree</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">left</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">right</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span> <span class="k">in</span> <span class="n">left</span><span class="p">)</span> <span class="k">yield</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">yield</span> <span class="k">value</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">foreach</span> <span class="p">(</span><span class="n">T</span> <span class="n">x</span> <span class="k">in</span> <span class="n">right</span><span class="p">)</span> <span class="k">yield</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">MakeTree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="p">(</span><span class="n">left</span> <span class="p">+</span> <span class="n">right</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
            <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">),</span>
            <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">MakeTree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">params</span> <span class="n">T</span><span class="p">[]</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">MakeTree</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">items</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// The output of the program is:</span>
    <span class="c1">// 1 2 3 4 5 6 7 8 9</span>
    <span class="c1">// Mon Tue Wed Thu Fri Sat Sun</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Tree</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">ints</span> <span class="p">=</span> <span class="nf">MakeTree</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="k">in</span> <span class="n">ints</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0} "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>

        <span class="n">Tree</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">strings</span> <span class="p">=</span> <span class="nf">MakeTree</span><span class="p">(</span>
            <span class="s">"Mon"</span><span class="p">,</span> <span class="s">"Tue"</span><span class="p">,</span> <span class="s">"Wed"</span><span class="p">,</span> <span class="s">"Thu"</span><span class="p">,</span> <span class="s">"Fri"</span><span class="p">,</span> <span class="s">"Sat"</span><span class="p">,</span> <span class="s">"Sun"</span><span class="p">);</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="k">in</span> <span class="n">strings</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">"{0} "</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <code class="prettyprint">GetEnumerator</code> method can be translated into an instantiation of a compiler-generated enumerator class that encapsulates the code in the iterator block, as shown in the following.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">__Enumerator1</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">;</span>
        <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__left</span><span class="p">,</span> <span class="n">__right</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">__state</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">__current</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">__Enumerator1</span><span class="p">(</span><span class="n">Node</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">__this</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">__this</span> <span class="p">=</span> <span class="n">__this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">{</span>
            <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__current</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">case</span> <span class="m">0</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__this</span><span class="p">.</span><span class="n">left</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__yield_value</span><span class="p">;</span>
                    <span class="n">__left</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
                    <span class="k">goto</span> <span class="k">case</span> <span class="m">1</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">2</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">__left</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span> <span class="k">goto</span> <span class="n">__left_dispose</span><span class="p">;</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__left</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="n">__left_dispose</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="n">__left</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>

                <span class="n">__yield_value</span><span class="p">:</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="k">value</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">2</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">__this</span><span class="p">.</span><span class="n">right</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">goto</span> <span class="n">__end</span><span class="p">;</span>
                    <span class="n">__right</span> <span class="p">=</span> <span class="n">__this</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
                    <span class="k">goto</span> <span class="k">case</span> <span class="m">3</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">3</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">3</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">__right</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span> <span class="k">goto</span> <span class="n">__right_dispose</span><span class="p">;</span>
                    <span class="n">__current</span> <span class="p">=</span> <span class="n">__right</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
                    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>

                <span class="n">__right_dispose</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
                    <span class="n">__right</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>

                <span class="n">__end</span><span class="p">:</span>
                    <span class="n">__state</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">__state</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="nf">Dispose</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">__state</span><span class="p">)</span> <span class="p">{</span>

                <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                <span class="k">case</span> <span class="p">-</span><span class="m">2</span><span class="p">:</span>
                    <span class="n">__left</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="k">case</span> <span class="m">3</span><span class="p">:</span>
                <span class="k">case</span> <span class="p">-</span><span class="m">3</span><span class="p">:</span>
                    <span class="n">__right</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span>
                <span class="n">__state</span> <span class="p">=</span> <span class="m">4</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The compiler generated temporaries used in the <code class="prettyprint">foreach</code> statements are lifted into the <code class="prettyprint">__left</code> and <code class="prettyprint">__right</code> fields of the enumerator object. The <code class="prettyprint">__state</code> field of the enumerator object is carefully updated so that the correct <code class="prettyprint">Dispose()</code> method will be called correctly if an exception is thrown. Note that it is not possible to write the translated code with simple <code class="prettyprint">foreach</code> statements.</p>

<h2 id="async-functions">Async functions</h2>

<p>A method (<a href="classes.md#methods">Methods</a>) or anonymous function (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) with the <code class="prettyprint">async</code> modifier is called an <strong><em>async function</em></strong>. In general, the term <strong><em>async</em></strong> is used to describe any kind of function that has the <code class="prettyprint">async</code> modifier.</p>

<p>It is a compile-time error for the formal parameter list of an async function to specify any <code class="prettyprint">ref</code> or <code class="prettyprint">out</code> parameters.</p>

<p>The <em>return_type</em> of an async method must be either <code class="prettyprint">void</code> or a <strong><em>task type</em></strong>. The task types are <code class="prettyprint">System.Threading.Tasks.Task</code> and types constructed from <code class="prettyprint">System.Threading.Tasks.Task&lt;T&gt;</code>. For the sake of brevity, in this chapter these types are referenced as <code class="prettyprint">Task</code> and <code class="prettyprint">Task&lt;T&gt;</code>, respectively. An async method returning a task type is said to be task-returning.</p>

<p>The exact definition of the task types is implementation defined, but from the language&rsquo;s point of view a task type is in one of the states incomplete, succeeded or faulted. A faulted task records a pertinent exception. A succeeded <code class="prettyprint">Task&lt;T&gt;</code> records a result of type <code class="prettyprint">T</code>. Task types are awaitable, and can therefore be the operands of await expressions (<a href="expressions.md#await-expressions">Await expressions</a>).</p>

<p>An async function invocation has the ability to suspend evaluation by means of await expressions (<a href="expressions.md#await-expressions">Await expressions</a>) in its body. Evaluation may later be resumed at the point of the suspending await expression by means of a <strong><em>resumption delegate</em></strong>. The resumption delegate is of type <code class="prettyprint">System.Action</code>, and when it is invoked, evaluation of the async function invocation will resume from the await expression where it left off. The <strong><em>current caller</em></strong> of an async function invocation is the original caller if the function invocation has never been suspended, or the most recent caller of the resumption delegate otherwise.</p>

<h3 id="evaluation-of-a-task-returning-async-function">Evaluation of a task-returning async function</h3>

<p>Invocation of a task-returning async function causes an instance of the returned task type to be generated. This is called the <strong><em>return task</em></strong> of the async function. The task is initially in an incomplete state.</p>

<p>The async function body is then evaluated until it is either suspended (by reaching an await expression) or terminates, at which point control is returned to the caller, along with the return task.</p>

<p>When the body of the async function terminates, the return task is moved out of the incomplete state:</p>

<ul>
<li> If the function body terminates as the result of reaching a return statement or the end of the body, any result value is recorded in the return task, which is put into a succeeded state.</li>
<li> If the function body terminates as the result of an uncaught exception (<a href="statements.md#the-throw-statement">The throw statement</a>) the exception is recorded in the return task which is put into a faulted state.</li>
</ul>

<h3 id="evaluation-of-a-void-returning-async-function">Evaluation of a void-returning async function</h3>

<p>If the return type of the async function is <code class="prettyprint">void</code>, evaluation differs from the above in the following way: Because no task is returned, the function instead communicates completion and exceptions to the current thread&rsquo;s <strong><em>synchronization context</em></strong>. The exact definition of synchronization context is implementation-dependent, but is a representation of &quot;where&rdquo; the current thread is running. The synchronization context is notified when evaluation of a void-returning async function commences, completes successfully, or causes an uncaught exception to be thrown.</p>

<p>This allows the context to keep track of how many void-returning async functions are running under it, and to decide how to propagate exceptions coming out of them.</p>
