<h1 id="types">Types</h1>

<p>The types of the C# language are divided into two main categories: <strong><em>value types</em></strong> and <strong><em>reference types</em></strong>. Both value types and reference types may be <strong><em>generic types</em></strong>, which take one or more <strong><em>type parameters</em></strong>. Type parameters can designate both value types and reference types.</p>
<pre class="highlight plaintext"><code>type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
</code></pre>
<p>The final category of types, pointers, is available only in unsafe code. This is discussed further in <a href="unsafe-code.md#pointer-types">Pointer types</a>.</p>

<p>Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store <strong><em>references</em></strong> to their data, the latter being known as <strong><em>objects</em></strong>. With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</p>

<p>C#&lsquo;s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the <code class="prettyprint">object</code> class type, and <code class="prettyprint">object</code> is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type <code class="prettyprint">object</code>. Values of value types are treated as objects by performing boxing and unboxing operations (<a href="types.md#boxing-and-unboxing">Boxing and unboxing</a>).</p>

<h2 id="value-types">Value types</h2>

<p>A value type is either a struct type or an enumeration type. C# provides a set of predefined struct types called the <strong><em>simple types</em></strong>. The simple types are identified through reserved words.</p>
<pre class="highlight plaintext"><code>value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
</code></pre>
<p>Unlike a variable of a reference type, a variable of a value type can contain the value <code class="prettyprint">null</code> only if the value type is a nullable type.  For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value <code class="prettyprint">null</code>.</p>

<p>Assignment to a variable of a value type creates a copy of the value being assigned. This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</p>

<h3 id="the-system-valuetype-type">The System.ValueType type</h3>

<p>All value types implicitly inherit from the class <code class="prettyprint">System.ValueType</code>, which, in turn, inherits from class <code class="prettyprint">object</code>. It is not possible for any type to derive from a value type, and value types are thus implicitly sealed (<a href="classes.md#sealed-classes">Sealed classes</a>).</p>

<p>Note that <code class="prettyprint">System.ValueType</code> is not itself a <em>value_type</em>. Rather, it is a <em>class_type</em> from which all *value_type*s are automatically derived.</p>

<h3 id="default-constructors">Default constructors</h3>

<p>All value types implicitly declare a public parameterless instance constructor called the <strong><em>default constructor</em></strong>. The default constructor returns a zero-initialized instance known as the <strong><em>default value</em></strong> for the value type:</p>

<ul>
<li> For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:

<ul>
<li>For <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code>, the default value is <code class="prettyprint">0</code>.</li>
<li>For <code class="prettyprint">char</code>, the default value is <code class="prettyprint">&#39;\x0000&#39;</code>.</li>
<li>For <code class="prettyprint">float</code>, the default value is <code class="prettyprint">0.0f</code>.</li>
<li>For <code class="prettyprint">double</code>, the default value is <code class="prettyprint">0.0d</code>.</li>
<li>For <code class="prettyprint">decimal</code>, the default value is <code class="prettyprint">0.0m</code>.</li>
<li>For <code class="prettyprint">bool</code>, the default value is <code class="prettyprint">false</code>.</li>
</ul></li>
<li> For an <em>enum_type</em> <code class="prettyprint">E</code>, the default value is <code class="prettyprint">0</code>, converted to the type <code class="prettyprint">E</code>.</li>
<li> For a <em>struct_type</em>, the default value is the value produced by setting all value type fields to their default value and all reference type fields to <code class="prettyprint">null</code>.</li>
<li> For a <em>nullable_type</em> the default value is an instance for which the <code class="prettyprint">HasValue</code> property is false and the <code class="prettyprint">Value</code> property is undefined. The default value is also known as the <strong><em>null value</em></strong> of the nullable type.</li>
</ul>

<p>Like any other instance constructor, the default constructor of a value type is invoked using the <code class="prettyprint">new</code> operator. For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call. In the example below, variables <code class="prettyprint">i</code> and <code class="prettyprint">j</code> are both initialized to zero.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor. A struct type is however permitted to declare parameterized instance constructors (<a href="structs.md#constructors">Constructors</a>).</p>

<h3 id="struct-types">Struct types</h3>

<p>A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types. The declaration of struct types is described in <a href="structs.md#struct-declarations">Struct declarations</a>.</p>

<h3 id="simple-types">Simple types</h3>

<p>C# provides a set of predefined struct types called the <strong><em>simple types</em></strong>. The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the <code class="prettyprint">System</code> namespace, as described in the table below.</p>

<table><thead>
<tr>
<th><strong>Reserved word</strong></th>
<th><strong>Aliased type</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">sbyte</code></td>
<td><code class="prettyprint">System.SByte</code></td>
</tr>
<tr>
<td><code class="prettyprint">byte</code></td>
<td><code class="prettyprint">System.Byte</code></td>
</tr>
<tr>
<td><code class="prettyprint">short</code></td>
<td><code class="prettyprint">System.Int16</code></td>
</tr>
<tr>
<td><code class="prettyprint">ushort</code></td>
<td><code class="prettyprint">System.UInt16</code></td>
</tr>
<tr>
<td><code class="prettyprint">int</code></td>
<td><code class="prettyprint">System.Int32</code></td>
</tr>
<tr>
<td><code class="prettyprint">uint</code></td>
<td><code class="prettyprint">System.UInt32</code></td>
</tr>
<tr>
<td><code class="prettyprint">long</code></td>
<td><code class="prettyprint">System.Int64</code></td>
</tr>
<tr>
<td><code class="prettyprint">ulong</code></td>
<td><code class="prettyprint">System.UInt64</code></td>
</tr>
<tr>
<td><code class="prettyprint">char</code></td>
<td><code class="prettyprint">System.Char</code></td>
</tr>
<tr>
<td><code class="prettyprint">float</code></td>
<td><code class="prettyprint">System.Single</code></td>
</tr>
<tr>
<td><code class="prettyprint">double</code></td>
<td><code class="prettyprint">System.Double</code></td>
</tr>
<tr>
<td><code class="prettyprint">bool</code></td>
<td><code class="prettyprint">System.Boolean</code></td>
</tr>
<tr>
<td><code class="prettyprint">decimal</code></td>
<td><code class="prettyprint">System.Decimal</code></td>
</tr>
</tbody></table>

<p>Because a simple type aliases a struct type, every simple type has members. For example, <code class="prettyprint">int</code> has the members declared in <code class="prettyprint">System.Int32</code> and the members inherited from <code class="prettyprint">System.Object</code>, and the following statements are permitted:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>           <span class="c1">// System.Int32.MaxValue constant</span>
<span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>        <span class="c1">// System.Int32.ToString() instance method</span>
<span class="kt">string</span> <span class="n">t</span> <span class="p">=</span> <span class="m">123.</span><span class="nf">ToString</span><span class="p">();</span>      <span class="c1">// System.Int32.ToString() instance method</span>
</code></pre>
<p>The simple types differ from other struct types in that they permit certain additional operations:</p>

<ul>
<li> Most simple types permit values to be created by writing <em>literals</em> (<a href="lexical-structure.md#literals">Literals</a>). For example, <code class="prettyprint">123</code> is a literal of type <code class="prettyprint">int</code> and <code class="prettyprint">&#39;a&#39;</code> is a literal of type <code class="prettyprint">char</code>. C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</li>
<li> When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time. Such an expression is known as a <em>constant_expression</em> (<a href="expressions.md#constant-expressions">Constant expressions</a>). Expressions involving operators defined by other struct types are not considered to be constant expressions.</li>
<li> Through <code class="prettyprint">const</code> declarations it is possible to declare constants of the simple types (<a href="classes.md#constants">Constants</a>). It is not possible to have constants of other struct types, but a similar effect is provided by <code class="prettyprint">static readonly</code> fields.</li>
<li> Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator (<a href="conversions.md#evaluation-of-user-defined-conversions">Evaluation of user-defined conversions</a>).</li>
</ul>

<h3 id="integral-types">Integral types</h3>

<p>C# supports nine integral types: <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, and <code class="prettyprint">char</code>. The integral types have the following sizes and ranges of values:</p>

<ul>
<li> The <code class="prettyprint">sbyte</code> type represents signed 8-bit integers with values between -128 and 127.</li>
<li> The <code class="prettyprint">byte</code> type represents unsigned 8-bit integers with values between 0 and 255.</li>
<li> The <code class="prettyprint">short</code> type represents signed 16-bit integers with values between -32768 and 32767.</li>
<li> The <code class="prettyprint">ushort</code> type represents unsigned 16-bit integers with values between 0 and 65535.</li>
<li> The <code class="prettyprint">int</code> type represents signed 32-bit integers with values between -2147483648 and 2147483647.</li>
<li> The <code class="prettyprint">uint</code> type represents unsigned 32-bit integers with values between 0 and 4294967295.</li>
<li> The <code class="prettyprint">long</code> type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</li>
<li> The <code class="prettyprint">ulong</code> type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</li>
<li> The <code class="prettyprint">char</code> type represents unsigned 16-bit integers with values between 0 and 65535. The set of possible values for the <code class="prettyprint">char</code> type corresponds to the Unicode character set. Although <code class="prettyprint">char</code> has the same representation as <code class="prettyprint">ushort</code>, not all operations permitted on one type are permitted on the other.</li>
</ul>

<p>The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</p>

<ul>
<li> For the unary <code class="prettyprint">+</code> and <code class="prettyprint">~</code> operators, the operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>.</li>
<li> For the unary <code class="prettyprint">-</code> operator, the operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code> and <code class="prettyprint">long</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>. The unary <code class="prettyprint">-</code> operator cannot be applied to operands of type <code class="prettyprint">ulong</code>.</li>
<li> For the binary <code class="prettyprint">+</code>, <code class="prettyprint">-</code>, <code class="prettyprint">*</code>, <code class="prettyprint">/</code>, <code class="prettyprint">%</code>, <code class="prettyprint">&amp;</code>, <code class="prettyprint">^</code>, <code class="prettyprint">|</code>, <code class="prettyprint">==</code>, <code class="prettyprint">!=</code>, <code class="prettyprint">&gt;</code>, <code class="prettyprint">&lt;</code>, <code class="prettyprint">&gt;=</code>, and <code class="prettyprint">&lt;=</code> operators, the operands are converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of both operands. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code> (or <code class="prettyprint">bool</code> for the relational operators). It is not permitted for one operand to be of type <code class="prettyprint">long</code> and the other to be of type <code class="prettyprint">ulong</code> with the binary operators.</li>
<li> For the binary <code class="prettyprint">&lt;&lt;</code> and <code class="prettyprint">&gt;&gt;</code> operators, the left operand is converted to type <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the first of <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, and <code class="prettyprint">ulong</code> that can fully represent all possible values of the operand. The operation is then performed using the precision of type <code class="prettyprint">T</code>, and the type of the result is <code class="prettyprint">T</code>.</li>
</ul>

<p>The <code class="prettyprint">char</code> type is classified as an integral type, but it differs from the other integral types in two ways:</p>

<ul>
<li> There are no implicit conversions from other types to the <code class="prettyprint">char</code> type. In particular, even though the <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, and <code class="prettyprint">ushort</code> types have ranges of values that are fully representable using the <code class="prettyprint">char</code> type, implicit conversions from <code class="prettyprint">sbyte</code>, <code class="prettyprint">byte</code>, or <code class="prettyprint">ushort</code> to <code class="prettyprint">char</code> do not exist.</li>
<li> Constants of the <code class="prettyprint">char</code> type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type <code class="prettyprint">char</code>. For example, <code class="prettyprint">(char)10</code> is the same as <code class="prettyprint">&#39;\x000A&#39;</code>.</li>
</ul>

<p>The <code class="prettyprint">checked</code> and <code class="prettyprint">unchecked</code> operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions (<a href="expressions.md#the-checked-and-unchecked-operators">The checked and unchecked operators</a>). In a <code class="prettyprint">checked</code> context, an overflow produces a compile-time error or causes a <code class="prettyprint">System.OverflowException</code> to be thrown. In an <code class="prettyprint">unchecked</code> context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</p>

<h3 id="floating-point-types">Floating point types</h3>

<p>C# supports two floating point types: <code class="prettyprint">float</code> and <code class="prettyprint">double</code>. The <code class="prettyprint">float</code> and <code class="prettyprint">double</code> types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</p>

<ul>
<li> Positive zero and negative zero. In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two (<a href="expressions.md#division-operator">Division operator</a>).</li>
<li> Positive infinity and negative infinity. Infinities are produced by such operations as dividing a non-zero number by zero. For example, <code class="prettyprint">1.0 / 0.0</code> yields positive infinity, and <code class="prettyprint">-1.0 / 0.0</code> yields negative infinity.</li>
<li> The <strong><em>Not-a-Number</em></strong> value, often abbreviated NaN. NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</li>
<li> The finite set of non-zero values of the form <code class="prettyprint">s * m * 2^e</code>, where <code class="prettyprint">s</code> is 1 or -1, and <code class="prettyprint">m</code> and <code class="prettyprint">e</code> are determined by the particular floating-point type: For <code class="prettyprint">float</code>, <code class="prettyprint">0 &lt; m &lt; 2^24</code> and <code class="prettyprint">-149 &lt;= e &lt;= 104</code>, and for <code class="prettyprint">double</code>, <code class="prettyprint">0 &lt; m &lt; 2^53</code> and <code class="prettyprint">1075 &lt;= e &lt;= 970</code>. Denormalized floating-point numbers are considered valid non-zero values.</li>
</ul>

<p>The <code class="prettyprint">float</code> type can represent values ranging from approximately <code class="prettyprint">1.5 * 10^-45</code> to <code class="prettyprint">3.4 * 10^38</code> with a precision of 7 digits.</p>

<p>The <code class="prettyprint">double</code> type can represent values ranging from approximately <code class="prettyprint">5.0 * 10^-324</code> to <code class="prettyprint">1.7 × 10^308</code> with a precision of 15-16 digits.</p>

<p>If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</p>

<ul>
<li> If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</li>
<li> Then, if either of the operands is of type <code class="prettyprint">double</code>, the other operand is converted to <code class="prettyprint">double</code>, the operation is performed using at least <code class="prettyprint">double</code> range and precision, and the type of the result is <code class="prettyprint">double</code> (or <code class="prettyprint">bool</code> for the relational operators).</li>
<li> Otherwise, the operation is performed using at least <code class="prettyprint">float</code> range and precision, and the type of the result is <code class="prettyprint">float</code> (or <code class="prettyprint">bool</code> for the relational operators).</li>
</ul>

<p>The floating-point operators, including the assignment operators, never produce exceptions. Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</p>

<ul>
<li> If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</li>
<li> If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</li>
<li> If a floating-point operation is invalid, the result of the operation becomes NaN.</li>
<li> If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</li>
</ul>

<p>Floating-point operations may be performed with higher precision than the result type of the operation. For example, some hardware architectures support an &ldquo;extended&rdquo; or &ldquo;long double&rdquo; floating-point type with greater range and precision than the <code class="prettyprint">double</code> type, and implicitly perform all floating-point operations using this higher precision type. Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations. Other than delivering more precise results, this rarely has any measurable effects. However, in expressions of the form <code class="prettyprint">x * y / z</code>, where the multiplication produces a result that is outside the <code class="prettyprint">double</code> range, but the subsequent division brings the temporary result back into the <code class="prettyprint">double</code> range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</p>

<h3 id="the-decimal-type">The decimal type</h3>

<p>The <code class="prettyprint">decimal</code> type is a 128-bit data type suitable for financial and monetary calculations. The <code class="prettyprint">decimal</code> type can represent values ranging from <code class="prettyprint">1.0 * 10^-28</code> to approximately <code class="prettyprint">7.9 * 10^28</code> with 28-29 significant digits.</p>

<p>The finite set of values of type <code class="prettyprint">decimal</code> are of the form <code class="prettyprint">(-1)^s * c * 10^-e</code>, where the sign <code class="prettyprint">s</code> is 0 or 1, the coefficient <code class="prettyprint">c</code> is given by <code class="prettyprint">0 &lt;= *c* &lt; 2^96</code>, and the scale <code class="prettyprint">e</code> is such that <code class="prettyprint">0 &lt;= e &lt;= 28</code>.The <code class="prettyprint">decimal</code> type does not support signed zeros, infinities, or NaN&rsquo;s. A <code class="prettyprint">decimal</code> is represented as a 96-bit integer scaled by a power of ten. For <code class="prettyprint">decimal</code>s with an absolute value less than <code class="prettyprint">1.0m</code>, the value is exact to the 28th decimal place, but no further. For <code class="prettyprint">decimal</code>s with an absolute value greater than or equal to <code class="prettyprint">1.0m</code>, the value is exact to 28 or 29 digits. Contrary to the <code class="prettyprint">float</code> and <code class="prettyprint">double</code> data types, decimal fractional numbers such as 0.1 can be represented exactly in the <code class="prettyprint">decimal</code> representation. In the <code class="prettyprint">float</code> and <code class="prettyprint">double</code> representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</p>

<p>If one of the operands of a binary operator is of type <code class="prettyprint">decimal</code>, then the other operand must be of an integral type or of type <code class="prettyprint">decimal</code>. If an integral type operand is present, it is converted to <code class="prettyprint">decimal</code> before the operation is performed.</p>

<p>The result of an operation on values of type <code class="prettyprint">decimal</code> is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation. Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as &ldquo;banker&rsquo;s rounding&rdquo;). A zero result always has a sign of 0 and a scale of 0.</p>

<p>If a decimal arithmetic operation produces a value less than or equal to <code class="prettyprint">5 * 10^-29</code> in absolute value, the result of the operation becomes zero. If a <code class="prettyprint">decimal</code> arithmetic operation produces a result that is too large for the <code class="prettyprint">decimal</code> format, a <code class="prettyprint">System.OverflowException</code> is thrown.</p>

<p>The <code class="prettyprint">decimal</code> type has greater precision but smaller range than the floating-point types. Thus, conversions from the floating-point types to <code class="prettyprint">decimal</code> might produce overflow exceptions, and conversions from <code class="prettyprint">decimal</code> to the floating-point types might cause loss of precision. For these reasons, no implicit conversions exist between the floating-point types and <code class="prettyprint">decimal</code>, and without explicit casts, it is not possible to mix floating-point and <code class="prettyprint">decimal</code> operands in the same expression.</p>

<h3 id="the-bool-type">The bool type</h3>

<p>The <code class="prettyprint">bool</code> type represents boolean logical quantities. The possible values of type <code class="prettyprint">bool</code> are <code class="prettyprint">true</code> and <code class="prettyprint">false</code>.</p>

<p>No standard conversions exist between <code class="prettyprint">bool</code> and other types. In particular, the <code class="prettyprint">bool</code> type is distinct and separate from the integral types, and a <code class="prettyprint">bool</code> value cannot be used in place of an integral value, and vice versa.</p>

<p>In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value <code class="prettyprint">false</code>, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value <code class="prettyprint">true</code>. In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to <code class="prettyprint">null</code>.</p>

<h3 id="enumeration-types">Enumeration types</h3>

<p>An enumeration type is a distinct type with named constants. Every enumeration type has an underlying type, which must be <code class="prettyprint">byte</code>, <code class="prettyprint">sbyte</code>, <code class="prettyprint">short</code>, <code class="prettyprint">ushort</code>, <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code> or <code class="prettyprint">ulong</code>. The set of values of the enumeration type is the same as the set of values of the underlying type. Values of the enumeration type are not restricted to the values of the named constants. Enumeration types are defined through enumeration declarations (<a href="enums.md#enum-declarations">Enum declarations</a>).</p>

<h3 id="nullable-types">Nullable types</h3>

<p>A nullable type can represent all values of its <strong><em>underlying type</em></strong> plus an additional null value. A nullable type is written <code class="prettyprint">T?</code>, where <code class="prettyprint">T</code> is the underlying type. This syntax is shorthand for <code class="prettyprint">System.Nullable&lt;T&gt;</code>, and the two forms can be used interchangeably.</p>

<p>A <strong><em>non-nullable value type</em></strong> conversely is any value type other than <code class="prettyprint">System.Nullable&lt;T&gt;</code> and its shorthand <code class="prettyprint">T?</code> (for any <code class="prettyprint">T</code>), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a <code class="prettyprint">struct</code> constraint). The <code class="prettyprint">System.Nullable&lt;T&gt;</code> type specifies the value type constraint for <code class="prettyprint">T</code> (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>), which means that the underlying type of a nullable type can be any non-nullable value type. The underlying type of a nullable type cannot be a nullable type or a reference type. For example, <code class="prettyprint">int??</code> and <code class="prettyprint">string?</code> are invalid types.</p>

<p>An instance of a nullable type <code class="prettyprint">T?</code> has two public read-only properties:</p>

<ul>
<li> A <code class="prettyprint">HasValue</code> property of type <code class="prettyprint">bool</code></li>
<li> A <code class="prettyprint">Value</code> property of type <code class="prettyprint">T</code></li>
</ul>

<p>An instance for which <code class="prettyprint">HasValue</code> is true is said to be non-null. A non-null instance contains a known value and <code class="prettyprint">Value</code> returns that value.</p>

<p>An instance for which <code class="prettyprint">HasValue</code> is false is said to be null. A null instance has an undefined value. Attempting to read the <code class="prettyprint">Value</code> of a null instance causes a <code class="prettyprint">System.InvalidOperationException</code> to be thrown. The process of accessing the <code class="prettyprint">Value</code> property of a nullable instance is referred to as <strong><em>unwrapping</em></strong>.</p>

<p>In addition to the default constructor, every nullable type <code class="prettyprint">T?</code> has a public constructor that takes a single argument of type <code class="prettyprint">T</code>. Given a value <code class="prettyprint">x</code> of type <code class="prettyprint">T</code>, a constructor invocation of the form</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">new</span> <span class="n">T</span><span class="p">?(</span><span class="n">x</span><span class="p">)</span>
</code></pre>
<p>creates a non-null instance of <code class="prettyprint">T?</code> for which the <code class="prettyprint">Value</code> property is <code class="prettyprint">x</code>. The process of creating a non-null instance of a nullable type for a given value is referred to as <strong><em>wrapping</em></strong>.</p>

<p>Implicit conversions are available from the <code class="prettyprint">null</code> literal to <code class="prettyprint">T?</code> (<a href="conversions.md#null-literal-conversions">Null literal conversions</a>) and from <code class="prettyprint">T</code> to <code class="prettyprint">T?</code> (<a href="conversions.md#implicit-nullable-conversions">Implicit nullable conversions</a>).</p>

<h2 id="reference-types">Reference types</h2>

<p>A reference type is a class type, an interface type, an array type, or a delegate type.</p>
<pre class="highlight plaintext"><code>reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
</code></pre>
<p>A reference type value is a reference to an <strong><em>instance</em></strong> of the type, the latter known as an <strong><em>object</em></strong>. The special value <code class="prettyprint">null</code> is compatible with all reference types and indicates the absence of an instance.</p>

<h3 id="class-types">Class types</h3>

<p>A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types. Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes. Instances of class types are created using *object_creation_expression*s (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>).</p>

<p>Class types are described in <a href="classes.md#classes">Classes</a>.</p>

<p>Certain predefined class types have special meaning in the C# language, as described in the table below.</p>

<table><thead>
<tr>
<th><strong>Class type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead><tbody>
<tr>
<td><code class="prettyprint">System.Object</code></td>
<td>The ultimate base class of all other types. See <a href="types.md#the-object-type">The object type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.String</code></td>
<td>The string type of the C# language. See <a href="types.md#the-string-type">The string type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.ValueType</code></td>
<td>The base class of all value types. See <a href="types.md#the-systemvaluetype-type">The System.ValueType type</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Enum</code></td>
<td>The base class of all enum types. See <a href="enums.md#enums">Enums</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Array</code></td>
<td>The base class of all array types. See <a href="arrays.md#arrays">Arrays</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Delegate</code></td>
<td>The base class of all delegate types. See <a href="delegates.md#delegates">Delegates</a>.</td>
</tr>
<tr>
<td><code class="prettyprint">System.Exception</code></td>
<td>The base class of all exception types. See <a href="exceptions.md#exceptions">Exceptions</a>.</td>
</tr>
</tbody></table>

<h3 id="the-object-type">The object type</h3>

<p>The <code class="prettyprint">object</code> class type is the ultimate base class of all other types. Every type in C# directly or indirectly derives from the <code class="prettyprint">object</code> class type.</p>

<p>The keyword <code class="prettyprint">object</code> is simply an alias for the predefined class <code class="prettyprint">System.Object</code>.</p>

<h3 id="the-dynamic-type">The dynamic type</h3>

<p>The <code class="prettyprint">dynamic</code> type, like <code class="prettyprint">object</code>, can reference any object. When operators are applied to expressions of type <code class="prettyprint">dynamic</code>, their resolution is deferred until the program is run. Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation. Instead an exception will be thrown when resolution of the operator fails at run-time.</p>

<p>Its purpose is to allow dynamic binding, which is described in detail in <a href="expressions.md#dynamic-binding">Dynamic binding</a>.</p>

<p><code class="prettyprint">dynamic</code> is considered identical to <code class="prettyprint">object</code> except in the following respects:</p>

<ul>
<li> Operations on expressions of type <code class="prettyprint">dynamic</code> can be dynamically bound (<a href="expressions.md#dynamic-binding">Dynamic binding</a>).</li>
<li> Type inference (<a href="expressions.md#type-inference">Type inference</a>) will prefer <code class="prettyprint">dynamic</code> over <code class="prettyprint">object</code> if both are candidates.</li>
</ul>

<p>Because of this equivalence, the following holds:</p>

<ul>
<li> There is an implicit identity conversion between <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>, and between constructed types that are the same when replacing <code class="prettyprint">dynamic</code> with <code class="prettyprint">object</code></li>
<li> Implicit and explicit conversions to and from <code class="prettyprint">object</code> also apply to and from <code class="prettyprint">dynamic</code>.</li>
<li> Method signatures that are the same when replacing <code class="prettyprint">dynamic</code> with <code class="prettyprint">object</code> are considered the same signature</li>
<li> The type <code class="prettyprint">dynamic</code> is indistinguishable from <code class="prettyprint">object</code> at run-time.</li>
<li> An expression of the type <code class="prettyprint">dynamic</code> is referred to as a <strong><em>dynamic expression</em></strong>.</li>
</ul>

<h3 id="the-string-type">The string type</h3>

<p>The <code class="prettyprint">string</code> type is a sealed class type that inherits directly from <code class="prettyprint">object</code>. Instances of the <code class="prettyprint">string</code> class represent Unicode character strings.</p>

<p>Values of the <code class="prettyprint">string</code> type can be written as string literals (<a href="lexical-structure.md#string-literals">String literals</a>).</p>

<p>The keyword <code class="prettyprint">string</code> is simply an alias for the predefined class <code class="prettyprint">System.String</code>.</p>

<h3 id="interface-types">Interface types</h3>

<p>An interface defines a contract. A class or struct that implements an interface must adhere to its contract. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</p>

<p>Interface types are described in <a href="interfaces.md#interfaces">Interfaces</a>.</p>

<h3 id="array-types">Array types</h3>

<p>An array is a data structure that contains zero or more variables which are accessed through computed indices. The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</p>

<p>Array types are described in <a href="arrays.md#arrays">Arrays</a>.</p>

<h3 id="delegate-types">Delegate types</h3>

<p>A delegate is a data structure that refers to one or more methods. For instance methods, it also refers to their corresponding object instances.</p>

<p>The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods. In the latter case, the delegate stores not only a reference to the method&rsquo;s entry point, but also a reference to the object instance on which to invoke the method.</p>

<p>Delegate types are described in <a href="delegates.md#delegates">Delegates</a>.</p>

<h2 id="boxing-and-unboxing">Boxing and unboxing</h2>

<p>The concept of boxing and unboxing is central to C#&rsquo;s type system. It provides a bridge between <em>value_type*s and *reference_type*s by permitting any value of a *value_type</em> to be converted to and from type <code class="prettyprint">object</code>. Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</p>

<h3 id="boxing-conversions">Boxing conversions</h3>

<p>A boxing conversion permits a <em>value_type</em> to be implicitly converted to a <em>reference_type</em>. The following boxing conversions exist:</p>

<ul>
<li> From any <em>value_type</em> to the type <code class="prettyprint">object</code>.</li>
<li> From any <em>value_type</em> to the type <code class="prettyprint">System.ValueType</code>.</li>
<li> From any <em>non_nullable_value_type</em> to any <em>interface_type</em> implemented by the <em>value_type</em>.</li>
<li> From any <em>nullable_type</em> to any <em>interface_type</em> implemented by the underlying type of the <em>nullable_type</em>.</li>
<li> From any <em>enum_type</em> to the type <code class="prettyprint">System.Enum</code>.</li>
<li> From any <em>nullable_type</em> with an underlying <em>enum_type</em> to the type <code class="prettyprint">System.Enum</code>.</li>
<li> Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type (<a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a>).</li>
</ul>

<p>Boxing a value of a <em>non_nullable_value_type</em> consists of allocating an object instance and copying the <em>non_nullable_value_type</em> value into that instance.</p>

<p>Boxing a value of a <em>nullable_type</em> produces a null reference if it is the <code class="prettyprint">null</code> value (<code class="prettyprint">HasValue</code> is <code class="prettyprint">false</code>), or the result of unwrapping and boxing the underlying value otherwise.</p>

<p>The actual process of boxing a value of a <em>non_nullable_value_type</em> is best explained by imagining the existence of a generic <strong><em>boxing class</em></strong>, which behaves as if it were declared as follows:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">sealed</span> <span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">System</span><span class="p">.</span><span class="n">ValueType</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="k">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">Box</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">value</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Boxing of a value <code class="prettyprint">v</code> of type <code class="prettyprint">T</code> now consists of executing the expression <code class="prettyprint">new Box&lt;T&gt;(v)</code>, and returning the resulting instance as a value of type <code class="prettyprint">object</code>. Thus, the statements
<code class="prettyprint">csharp
int i = 123;
object box = i;
</code>
conceptually correspond to
<code class="prettyprint">csharp
int i = 123;
object box = new Box&lt;int&gt;(i);
</code></p>

<p>A boxing class like <code class="prettyprint">Box&lt;T&gt;</code> above doesn&rsquo;t actually exist and the dynamic type of a boxed value isn&rsquo;t actually a class type. Instead, a boxed value of type <code class="prettyprint">T</code> has the dynamic type <code class="prettyprint">T</code>, and a dynamic type check using the <code class="prettyprint">is</code> operator can simply reference type <code class="prettyprint">T</code>. For example,
<code class="prettyprint">csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write(&quot;Box contains an int&quot;);
}
</code>
will output the string &ldquo;<code class="prettyprint">Box contains an int</code>&rdquo; on the console.</p>

<p>A boxing conversion implies making a copy of the value being boxed. This is different from a conversion of a <em>reference_type</em> to type <code class="prettyprint">object</code>, in which the value continues to reference the same instance and simply is regarded as the less derived type <code class="prettyprint">object</code>. For example, given the declaration
&ldquo;`csharp
struct Point
{
    public int x, y;</p>

<p>public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
<code class="prettyprint">
the following statements
</code>csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
&rdquo;<code class="prettyprint">
will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of</code>p<code class="prettyprint">to</code>box<code class="prettyprint">causes the value of</code>p<code class="prettyprint">to be copied. Had</code>Point<code class="prettyprint">been declared a</code>class<code class="prettyprint">instead, the value 20 would be output because</code>p<code class="prettyprint">and</code>box` would reference the same instance.</p>

<h3 id="unboxing-conversions">Unboxing conversions</h3>

<p>An unboxing conversion permits a <em>reference_type</em> to be explicitly converted to a <em>value_type</em>. The following unboxing conversions exist:</p>

<ul>
<li> From the type <code class="prettyprint">object</code> to any <em>value_type</em>.</li>
<li> From the type <code class="prettyprint">System.ValueType</code> to any <em>value_type</em>.</li>
<li> From any <em>interface_type</em> to any <em>non_nullable_value_type</em> that implements the <em>interface_type</em>.</li>
<li> From any <em>interface_type</em> to any <em>nullable_type</em> whose underlying type implements the <em>interface_type</em>.</li>
<li> From the type <code class="prettyprint">System.Enum</code> to any <em>enum_type</em>.</li>
<li> From the type <code class="prettyprint">System.Enum</code> to any <em>nullable_type</em> with an underlying <em>enum_type</em>.</li>
<li> Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type (<a href="conversions.md#explicit-dynamic-conversions">Explicit dynamic conversions</a>).</li>
</ul>

<p>An unboxing operation to a <em>non_nullable_value_type</em> consists of first checking that the object instance is a boxed value of the given <em>non_nullable_value_type</em>, and then copying the value out of the instance.</p>

<p>Unboxing to a <em>nullable_type</em> produces the null value of the <em>nullable_type</em> if the source operand is <code class="prettyprint">null</code>, or the wrapped result of unboxing the object instance to the underlying type of the <em>nullable_type</em> otherwise.</p>

<p>Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object <code class="prettyprint">box</code> to a <em>value_type</em> <code class="prettyprint">T</code> consists of executing the expression <code class="prettyprint">((Box&lt;T&gt;)box).value</code>. Thus, the statements
<code class="prettyprint">csharp
object box = 123;
int i = (int)box;
</code>
conceptually correspond to
<code class="prettyprint">csharp
object box = new Box&lt;int&gt;(123);
int i = ((Box&lt;int&gt;)box).value;
</code></p>

<p>For an unboxing conversion to a given <em>non_nullable_value_type</em> to succeed at run-time, the value of the source operand must be a reference to a boxed value of that <em>non_nullable_value_type</em>. If the source operand is <code class="prettyprint">null</code>, a <code class="prettyprint">System.NullReferenceException</code> is thrown. If the source operand is a reference to an incompatible object, a <code class="prettyprint">System.InvalidCastException</code> is thrown.</p>

<p>For an unboxing conversion to a given <em>nullable_type</em> to succeed at run-time, the value of the source operand must be either <code class="prettyprint">null</code> or a reference to a boxed value of the underlying <em>non_nullable_value_type</em> of the <em>nullable_type</em>. If the source operand is a reference to an incompatible object, a <code class="prettyprint">System.InvalidCastException</code> is thrown.</p>

<h2 id="constructed-types">Constructed types</h2>

<p>A generic type declaration, by itself, denotes an <strong><em>unbound generic type</em></strong> that is used as a &ldquo;blueprint&rdquo; to form many different types, by way of applying <strong><em>type arguments</em></strong>. The type arguments are written within angle brackets (<code class="prettyprint">&lt;</code> and <code class="prettyprint">&gt;</code>) immediately following the name of the generic type. A type that includes at least one type argument is called a <strong><em>constructed type</em></strong>. A constructed type can be used in most places in the language in which a type name can appear. An unbound generic type can only be used within a <em>typeof_expression</em> (<a href="expressions.md#the-typeof-operator">The typeof operator</a>).</p>

<p>Constructed types can also be used in expressions as simple names (<a href="expressions.md#simple-names">Simple names</a>) or when accessing a member (<a href="expressions.md#member-access">Member access</a>).</p>

<p>When a <em>namespace_or_type_name</em> is evaluated, only generic types with the correct number of type parameters are considered. Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters. This is useful when mixing generic and non-generic classes in the same program:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">namespace</span> <span class="nn">Widgets</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Queue</span> <span class="p">{...}</span>
    <span class="k">class</span> <span class="nc">Queue</span><span class="p">&lt;</span><span class="n">TElement</span><span class="p">&gt;</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nn">MyApplication</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">Widgets</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">X</span>
    <span class="p">{</span>
        <span class="n">Queue</span> <span class="n">q1</span><span class="p">;</span>            <span class="c1">// Non-generic Widgets.Queue</span>
        <span class="n">Queue</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">q2</span><span class="p">;</span>       <span class="c1">// Generic Widgets.Queue</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>A <em>type_name</em> might identify a constructed type even though it doesn&rsquo;t specify type parameters directly. This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup (<a href="classes.md#nested-types-in-generic-classes">Nested types in generic classes</a>):</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Outer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Inner</span> <span class="p">{...}</span>

    <span class="k">public</span> <span class="n">Inner</span> <span class="n">i</span><span class="p">;</span>                <span class="c1">// Type of i is Outer&lt;T&gt;.Inner</span>
<span class="p">}</span>
</code></pre>
<p>In unsafe code, a constructed type cannot be used as an <em>unmanaged_type</em> (<a href="unsafe-code.md#pointer-types">Pointer types</a>).</p>

<h3 id="type-arguments">Type arguments</h3>

<p>Each argument in a type argument list is simply a <em>type</em>.</p>
<pre class="highlight plaintext"><code>type_argument_list
    : '&lt;' type_arguments '&gt;'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
</code></pre>
<p>In unsafe code (<a href="unsafe-code.md#unsafe-code">Unsafe code</a>), a <em>type_argument</em> may not be a pointer type. Each type argument must satisfy any constraints on the corresponding type parameter (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</p>

<h3 id="open-and-closed-types">Open and closed types</h3>

<p>All types can be classified as either <strong><em>open types</em></strong> or <strong><em>closed types</em></strong>. An open type is a type that involves type parameters. More specifically:</p>

<ul>
<li> A type parameter defines an open type.</li>
<li> An array type is an open type if and only if its element type is an open type.</li>
<li> A constructed type is an open type if and only if one or more of its type arguments is an open type. A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</li>
</ul>

<p>A closed type is a type that is not an open type.</p>

<p>At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration. Each type parameter within the generic type is bound to a particular run-time type. The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</p>

<p>Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types. Since an open type does not exist at run-time, there are no static variables associated with an open type. Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</p>

<h3 id="bound-and-unbound-types">Bound and unbound types</h3>

<p>The term <strong><em>unbound type</em></strong> refers to a non-generic type or an unbound generic type. The term <strong><em>bound type</em></strong> refers to a non-generic type or a constructed type.</p>

<p>An unbound type refers to the entity declared by a type declaration. An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type. The only construct in which an unbound generic type can be referenced is the <code class="prettyprint">typeof</code> expression (<a href="expressions.md#the-typeof-operator">The typeof operator</a>).</p>

<h3 id="satisfying-constraints">Satisfying constraints</h3>

<p>Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>). For each <code class="prettyprint">where</code> clause, the type argument <code class="prettyprint">A</code> that corresponds to the named type parameter is checked against each constraint as follows:</p>

<ul>
<li> If the constraint is a class type, an interface type, or a type parameter, let <code class="prettyprint">C</code> represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint. To satisfy the constraint, it must be the case that type <code class="prettyprint">A</code> is convertible to type <code class="prettyprint">C</code> by one of the following:

<ul>
<li>An identity conversion (<a href="conversions.md#identity-conversion">Identity conversion</a>)</li>
<li>An implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>)</li>
<li>A boxing conversion (<a href="conversions.md#boxing-conversions">Boxing conversions</a>), provided that type A is a non-nullable value type.</li>
<li>An implicit reference, boxing or type parameter conversion from a type parameter <code class="prettyprint">A</code> to <code class="prettyprint">C</code>.</li>
</ul></li>
<li> If the constraint is the reference type constraint (<code class="prettyprint">class</code>), the type <code class="prettyprint">A</code> must satisfy one of the following:

<ul>
<li><code class="prettyprint">A</code> is an interface type, class type, delegate type or array type. Note that <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">System.Enum</code> are reference types that satisfy this constraint.</li>
<li><code class="prettyprint">A</code> is a type parameter that is known to be a reference type (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
</ul></li>
<li> If the constraint is the value type constraint (<code class="prettyprint">struct</code>), the type <code class="prettyprint">A</code> must satisfy one of the following:

<ul>
<li><code class="prettyprint">A</code> is a struct type or enum type, but not a nullable type. Note that <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">System.Enum</code> are reference types that do not satisfy this constraint.</li>
<li><code class="prettyprint">A</code> is a type parameter having the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
</ul></li>
<li> If the constraint is the constructor constraint <code class="prettyprint">new()</code>, the type <code class="prettyprint">A</code> must not be <code class="prettyprint">abstract</code> and must have a public parameterless constructor. This is satisfied if one of the following is true:

<ul>
<li><code class="prettyprint">A</code> is a value type, since all value types have a public default constructor (<a href="types.md#default-constructors">Default constructors</a>).</li>
<li><code class="prettyprint">A</code> is a type parameter having the constructor constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li><code class="prettyprint">A</code> is a type parameter having the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li><code class="prettyprint">A</code> is a class that is not <code class="prettyprint">abstract</code> and contains an explicitly declared <code class="prettyprint">public</code> constructor with no parameters.</li>
<li><code class="prettyprint">A</code> is not <code class="prettyprint">abstract</code> and has a default constructor (<a href="classes.md#default-constructors">Default constructors</a>).</li>
</ul></li>
</ul>

<p>A compile-time error occurs if one or more of a type parameter&rsquo;s constraints are not satisfied by the given type arguments.</p>

<p>Since type parameters are not inherited, constraints are never inherited either. In the example below, <code class="prettyprint">D</code> needs to specify the constraint on its type parameter <code class="prettyprint">T</code> so that <code class="prettyprint">T</code> satisfies the constraint imposed by the base class <code class="prettyprint">B&lt;T&gt;</code>. In contrast, class <code class="prettyprint">E</code> need not specify a constraint, because <code class="prettyprint">List&lt;T&gt;</code> implements <code class="prettyprint">IEnumerable</code> for any <code class="prettyprint">T</code>.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IEnumerable</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">D</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">IEnumerable</span> <span class="p">{...}</span>

<span class="k">class</span> <span class="nc">E</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;:</span> <span class="n">B</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="p">{...}</span>
</code></pre>
<h2 id="type-parameters">Type parameters</h2>

<p>A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</p>
<pre class="highlight plaintext"><code>type_parameter
    : identifier
    ;
</code></pre>
<p>Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types. These include:</p>

<ul>
<li> A type parameter cannot be used directly to declare a base class (<a href="classes.md#base-class">Base class</a>) or interface (<a href="interfaces.md#variant-type-parameter-lists">Variant type parameter lists</a>).</li>
<li> The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter. They are detailed in <a href="expressions.md#member-lookup">Member lookup</a>.</li>
<li> The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter. They are detailed in <a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a> and <a href="conversions.md#explicit-dynamic-conversions">Explicit dynamic conversions</a>.</li>
<li> The literal <code class="prettyprint">null</code> cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type (<a href="conversions.md#implicit-conversions-involving-type-parameters">Implicit conversions involving type parameters</a>). However, a <code class="prettyprint">default</code> expression (<a href="expressions.md#default-value-expressions">Default value expressions</a>) can be used instead. In addition, a value with a type given by a type parameter can be compared with <code class="prettyprint">null</code> using <code class="prettyprint">==</code> and <code class="prettyprint">!=</code> (<a href="expressions.md#reference-type-equality-operators">Reference type equality operators</a>) unless the type parameter has the value type constraint.</li>
<li> A <code class="prettyprint">new</code> expression (<a href="expressions.md#object-creation-expressions">Object creation expressions</a>) can only be used with a type parameter if the type parameter is constrained by a <em>constructor_constraint</em> or the value type constraint (<a href="classes.md#type-parameter-constraints">Type parameter constraints</a>).</li>
<li> A type parameter cannot be used anywhere within an attribute.</li>
<li> A type parameter cannot be used in a member access (<a href="expressions.md#member-access">Member access</a>) or type name (<a href="basic-concepts.md#namespace-and-type-names">Namespace and type names</a>) to identify a static member or a nested type.</li>
<li> In unsafe code, a type parameter cannot be used as an <em>unmanaged_type</em> (<a href="unsafe-code.md#pointer-types">Pointer types</a>).</li>
</ul>

<p>As a type, type parameters are purely a compile-time construct. At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration. Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type (<a href="types.md#open-and-closed-types">Open and closed types</a>). The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</p>

<h2 id="expression-tree-types">Expression tree types</h2>

<p><strong><em>Expression trees</em></strong> permit lambda expressions to be represented as data structures instead of executable code. Expression trees are values of <strong><em>expression tree types</em></strong> of the form <code class="prettyprint">System.Linq.Expressions.Expression&lt;D&gt;</code>, where <code class="prettyprint">D</code> is any delegate type. For the remainder of this specification we will refer to these types using the shorthand <code class="prettyprint">Expression&lt;D&gt;</code>.</p>

<p>If a conversion exists from a lambda expression to a delegate type <code class="prettyprint">D</code>, a conversion also exists to the expression tree type <code class="prettyprint">Expression&lt;D&gt;</code>. Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</p>

<p>Expression trees are efficient in-memory data representations of lambda expressionsand make the structure of the lambda expressiontransparent and explicit.</p>

<p>Just like a delegate type <code class="prettyprint">D</code>, <code class="prettyprint">Expression&lt;D&gt;</code> is said to have parameter and return types, which are the same as those of <code class="prettyprint">D</code>.</p>

<p>The following example represents a lambda expressionboth as executable code and as an expression tree. Because a conversion exists to <code class="prettyprint">Func&lt;int,int&gt;</code>, a conversion also exists to <code class="prettyprint">Expression&lt;Func&lt;int,int&gt;&gt;</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">del</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>                    <span class="c1">// Code</span>

<span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;&gt;</span> <span class="n">exp</span> <span class="p">=</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>        <span class="c1">// Data</span>
</code></pre>
<p>Following these assignments, the delegate <code class="prettyprint">del</code> references a method that returns <code class="prettyprint">x + 1</code>, and the expression tree <code class="prettyprint">exp</code> references a data structure that describes the expression <code class="prettyprint">x =&gt; x + 1</code>.</p>

<p>The exact definition of the generic type <code class="prettyprint">Expression&lt;D&gt;</code> as well as the precise rules for constructing an expression tree when a lambda expressionis converted to an expression tree type, are both outside the scope of this specification.</p>

<p>Two things are important to make explicit:</p>

<ul>
<li> Not all lambda expressions can be converted to expression trees. For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented. In these cases, a conversion still exists, but will fail at compile-time. These exceptions are detailed in <a href="conversions.md#anonymous-function-conversions">Anonymous function conversions</a>.</li>
<li><p><code class="prettyprint">Expression&lt;D&gt;</code> offers an instance method <code class="prettyprint">Compile</code> which produces a delegate of type <code class="prettyprint">D</code>:</p>
<pre class="highlight csharp tab-csharp"><code><span class="n">Func</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">del2</span> <span class="p">=</span> <span class="n">exp</span><span class="p">.</span><span class="nf">Compile</span><span class="p">();</span>
</code></pre>
<p>Invoking this delegate causes the code represented by the expression tree to be executed. Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</p>
<pre class="highlight csharp tab-csharp"><code><span class="kt">int</span> <span class="n">i1</span> <span class="p">=</span> <span class="nf">del</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">i2</span> <span class="p">=</span> <span class="nf">del2</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
</code></pre>
<p>After executing this code,  <code class="prettyprint">i1</code> and <code class="prettyprint">i2</code> will both have the value <code class="prettyprint">2</code>.</p></li>
</ul>
