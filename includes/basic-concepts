<h1 id="basic-concepts">Basic concepts</h1>

<h2 id="application-startup">Application Startup</h2>

<p>An assembly that has an <strong><em>entry point</em></strong> is called an <strong><em>application</em></strong>. When an application is run, a new <strong><em>application domain</em></strong> is created. Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</p>

<p>An application domain enables application isolation by acting as a container for application state. An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses. Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains. For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain. Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</p>

<p><strong><em>Application startup</em></strong> occurs when the execution environment calls a designated method, which is referred to as the application&rsquo;s entry point. This entry point method is always named <code class="prettyprint">Main</code>, and can have one of the following signatures:</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{...}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{...}</span>
</code></pre>
<p>As shown, the entry point may optionally return an <code class="prettyprint">int</code> value. This return value is used in application termination (<a href="basic-concepts.md#application-termination">Application termination</a>).</p>

<p>The entry point may optionally have one formal parameter. The parameter may have any name, but the type of the parameter must be <code class="prettyprint">string[]</code>. If the formal parameter is present, the execution environment creates and passes a <code class="prettyprint">string[]</code> argument containing the command-line arguments that were specified when the application was started. The <code class="prettyprint">string[]</code> argument is never null, but it may have a length of zero if no command-line arguments were specified.</p>

<p>Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature. However, within a single program, no class or struct may contain more than one method called <code class="prettyprint">Main</code> whose definition qualifies it to be used as an application entry point. Other overloaded versions of <code class="prettyprint">Main</code> are permitted, however, provided they have more than one parameter, or their only parameter is other than type <code class="prettyprint">string[]</code>.</p>

<p>An application can be made up of multiple classes or structs. It is possible for more than one of these classes or structs to contain a method called <code class="prettyprint">Main</code> whose definition qualifies it to be used as an application entry point. In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these <code class="prettyprint">Main</code> methods as the entry point.</p>

<p>In C#, every method must be defined as a member of a class or struct. Ordinarily, the declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) of a method is determined by the access modifiers (<a href="classes.md#access-modifiers">Access modifiers</a>) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration. In order for a given method of a given type to be callable, both the type and the member must be accessible. However, the application entry point is a special case. Specifically, the execution environment can access the application&rsquo;s entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</p>

<p>The application entry point method may not be in a generic class declaration.</p>

<p>In all other respects, entry point methods behave like those that are not entry points.</p>

<h2 id="application-termination">Application termination</h2>

<p><strong><em>Application termination</em></strong> returns control to the execution environment.</p>

<p>If the return type of the application&rsquo;s <strong><em>entry point</em></strong> method is <code class="prettyprint">int</code>, the value returned serves as the application&rsquo;s <strong><em>termination status code</em></strong>. The purpose of this code is to allow communication of success or failure to the execution environment.</p>

<p>If the return type of the entry point method is <code class="prettyprint">void</code>, reaching the right brace (<code class="prettyprint">}</code>) which terminates that method, or executing a <code class="prettyprint">return</code> statement that has no expression, results in a termination status code of <code class="prettyprint">0</code>.</p>

<p>Prior to an application&rsquo;s termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method <code class="prettyprint">GC.SuppressFinalize</code>, for example).</p>

<h2 id="declarations">Declarations</h2>

<p>Declarations in a C# program define the constituent elements of the program. C# programs are organized using namespaces (<a href="namespaces.md#namespaces">Namespaces</a>), which can contain type declarations and nested namespace declarations. Type declarations (<a href="namespaces.md#type-declarations">Type declarations</a>) are used to define classes (<a href="classes.md#classes">Classes</a>), structs (<a href="classes.md#iterators">Iterators</a>), interfaces (<a href="interfaces.md#interfaces">Interfaces</a>), enums (<a href="enums.md#enums">Enums</a>), and delegates (<a href="delegates.md#delegates">Delegates</a>). The kinds of members permitted in a type declaration depend on the form of the type declaration. For instance, class declarations can contain declarations for constants (<a href="classes.md#constants">Constants</a>), fields (<a href="classes.md#fields">Fields</a>), methods (<a href="classes.md#methods">Methods</a>), properties (<a href="classes.md#properties">Properties</a>), events (<a href="classes.md#events">Events</a>), indexers (<a href="classes.md#indexers">Indexers</a>), operators (<a href="classes.md#operators">Operators</a>), instance constructors (<a href="classes.md#instance-constructors">Instance constructors</a>), static constructors (<a href="classes.md#static-constructors">Static constructors</a>), destructors (<a href="classes.md#destructors">Destructors</a>), and nested types(<a href="classes.md#nested-types">Nested types</a>).</p>

<p>A declaration defines a name in the <strong><em>declaration space</em></strong> to which the declaration belongs. Except for overloaded members (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space. It is never possible for a declaration space to contain different kinds of members with the same name. For example, a declaration space can never contain a field and a method by the same name.</p>

<p>There are several different types of declaration spaces, as described in the following.</p>

<ul>
<li> Within all source files of a program, <em>namespace_member_declaration*s with no enclosing *namespace_declaration</em> are members of a single combined declaration space called the <strong><em>global declaration space</em></strong>.</li>
<li> Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</li>
<li> Each class, struct, or interface declaration creates a new declaration space. Names are introduced into this declaration space through <em>class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s. Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct. A class, struct, or interface permits the declaration of overloaded methods and indexers. Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators. For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature (<a href="basic-concepts.md#signatures-and-overloading">Signatures and overloading</a>). Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface. Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member. Such a member is said to *</em><em>hide</em>** the inherited member.</li>
<li> Each delegate declaration creates a new declaration space. Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</li>
<li> Each enumeration declaration creates a new declaration space. Names are introduced into this declaration space through <em>enum_member_declarations</em>.</li>
<li> Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a <strong><em>local variable declaration space</em></strong>. Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s. The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space. It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name. Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space. It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</li>
<li> Each <em>block</em> or <em>switch_block</em> , as well as a <em>for</em>, <em>foreach</em> and <em>using</em> statement, creates a local variable declaration space for local variables and local constants . Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s. Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters. Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</li>
<li> Each <em>block</em> or <em>switch_block</em> creates a separate declaration space for labels. Names are introduced into this declaration space through <em>labeled_statement*s, and the names are referenced through *goto_statement*s. The *</em><em>label declaration space</em>** of a block includes any nested blocks. Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</li>
</ul>

<p>The textual order in which names are declared is generally of no significance. In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types. Declaration order is significant in the following ways:</p>

<ul>
<li> Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</li>
<li> Local variables must be defined before they are used (<a href="basic-concepts.md#scopes">Scopes</a>).</li>
<li> Declaration order for enum member declarations (<a href="enums.md#enum-members">Enum members</a>) is significant when <em>constant_expression</em> values are omitted.</li>
</ul>

<p>The declaration space of a namespace is &ldquo;open ended&rdquo;, and two namespace declarations with the same fully qualified name contribute to the same declaration space. For example
&ldquo;`csharp
namespace Megacorp.Data
{
    class Customer
    {
        &hellip;
    }
}</p>

<p>namespace Megacorp.Data
{
    class Order
    {
        &hellip;
    }
}
&rdquo;`</p>

<p>The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names <code class="prettyprint">Megacorp.Data.Customer</code> and <code class="prettyprint">Megacorp.Data.Order</code>. Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</p>

<p>As specified above, the declaration space of a block includes any nested blocks. Thus, in the following example, the <code class="prettyprint">F</code> and <code class="prettyprint">G</code> methods result in a compile-time error because the name <code class="prettyprint">i</code> is declared in the outer block and cannot be redeclared in the inner block. However, the <code class="prettyprint">H</code> and <code class="prettyprint">I</code> methods are valid since the two <code class="prettyprint">i</code>&lsquo;s are declared in separate non-nested blocks.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>            
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>                
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">H</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">I</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="nf">H</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="nf">H</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id="members">Members</h2>

<p>Namespaces and types have <strong><em>members</em></strong>. The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a &ldquo;<code class="prettyprint">.</code>&rdquo; token, followed by the name of the member.</p>

<p>Members of a type are either declared in the type declaration or <strong><em>inherited</em></strong> from the base class of the type. When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type. The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn&rsquo;t an instance constructor, static constructor, or destructor. However, an inherited member may not be accessible in a derived type, either because of its declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) or because it is hidden by a declaration in the type itself (<a href="basic-concepts.md#hiding-through-inheritance">Hiding through inheritance</a>).</p>

<h3 id="namespace-members">Namespace members</h3>

<p>Namespaces and types that have no enclosing namespace are members of the <strong><em>global namespace</em></strong>. This corresponds directly to the names declared in the global declaration space.</p>

<p>Namespaces and types declared within a namespace are members of that namespace. This corresponds directly to the names declared in the declaration space of the namespace.</p>

<p>Namespaces have no access restrictions. It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</p>

<h3 id="struct-members">Struct members</h3>

<p>The members of a struct are the members declared in the struct and the members inherited from the struct&rsquo;s direct base class <code class="prettyprint">System.ValueType</code> and the indirect base class <code class="prettyprint">object</code>.</p>

<p>The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</p>

<ul>
<li> The members of <code class="prettyprint">sbyte</code> are the members of the <code class="prettyprint">System.SByte</code> struct.</li>
<li> The members of <code class="prettyprint">byte</code> are the members of the <code class="prettyprint">System.Byte</code> struct.</li>
<li> The members of <code class="prettyprint">short</code> are the members of the <code class="prettyprint">System.Int16</code> struct.</li>
<li> The members of <code class="prettyprint">ushort</code> are the members of the <code class="prettyprint">System.UInt16</code> struct.</li>
<li> The members of <code class="prettyprint">int</code> are the members of the <code class="prettyprint">System.Int32</code> struct.</li>
<li> The members of <code class="prettyprint">uint</code> are the members of the <code class="prettyprint">System.UInt32</code> struct.</li>
<li> The members of <code class="prettyprint">long</code> are the members of the <code class="prettyprint">System.Int64</code> struct.</li>
<li> The members of <code class="prettyprint">ulong</code> are the members of the <code class="prettyprint">System.UInt64</code> struct.</li>
<li> The members of <code class="prettyprint">char</code> are the members of the <code class="prettyprint">System.Char</code> struct.</li>
<li> The members of <code class="prettyprint">float</code> are the members of the <code class="prettyprint">System.Single</code> struct.</li>
<li> The members of <code class="prettyprint">double</code> are the members of the <code class="prettyprint">System.Double</code> struct.</li>
<li> The members of <code class="prettyprint">decimal</code> are the members of the <code class="prettyprint">System.Decimal</code> struct.</li>
<li> The members of <code class="prettyprint">bool</code> are the members of the <code class="prettyprint">System.Boolean</code> struct.</li>
</ul>

<h3 id="enumeration-members">Enumeration members</h3>

<p>The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration&rsquo;s direct base class <code class="prettyprint">System.Enum</code> and the indirect base classes <code class="prettyprint">System.ValueType</code> and <code class="prettyprint">object</code>.</p>

<h3 id="class-members">Class members</h3>

<p>The members of a class are the members declared in the class and the members inherited from the base class (except for class <code class="prettyprint">object</code> which has no base class). The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class. Base class members are inherited without regard to their accessibility.</p>

<p>A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</p>

<p>The members of <code class="prettyprint">object</code> and <code class="prettyprint">string</code> correspond directly to the members of the class types they alias:</p>

<ul>
<li> The members of <code class="prettyprint">object</code> are the members of the <code class="prettyprint">System.Object</code> class.</li>
<li> The members of <code class="prettyprint">string</code> are the members of the <code class="prettyprint">System.String</code> class.</li>
</ul>

<h3 id="interface-members">Interface members</h3>

<p>The members of an interface are the members declared in the interface and in all base interfaces of the interface. The members in class <code class="prettyprint">object</code> are not, strictly speaking, members of any interface (<a href="interfaces.md#interface-members">Interface members</a>). However, the members in class <code class="prettyprint">object</code> are available via member lookup in any interface type (<a href="expressions.md#member-lookup">Member lookup</a>).</p>

<h3 id="array-members">Array members</h3>

<p>The members of an array are the members inherited from class <code class="prettyprint">System.Array</code>.</p>

<h3 id="delegate-members">Delegate members</h3>

<p>The members of a delegate are the members inherited from class <code class="prettyprint">System.Delegate</code>.</p>

<h2 id="member-access">Member access</h2>

<p>Declarations of members allow control over member access. The accessibility of a member is established by the declared accessibility (<a href="basic-concepts.md#declared-accessibility">Declared accessibility</a>) of the member combined with the accessibility of the immediately containing type, if any.</p>

<p>When access to a particular member is allowed, the member is said to be <strong><em>accessible</em></strong>. Conversely, when access to a particular member is disallowed, the member is said to be <strong><em>inaccessible</em></strong>. Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the member.</p>

<h3 id="declared-accessibility">Declared accessibility</h3>

<p>The <strong><em>declared accessibility</em></strong> of a member can be one of the following:</p>

<ul>
<li> Public, which is selected by including a <code class="prettyprint">public</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">public</code> is &ldquo;access not limited&rdquo;.</li>
<li> Protected, which is selected by including a <code class="prettyprint">protected</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">protected</code> is &ldquo;access limited to the containing class or types derived from the containing class&rdquo;.</li>
<li> Internal, which is selected by including an <code class="prettyprint">internal</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">internal</code> is &ldquo;access limited to this program&rdquo;.</li>
<li> Protected internal (meaning protected or internal), which is selected by including both a <code class="prettyprint">protected</code> and an <code class="prettyprint">internal</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">protected internal</code> is &ldquo;access limited to this program or types derived from the containing class&rdquo;.</li>
<li> Private, which is selected by including a <code class="prettyprint">private</code> modifier in the member declaration. The intuitive meaning of <code class="prettyprint">private</code> is &ldquo;access limited to the containing type&rdquo;.</li>
</ul>

<p>Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted. Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</p>

<ul>
<li> Namespaces implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on namespace declarations.</li>
<li> Types declared in compilation units or namespaces can have <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility and default to <code class="prettyprint">internal</code> declared accessibility.</li>
<li> Class members can have any of the five kinds of declared accessibility and default to <code class="prettyprint">private</code> declared accessibility. (Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility.)</li>
<li> Struct members can have <code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> declared accessibility and default to <code class="prettyprint">private</code> declared accessibility because structs are implicitly sealed. Struct members introduced in a struct (that is, not inherited by that struct) cannot have <code class="prettyprint">protected</code> or <code class="prettyprint">protected internal</code> declared accessibility. (Note that a type declared as a member of a struct can have <code class="prettyprint">public</code>, <code class="prettyprint">internal</code>, or <code class="prettyprint">private</code> declared accessibility, whereas a type declared as a member of a namespace can have only <code class="prettyprint">public</code> or <code class="prettyprint">internal</code> declared accessibility.)</li>
<li> Interface members implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on interface member declarations.</li>
<li> Enumeration members implicitly have <code class="prettyprint">public</code> declared accessibility. No access modifiers are allowed on enumeration member declarations.</li>
</ul>

<h3 id="accessibility-domains">Accessibility domains</h3>

<p>The <strong><em>accessibility domain</em></strong> of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted. For purposes of defining the accessibility domain of a member, a member is said to be <strong><em>top-level</em></strong> if it is not declared within a type, and a member is said to be <strong><em>nested</em></strong> if it is declared within another type. Furthermore, the <strong><em>program text</em></strong> of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</p>

<p>The accessibility domain of a predefined type (such as <code class="prettyprint">object</code>, <code class="prettyprint">int</code>, or <code class="prettyprint">double</code>) is unlimited.</p>

<p>The accessibility domain of a top-level unbound type <code class="prettyprint">T</code> (<a href="types.md#bound-and-unbound-types">Bound and unbound types</a>) that is declared in a program <code class="prettyprint">P</code> is defined as follows:</p>

<ul>
<li> If the declared accessibility of <code class="prettyprint">T</code> is <code class="prettyprint">public</code>, the accessibility domain of <code class="prettyprint">T</code> is the program text of <code class="prettyprint">P</code> and any program that references <code class="prettyprint">P</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">T</code> is <code class="prettyprint">internal</code>, the accessibility domain of <code class="prettyprint">T</code> is the program text of <code class="prettyprint">P</code>.</li>
</ul>

<p>From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</p>

<p>The accessibility domain for a constructed type <code class="prettyprint">T&lt;A1, ..., An&gt;</code> is the intersection of the accessibility domain of the unbound generic type <code class="prettyprint">T</code> and the accessibility domains of the type arguments <code class="prettyprint">A1, ..., An</code>.</p>

<p>The accessibility domain of a nested member <code class="prettyprint">M</code> declared in a type <code class="prettyprint">T</code> within a program <code class="prettyprint">P</code> is defined as follows (noting that <code class="prettyprint">M</code> itself may possibly be a type):</p>

<ul>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">public</code>, the accessibility domain of <code class="prettyprint">M</code> is the accessibility domain of <code class="prettyprint">T</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">protected internal</code>, let <code class="prettyprint">D</code> be the union of the program text of <code class="prettyprint">P</code> and the program text of any type derived from <code class="prettyprint">T</code>, which is declared outside <code class="prettyprint">P</code>. The accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with <code class="prettyprint">D</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">protected</code>, let <code class="prettyprint">D</code> be the union of the program text of <code class="prettyprint">T</code> and the program text of any type derived from <code class="prettyprint">T</code>. The accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with <code class="prettyprint">D</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">internal</code>, the accessibility domain of <code class="prettyprint">M</code> is the intersection of the accessibility domain of <code class="prettyprint">T</code> with the program text of <code class="prettyprint">P</code>.</li>
<li> If the declared accessibility of <code class="prettyprint">M</code> is <code class="prettyprint">private</code>, the accessibility domain of <code class="prettyprint">M</code> is the program text of <code class="prettyprint">T</code>.</li>
</ul>

<p>From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared. Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</p>

<p>In intuitive terms, when a type or member <code class="prettyprint">M</code> is accessed, the following steps are evaluated to ensure that the access is permitted:</p>

<ul>
<li> First, if <code class="prettyprint">M</code> is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</li>
<li> Then, if <code class="prettyprint">M</code> is <code class="prettyprint">public</code>, the access is permitted.</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">protected internal</code>, the access is permitted if it occurs within the program in which <code class="prettyprint">M</code> is declared, or if it occurs within a class derived from the class in which <code class="prettyprint">M</code> is declared and takes place through the derived class type (<a href="basic-concepts.md#protected-access-for-instance-members">Protected access for instance members</a>).</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">protected</code>, the access is permitted if it occurs within the class in which <code class="prettyprint">M</code> is declared, or if it occurs within a class derived from the class in which <code class="prettyprint">M</code> is declared and takes place through the derived class type (<a href="basic-concepts.md#protected-access-for-instance-members">Protected access for instance members</a>).</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">internal</code>, the access is permitted if it occurs within the program in which <code class="prettyprint">M</code> is declared.</li>
<li> Otherwise, if <code class="prettyprint">M</code> is <code class="prettyprint">private</code>, the access is permitted if it occurs within the type in which <code class="prettyprint">M</code> is declared.</li>
<li> Otherwise, the type or member is inaccessible, and a compile-time error occurs.</li>
</ul>

<p>In the example
&ldquo;`csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}</p>

<p>internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;</p>

<p>public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }</p>

<p>private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
&rdquo;`
the classes and members have the following accessibility domains:</p>

<ul>
<li> The accessibility domain of <code class="prettyprint">A</code> and <code class="prettyprint">A.X</code> is unlimited.</li>
<li> The accessibility domain of <code class="prettyprint">A.Y</code>, <code class="prettyprint">B</code>, <code class="prettyprint">B.X</code>, <code class="prettyprint">B.Y</code>, <code class="prettyprint">B.C</code>, <code class="prettyprint">B.C.X</code>, and <code class="prettyprint">B.C.Y</code> is the program text of the containing program.</li>
<li> The accessibility domain of <code class="prettyprint">A.Z</code> is the program text of <code class="prettyprint">A</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.Z</code> and <code class="prettyprint">B.D</code> is the program text of <code class="prettyprint">B</code>, including the program text of <code class="prettyprint">B.C</code> and <code class="prettyprint">B.D</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.C.Z</code> is the program text of <code class="prettyprint">B.C</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.D.X</code> and <code class="prettyprint">B.D.Y</code> is the program text of <code class="prettyprint">B</code>, including the program text of <code class="prettyprint">B.C</code> and <code class="prettyprint">B.D</code>.</li>
<li> The accessibility domain of <code class="prettyprint">B.D.Z</code> is the program text of <code class="prettyprint">B.D</code>.</li>
</ul>

<p>As the example illustrates, the accessibility domain of a member is never larger than that of a containing type. For example, even though all <code class="prettyprint">X</code> members have public declared accessibility, all but <code class="prettyprint">A.X</code> have accessibility domains that are constrained by a containing type.</p>

<p>As described in <a href="basic-concepts.md#members">Members</a>, all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types. This includes even private members of a base class. However, the accessibility domain of a private member includes only the program text of the type in which the member is declared. In the example
&ldquo;`csharp
class A
{
    int x;</p>

<p>static void F(B b) {
        b.x = 1;        // Ok
    }
}</p>

<p>class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
&rdquo;<code class="prettyprint">
the</code>B<code class="prettyprint">class inherits the private member</code>x<code class="prettyprint">from the</code>A<code class="prettyprint">class. Because the member is private, it is only accessible within the *class_body* of</code>A<code class="prettyprint">. Thus, the access to</code>b.x<code class="prettyprint">succeeds in the</code>A.F<code class="prettyprint">method, but fails in the</code>B.F` method.</p>

<h3 id="protected-access-for-instance-members">Protected access for instance members</h3>

<p>When a <code class="prettyprint">protected</code> instance member is accessed outside the program text of the class in which it is declared, and when a <code class="prettyprint">protected internal</code> instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared. Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it. This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</p>

<p>Let <code class="prettyprint">B</code> be a base class that declares a protected instance member <code class="prettyprint">M</code>, and let <code class="prettyprint">D</code> be a class that derives from <code class="prettyprint">B</code>. Within the <em>class_body</em> of <code class="prettyprint">D</code>, access to <code class="prettyprint">M</code> can take one of the following forms:</p>

<ul>
<li> An unqualified <em>type_name</em> or <em>primary_expression</em> of the form <code class="prettyprint">M</code>.</li>
<li> A <em>primary_expression</em> of the form <code class="prettyprint">E.M</code>, provided the type of <code class="prettyprint">E</code> is <code class="prettyprint">T</code> or a class derived from <code class="prettyprint">T</code>, where <code class="prettyprint">T</code> is the class type <code class="prettyprint">D</code>, or a class type constructed from <code class="prettyprint">D</code></li>
<li> A <em>primary_expression</em> of the form <code class="prettyprint">base.M</code>.</li>
</ul>

<p>In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a <em>constructor_initializer</em> (<a href="classes.md#constructor-initializers">Constructor initializers</a>).</p>

<p>In the example
&ldquo;`csharp
public class A
{
    protected int x;</p>

<p>static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}</p>

<p>public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
&rdquo;<code class="prettyprint">
within</code>A<code class="prettyprint">, it is possible to access</code>x<code class="prettyprint">through instances of both</code>A<code class="prettyprint">and</code>B<code class="prettyprint">, since in either case the access takes place through an instance of</code>A<code class="prettyprint">or a class derived from</code>A<code class="prettyprint">. However, within</code>B<code class="prettyprint">, it is not possible to access</code>x<code class="prettyprint">through an instance of</code>A<code class="prettyprint">, since</code>A<code class="prettyprint">does not derive from</code>B`.</p>

<p>In the example
&ldquo;`csharp
class C<T>
{
    protected T x;
}</p>

<p>class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = &quot;test&rdquo;;
    }
}
&ldquo;<code class="prettyprint">
the three assignments to</code>x` are permitted because they all take place through instances of class types constructed from the generic type.</p>

<h3 id="accessibility-constraints">Accessibility constraints</h3>

<p>Several constructs in the C# language require a type to be <strong><em>at least as accessible as</em></strong> a member or another type. A type <code class="prettyprint">T</code> is said to be at least as accessible as a member or type <code class="prettyprint">M</code> if the accessibility domain of <code class="prettyprint">T</code> is a superset of the accessibility domain of <code class="prettyprint">M</code>. In other words, <code class="prettyprint">T</code> is at least as accessible as <code class="prettyprint">M</code> if <code class="prettyprint">T</code> is accessible in all contexts in which <code class="prettyprint">M</code> is accessible.</p>

<p>The following accessibility constraints exist:</p>

<ul>
<li> The direct base class of a class type must be at least as accessible as the class type itself.</li>
<li> The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</li>
<li> The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</li>
<li> The type of a constant must be at least as accessible as the constant itself.</li>
<li> The type of a field must be at least as accessible as the field itself.</li>
<li> The return type and parameter types of a method must be at least as accessible as the method itself.</li>
<li> The type of a property must be at least as accessible as the property itself.</li>
<li> The type of an event must be at least as accessible as the event itself.</li>
<li> The type and parameter types of an indexer must be at least as accessible as the indexer itself.</li>
<li> The return type and parameter types of an operator must be at least as accessible as the operator itself.</li>
<li> The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</li>
</ul>

<p>In the example
&rdquo;`csharp
class A {&hellip;}</p>

<p>public class B: A {&hellip;}
&ldquo;<code class="prettyprint">
the</code>B<code class="prettyprint">class results in a compile-time error because</code>A<code class="prettyprint">is not at least as accessible as</code>B`.</p>

<p>Likewise, in the example
&rdquo;`csharp
class A {&hellip;}</p>

<p>public class B
{
    A F() {&hellip;}</p>

<p>internal A G() {&hellip;}</p>

<p>public A H() {&hellip;}
}
&ldquo;<code class="prettyprint">
the</code>H<code class="prettyprint">method in</code>B<code class="prettyprint">results in a compile-time error because the return type</code>A` is not at least as accessible as the method.</p>

<h2 id="signatures-and-overloading">Signatures and overloading</h2>

<p>Methods, instance constructors, indexers, and operators are characterized by their <strong><em>signatures</em></strong>:</p>

<ul>
<li> The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right. For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method. The signature of a method specifically does not include the return type, the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</li>
<li> The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right. The signature of an instance constructor specifically does not include the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter.</li>
<li> The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right. The signature of an indexer specifically does not include the element type, nor does it include the <code class="prettyprint">params</code> modifier that may be specified for the right-most parameter.</li>
<li> The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right. The signature of an operator specifically does not include the result type.</li>
</ul>

<p>Signatures are the enabling mechanism for <strong><em>overloading</em></strong> of members in classes, structs, and interfaces:</p>

<ul>
<li> Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</li>
<li> Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</li>
<li> Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</li>
<li> Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</li>
</ul>

<p>Although <code class="prettyprint">out</code> and <code class="prettyprint">ref</code> parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>. A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with <code class="prettyprint">out</code> modifiers were changed to <code class="prettyprint">ref</code> modifiers. For other purposes of signature matching (e.g., hiding or overriding), <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> are considered part of the signature and do not match each other. (This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>.)</p>

<p>For the purposes of singatures, the types <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code> are considered the same. Members declared in a single type can therefore not differ in signature solely by <code class="prettyprint">object</code> and <code class="prettyprint">dynamic</code>.</p>

<p>The following example shows a set of overloaded method declarations along with their signatures.
&rdquo;`csharp
interface ITest
{
    void F();                        // F()</p>

<p>void F(int x);                   // F(int)</p>

<p>void F(ref int x);               // F(ref int)</p>

<p>void F(out int x);               // F(out int)      error</p>

<p>void F(int x, int y);            // F(int, int)</p>

<p>int F(string s);                 // F(string)</p>

<p>int F(int x);                    // F(int)          error</p>

<p>void F(string[] a);              // F(string[])</p>

<p>void F(params string[] a);       // F(string[])     error
}
&ldquo;`</p>

<p>Note that any <code class="prettyprint">ref</code> and <code class="prettyprint">out</code> parameter modifiers (<a href="classes.md#method-parameters">Method parameters</a>) are part of a signature. Thus, <code class="prettyprint">F(int)</code> and <code class="prettyprint">F(ref int)</code> are unique signatures. However, <code class="prettyprint">F(ref int)</code> and <code class="prettyprint">F(out int)</code> cannot be declared within the same interface because their signatures differ solely by <code class="prettyprint">ref</code> and <code class="prettyprint">out</code>. Also, note that the return type and the <code class="prettyprint">params</code> modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the <code class="prettyprint">params</code> modifier. As such, the declarations of the methods <code class="prettyprint">F(int)</code> and <code class="prettyprint">F(params string[])</code> identified above result in a compile-time error.</p>

<h2 id="scopes">Scopes</h2>

<p>The <strong><em>scope</em></strong> of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name. Scopes can be <strong><em>nested</em></strong>, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by <a href="basic-concepts.md#declarations">Declarations</a> that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block). The name from the outer scope is then said to be <strong><em>hidden</em></strong> in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</p>

<ul>
<li> The scope of a namespace member declared by a <em>namespace_member_declaration</em> (<a href="namespaces.md#namespace-members">Namespace members</a>) with no enclosing <em>namespace_declaration</em> is the entire program text.</li>
<li> The scope of a namespace member declared by a <em>namespace_member_declaration</em> within a <em>namespace_declaration</em> whose fully qualified name is <code class="prettyprint">N</code> is the <em>namespace_body</em> of every <em>namespace_declaration</em> whose fully qualified name is <code class="prettyprint">N</code> or starts with <code class="prettyprint">N</code>, followed by a period.</li>
<li> The scope of name defined by an <em>extern_alias_directive</em> extends over the <em>using_directive*s, *global_attributes</em> and <em>namespace_member_declaration*s of its immediately containing compilation unit or namespace body. An *extern_alias_directive</em> does not contribute any new members to the underlying declaration space. In other words, an <em>extern_alias_directive</em> is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</li>
<li> The scope of a name defined or imported by a <em>using_directive</em> (<a href="namespaces.md#using-directives">Using directives</a>) extends over the <em>namespace_member_declaration*s of the *compilation_unit</em> or <em>namespace_body</em> in which the <em>using_directive</em> occurs. A <em>using_directive</em> may make zero or more namespace, type or member names available within a particular <em>compilation_unit</em> or <em>namespace_body</em>, but does not contribute any new members to the underlying declaration space. In other words, a <em>using_directive</em> is not transitive but rather affects only the <em>compilation_unit</em> or <em>namespace_body</em> in which it occurs.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>class_declaration</em> (<a href="classes.md#class-declarations">Class declarations</a>) is the <em>class_base</em>, <em>type_parameter_constraints_clause*s, and *class_body</em> of that <em>class_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>struct_declaration</em> (<a href="structs.md#struct-declarations">Struct declarations</a>) is the <em>struct_interfaces</em>, <em>type_parameter_constraints_clause*s, and *struct_body</em> of that <em>struct_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on an <em>interface_declaration</em> (<a href="interfaces.md#interface-declarations">Interface declarations</a>) is the <em>interface_base</em>, <em>type_parameter_constraints_clause*s, and *interface_body</em> of that <em>interface_declaration</em>.</li>
<li> The scope of a type parameter declared by a <em>type_parameter_list</em> on a <em>delegate_declaration</em> (<a href="delegates.md#delegate-declarations">Delegate declarations</a>) is the <em>return_type</em>, <em>formal_parameter_list</em>, and <em>type_parameter_constraints_clause*s of that *delegate_declaration</em>.</li>
<li> The scope of a member declared by a <em>class_member_declaration</em> (<a href="classes.md#class-body">Class body</a>) is the <em>class_body</em> in which the declaration occurs. In addition, the scope of a class member extends to the <em>class_body</em> of those derived classes that are included in the accessibility domain (<a href="basic-concepts.md#accessibility-domains">Accessibility domains</a>) of the member.</li>
<li> The scope of a member declared by a <em>struct_member_declaration</em> (<a href="structs.md#struct-members">Struct members</a>) is the <em>struct_body</em> in which the declaration occurs.</li>
<li> The scope of a member declared by an <em>enum_member_declaration</em>  (<a href="enums.md#enum-members">Enum members</a>) is the <em>enum_body</em> in which the declaration occurs.</li>
<li> The scope of a parameter declared in a <em>method_declaration</em> (<a href="classes.md#methods">Methods</a>) is the <em>method_body</em> of that <em>method_declaration</em>.</li>
<li> The scope of a parameter declared in an <em>indexer_declaration</em> (<a href="classes.md#indexers">Indexers</a>) is the <em>accessor_declarations</em> of that <em>indexer_declaration</em>.</li>
<li> The scope of a parameter declared in an <em>operator_declaration</em> (<a href="classes.md#operators">Operators</a>) is the <em>block</em> of that <em>operator_declaration</em>.</li>
<li> The scope of a parameter declared in a <em>constructor_declaration</em> (<a href="classes.md#instance-constructors">Instance constructors</a>) is the <em>constructor_initializer</em> and <em>block</em> of that <em>constructor_declaration</em>.</li>
<li> The scope of a parameter declared in a <em>lambda_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) is the <em>anonymous_function_body</em> of that <em>lambda_expression</em></li>
<li> The scope of a parameter declared in an <em>anonymous_method_expression</em> (<a href="expressions.md#anonymous-function-expressions">Anonymous function expressions</a>) is the <em>block</em> of that <em>anonymous_method_expression</em>.</li>
<li> The scope of a label declared in a <em>labeled_statement</em> (<a href="statements.md#labeled-statements">Labeled statements</a>) is the <em>block</em> in which the declaration occurs.</li>
<li> The scope of a local variable declared in a <em>local_variable_declaration</em> (<a href="statements.md#local-variable-declarations">Local variable declarations</a>) is the block in which the declaration occurs.</li>
<li> The scope of a local variable declared in a <em>switch_block</em> of a <code class="prettyprint">switch</code> statement (<a href="statements.md#the-switch-statement">The switch statement</a>) is the <em>switch_block</em>.</li>
<li> The scope of a local variable declared in a <em>for_initializer</em> of a <code class="prettyprint">for</code> statement (<a href="statements.md#the-for-statement">The for statement</a>) is the <em>for_initializer</em>, the <em>for_condition</em>, the <em>for_iterator</em>, and the contained <em>statement</em> of the <code class="prettyprint">for</code> statement.</li>
<li> The scope of a local constant declared in a <em>local_constant_declaration</em> (<a href="statements.md#local-constant-declarations">Local constant declarations</a>) is the block in which the declaration occurs. It is a compile-time error to refer to a local constant in a textual position that precedes its <em>constant_declarator</em>.</li>
<li> The scope of a variable declared as part of a <em>foreach_statement</em>, <em>using_statement</em>, <em>lock_statement</em> or <em>query_expression</em> is determined by the expansion of the given construct.</li>
</ul>

<p>Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member. For example
&rdquo;`csharp
class A
{
    void F() {
        i = 1;
    }</p>

<p>int i = 0;
}
&ldquo;<code class="prettyprint">
Here, it is valid for</code>F<code class="prettyprint">to refer to</code>i` before it is declared.</p>

<p>Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the <em>local_variable_declarator</em> of the local variable. For example
&rdquo;`csharp
class A
{
    int i = 0;</p>

<p>void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }</p>

<p>void G() {
        int j = (j = 1);        // Valid
    }</p>

<p>void H() {
        int a = 1, b = ++a;    // Valid
    }
}
&ldquo;`</p>

<p>In the <code class="prettyprint">F</code> method above, the first assignment to <code class="prettyprint">i</code> specifically does not refer to the field declared in the outer scope. Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable. In the <code class="prettyprint">G</code> method, the use of <code class="prettyprint">j</code> in the initializer for the declaration of <code class="prettyprint">j</code> is valid because the use does not precede the <em>local_variable_declarator</em>. In the <code class="prettyprint">H</code> method, a subsequent <em>local_variable_declarator</em> correctly refers to a local variable declared in an earlier <em>local_variable_declarator</em> within the same <em>local_variable_declaration</em>.</p>

<p>The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block. If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</p>

<p>The meaning of a name within a block may differ based on the context in which the name is used. In the example
&rdquo;`csharp
using System;</p>

<p>class A {}</p>

<p>class Test
{
    static void Main() {
        string A = &ldquo;hello, world&rdquo;;
        string s = A;                            // expression context</p>

<p>Type t = typeof(A);                      // type context</p>

<p>Console.WriteLine(s);                    // writes &ldquo;hello, world&rdquo;
        Console.WriteLine(t);                    // writes &ldquo;A&rdquo;
    }
}
&ldquo;<code class="prettyprint">
the name</code>A<code class="prettyprint">is used in an expression context to refer to the local variable</code>A<code class="prettyprint">and in a type context to refer to the class</code>A`.</p>

<h3 id="name-hiding">Name hiding</h3>

<p>The scope of an entity typically encompasses more program text than the declaration space of the entity. In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name. Such declarations cause the original entity to become <strong><em>hidden</em></strong>. Conversely, an entity is said to be <strong><em>visible</em></strong> when it is not hidden.</p>

<p>Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance. The characteristics of the two types of hiding are described in the following sections.</p>

<h4 id="hiding-through-nesting">Hiding through nesting</h4>

<p>Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</p>

<p>In the example
&rdquo;`csharp
class A
{
    int i = 0;</p>

<p>void F() {
        int i = 1;
    }</p>

<p>void G() {
        i = 1;
    }
}
&ldquo;<code class="prettyprint">
within the</code>F<code class="prettyprint">method, the instance variable</code>i<code class="prettyprint">is hidden by the local variable</code>i<code class="prettyprint">, but within the</code>G<code class="prettyprint">method,</code>i` still refers to the instance variable.</p>

<p>When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name. In the example
&rdquo;`csharp
class Outer
{
    static void F(int i) {}</p>

<p>static void F(string s) {}</p>

<p>class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F(&ldquo;Hello&rdquo;);        // Error
        }</p>

<p>static void F(long l) {}
    }
}
&ldquo;<code class="prettyprint">
the call</code>F(1)<code class="prettyprint">invokes the</code>F<code class="prettyprint">declared in</code>Inner<code class="prettyprint">because all outer occurrences of</code>F<code class="prettyprint">are hidden by the inner declaration. For the same reason, the call</code>F(&quot;Hello&rdquo;)` results in a compile-time error.</p>

<h4 id="hiding-through-inheritance">Hiding through inheritance</h4>

<p>Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes. This type of name hiding takes one of the following forms:</p>

<ul>
<li> A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</li>
<li> A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</li>
<li> An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</li>
</ul>

<p>The rules governing operator declarations (<a href="classes.md#operators">Operators</a>) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class. Thus, operators never hide one another.</p>

<p>Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported. In the example
&ldquo;`csharp
class Base
{
    public void F() {}
}</p>

<p>class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
&rdquo;<code class="prettyprint">
the declaration of</code>F<code class="prettyprint">in</code>Derived<code class="prettyprint">causes a warning to be reported. Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes. For example, the above situation might have come about because a later version of</code>Base<code class="prettyprint">introduced an</code>F` method that wasn&rsquo;t present in an earlier version of the class. Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</p>

<p>The warning caused by hiding an inherited name can be eliminated through use of the <code class="prettyprint">new</code> modifier:
&ldquo;`csharp
class Base
{
    public void F() {}
}</p>

<p>class Derived: Base
{
    new public void F() {}
}
&rdquo;`</p>

<p>The <code class="prettyprint">new</code> modifier indicates that the <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> is &ldquo;new&rdquo;, and that it is indeed intended to hide the inherited member.</p>

<p>A declaration of a new member hides an inherited member only within the scope of the new member.</p>
<pre class="highlight csharp tab-csharp"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">new</span> <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">F</span><span class="p">()</span> <span class="p">{}</span>    <span class="c1">// Hides Base.F in Derived only</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MoreDerived</span><span class="p">:</span> <span class="n">Derived</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">G</span><span class="p">()</span> <span class="p">{</span> <span class="nf">F</span><span class="p">();</span> <span class="p">}</span>          <span class="c1">// Invokes Base.F</span>
<span class="p">}</span>
</code></pre>
<p>In the example above, the declaration of <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> hides the <code class="prettyprint">F</code> that was inherited from <code class="prettyprint">Base</code>, but since the new <code class="prettyprint">F</code> in <code class="prettyprint">Derived</code> has private access, its scope does not extend to <code class="prettyprint">MoreDerived</code>. Thus, the call <code class="prettyprint">F()</code> in <code class="prettyprint">MoreDerived.G</code> is valid and will invoke <code class="prettyprint">Base.F</code>.</p>

<h2 id="namespace-and-type-names">Namespace and type names</h2>

<p>Several contexts in a C# program require a <em>namespace_name</em> or a <em>type_name</em> to be specified.</p>
<pre class="highlight plaintext"><code>namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
</code></pre>
<p>A <em>namespace_name</em> is a <em>namespace_or_type_name</em> that refers to a namespace. Following resolution as described below, the <em>namespace_or_type_name</em> of a <em>namespace_name</em> must refer to a namespace, or otherwise a compile-time error occurs. No type arguments (<a href="types.md#type-arguments">Type arguments</a>) can be present in a <em>namespace_name</em> (only types can have type arguments).</p>

<p>A <em>type_name</em> is a <em>namespace_or_type_name</em> that refers to a type. Following resolution as described below, the <em>namespace_or_type_name</em> of a <em>type_name</em> must refer to a type, or otherwise a compile-time error occurs.</p>

<p>If the <em>namespace_or_type_name</em> is a qualified-alias-member its meaning is as described in <a href="namespaces.md#namespace-alias-qualifiers">Namespace alias qualifiers</a>. Otherwise, a <em>namespace_or_type_name</em> has one of four forms:</p>

<ul>
<li> <code class="prettyprint">I</code></li>
<li> <code class="prettyprint">I&lt;A1, ..., Ak&gt;</code></li>
<li> <code class="prettyprint">N.I</code></li>
<li> <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code></li>
</ul>

<p>where <code class="prettyprint">I</code> is a single identifier, <code class="prettyprint">N</code> is a <em>namespace_or_type_name</em> and <code class="prettyprint">&lt;A1, ..., Ak&gt;</code> is an optional <em>type_argument_list</em>. When no <em>type_argument_list</em> is specified, consider <code class="prettyprint">k</code> to be zero.</p>

<p>The meaning of a <em>namespace_or_type_name</em> is determined as follows:</p>

<ul>
<li>  If the <em>namespace_or_type_name</em> is of the form <code class="prettyprint">I</code> or of the form <code class="prettyprint">I&lt;A1, ..., Ak&gt;</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the <em>namespace_or_type_name</em> appears within a generic method declaration (<a href="classes.md#methods">Methods</a>) and if that declaration includes a type parameter (<a href="classes.md#type-parameters">Type parameters</a>) with name <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that type parameter.</li>
<li>Otherwise, if the <em>namespace_or_type_name</em> appears within a type declaration, then for each instance type <code class="prettyprint">T</code> (<a href="classes.md#the-instance-type">The instance type</a>), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):

<ul>
<li>If <code class="prettyprint">K</code> is zero and the declaration of <code class="prettyprint">T</code> includes a type parameter with name <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that type parameter.</li>
<li>Otherwise, if the <em>namespace_or_type_name</em> appears within the body of the type declaration, and <code class="prettyprint">T</code> or any of its base types contain a nested accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments. If there is more than one such type, the type declared within the more derived type is selected. Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the <em>namespace_or_type_name</em>.</li>
</ul></li>
<li>If the previous steps were unsuccessful then, for each namespace <code class="prettyprint">N</code>, starting with the namespace in which the <em>namespace_or_type_name</em> occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:

<ul>
<li>If <code class="prettyprint">K</code> is zero and <code class="prettyprint">I</code> is the name of a namespace in <code class="prettyprint">N</code>, then:

<ul>
<li>If the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with a namespace or type, then the <em>namespace_or_type_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the namespace named <code class="prettyprint">I</code> in <code class="prettyprint">N</code>.</li>
</ul></li>
<li>Otherwise, if <code class="prettyprint">N</code> contains an accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code> and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with a namespace or type, then the <em>namespace_or_type_name</em> is ambiguous and a compile-time error occurs.</li>
<li>Otherwise, the <em>namespace_or_type_name</em> refers to the type constructed with the given type arguments.</li>
</ul></li>
<li>Otherwise, if the location where the <em>namespace_or_type_name</em> occurs is enclosed by a namespace declaration for <code class="prettyprint">N</code>:

<ul>
<li>If <code class="prettyprint">K</code> is zero and the namespace declaration contains an <em>extern_alias_directive</em> or <em>using_alias_directive</em> that associates the name <code class="prettyprint">I</code> with an imported namespace or type, then the <em>namespace_or_type_name</em> refers to that namespace or type.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the *namespace_or_type_name</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, if the namespaces and type declarations imported by the <em>using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the *namespace_or_type_name</em> is ambiguous and an error occurs.</li>
</ul></li>
</ul></li>
<li>Otherwise, the <em>namespace_or_type_name</em> is undefined and a compile-time error occurs.</li>
</ul></li>
<li> Otherwise, the <em>namespace_or_type_name</em> is of the form <code class="prettyprint">N.I</code> or of the form <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code>. <code class="prettyprint">N</code> is first resolved as a <em>namespace_or_type_name</em>. If the resolution of <code class="prettyprint">N</code> is not successful, a compile-time error occurs. Otherwise, <code class="prettyprint">N.I</code> or <code class="prettyprint">N.I&lt;A1, ..., Ak&gt;</code> is resolved as follows:

<ul>
<li>If <code class="prettyprint">K</code> is zero and <code class="prettyprint">N</code> refers to a namespace and <code class="prettyprint">N</code> contains a nested namespace with name <code class="prettyprint">I</code>, then the <em>namespace_or_type_name</em> refers to that nested namespace.</li>
<li>Otherwise, if <code class="prettyprint">N</code> refers to a namespace and <code class="prettyprint">N</code> contains an accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments.</li>
<li>Otherwise, if <code class="prettyprint">N</code> refers to a (possibly constructed) class or struct type and <code class="prettyprint">N</code> or any of its base classes contain a nested accessible type having name <code class="prettyprint">I</code> and <code class="prettyprint">K</code> type parameters, then the <em>namespace_or_type_name</em> refers to that type constructed with the given type arguments. If there is more than one such type, the type declared within the more derived type is selected. Note that if the meaning of <code class="prettyprint">N.I</code> is being determined as part of resolving the base class specification of <code class="prettyprint">N</code> then the direct base class of <code class="prettyprint">N</code> is considered to be object (<a href="classes.md#base-classes">Base classes</a>).</li>
<li>Otherwise, <code class="prettyprint">N.I</code> is an invalid <em>namespace_or_type_name</em>, and a compile-time error occurs.</li>
</ul></li>
</ul>

<p>A <em>namespace_or_type_name</em> is permitted to reference a static class (<a href="classes.md#static-classes">Static classes</a>) only if</p>

<ul>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>namespace_or_type_name</em> of the form <code class="prettyprint">T.I</code>, or</li>
<li> The <em>namespace_or_type_name</em> is the <code class="prettyprint">T</code> in a <em>typeof_expression</em> (<a href="expressions.md#argument-lists">Argument lists</a>1) of the form <code class="prettyprint">typeof(T)</code>.</li>
</ul>

<h3 id="fully-qualified-names">Fully qualified names</h3>

<p>Every namespace and type has a <strong><em>fully qualified name</em></strong>, which uniquely identifies the namespace or type amongst all others. The fully qualified name of a namespace or type <code class="prettyprint">N</code> is determined as follows:</p>

<ul>
<li> If <code class="prettyprint">N</code> is a member of the global namespace, its fully qualified name is <code class="prettyprint">N</code>.</li>
<li> Otherwise, its fully qualified name is <code class="prettyprint">S.N</code>, where <code class="prettyprint">S</code> is the fully qualified name of the namespace or type in which <code class="prettyprint">N</code> is declared.</li>
</ul>

<p>In other words, the fully qualified name of <code class="prettyprint">N</code> is the complete hierarchical path of identifiers that lead to <code class="prettyprint">N</code>, starting from the global namespace. Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</p>

<p>The example below shows several namespace and type declarations along with their associated fully qualified names.
&ldquo;`csharp
class A {}                // A</p>

<p>namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }</p>

<p>namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}</p>

<p>namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
&rdquo;`</p>

<h2 id="automatic-memory-management">Automatic memory management</h2>

<p>C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects. Automatic memory management policies are implemented by a <strong><em>garbage collector</em></strong>. The memory management life cycle of an object is as follows:</p>

<ol>
<li>When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</li>
<li>If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction. The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future. For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</li>
<li>Once the object is eligible for destruction, at some unspecified later time the destructor (<a href="classes.md#destructors">Destructors</a>) (if any) for the object is run. Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</li>
<li>Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</li>
<li>Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</li>
</ol>

<p>The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</p>

<p>Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies. For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</p>

<p>The behavior of the garbage collector can be controlled, to some degree, via static methods on the class <code class="prettyprint">System.GC</code>. This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</p>

<p>Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code. The program
&ldquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&quot;Destruct instance of A&rdquo;);
    }
}</p>

<p>class B
{
    object Ref;</p>

<p>public B(object o) {
        Ref = o;
    }</p>

<p>~B() {
        Console.WriteLine(&ldquo;Destruct instance of B&rdquo;);
    }
}</p>

<p>class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
<code class="prettyprint">
creates an instance of class `A` and an instance of class `B`. These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them. The output could be either
</code>
Destruct instance of A
Destruct instance of B
<code class="prettyprint">
or
</code>
Destruct instance of B
Destruct instance of A
&ldquo;`
because the language imposes no constraints on the order in which objects are garbage collected.</p>

<p>In subtle cases, the distinction between &quot;eligible for destruction&rdquo; and &ldquo;eligible for collection&rdquo; can be important. For example,
&ldquo;`csharp
using System;</p>

<p>class A
{
    ~A() {
        Console.WriteLine(&quot;Destruct instance of A&rdquo;);
    }</p>

<p>public void F() {
        Console.WriteLine(&ldquo;A.F&rdquo;);
        Test.RefA = this;
    }
}</p>

<p>class B
{
    public A Ref;</p>

<p>~B() {
        Console.WriteLine(&ldquo;Destruct instance of B&rdquo;);
        Ref.F();
    }
}</p>

<p>class Test
{
    public static A RefA;
    public static B RefB;</p>

<p>static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;</p>

<p>// A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();</p>

<p>// B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine(&ldquo;RefA is not null&rdquo;);
    }
}
&ldquo;`</p>

<p>In the above program, if the garbage collector chooses to run the destructor of <code class="prettyprint">A</code> before the destructor of <code class="prettyprint">B</code>, then the output of this program might be:
<code class="prettyprint">
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
</code></p>

<p>Note that although the instance of <code class="prettyprint">A</code> was not in use and <code class="prettyprint">A</code>&rsquo;s destructor was run, it is still possible for methods of <code class="prettyprint">A</code> (in this case, <code class="prettyprint">F</code>) to be called from another destructor. Also, note that running of a destructor may cause an object to become usable from the mainline program again. In this case, the running of <code class="prettyprint">B</code>&rsquo;s destructor caused an instance of <code class="prettyprint">A</code> that was previously not in use to become accessible from the live reference <code class="prettyprint">Test.RefA</code>. After the call to <code class="prettyprint">WaitForPendingFinalizers</code>, the instance of <code class="prettyprint">B</code> is eligible for collection, but the instance of <code class="prettyprint">A</code> is not, because of the reference <code class="prettyprint">Test.RefA</code>.</p>

<p>To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object&rsquo;s own fields, and not to perform any actions on referenced objects or static fields.</p>

<p>An alternative to using destructors is to let a class implement the <code class="prettyprint">System.IDisposable</code> interface. This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a <code class="prettyprint">using</code> statement (<a href="statements.md#the-using-statement">The using statement</a>).</p>

<h2 id="execution-order">Execution order</h2>

<p>Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points. A <strong><em>side effect</em></strong> is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception. The critical execution points at which the order of these side effects must be preserved are references to volatile fields (<a href="classes.md#volatile-fields">Volatile fields</a>), <code class="prettyprint">lock</code> statements (<a href="statements.md#the-lock-statement">The lock statement</a>), and thread creation and termination. The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</p>

<ul>
<li> Data dependence is preserved within a thread of execution. That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</li>
<li> Initialization ordering rules are preserved (<a href="classes.md#field-initialization">Field initialization</a> and <a href="classes.md#variable-initializers">Variable initializers</a>).</li>
<li> The ordering of side effects is preserved with respect to volatile reads and writes (<a href="classes.md#volatile-fields">Volatile fields</a>). Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression&rsquo;s value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field). When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</li>
</ul>
