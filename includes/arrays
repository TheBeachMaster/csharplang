<h1 id="arrays">Arrays</h1>

<p>An array is a data structure that contains a number of variables which are accessed through computed indices. The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</p>

<p>An array has a rank which determines the number of indices associated with each array element. The rank of an array is also referred to as the dimensions of the array. An array with a rank of one is called a <strong><em>single-dimensional array</em></strong>. An array with a rank greater than one is called a <strong><em>multi-dimensional array</em></strong>. Specific sized multi-dimensional arrays are often referred to as two-dimensional arrays, three-dimensional arrays, and so on.</p>

<p>Each dimension of an array has an associated length which is an integral number greater than or equal to zero. The dimension lengths are not part of the type of the array, but rather are established when an instance of the array type is created at run-time. The length of a dimension determines the valid range of indices for that dimension: For a dimension of length <code class="prettyprint">N</code>, indices can range from <code class="prettyprint">0</code> to <code class="prettyprint">N - 1</code> inclusive. The total number of elements in an array is the product of the lengths of each dimension in the array. If one or more of the dimensions of an array have a length of zero, the array is said to be empty.</p>

<p>The element type of an array can be any type, including an array type.</p>

<h2 id="array-types">Array types</h2>

<p>An array type is written as a <em>non_array_type</em> followed by one or more *rank_specifier*s:</p>
<pre class="highlight plaintext"><code>array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;
</code></pre>
<p>A <em>non_array_type</em> is any <em>type</em> that is not itself an <em>array_type</em>.</p>

<p>The rank of an array type is given by the leftmost <em>rank_specifier</em> in the <em>array_type</em>: A <em>rank_specifier</em> indicates that the array is an array with a rank of one plus the number of &ldquo;<code class="prettyprint">,</code>&rdquo; tokens in the <em>rank_specifier</em>.</p>

<p>The element type of an array type is the type that results from deleting the leftmost <em>rank_specifier</em>:</p>

<ul>
<li> An array type of the form <code class="prettyprint">T[R]</code> is an array with rank <code class="prettyprint">R</code> and a non-array element type <code class="prettyprint">T</code>.</li>
<li> An array type of the form <code class="prettyprint">T[R][R1]...[Rn]</code> is an array with rank <code class="prettyprint">R</code> and an element type <code class="prettyprint">T[R1]...[Rn]</code>.</li>
</ul>

<p>In effect, the *rank_specifier*s are read from left to right before the final non-array element type. The type <code class="prettyprint">int[][,,][,]</code> is a single-dimensional array of three-dimensional arrays of two-dimensional arrays of <code class="prettyprint">int</code>.</p>

<p>At run-time, a value of an array type can be <code class="prettyprint">null</code> or a reference to an instance of that array type.</p>

<h3 id="the-system-array-type">The System.Array type</h3>

<p>The type <code class="prettyprint">System.Array</code> is the abstract base type of all array types. An implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) exists from any array type to <code class="prettyprint">System.Array</code>, and an explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from <code class="prettyprint">System.Array</code> to any array type. Note that <code class="prettyprint">System.Array</code> is not itself an <em>array_type</em>. Rather, it is a <em>class_type</em> from which all *array_type*s are derived.</p>

<p>At run-time, a value of type <code class="prettyprint">System.Array</code> can be <code class="prettyprint">null</code> or a reference to an instance of any array type.</p>

<h3 id="arrays-and-the-generic-ilist-interface">Arrays and the generic IList interface</h3>

<p>A one-dimensional array <code class="prettyprint">T[]</code> implements the interface <code class="prettyprint">System.Collections.Generic.IList&lt;T&gt;</code> (<code class="prettyprint">IList&lt;T&gt;</code> for short) and its base interfaces. Accordingly, there is an implicit conversion from <code class="prettyprint">T[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces. In addition, if there is an implicit reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> then <code class="prettyprint">S[]</code> implements <code class="prettyprint">IList&lt;T&gt;</code> and there is an implicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>). If there is an explicit reference conversion from <code class="prettyprint">S</code> to <code class="prettyprint">T</code> then there is an explicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>). For example:
&ldquo;`csharp
using System.Collections.Generic;</p>

<p>class Test
{
    static void Main() {
        string[] sa = new string[5];
        object[] oa1 = new object[5];
        object[] oa2 = sa;</p>

<p>IList<string> lst1 = sa;                    // Ok
        IList<string> lst2 = oa1;                   // Error, cast needed
        IList<object> lst3 = sa;                    // Ok
        IList<object> lst4 = oa1;                   // Ok</p>

<p>IList<string> lst5 = (IList<string>)oa1;    // Exception
        IList<string> lst6 = (IList<string>)oa2;    // Ok
    }
}
&rdquo;`</p>

<p>The assignment <code class="prettyprint">lst2 = oa1</code> generates a compile-time error since the conversion from <code class="prettyprint">object[]</code> to <code class="prettyprint">IList&lt;string&gt;</code> is an explicit conversion, not implicit. The cast <code class="prettyprint">(IList&lt;string&gt;)oa1</code> will cause an exception to be thrown at run-time since <code class="prettyprint">oa1</code> references an <code class="prettyprint">object[]</code> and not a <code class="prettyprint">string[]</code>. However the cast <code class="prettyprint">(IList&lt;string&gt;)oa2</code> will not cause an exception to be thrown since <code class="prettyprint">oa2</code> references a <code class="prettyprint">string[]</code>.</p>

<p>Whenever there is an implicit or explicit reference conversion from <code class="prettyprint">S[]</code> to <code class="prettyprint">IList&lt;T&gt;</code>, there is also an explicit reference conversion from <code class="prettyprint">IList&lt;T&gt;</code> and its base interfaces to <code class="prettyprint">S[]</code> (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>).</p>

<p>When an array type <code class="prettyprint">S[]</code> implements <code class="prettyprint">IList&lt;T&gt;</code>, some of the members of the implemented interface may throw exceptions. The precise behavior of the implementation of the interface is beyond the scope of this specification.</p>

<h2 id="array-creation">Array creation</h2>

<p>Array instances are created by <em>array_creation_expression*s (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>) or by field or local variable declarations that include an *array_initializer</em> (<a href="arrays.md#array-initializers">Array initializers</a>).</p>

<p>When an array instance is created, the rank and length of each dimension are established and then remain constant for the entire lifetime of the instance. In other words, it is not possible to change the rank of an existing array instance, nor is it possible to resize its dimensions.</p>

<p>An array instance is always of an array type. The <code class="prettyprint">System.Array</code> type is an abstract type that cannot be instantiated.</p>

<p>Elements of arrays created by *array_creation_expression*s are always initialized to their default value (<a href="variables.md#default-values">Default values</a>).</p>

<h2 id="array-element-access">Array element access</h2>

<p>Array elements are accessed using <em>element_access</em> expressions (<a href="expressions.md#array-access">Array access</a>) of the form <code class="prettyprint">A[I1, I2, ..., In]</code>, where <code class="prettyprint">A</code> is an expression of an array type and each <code class="prettyprint">Ix</code> is an expression of type <code class="prettyprint">int</code>, <code class="prettyprint">uint</code>, <code class="prettyprint">long</code>, <code class="prettyprint">ulong</code>, or can be implicitly converted to one or more of these types. The result of an array element access is a variable, namely the array element selected by the indices.</p>

<p>The elements of an array can be enumerated using a <code class="prettyprint">foreach</code> statement (<a href="statements.md#the-foreach-statement">The foreach statement</a>).</p>

<h2 id="array-members">Array members</h2>

<p>Every array type inherits the members declared by the <code class="prettyprint">System.Array</code> type.</p>

<h2 id="array-covariance">Array covariance</h2>

<p>For any two <em>reference_type*s <code class="prettyprint">A</code> and <code class="prettyprint">B</code>, if an implicit reference conversion (<a href="conversions.md#implicit-reference-conversions">Implicit reference conversions</a>) or explicit reference conversion (<a href="conversions.md#explicit-reference-conversions">Explicit reference conversions</a>) exists from <code class="prettyprint">A</code> to <code class="prettyprint">B</code>, then the same reference conversion also exists from the array type <code class="prettyprint">A[R]</code> to the array type <code class="prettyprint">B[R]</code>, where <code class="prettyprint">R</code> is any given *rank_specifier</em> (but the same for both array types). This relationship is known as <strong><em>array covariance</em></strong>. Array covariance in particular means that a value of an array type <code class="prettyprint">A[R]</code> may actually be a reference to an instance of an array type <code class="prettyprint">B[R]</code>, provided an implicit reference conversion exists from <code class="prettyprint">B</code> to <code class="prettyprint">A</code>.</p>

<p>Because of array covariance, assignments to elements of reference type arrays include a run-time check which ensures that the value being assigned to the array element is actually of a permitted type (<a href="expressions.md#simple-assignment">Simple assignment</a>). For example:
&ldquo;`csharp
class Test
{
    static void Fill(object[] array, int index, int count, object value) {
        for (int i = index; i &lt; index + count; i++) array[i] = value;
    }</p>

<p>static void Main() {
        string[] strings = new string[100];
        Fill(strings, 0, 100, &quot;Undefined&rdquo;);
        Fill(strings, 0, 10, null);
        Fill(strings, 90, 10, 0);
    }
}
&ldquo;`</p>

<p>The assignment to <code class="prettyprint">array[i]</code> in the <code class="prettyprint">Fill</code> method implicitly includes a run-time check which ensures that the object referenced by <code class="prettyprint">value</code> is either <code class="prettyprint">null</code> or an instance that is compatible with the actual element type of <code class="prettyprint">array</code>. In <code class="prettyprint">Main</code>, the first two invocations of <code class="prettyprint">Fill</code> succeed, but the third invocation causes a <code class="prettyprint">System.ArrayTypeMismatchException</code> to be thrown upon executing the first assignment to <code class="prettyprint">array[i]</code>. The exception occurs because a boxed <code class="prettyprint">int</code> cannot be stored in a <code class="prettyprint">string</code> array.</p>

<p>Array covariance specifically does not extend to arrays of *value_type*s. For example, no conversion exists that permits an <code class="prettyprint">int[]</code> to be treated as an <code class="prettyprint">object[]</code>.</p>

<h2 id="array-initializers">Array initializers</h2>

<p>Array initializers may be specified in field declarations (<a href="classes.md#fields">Fields</a>), local variable declarations (<a href="statements.md#local-variable-declarations">Local variable declarations</a>), and array creation expressions (<a href="expressions.md#array-creation-expressions">Array creation expressions</a>):</p>
<pre class="highlight plaintext"><code>array_initializer
    : '{' variable_initializer_list? '}'
    | '{' variable_initializer_list ',' '}'
    ;

variable_initializer_list
    : variable_initializer (',' variable_initializer)*
    ;

variable_initializer
    : expression
    | array_initializer
    ;
</code></pre>
<p>An array initializer consists of a sequence of variable initializers, enclosed by &rdquo;<code class="prettyprint">{</code>&ldquo; and &rdquo;<code class="prettyprint">}</code>&ldquo; tokens and separated by &rdquo;<code class="prettyprint">,</code>&ldquo; tokens. Each variable initializer is an expression or, in the case of a multi-dimensional array, a nested array initializer.</p>

<p>The context in which an array initializer is used determines the type of the array being initialized. In an array creation expression, the array type immediately precedes the initializer, or is inferred from the expressions in the array initializer. In a field or variable declaration, the array type is the type of the field or variable being declared. When an array initializer is used in a field or variable declaration, such as:
<code class="prettyprint">csharp
int[] a = {0, 2, 4, 6, 8};
</code>
it is simply shorthand for an equivalent array creation expression:
<code class="prettyprint">csharp
int[] a = new int[] {0, 2, 4, 6, 8};
</code></p>

<p>For a single-dimensional array, the array initializer must consist of a sequence of expressions that are assignment compatible with the element type of the array. The expressions initialize array elements in increasing order, starting with the element at index zero. The number of expressions in the array initializer determines the length of the array instance being created. For example, the array initializer above creates an <code class="prettyprint">int[]</code> instance of length 5 and then initializes the instance with the following values:
<code class="prettyprint">csharp
a[0] = 0; a[1] = 2; a[2] = 4; a[3] = 6; a[4] = 8;
</code></p>

<p>For a multi-dimensional array, the array initializer must have as many levels of nesting as there are dimensions in the array. The outermost nesting level corresponds to the leftmost dimension and the innermost nesting level corresponds to the rightmost dimension. The length of each dimension of the array is determined by the number of elements at the corresponding nesting level in the array initializer. For each nested array initializer, the number of elements must be the same as the other array initializers at the same level. The example:
<code class="prettyprint">csharp
int[,] b = {{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}};
</code>
creates a two-dimensional array with a length of five for the leftmost dimension and a length of two for the rightmost dimension:
<code class="prettyprint">csharp
int[,] b = new int[5, 2];
</code>
and then initializes the array instance with the following values:
<code class="prettyprint">csharp
b[0, 0] = 0; b[0, 1] = 1;
b[1, 0] = 2; b[1, 1] = 3;
b[2, 0] = 4; b[2, 1] = 5;
b[3, 0] = 6; b[3, 1] = 7;
b[4, 0] = 8; b[4, 1] = 9;
</code></p>

<p>If a dimension other than the rightmost is given with length zero, the subsequent dimensions are assumed to also have length zero. The example:
<code class="prettyprint">csharp
int[,] c = {};
</code>
creates a two-dimensional array with a length of zero for both the leftmost and the rightmost dimension:
<code class="prettyprint">csharp
int[,] c = new int[0, 0];
</code></p>

<p>When an array creation expression includes both explicit dimension lengths and an array initializer, the lengths must be constant expressions and the number of elements at each nesting level must match the corresponding dimension length. Here are some examples:
<code class="prettyprint">csharp
int i = 3;
int[] x = new int[3] {0, 1, 2};        // OK
int[] y = new int[i] {0, 1, 2};        // Error, i not a constant
int[] z = new int[3] {0, 1, 2, 3};     // Error, length/initializer mismatch
</code></p>

<p>Here, the initializer for <code class="prettyprint">y</code> results in a compile-time error because the dimension length expression is not a constant, and the initializer for <code class="prettyprint">z</code> results in a compile-time error because the length and the number of elements in the initializer do not agree.</p>
